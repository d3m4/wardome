::::::::::::::
act.comm.c
::::::::::::::
/* ************************************************************************
*   File: act.comm.c                                    Part of CircleMUD *
*  Usage: Player-level communication commands                             *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "screen.h"
#include "dg_scripts.h"
#include "buffer.h"

/* extern variables */
extern int level_can_shout;
extern int holler_move_cost;
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;



/* local functions */
void perform_tell(struct char_data *ch, struct char_data *vict, char *arg);
int is_tell_ok(struct char_data *ch, struct char_data *vict);
ACMD(do_say);
ACMD(do_gsay);
ACMD(do_tell);
ACMD(do_reply);
ACMD(do_spec_comm);
ACMD(do_write);
ACMD(do_page);
ACMD(do_gen_comm);
ACMD(do_qcomm);
ACMD(do_ctell);
ACMD(do_newbie);
void garble_text(char *string, int percent);

/* Function to include racial speaking 'sludder' to a sentence string */
void add_racial_sentence(struct char_data *ch, char *sent)
{
  char *ptr, *tmp, new[MAX_INPUT_LENGTH], add[16];
  int i = 0, len;

  if(IS_NPC(ch))
    return;

  if (GET_RACE(ch) == RACE_OGRE)
    strcpy(add, " (grunt) ");
  else if (GET_RACE(ch) == RACE_TROLL)
    strcpy(add, " (grunt) ");
  else if (GET_RACE(ch) == RACE_GITH)
    strcpy(add, " (hiss) ");
  else if (GET_RACE(ch) == RACE_LIZARDMAN)
    strcpy(add, " (hiss) ");
  else if (GET_RACE(ch) == RACE_SEA_ELF)
    strcpy(add, " (glup) ");
  else
    return;

  *new = '\0';
  ptr = sent;
  tmp = new;

  while (*ptr != '\0' && i < 240) {
    if (*ptr == ' ' && !number(0, 10)) {
      strcpy(tmp, add);
      len = strlen(add)-1;
      tmp += len;
      i += len;
    } else
      *tmp = *ptr;

    ptr++;
    tmp++;
    i++;
  }
  *tmp = '\0';

  strcpy(sent, new);
}

/*
ACMD(do_say)
{
  skip_spaces(&argument);

  if (!*argument)
    send_to_char("Yes, but WHAT do you want to say?\r\n", ch);
  else {
    sprintf(buf, "$n says, '%s'", argument);
    act(buf, FALSE, ch, 0, 0, TO_ROOM|DG_NO_TRIG);

    if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      sprintf(buf, "You say, '%s'", argument);
      act(buf, FALSE, ch, 0, argument, TO_CHAR);
    }
  }
  speech_mtrigger(ch, argument);
  speech_wtrigger(ch, argument);
}
*/

ACMD(do_say)
{
  char buf2[MAX_STRING_LENGTH];
  skip_spaces(&argument);

  if (!*argument)
  {
    send_to_char("Yes, but WHAT do you want to say?\r\n", ch);
    return;
  }

  if (argument[strlen(argument) - 1] == '?')
  {
    add_racial_sentence(ch, argument);
    sprintf(buf, "You ask, '%s&n'", argument);
    sprintf(buf2, "$U$n asks, '%s&n'", argument);
  }
  else if(argument[strlen(argument) - 1] == '!')
  {
    add_racial_sentence(ch, argument);
    sprintf(buf, "You exclaim, '%s&n'", argument);
    sprintf(buf2, "$U$n exclaims, '%s&n'", argument);
  }
  else if (argument[strlen(argument) - 1] == '.' &&
           argument[strlen(argument) - 2] == '.' &&
           argument[strlen(argument) - 3] == '.')
  {
    add_racial_sentence(ch, argument);
    sprintf(buf, "You mutter, '%s&n'", argument);
    sprintf(buf2, "$U$n mutters, '%s&n'", argument);
  }
  else
  {
    add_racial_sentence(ch, argument);
    sprintf(buf, "You say, '%s&n'", argument);
    sprintf(buf2, "$U$n says, '%s&n'", argument);
  }

  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
  send_to_char(OK, ch);
  else
  {
    act(buf, FALSE, ch, 0, 0, TO_CHAR);
  }

  act(buf2, FALSE, ch, 0, argument, TO_ROOM|DG_NO_TRIG);

  /* Remove the next three lines if you don't have dg_scripts. */
  /* trigger check */
  speech_mtrigger(ch, argument);
  speech_wtrigger(ch, argument);
}

ACMD(do_gsay)
{
  struct char_data *k;
  struct follow_type *f;

  skip_spaces(&argument);

  if (!AFF_FLAGGED(ch, AFF_GROUP)) {
    send_to_char("But you are not the member of a group!\r\n", ch);
    return;
  }
  if (!*argument)
    send_to_char("Yes, but WHAT do you want to group-say?\r\n", ch);
  else {
    if (ch->master)
      k = ch->master;
    else
      k = ch;

    add_racial_sentence(ch, argument);
    sprintf(buf, "&R$U$n &Wtells the group, &w'%s'&n", argument);

    if (AFF_FLAGGED(k, AFF_GROUP) && (k != ch))
      act(buf, FALSE, ch, 0, k, TO_VICT | TO_SLEEP);
    for (f = k->followers; f; f = f->next)
      if (AFF_FLAGGED(f->follower, AFF_GROUP) && (f->follower != ch))
        act(buf, FALSE, ch, 0, f->follower, TO_VICT | TO_SLEEP);

    if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      sprintf(buf, "&WYou tell the group, &w'%s'&n", argument);
      act(buf, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
    }
  }
}


void perform_tell(struct char_data *ch, struct char_data *vict, char *arg)
{
  add_racial_sentence(ch, arg);
  sprintf(buf, "&g$U$n tells you, '%s&y'", arg);
  act(buf, FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);

  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    sprintf(buf, "&gYou tell $N, '%s&y'", arg);
    act(buf, FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  }

  if (!IS_NPC(vict) && !IS_NPC(ch))
   if(!PRF2_FLAGGED(ch, PRF2_NOREPEAT))
    GET_LAST_TELL(vict) = GET_IDNUM(ch);
}

int is_tell_ok(struct char_data *ch, struct char_data *vict)
{
  if (ch == vict)
    send_to_char("You try to tell yourself something.\r\n", ch);
  else if (IS_NPC(vict))
    send_to_char("You can't tell mobs.\r\n", ch);
  else if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOTELL))
    send_to_char("You can't tell other people while you have notell on.\r\n", ch);
  else if (!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_AFK))
    send_to_char("You can't tell other people while they are AFK.\r\n", ch);
  else if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF))
    send_to_char("The walls seem to absorb your words.\r\n", ch);
  else if (!IS_NPC(vict) && !vict->desc)        /* linkless */
    act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if (PLR_FLAGGED(vict, PLR_WRITING))
    act("$E's writing a message right now; try again later.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else if ((!IS_NPC(vict) && PRF_FLAGGED(vict, PRF_NOTELL)) || ROOM_FLAGGED(vict->in_room, ROOM_SOUNDPROOF))
    act("$E can't hear you.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
  else
    return (TRUE);

  return (FALSE);
}

/*
 * Yes, do_tell probably could be combined with whisper and ask, but
 * called frequently, and should IMHO be kept as tight as possible.
 */
ACMD(do_tell)
{
  struct char_data *vict = NULL;

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2)
    send_to_char("Who do you wish to tell what??\r\n", ch);
  else if (GET_LEVEL(ch) < LVL_IMMORT && !(vict = get_player_vis(ch, buf, 0)))
    send_to_char(NOPERSON, ch);
  else if (GET_LEVEL(ch) >= LVL_IMMORT && !(vict = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (is_tell_ok(ch, vict))
    perform_tell(ch, vict, buf2);
}


ACMD(do_reply)
{
  struct char_data *tch = character_list;

  if (IS_NPC(ch))
    return;

  skip_spaces(&argument);

  if (GET_LAST_TELL(ch) == NOBODY)
    send_to_char("You have no-one to reply to!\r\n", ch);
  else if (!*argument)
    send_to_char("What is your reply?\r\n", ch);
  else {
    /*
     * Make sure the person you're replying to is still playing by searching
     * for them.  Note, now last tell is stored as player IDnum instead of
     * a pointer, which is much better because it's safer, plus will still
     * work if someone logs out and back in again.
     */

    /*
     * XXX: A descriptor list based search would be faster although
     *      we could not find link dead people.  Not that they can
     *      hear tells anyway. :) -gg 2/24/98
     */
    while (tch != NULL && (IS_NPC(tch) || GET_IDNUM(tch) != GET_LAST_TELL(ch)))
      tch = tch->next;

    if (tch == NULL)
      send_to_char("They are no longer playing.\r\n", ch);
    else if (is_tell_ok(ch, tch))
      perform_tell(ch, tch, argument);
  }
}


ACMD(do_spec_comm)
{
  struct char_data *vict;
  const char *action_sing, *action_plur, *action_others;

  switch (subcmd) {
  case SCMD_WHISPER:
    action_sing = "whisper to";
    action_plur = "whispers to";
    action_others = "$n whispers something to $N.";
    break;

  case SCMD_ASK:
    action_sing = "ask";
    action_plur = "asks";
    action_others = "$n asks $N a question.";
    break;

  default:
    action_sing = "oops";
    action_plur = "oopses";
    action_others = "$n is tongue-tied trying to speak with $N.";
    break;
  }

  half_chop(argument, buf, buf2);

  if (!*buf || !*buf2) {
    sprintf(buf, "Whom do you want to %s.. and what??\r\n", action_sing);
    send_to_char(buf, ch);
  } else if (!(vict = get_char_room_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (vict == ch)
    send_to_char("You can't get your mouth close enough to your ear...\r\n", ch);
  else {
    sprintf(buf, "$n %s you, '%s'", action_plur, buf2);
    act(buf, FALSE, ch, 0, vict, TO_VICT);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      sprintf(buf, "You %s %s, '%s'\r\n", action_sing, GET_NAME(vict), buf2);
      send_to_char(buf, ch);
    }
    act(action_others, FALSE, ch, 0, vict, TO_NOTVICT);
  }
}



#define MAX_NOTE_LENGTH 1000    /* arbitrary */

ACMD(do_write)
{
  struct obj_data *paper, *pen = NULL;
  char *papername, *penname;

  papername = buf1;
  penname = buf2;

  two_arguments(argument, papername, penname);

  if (!ch->desc)
    return;

  if (!*papername) {            /* nothing was delivered */
    send_to_char("Write?  With what?  ON what?  What are you trying to do?!?\r\n", ch);
    return;
  }
  if (*penname) {               /* there were two arguments */
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
      sprintf(buf, "You have no %s.\r\n", papername);
      send_to_char(buf, ch);
      return;
    }
    if (!(pen = get_obj_in_list_vis(ch, penname, ch->carrying))) {
      sprintf(buf, "You have no %s.\r\n", penname);
      send_to_char(buf, ch);
      return;
    }
  } else {              /* there was one arg.. let's see what we can find */
    if (!(paper = get_obj_in_list_vis(ch, papername, ch->carrying))) {
      sprintf(buf, "There is no %s in your inventory.\r\n", papername);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(paper) == ITEM_PEN) {      /* oops, a pen.. */
      pen = paper;
      paper = NULL;
    } else if (GET_OBJ_TYPE(paper) != ITEM_NOTE) {
      send_to_char("That thing has nothing to do with writing.\r\n", ch);
      return;
    }
    /* One object was found.. now for the other one. */
    if (!GET_EQ(ch, WEAR_HOLD)) {
      sprintf(buf, "You can't write with %s %s alone.\r\n", AN(papername),
              papername);
      send_to_char(buf, ch);
      return;
    }
    if (!CAN_SEE_OBJ(ch, GET_EQ(ch, WEAR_HOLD))) {
      send_to_char("The stuff in your hand is invisible!  Yeech!!\r\n", ch);
      return;
    }
    if (pen)
      paper = GET_EQ(ch, WEAR_HOLD);
    else
      pen = GET_EQ(ch, WEAR_HOLD);
  }


  /* ok.. now let's see what kind of stuff we've found */
  if (GET_OBJ_TYPE(pen) != ITEM_PEN)
    act("$p is no good for writing with.", FALSE, ch, pen, 0, TO_CHAR);
  else if (GET_OBJ_TYPE(paper) != ITEM_NOTE)
    act("You can't write on $p.", FALSE, ch, paper, 0, TO_CHAR);
  else if (paper->action_description)
    send_to_char("There's something written on it already.\r\n", ch);
  else {
    /* we can write - hooray! */
     /* this is the PERFECT code example of how to set up:
      * a) the text editor with a message already loaed
      * b) the abort buffer if the player aborts the message
      */
     ch->desc->backstr = NULL;
     send_to_char("Write your note.  (/s saves /h for help)\r\n", ch);
     /* ok, here we check for a message ALREADY on the paper */
     if (paper->action_description) {
        /* we str_dup the original text to the descriptors->backstr */
        ch->desc->backstr = str_dup(paper->action_description);
        /* send to the player what was on the paper (cause this is already */
        /* loaded into the editor) */
        send_to_char(paper->action_description, ch);
     }
    act("$n begins to jot down a note.", TRUE, ch, 0, 0, TO_ROOM);
     /* assign the descriptor's->str the value of the pointer to the text */
     /* pointer so that we can reallocate as needed (hopefully that made */
     /* sense :>) */
    ch->desc->str = &paper->action_description;
    ch->desc->max_str = MAX_NOTE_LENGTH;
  }
}



ACMD(do_page)
{
  struct descriptor_data *d;
  struct char_data *vict;

  half_chop(argument, arg, buf2);

  if (IS_NPC(ch))
    send_to_char("Monsters can't page.. go away.\r\n", ch);
  else if (!*arg)
    send_to_char("Whom do you wish to page?\r\n", ch);
  else {
    sprintf(buf, "\007\007*%s* %s\r\n", GET_NAME(ch), buf2);
    if (!str_cmp(arg, "all")) {
      if (GET_LEVEL(ch) > LVL_GOD) {
        for (d = descriptor_list; d; d = d->next)
          if (STATE(d) == CON_PLAYING && d->character)
            act(buf, FALSE, ch, 0, d->character, TO_VICT);
      } else
        send_to_char("You will never be godly enough to do that!\r\n", ch);
      return;
    }
    if ((vict = get_char_vis(ch, arg)) != NULL) {
      act(buf, FALSE, ch, 0, vict, TO_VICT);
      if (PRF_FLAGGED(ch, PRF_NOREPEAT))
        send_to_char(OK, ch);
      else
        act(buf, FALSE, ch, 0, vict, TO_CHAR);
    } else
      send_to_char("There is no such person in the game!\r\n", ch);
  }
}


/**********************************************************************
 * generalized communication func, originally by Fred C. Merkel (Torg) *
  *********************************************************************/

ACMD(do_gen_comm)
{
  struct descriptor_data *i;
  char color_on[24];
  byte gmote = FALSE;

  /* Array of flags which must _not_ be set in order for comm to be heard */
  int channels[][2] = {
    { 0, 0 },
    { PRF_DEAF, 1},
    { PRF_NOGOSS, 1},
    { PRF_NOAUCT, 1},
    { PRF_NOGRATZ, 1},
    { 0, 1},
    { PRF_NOCHAT, 1},
    { PRF2_NONEWBIE, 2},
    { 0, 0 },
  };

  /*
   * com_msgs: [0] Message if you can't perform the action because of noshout
   *           [1] name of the action
   *           [2] message if you're not on the channel
   *           [3] a color string.
   */
  const char *com_msgs[][4] = {
    {"You cannot holler!!\r\n",
      "holler",
      "",
    KYEL},

    {"You cannot shout!!\r\n",
      "shout",
      "Turn off your noshout flag first!\r\n",
    KYEL},

    {"You cannot gossip!!\r\n",
      "gossip",
      "You aren't even on the channel!\r\n",
    KCYN},

    {"You cannot auction!!\r\n",
      "auction",
      "You aren't even on the channel!\r\n",
    KMAG},

    {"You cannot congratulate!\r\n",
      "congrat",
      "You aren't even on the channel!\r\n",
    KGRN},

    {"You cannot gemote!!\r\n",
     "gemote",
     "",
    KYEL},

    { "You cannot chat!\n\r",
       "chat",
       "You aren't even on the chat channel!\n\r",
    KBWHT},

    { "You cannot newbie chat!\n\r",
      "newbie chat",
      "You aren't even on the newbie chat channel!\n\r",
      KMAG},
  };

  ACMD(do_gmote);

  /* to keep pets, etc from being ordered to shout */
  if (!ch->desc)
    return;

  if (PLR_FLAGGED(ch, PLR_NOSHOUT)) {
    send_to_char(com_msgs[subcmd][0], ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_SOUNDPROOF)) {
    send_to_char("The walls seem to absorb your words.\r\n", ch);
    return;
  }
  /* level_can_shout defined in config.c */
  if (GET_LEVEL(ch) < level_can_shout) {
    sprintf(buf1, "You must be at least level %d before you can %s.\r\n",
            level_can_shout, com_msgs[subcmd][1]);
    send_to_char(buf1, ch);
    return;
  }
  /* make sure the char is on the channel */
  if (!IS_NPC(ch) && (channels[subcmd][1] == 1 ? PRF_FLAGGED(ch, channels[subcmd][0]) : PRF2_FLAGGED(ch, channels[subcmd][0]))) {
    send_to_char(com_msgs[subcmd][2], ch);
    return;
  }

  /* skip leading spaces */
  skip_spaces(&argument);

  if(subcmd == SCMD_GMOTE || (subcmd == SCMD_GOSSIP && *argument == '@')) {
    subcmd = SCMD_GOSSIP;
    gmote = TRUE;
  }

  /* make sure that there is something there to say! */
  if (!*argument) {
    sprintf(buf1, "Yes, %s, fine, %s we must, but WHAT???\r\n",
            com_msgs[subcmd][1], com_msgs[subcmd][1]);
    send_to_char(buf1, ch);
    return;
  }

  if (gmote) {
    if (*argument == '@')
      do_gmote(ch, argument + 1, 0, 1);
    else
      do_gmote(ch, argument, 0, 1);
    return;
  }

  /* verify if you *can* do it */
  if (subcmd == SCMD_HOLLER) {
    if (GET_MOVE(ch) < holler_move_cost) {
      send_to_char("You're too exhausted to holler.\r\n", ch);
      return;
    } else
      GET_MOVE(ch) -= holler_move_cost;
  }

  /* set up the color on code */
  strcpy(color_on, com_msgs[subcmd][3]);

  add_racial_sentence(ch, argument);

  /* first, set up strings to be given to the communicator */
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
  else {
    if (COLOR_LEV(ch) >= C_CMP)
      sprintf(buf1, "%sYou %s, '%s%s'%s", color_on, com_msgs[subcmd][1],
              argument, color_on, KNRM);
    else
      sprintf(buf1, "You %s, '%s'", com_msgs[subcmd][1], argument);
    act(buf1, FALSE, ch, 0, 0, TO_CHAR | TO_SLEEP);
  }

  sprintf(buf, "$n %ss, '%s%s'", com_msgs[subcmd][1], argument, color_on);

  /* now send all the strings out */
  for (i = descriptor_list; i; i = i->next) {
    if (STATE(i) == CON_PLAYING && i != ch->desc && i->character &&
        !IS_NPC(i->character) && !(channels[subcmd][1] == 1 ? PRF_FLAGGED(i->character, channels[subcmd][0]) : PRF2_FLAGGED(i->character, channels[subcmd][0])) &&
        !PLR_FLAGGED(i->character, PLR_WRITING) &&
        !ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF)) {

      if (subcmd == SCMD_SHOUT &&
          ((world[ch->in_room].zone != world[i->character->in_room].zone) ||
           GET_POS(i->character) < POS_RESTING))
        continue;

      if (COLOR_LEV(i->character) >= C_NRM)
        send_to_char(color_on, i->character);
      act(buf, FALSE, ch, 0, i->character, TO_VICT | TO_SLEEP);
      if (COLOR_LEV(i->character) >= C_NRM)
        send_to_char(KNRM, i->character);
    }
  }
}


ACMD(do_qcomm)

{

  struct descriptor_data *i;

  if(IS_NPC(ch)) /*adicionado por ultimo pra tentar resolver bug*/
    return;

  if(PLR_FLAGGED(ch, PLR_NOSHOUT)) {
    send_to_char("You can't do this while you can't talk!\r\n", ch);
    return;
}
  if (!PRF_FLAGGED(ch, PRF_QUEST)) {
    send_to_char("You aren't even part of the quest!\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "%s?  Yes, fine, %s we must, but WHAT??\r\n", CMD_NAME,
            CMD_NAME);
    CAP(buf);
    send_to_char(buf, ch);
  } else {
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else {
      if (subcmd == SCMD_QSAY)
        sprintf(buf, "&WYou quest-say, &w'%s'&n", argument);
      else
        strcpy(buf, argument);
      act(buf, FALSE, ch, 0, argument, TO_CHAR);
    }

    if (subcmd == SCMD_QSAY)
      sprintf(buf, "$n quest-says, '%s'", argument);
    else
      strcpy(buf, argument);

    for (i = descriptor_list; i; i = i->next)
      if (STATE(i) == CON_PLAYING && i != ch->desc &&
          PRF_FLAGGED(i->character, PRF_QUEST))
        act(buf, 0, ch, 0, i->character, TO_VICT | TO_SLEEP);
  }
}

void garble_text(char *string, int percent)
{
  char letters[] = "aeiousthpwxyz";
  int i;

  for (i = 0; i < strlen(string); ++i)
    if (isalpha(string[i]) && number(0, 1) && number(0, 100) > percent)
      string[i] = letters[number(0, 12)];
}
::::::::::::::
act.informative.c
::::::::::::::
/*************************************************************************
*   File: act.informative.c                             Part of CircleMUD *
*  Usage: Player-level commands of an informative nature                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "constants.h"
#include "olc.h"
#include "dg_scripts.h"
#include "clan.h"

/* extern variables */
extern int top_of_helpt;
extern int godmana[9];
extern int maxgodmana[9];
extern int godpower[9] ;
extern struct help_index_element *help_table;
extern char *help;
extern struct time_info_data time_info;
extern const char *weekdays[];
extern const char *month_name[];
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct spell_info_type spell_info[];
extern struct message_data mess_info;
extern int top_of_world;
extern char *npc_class_abbrevs[];
extern char *pc_class_types[];
extern char *pc_race_types[];
extern sh_int to_fly_rooms[4];
extern const char *cnome_trans[];
extern const char *ctitle_trans[];
extern sh_int total_p;

extern char *credits;
extern char *news;
extern char *info;
extern char *motd;
extern char *imotd;
extern char *wizlist;
extern char *immlist;
extern char *policies;
extern char *handbook;
extern char *spells[];
extern char *class_abbrevs[];
extern char *race_abbrevs[];
extern const char *god_wiznames[];
extern const char *remort_names[];
extern const char *cnome_trans[];

/* extern functions */
ACMD(do_action);
long find_class_bitvector(char arg);
int level_exp(int remort, int level);
char *title_male(int chclass, int level);
char *title_female(int chclass, int level);
struct time_info_data *real_time_passed(time_t t2, time_t t1);
bool affected_by_spell(struct char_data * ch, int type);
char *add_points(int value);
int parse_class(char arg);
extern struct help_index_element *help_table;
char *item_condition(struct obj_data *obj);
extern const int wear_order_index[NUM_WEARS];
char *make_mbar(int min, int val, int max, int len, int cores);
int invalid_class(struct char_data *ch, struct obj_data *obj);
int can_pk(struct char_data * ch, struct char_data * vt);
int conta_cores(const char *texto);
int saving_throws(int class_num, int type, int level);
int thaco(int class_num, int level);

/* local functions */
void print_object_location(int num, struct obj_data * obj, struct char_data * ch, int recur);
void show_obj_to_char(struct obj_data * object, struct char_data * ch, int mode);
void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode, int show);
ACMD(do_look);
ACMD(do_examine);
ACMD(do_gold);
ACMD(do_score);
ACMD(do_topten);
ACMD(do_relialin) ;
ACMD(do_inventory);
ACMD(do_equipment);
ACMD(do_time);
ACMD(do_weather);
ACMD(do_help);
ACMD(do_who);
ACMD(do_users);
ACMD(do_gen_ps);
void perform_mortal_where(struct char_data * ch, char *arg);
void perform_immort_where(struct char_data * ch, char *arg);
ACMD(do_where);
ACMD(do_levels);
ACMD(do_consider);
ACMD(do_diagnose);
ACMD(do_color);
ACMD(do_toggle);
void sort_commands(void);
ACMD(do_commands);
void diag_char_to_char(struct char_data * i, struct char_data * ch);
void look_at_char(struct char_data * i, struct char_data * ch);
void list_all_char(struct char_data * i, struct char_data * ch, int num);
void list_char_to_char(struct char_data * list, struct char_data * ch);
void do_auto_exits(struct char_data * ch);
ACMD(do_exits);
void look_in_direction(struct char_data * ch, int dir);
void look_in_obj(struct char_data * ch, char *arg);
char *find_exdesc(char *word, struct extra_descr_data * list);
void look_at_target(struct char_data * ch, char *arg);
ACMD(do_spell);
ACMD(do_skill);
ACMD(do_scan);
ACMD(do_whois);
ACMD(do_player);
ACMD(do_pray);

// religion
ACMD(do_muir);
ACMD(do_ilmanateur);
ACMD(do_selune);
ACMD(do_helm);
ACMD(do_ohgma);
ACMD(do_tempus);
ACMD(do_bane);
ACMD(do_pandora);
ACMD(do_talos);

char *make_bar(int val, int max, int len, int cores);


ACMD(do_muir)
{
 if(GET_RELIGION(ch) != 1) {
  send_to_char("Essa nao eh sua religiao\r\n", ch); 
  return ;
 }

 if(godmana[0] < godpower[0])
  send_to_char("Muir nao tem poder suficiente.\r\n", ch);
 else
 {
  godmana[0] = godmana[0] - godpower[0];
  send_to_room("Grande e gloriosa deusa Muir, forneca a sua ajuda em\r\n",ch->in_room);
  send_to_room("forma de uma espada de luz que ira erradicar o mal.\r\n",ch->in_room);
  mag_affects(GET_LEVEL(ch) , ch, ch, SPELL_MUIR,4);
 }
}

ACMD(do_ilmanateur)
{
 if(GET_RELIGION(ch) != 2) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 } 

 if(godmana[1] < godpower[1])
  send_to_char("Ilmanateur nao tem poder suficiente.\r\n", ch);
 else
 {
  godmana[1] = godmana[1] - godpower[1];
  send_to_room("Senhor do perdao e da humildade, que seu sangue e\r\n",ch->in_room) ;
  send_to_room("carne nos proteja como um escudo da fe.\r\n",ch->in_room);
  mag_affects(GET_LEVEL(ch) , ch, ch, SPELL_ILMANATEUR,4);
 }
}

ACMD(do_selune)
{
 if(GET_RELIGION(ch) != 3) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 }

 if(godmana[2] < godpower[2])
  send_to_char("Selune nao tem poder suficiente.\r\n", ch);
 else
 {
  godmana[2] = godmana[2] - godpower[2];
  send_to_room("Dama da lua e criatividade, que a sua luz branca\r\n",ch->in_room);
  send_to_room("de amor enfraqueca os coracoes sanguinarios.\r\n",ch->in_room);
  mag_affects(GET_LEVEL(ch) , ch, ch, SPELL_SELUNE,4);
 }
}

ACMD(do_helm)
{
  if(GET_RELIGION(ch) != 4) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 } 

 if(godmana[3] < godpower[3])
  send_to_char("Helm nao tem poder suficiente.\r\n", ch);
 else
 {
  godmana[3] = godmana[3] - godpower[3];
  send_to_room("Honrada e ordeiro Helm, faca com que os seus servos\r\n",ch->in_room);
  send_to_room("se unam como uma bainha e uma lamina de espada que\r\n",ch->in_room);
  send_to_room("ira cortar o caos e a loucura.\r\n",ch->in_room);
  mag_summons(GET_LEVEL(ch) , ch, 0, SPELL_HELM,4);
 }
}

ACMD(do_ohgma)
{
 struct char_data *found_char = NULL;
 struct obj_data *found_obj = NULL;

 if(GET_RELIGION(ch) != 5) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 }

 one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Identify what?\r\n", ch);
    return;
  }

 generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM |FIND_CHAR_ROOM, ch,
              &found_char, &found_obj);

  if (found_char != NULL)
  {
   call_magic(ch,found_char,0,SPELL_OGHMA,GET_LEVEL(ch), CAST_SPELL) ;
   return ;  
  } 

  if (found_obj != NULL) 
  {
//   call_magic(ch,0,found_obj,SPELL_OGHMA,GET_LEVEL(ch), CAST_SPELL) ;
//   return ;  
  } 
}

ACMD(do_tempus)
{
 struct obj_data *obj ;

 int x = 10 ;
 int y  = 5 ;
 int z ; 

  if(GET_RELIGION(ch) != 6) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 }

  if(godmana[5] < godpower[5])
  {
   send_to_char("Tempus nao tem poder suficiente.\r\n", ch);
   return ; 
  }
 
  godmana[5] = godmana[5] - godpower[5];
  send_to_room("Lorde da guerra e protetor do mais forte, forneca-me a\r\n",ch->in_room);
  send_to_room("determinacao do fogo e a coragem do aco.\r\n",ch->in_room);


 if(GET_EQ(ch, WEAR_WIELD))
 { 
  x =  GET_OBJ_VAL((GET_EQ(ch, WEAR_WIELD)),1) ;
  y =  GET_OBJ_VAL((GET_EQ(ch, WEAR_WIELD)),2) ;
 }
 
 z = (GET_LEVEL(ch) / 4) ;

 obj = read_object(496, VIRTUAL);  
 GET_OBJ_VAL(obj, 2) = y;
 GET_OBJ_VAL(obj, 1) = x ;
 obj->affected[0].location = APPLY_HITROLL;
 obj->affected[0].modifier = z ;
 obj->affected[1].location = APPLY_DAMROLL;
 obj->affected[1].modifier = z ;
 GET_OBJ_LEVEL(obj) = GET_LEVEL(ch) + GET_REMORT(ch) * 200 ;
 obj_to_room(obj, ch->in_room); // NAO MUDAR
 send_to_char("Tempus sends its sword to you.\r\n", ch);
}

ACMD(do_bane)
{
  
  struct char_data * vict = FIGHTING(ch);
 
  if(GET_RELIGION(ch) != 7) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 }

 if(godmana[6] < godpower[6])
  send_to_char("Bane nao tem poder suficiente.\r\n", ch);
 else
 {
  if(vict == NULL)
  {
   send_to_char("Eh necessario estar em combate para se usar o poder de Bane.\r\n",ch);
   return ;
  }
 
  if ((ch->in_room != vict->in_room))
   return ;                           // para evitar bugs

  godmana[6] = godmana[6] - godpower[6];
  send_to_room("Podoroso lorde negro Bane, que o seu punho de tirania\r\n",ch->in_room);
  send_to_room("forneca-me poder para acabar com os meus inimigos.\r\n",ch->in_room);
  damage(ch,vict,GET_REMORT(ch)* 200, 700);
 }

}

ACMD(do_pandora)
{
  struct char_data * vict = FIGHTING(ch);

  if(GET_RELIGION(ch) != 8) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 }

 if(godmana[7] < godpower[7])
  send_to_char("Pandora nao tem poder suficiente.\r\n", ch);
 else
 {
  if(vict == NULL)
  {
   send_to_char("Eh necessario estar em combate para se usar o poder de Pandora.\r\n",ch);
   return ;
  }

  if ((ch->in_room != vict->in_room))
   return ;                           // para evitar bugs

  godmana[7] = godmana[7] - godpower[7];
  send_to_room("Maligna e sedutora Pandora, que o seu toque limite a\r\n",ch->in_room);
  send_to_room("forca fisica e sexual de meu oponente..\r\n",ch->in_room);
  if(GET_HIT(vict) > 1)
  { 
   GET_HIT(vict) = GET_HIT(vict) * 0.7 ;
   send_to_char("O toque de Pandora retirou 30% da sua energia vital.\r\n", vict);
  }
 }
}

ACMD(do_talos)
{
 if(GET_RELIGION(ch) != 9) {
  send_to_char("Essa nao eh sua religiao\r\n", ch);
  return ;
 } 

  if(godmana[8] < godpower[8])
  send_to_char("Talos nao tem poder suficiente.\r\n", ch);
 else
 {
  godmana[8] = godmana[8] - godpower[8];
  send_to_room("Grande e poderoso Talos, que o seu sopro se transforme numa\r\n",ch->in_room);
  send_to_room("tempestade que ira livrar o mundo dos fracos e inferiores.\r\n",ch->in_room);
  mag_areas(GET_LEVEL(ch) , ch,  SPELL_TALOS,4);
 }
}


ACMD(do_pray)
{
 int i = GET_RELIGION(ch);
 if(i > 0)
 {
  sprintf(buf, "Seu Deus tem %d/%d pontos divinos.\r\n", godmana[i-1],
      maxgodmana[i-1]);
  send_to_char(buf, ch);
  sprintf(buf, "Ele precisa de %d pontos para poder ajudar.\r\n", 
     godpower[i-1]);
  send_to_char(buf, ch);

 }
 else send_to_char("You have no religion.\r\n", ch);
  
} 

ACMD(do_relialin)
{

   switch (GET_RELIGION(ch))
 {
      case  1:
        send_to_char("You are a Justice Guardian of Muir.\r\n", ch) ;
        break ;
      case  2:
        send_to_char("You are a Pain Bearer of Ilmanateur.\r\n", ch) ;
        break ;
      case  3:
        send_to_char("You are a Moon Blade of Selune.\r\n", ch) ;
        break ;
      case  4:
        send_to_char("You are a Law Keeper of Helm.\r\n", ch) ;
        break ;
      case  5:
        send_to_char("You are a Wisdom Seeker of Ohgma.\r\n", ch) ;
        break ;
      case  6:
        send_to_char("You are a Battle Guard of Tempus.\r\n", ch) ;
        break ;
      case  7:
        send_to_char("You are a Dread Master of Bane.\r\n", ch) ;
        break ;
      case  8:
        send_to_char("You are a Killer Rose of Pandora.\r\n", ch) ;
        break ;
      case  9:
        send_to_char("You are a Storm Lord of Talos.\r\n", ch) ;
        break ;
     default :
        send_to_char("You have no religion.\r\n", ch) ;
        break ;
  }

   switch (GET_ALIGNMENT(ch))
 {
      case  999:
        send_to_char("You are Lawful Good.\r\n", ch) ;
        break ;
      case  1000:
        send_to_char("You are Neutral Good.\r\n", ch) ;
        break ;
      case  994:
        send_to_char("You are Chaotic Good.\r\n", ch) ;
        break ;
      case  3:
        send_to_char("You are Lawful Neutral.\r\n", ch) ;
        break ;
      case  5:
        send_to_char("You are True Neutral.\r\n", ch) ;
        break ;
      case  7:
        send_to_char("You are Chaotic Neutral.\r\n", ch) ;
        break ;
      case  -999:
        send_to_char("You are Lawful Evil.\r\n", ch) ;
        break ;
      case  -1000:
        send_to_char("You are Neutral Evil.\r\n", ch) ;
        break ;
      case  -994:
        send_to_char("You are Chaotic Evil.\r\n", ch) ;
        break ;
     default :
        send_to_char("You have no alignment. Report to Luigi.\r\n", ch) ;
        break ;
  }
}



ACMD(do_topten)
{
  int aux ;
  struct toptenlevel
 {
  char nome[30] ;
  int level ;
  long id ;
 } ;

 FILE *fl;

 const char *filename ;
 struct toptenlevel topvetor[10] ;

 one_argument(argument, arg);

 if (!*arg)
 {
    send_to_char("&cType: &CTopTen &c0&C/&c1&C/&c2&n\r\n", ch);
    return;
 }

 aux = atoi(arg);

 switch(aux)
 {
  case 0 : filename = TOPTEN_FILE ; break ;
  case 1 : filename = TOPTEN_FILE1 ; break ;
  case 2 : filename = TOPTEN_FILE2 ; break ;
  default: return ;
 }

 if (!(fl = fopen(filename, "r")))
 {
  send_to_char("Could not open the file. Report to Luigi.\r\n", ch);
  return;
 }

 fread(topvetor, sizeof(struct toptenlevel[10]),1, fl)   ;
 fclose(fl);


  if(aux == 0)
  {
sprintf(buf, " \r\n");send_to_char(buf, ch);
sprintf(buf, "                           &gWardome &CTOPTEN &gQuest\r\n");send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+\r\n");send_to_char(buf, ch);
sprintf(buf, "&w| &cRank &w| &gName           &w| &cFlagged As                   &w|  &gQuestPoints  &w|\r\n");send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+\r\n");send_to_char(buf, ch);
sprintf(buf, "&w|  &c1   &w| &g%-10s     &w| &cThe &Csupreme &gQuestMaster      &w|      &g%-3d     &w|  \r\n",topvetor[0].nome, topvetor[0].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c2   &w| &g%-10s     &w| &cThe &Cincredible &gQuestMaster   &w|      &g%-3d     &w|  \r\n",topvetor[1].nome, topvetor[1].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c3   &w| &g%-10s     &w| &cThe &Camazing  &gQuestMaster     &w|      &g%-3d     &w|  \r\n",topvetor[2].nome, topvetor[2].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c4   &w| &g%-10s     &w| &cThe &Cglorious &gQuestMaster     &w|      &g%-3d     &w|  \r\n",topvetor[3].nome, topvetor[3].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c5   &w| &g%-10s     &w| &cThe &Cinfamous &gQuestMaster     &w|      &g%-3d     &w|  \r\n",topvetor[4].nome, topvetor[4].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c6   &w| &g%-10s     &w| &cThe &Cwonderful &gQuestMaster    &w|      &g%-3d     &w|  \r\n",topvetor[5].nome, topvetor[5].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c7   &w| &g%-10s     &w| &cThe &Cgreat &gQuestMaster        &w|      &g%-3d     &w|  \r\n",topvetor[6].nome, topvetor[6].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c8   &w| &g%-10s     &w| &cThe &Cgood &gQuestMaster         &w|      &g%-3d     &w|  \r\n",topvetor[7].nome, topvetor[7].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c9   &w| &g%-10s     &w| &cThe &Csmart &gQuestMaster        &w|      &g%-3d     &w|  \r\n",topvetor[8].nome, topvetor[8].level);send_to_char(buf, ch);
sprintf(buf, "&w| &c10   &w| &g%-10s     &w| &cThe &CQuestMaster              &w|      &g%-3d     &w|  \r\n",topvetor[9].nome, topvetor[9].level);send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+&n \r\n");send_to_char(buf, ch);
}

  if(aux == 1)
  {
sprintf(buf, "\r\n");send_to_char(buf, ch);
sprintf(buf, "                             &rWardome &CTOPTEN &rArena\r\n");send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+ \r\n");send_to_char(buf, ch);
sprintf(buf, "&w| &cRank &w| &rName           &w| &cFlagged As                   &w|  &rArena Score  &w|\r\n");send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+ \r\n");send_to_char(buf, ch);
sprintf(buf, "&w|  &c1   &w| &r%-10s     &w| &cThe &Csupreme &cGladiator        &w|      &r%-5d    &w|\r\n",topvetor[0].nome, topvetor[0].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c2   &w| &r%-10s     &w| &cThe &Cincredible &cGladiator     &w|      &r%-5d    &w|\r\n",topvetor[1].nome, topvetor[1].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c3   &w| &r%-10s     &w| &cThe &Camazing  &cGladiator       &w|      &r%-5d    &w|\r\n",topvetor[2].nome, topvetor[2].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c4   &w| &r%-10s     &w| &cThe &Cglorious &cGladiator       &w|      &r%-5d    &w|\r\n",topvetor[3].nome, topvetor[3].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c5   &w| &r%-10s     &w| &cThe &Cinfamous &cGladiator       &w|      &r%-5d    &w|\r\n",topvetor[4].nome, topvetor[4].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c6   &w| &r%-10s     &w| &cThe &Cwonderful &cGladiator      &w|      &r%-5d    &w|\r\n",topvetor[5].nome, topvetor[5].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c7   &w| &r%-10s     &w| &cThe &Cgreat &cGladiator          &w|      &r%-5d    &w|\r\n",topvetor[6].nome, topvetor[6].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c8   &w| &r%-10s     &w| &cThe &Cgood &cGladiator           &w|      &r%-5d    &w|\r\n",topvetor[7].nome, topvetor[7].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c9   &w| &r%-10s     &w| &cThe &Csmart &cGladiator          &w|      &r%-5d    &w|\r\n",topvetor[8].nome, topvetor[8].level);send_to_char(buf, ch);
sprintf(buf, "&w| &c10   &w| &r%-10s     &w| &cThe &CGladiator                &w|      &r%-5d    &w|  \r\n",topvetor[9].nome, topvetor[9].level);send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+&n \r\n");send_to_char(buf, ch);
  }

  if(aux == 2)
  {
sprintf(buf, "\r\n");send_to_char(buf, ch);
sprintf(buf, "                               &mWardome &CTOPTEN &mLevels \r\n"); send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+ \r\n");send_to_char(buf, ch);
sprintf(buf, "&w| &cRank &w| &mName           &w| &cFlagged As                   &w|     &mLevels    &w| \r\n");send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+ \r\n");send_to_char(buf, ch);
sprintf(buf, "&w|  &c1   &w| &m%-10s     &w| &cThe &Csupreme &cLevelMaster      &w|      &m%-5d    &w| \r\n",topvetor[0].nome, topvetor[0].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c2   &w| &m%-10s     &w| &cThe &Cincredible &cLevelMaster   &w|      &m%-5d    &w| \r\n",topvetor[1].nome, topvetor[1].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c3   &w| &m%-10s     &w| &cThe &Camazing  &cLevelMaster     &w|      &m%-5d    &w| \r\n",topvetor[2].nome, topvetor[2].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c4   &w| &m%-10s     &w| &cThe &Cglorious &cLevelMaster     &w|      &m%-5d    &w| \r\n",topvetor[3].nome, topvetor[3].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c5   &w| &m%-10s     &w| &cThe &Cinfamous &cLevelMaster     &w|      &m%-5d    &w| \r\n",topvetor[4].nome, topvetor[4].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c6   &w| &m%-10s     &w| &cThe &Cwonderful &cLevelMaster    &w|      &m%-5d    &w| \r\n",topvetor[5].nome, topvetor[5].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c7   &w| &m%-10s     &w| &cThe &Cgreat &cLevelMaster        &w|      &m%-5d    &w| \r\n",topvetor[6].nome, topvetor[6].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c8   &w| &m%-10s     &w| &cThe &Cgood &cLevelMaster         &w|      &m%-5d    &w| \r\n",topvetor[7].nome, topvetor[7].level);send_to_char(buf, ch);
sprintf(buf, "&w|  &c9   &w| &m%-10s     &w| &cThe &Csmart &cLevelMaster        &w|      &m%-5d    &w| \r\n",topvetor[8].nome, topvetor[8].level);send_to_char(buf, ch);
sprintf(buf, "&w| &c10   &w| &m%-10s     &w| &cThe &CLevelMaster              &w|      &m%-5d    &w| \r\n",topvetor[9].nome, topvetor[9].level);send_to_char(buf, ch);
sprintf(buf, "&w+------+----------------+------------------------------+---------------+ \r\n");send_to_char(buf, ch);
  }

}


// Fenix - WHS
/*void list_objs_in_house(struct char_data *ch)
{
   struct obj_data *i;
   bool found;
   int how_many = 0;

   found = FALSE;
   send_to_char("\r\n&g", ch);
   for (i = world[ch->in_room].contents; i ; i = i->next_content ) {
	  if (CAN_SEE_OBJ(ch, i)) {
		  found = TRUE;
		  if (i->next_content &&
			  (i->item_number == i->next_content->item_number) &&
			  (i->obj_flags.extra_flags == i->next_content->obj_flags.extra_flags) &&
			  !str_cmp(i->short_description, i->next_content->short_description))
			  {
			  how_many++;
		  } else {
			  if (how_many) {
				  sprintf(buf, "&g[&G%2d&g] ", how_many + 1);
				  send_to_char(buf, ch);
				  how_many = 0;
			  }
			  send_to_char("&g", ch);
			  sprintf(buf, "%s.\r\n&n", i->short_description);
			  CAP(buf);
			  send_to_char(buf, ch);
	}
    }
  }
}
*/
/*
 * This function screams bitvector... -gg 6/45/98
 */
void show_obj_to_char(struct obj_data * object, struct char_data * ch, int mode)
{
  bool found;
  int remort, level;

  if (!object || !ch) {
    log("SYSERR: NULL pointer in show_obj_to_char(): obj=%p ch=%p", object, ch);
    return;
  }

  *buf = '\0';

  if ((mode == 0) && object->description)
    strcpy(buf, object->description);
  else if (object->short_description && ((mode == 1) ||
                                 (mode == 2) || (mode == 3) || (mode == 4)))
    strcpy(buf, object->short_description);
  else if (mode == 5) {
    if (GET_OBJ_TYPE(object) == ITEM_NOTE) {
      if (object->action_description) {
        strcpy(buf, "There is something written upon it:\r\n\r\n");
        strcat(buf, object->action_description);
        page_string(ch->desc, buf, 1);
      } else
         send_to_char("It's blank.\r\n", ch);
      return;
    } else if (GET_OBJ_TYPE(object) != ITEM_DRINKCON) {
      strcpy(buf, "You see nothing special..");
    } else                      /* ITEM_TYPE == ITEM_DRINKCON||FOUNTAIN */
      strcpy(buf, "It looks like a drink container.");
  }
  if (mode != 3) {
    found = FALSE;
    if (GET_OBJ_TYPE(object) == ITEM_WEAPON || GET_OBJ_TYPE(object) == ITEM_ARMOR ||
    	GET_OBJ_TYPE(object) == ITEM_WAND || GET_OBJ_TYPE(object) == ITEM_LIGHT ||
    	GET_OBJ_TYPE(object) == ITEM_STAFF || GET_OBJ_TYPE(object) == ITEM_WORN ||
    	(GET_OBJ_TYPE(object) == ITEM_CONTAINER && (object->carried_by || object->worn_by) && !IS_CORPSE(object))) {
      sprintf(buf+strlen(buf), "%s", item_condition(object));
      found = TRUE;
    } else {
      strcat(buf, " ");
      found = TRUE;
    }

    if(invalid_class(ch, object) && GET_LEVEL(ch) < LVL_GOD) {
     if (GET_OBJ_TYPE(object) == ITEM_WEAPON || GET_OBJ_TYPE(object) == ITEM_ARMOR ||
    	GET_OBJ_TYPE(object) == ITEM_WAND || GET_OBJ_TYPE(object) == ITEM_LIGHT ||
    	GET_OBJ_TYPE(object) == ITEM_STAFF || GET_OBJ_TYPE(object) == ITEM_WORN ||
    	(GET_OBJ_TYPE(object) == ITEM_CONTAINER && (object->carried_by || object->worn_by) && !IS_CORPSE(object)))
         strcat(buf, "&R(!)&n ");
      found = TRUE;
    }

    level = (GET_OBJ_LEVEL(object)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(object)/(LVL_IMMORT - 1))));
    if ((level == 0) && (GET_OBJ_LEVEL(object) > 0)){
     level = (LVL_IMMORT - 1);
     remort = (GET_OBJ_LEVEL(object)/(LVL_IMMORT - 1)) - 1;
    }
    else{
     remort = (GET_OBJ_LEVEL(object)/(LVL_IMMORT - 1));
    }

    if (GET_REMORT(ch) < remort) {
      strcat(buf, "&y(&GR&Y+&y)&n ");
      found = TRUE;
    } else if (GET_LEVEL(ch) < level ) {
      strcat(buf, "&Y(+)&n ");
      found = TRUE;
    }

    if (IS_OBJ_STAT(object, ITEM_INVISIBLE)) {
      strcat(buf, "&W(invis&n) ");
      found = TRUE;
    }
    if (IS_OBJ_STAT(object, ITEM_BLESS) && AFF_FLAGGED(ch, AFF_DETECT_ALIGN)) {
      strcat(buf, "&B(blessed)&n ");
      found = TRUE;
    }
    if (IS_OBJ_STAT(object, ITEM_MAGIC) && AFF_FLAGGED(ch, AFF_DETECT_MAGIC)) {
      strcat(buf, "&C(magic)&n ");
      found = TRUE;
    }
    if (IS_OBJ_STAT(object, ITEM_GLOW)) {
      strcat(buf, "&G(glow)&n ");
      found = TRUE;
    }
    if (IS_OBJ_STAT(object, ITEM_HUM)) {
      strcat(buf, "&c(hum)&n ");
      found = TRUE;
    }
  }
  strcat(buf, "\r\n");
  send_to_char(buf, ch);
//  page_string(ch->desc, buf, TRUE);
}

/*
void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode,
                           int show)
{
  struct obj_data *i;
  bool found;

  found = FALSE;
  for (i = list; i; i = i->next_content) {
    if (CAN_SEE_OBJ(ch, i)) {
      show_obj_to_char(i, ch, mode);
      found = TRUE;
    }
  }
  if (!found && show)
    send_to_char(" Nothing.\r\n", ch);
}
*/

void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode, int show)
{
  struct obj_data *i, *j;
  bool found;
  int num;

  found = FALSE;
  for (i = list; i; i = i->next_content) {
      num = 0;
      for (j = list; j != i; j = j->next_content)
	if (j->item_number==NOTHING) {
	    if(strcmp(j->short_description,i->short_description)==0) break;
	}
	else if (j->item_number==i->item_number) break;
      if (j!=i) continue;
      for (j = i; j; j = j->next_content)
	if (j->item_number==NOTHING) {
	    if(strcmp(j->short_description,i->short_description)==0) num++;
	  }
	else if (j->item_number==i->item_number) num++;

      if ((CAN_SEE_OBJ(ch, i) || (GET_OBJ_TYPE(i) == ITEM_LIGHT)) && !is_abbrev(i->description, "Undefined")) {
	  if (num!=1) {
		sprintf(buf,"&g(&G%d&g) ",num);
		send_to_char(buf,ch);
          } else if(num == 1) {
		sprintf(buf,"&g");
		send_to_char(buf,ch);
	  }
	if(!is_abbrev(i->description, "Undefined")){
	  show_obj_to_char(i, ch, mode);
	  found = TRUE;
	} else
	  found = FALSE;
      }
  }
  if (!found && show)
    send_to_char(" Nothing.\r\n", ch);
}



void diag_char_to_char(struct char_data * i, struct char_data * ch)
{
  int percent;

  if (GET_MAX_HIT(i) > 0)
    percent = (100 * GET_HIT(i)) / GET_MAX_HIT(i);
  else
    percent = -1;               /* How could MAX_HIT be < 1?? */

  strcpy(buf, PERS(i, ch));
  CAP(buf);

  if (percent >= 100)
    strcat(buf, " is in excellent condition.\r\n");
  else if (percent >= 90)
    strcat(buf, " has a few scratches.\r\n");
  else if (percent >= 75)
    strcat(buf, " has some small wounds and bruises.\r\n");
  else if (percent >= 50)
    strcat(buf, " has quite a few wounds.\r\n");
  else if (percent >= 30)
    strcat(buf, " has some big nasty wounds and scratches.\r\n");
  else if (percent >= 15)
    strcat(buf, " looks pretty hurt.\r\n");
  else if (percent >= 0)
    strcat(buf, " is in awful condition.\r\n");
  else
    strcat(buf, " is bleeding awfully from big wounds.\r\n");

  send_to_char(buf, ch);
}


void look_at_char(struct char_data * i, struct char_data * ch)
{
  int j, found;

  if (!ch->desc)
    return;

   if (i->player.description)
    send_to_char(i->player.description, ch);
  else
    act("You see nothing special about $m.", FALSE, i, 0, ch, TO_VICT);

  diag_char_to_char(i, ch);

  found = FALSE;
  for (j = 0; !found && j < NUM_WEARS; j++)
    if (GET_EQ(i, j) && CAN_SEE_OBJ(ch, GET_EQ(i, j)))
      found = TRUE;

  if (found) {
    send_to_char("\r\n", ch);	/* act() does capitalization. */
    act("&c$U$n is using:&n", FALSE, i, 0, ch, TO_VICT);
    for (j = 0; j < NUM_WEARS; j++)
      if (GET_EQ(i, wear_order_index[j])
          && CAN_SEE_OBJ(ch, GET_EQ(i, wear_order_index[j]))) {
        send_to_char(where[wear_order_index[j]], ch);
        send_to_char("&y", ch);
        show_obj_to_char(GET_EQ(i, wear_order_index[j]), ch, 1);
        send_to_char("&n", ch);
      }
  }
  if (ch != i && (IS_THIEF(ch) || GET_LEVEL(ch) >= LVL_IMMORT)) {
    found = FALSE;
    act("\r\n&GYou attempt to peek at $s inventory:&n", FALSE, i, 0, ch, TO_VICT);
     if(i->carrying){
        found = TRUE;
        list_obj_to_char(i->carrying, ch, 1, TRUE);
     }
    if (!found)
      send_to_char("&yYou can't see anything.&n\r\n", ch);

   if (IS_AFFECTED(i, AFF_TANGLED))
      act("$e is entangled in vines.", FALSE, i, 0, ch, TO_VICT);
  }
}


/*void look_at_char(struct char_data * i, struct char_data * ch)
{
  int j, found;
  struct obj_data *tmp_obj;

  if (!ch->desc)
    return;

   if (i->player.description)
    send_to_char(i->player.description, ch);
  else
    act("You see nothing special about $m.", FALSE, i, 0, ch, TO_VICT);

  diag_char_to_char(i, ch);

  found = FALSE;
  for (j = 0; !found && j < NUM_WEARS; j++)
    if (GET_EQ(i, j) && CAN_SEE_OBJ(ch, GET_EQ(i, j)))
      found = TRUE;

  if (found) {
    act("\r\n&c$n is using:&n", FALSE, i, 0, ch, TO_VICT);
    for (j = 0; j < NUM_WEARS; j++)
      if (GET_EQ(i, j) && CAN_SEE_OBJ(ch, GET_EQ(i, j))) {
	send_to_char(where[j], ch);
        send_to_char("&y", ch);
	show_obj_to_char(GET_EQ(i, j), ch, 1);
        send_to_char("&n", ch);
      }
  }
  if (ch != i && (IS_THIEF(ch) || GET_LEVEL(ch) >= LVL_IMMORT)) {
    found = FALSE;
    act("\r\n&GYou attempt to peek at $s inventory:&n", FALSE, i, 0, ch, TO_VICT);
    for (tmp_obj = i->carrying; tmp_obj; tmp_obj = tmp_obj->next_content) {
      if (CAN_SEE_OBJ(ch, tmp_obj) && (number(0, 20) < GET_LEVEL(ch))) {
	show_obj_to_char(tmp_obj, ch, 1);
	found = TRUE;
      }
    }

    if (!found)
      send_to_char("&yYou can't see anything.&n\r\n", ch);

   if (IS_AFFECTED(i, AFF_TANGLED))
      act("$e is entangled in vines.", FALSE, i, 0, ch, TO_VICT);
  }
}
*/
void list_all_char(struct char_data * i, struct char_data * ch, int num)
{
  const char *positions[] = {
    " is lying here, dead.",
    " is lying here, mortally wounded.",
    " is lying here, incapacitated.",
    " is lying here, stunned.",
    " is sleeping here. (...ZzZzZ)",
    " is resting here.",
    " is sitting here.",
    "!FIGHTING!",
    " is standing here.",
    " is flying here mounting a winged dragon."
  };

  if (IS_NPC(i) && i->player.long_descr && GET_POS(i) == GET_DEFAULT_POS(i))
  {
    if (AFF_FLAGGED(i, AFF_INVISIBLE))
      strcpy(buf, "*");
    else
      *buf = '\0';

    if (AFF_FLAGGED(ch, AFF_DETECT_ALIGN))
    {
      if (IS_EVIL(i))
        strcat(buf, "&R(Red Aura)&n ");
      else if (IS_GOOD(i))
        strcat(buf, "&B(Blue Aura)&n ");
    }
    if (num > 1)
            {
                while ((buf[strlen(buf)-1]=='\r') ||
                       (buf[strlen(buf)-1]=='\n') ||
                       (buf[strlen(buf)-1]==' '))
                {
                    buf[strlen(buf)-1] = '\0';
                }
                sprintf(buf2," &y[&Y%2d&y]&n ", num);
                strcat(buf, buf2);
            }
    sprintf(buf + strlen(buf), "&y%s&n", i->player.long_descr);
    send_to_char(buf, ch);

   if (AFF_FLAGGED(ch, AFF_DETECT_MAGIC) || GET_LEVEL(ch) > LVL_ELDER)
    {
     if (AFF_FLAGGED(i, AFF_SANCTUARY))
       act("&c...&w$e glows with a bright light!&n", FALSE, i, 0, ch, TO_VICT);
     if (AFF_FLAGGED(i, AFF_SATAN))
       act("&c...&R$e glows with a red light!&n", FALSE, i, 0, ch, TO_VICT);
     if (AFF_FLAGGED(i, AFF_GOD))
       act("&c...&Y$e glows with a yellow light!&n", FALSE, i, 0, ch, TO_VICT);
     if (IS_AFFECTED(i, AFF_TANGLED))
       act("&c...$e is entangled in vines!&n", FALSE, i, 0, ch, TO_VICT);
     if (IS_AFFECTED(i, AFF_FIRESHIELD))
       act("&c...&r$e is surrounded by burning flames!&n", FALSE, i, 0, ch, TO_VICT);
     if (AFF_FLAGGED(i, AFF_BLIND))
       act("&c...&W$e is groping around blindly!&n", FALSE, i, 0, ch, TO_VICT);
    if (AFF2_FLAGGED(i, AFF2_BANSHEE))
       act("&c...&m$e glows with a dark light!&n", FALSE, i, 0, ch, TO_VICT);
    }
    return;
  }
  if (IS_NPC(i)) {
    *buf = '\0';
    if (num > 1)
            {
                while ((buf[strlen(buf)-1]=='\r') ||
                       (buf[strlen(buf)-1]=='\n') ||
                       (buf[strlen(buf)-1]==' '))
                {
                    buf[strlen(buf)-1] = '\0';
                }
                sprintf(buf2," &y[&Y%2d&y]&n ", num);
                strcpy(buf, buf2);
            }
    sprintf(buf1, "&y%s&n", CAP(i->player.short_descr));
    strcat(buf, buf1);
//    CAP(buf);
  } else
    if(AFF2_FLAGGED(i, AFF2_TRANSFORM))
      sprintf(buf, "%s &Y%s %s&n", cnome_trans[GET_TRANS(i)], i->player.name,
       ctitle_trans[GET_TRANS(i)]);
    else
      sprintf(buf, "&y%s&c%s&n &y%s&n", (GET_PRENAME(i) ? GET_PRENAME(i) : ""),
      i->player.name, GET_TITLE(i));

  if (AFF_FLAGGED(i, AFF_INVISIBLE))
    strcat(buf, " &W(invisible)&n");
  if (AFF_FLAGGED(i, AFF_HIDE))
    strcat(buf, " &G(hidden)&n");
  if (!IS_NPC(i) && !i->desc)
    strcat(buf, " &B(linkless)&n");
  if (PLR_FLAGGED(i, PLR_WRITING))
    strcat(buf, " &n(writing)&n");
  if (PLR_FLAGGED(i, PLR_MEDITATE))
    strcat(buf, " &C(mediting)&n");

  if (GET_POS(i) != POS_FIGHTING){
    if ((real_room(to_fly_rooms[0]) == i->in_room) ||
        (real_room(to_fly_rooms[1]) == i->in_room) ||
        (real_room(to_fly_rooms[2]) == i->in_room))
      {
    sprintf(buf + strlen(buf), "&y%s&n", positions[(int) 9 ]);
    }
    else{
     sprintf(buf + strlen(buf), "&y%s&n", positions[(int) GET_POS(i)]);
    }
  }

//    strcat(buf, buf2);
  else {
    if (FIGHTING(i)) {
      strcat(buf, " &yis here, fighting&n ");
      if (FIGHTING(i) == ch)
        strcat(buf, "&WYOU!&n");
      else {
        if (i->in_room == FIGHTING(i)->in_room)
          strcat(buf, PERS(FIGHTING(i), ch));
        else
          strcat(buf, "&ysomeone who has already left&n");
        strcat(buf, "!");
      }
    } else                      /* NIL fighting pointer */
      strcat(buf, " &cis here struggling with thin air.&n");
  }

  if (AFF_FLAGGED(ch, AFF_DETECT_ALIGN)) {
    if (IS_EVIL(i))
      strcat(buf, " &R(Red Aura)&n");
    else if (IS_GOOD(i))
      strcat(buf, " &B(Blue Aura)&n");
  }
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  if(!AFF2_FLAGGED(i, AFF2_TRANSFORM)) {
   if (AFF_FLAGGED(ch, AFF_DETECT_MAGIC) || GET_LEVEL(ch) > LVL_ELDER) {
     if (AFF_FLAGGED(i, AFF_SANCTUARY))
       act("&c...&w$e glows with a bright light!&n", FALSE, i, 0, ch, TO_VICT);
     if (AFF_FLAGGED(i, AFF_SATAN))
       act("&c...&R$e glows with a red light!&n", FALSE, i, 0, ch, TO_VICT);
     if (AFF_FLAGGED(i, AFF_GOD))
       act("&c...&Y$e glows with a yellow light!&n", FALSE, i, 0, ch, TO_VICT);
     if (IS_AFFECTED(i, AFF_TANGLED))
       act("&c...$e is entangled in vines!&n", FALSE, i, 0, ch, TO_VICT);
     if (IS_AFFECTED(i, AFF_FIRESHIELD))
       act("&c...&r$e is surrounded by burning flames!&n", FALSE, i, 0, ch, TO_VICT);
     if (AFF_FLAGGED(i, AFF_BLIND))
       act("&c...&c$e is groping around blindly!&n", FALSE, i, 0, ch, TO_VICT);
   }
  } else
       act("&y...&Y$e is surrounded by a shine aura!&n", FALSE, i, 0, ch, TO_VICT);
}

/*
void list_char_to_char(struct char_data * list, struct char_data * ch)
{
  struct char_data *i;

  for (i = list; i; i = i->next_in_room)
    if (ch != i) {
      if (CAN_SEE(ch, i))
        list_one_char(i, ch);
      else if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch) &&
               AFF_FLAGGED(i, AFF_INFRAVISION))
        send_to_char("You see a pair of glowing red eyes looking your way.\r\n", ch);
    }
}*/

void list_char_to_char(struct char_data *list, struct char_data *ch)
{
    struct char_data *i, *plr_list[100];
    int num, counter, locate_list[100], found=FALSE;

    num = 0;

    for (i=list; i; i = i->next_in_room)
    {
      if(i != ch)
      {
        if (CAN_SEE(ch, i))
        {
            if (num < 100)
            {
                found = FALSE;
                for (counter=0;(counter<num&& !found);counter++)
                {

                  if (AFF_FLAGGED(ch, AFF_DETECT_MAGIC))
                   {
                    if (i->nr == plr_list[counter]->nr &&
                        (GET_POS(i) == GET_POS(plr_list[counter])) &&
                        (AFF_FLAGS(i)==AFF_FLAGS(plr_list[counter])) &&
                        (FIGHTING(i) == FIGHTING(plr_list[counter])) &&
                        !strcmp(GET_NAME(i), GET_NAME(plr_list[counter])))
                     {
                        locate_list[counter] += 1;
                        found=TRUE;
                    }
                   }
                   else
                   {
                    if (i->nr == plr_list[counter]->nr &&
                        (GET_POS(i) == GET_POS(plr_list[counter])) &&
                        (FIGHTING(i) == FIGHTING(plr_list[counter])) &&
                        !strcmp(GET_NAME(i), GET_NAME(plr_list[counter])))
                     {
                        locate_list[counter] += 1;
                        found=TRUE;
                    }
                   }

                }
                if (!found)
                {
                    plr_list[num] = i;
                    locate_list[num] = 1;
                    num++;
                }
            }
            else
            {
                list_all_char(i,ch,0);
            }
        }
        else if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch) &&
               AFF_FLAGGED(i, AFF_INFRAVISION))
             send_to_char("You see a pair of glowing red eyes looking your way.\r\n", ch);

      }
    }
    if (num) {
        for (counter=0; counter<num; counter++) {
            if (locate_list[counter] > 1) {
                list_all_char(plr_list[counter],ch,locate_list[counter]);
            } else {
                list_all_char(plr_list[counter],ch,0);
            }
        }
    }
}


void do_auto_exits(struct char_data * ch)
{
  int door, slen = 0;

  *buf = '\0';

  for (door = 0; door < NUM_OF_DIRS; door++)
    if (EXIT(ch, door) && EXIT(ch, door)->to_room != NOWHERE) {
      if (EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED))
        slen += sprintf(buf + slen, "%c ", UPPER(*dirs[door]));
      else
        slen += sprintf(buf + slen, "%c ", LOWER(*dirs[door]));
    }

  sprintf(buf2, "%s[ Exits: %s]%s\r\n", CCCYN(ch, C_NRM),
          *buf ? buf : "None! ", CCNRM(ch, C_NRM));

  send_to_char(buf2, ch);
}


ACMD(do_exits)
{
  int door;

  *buf = '\0';

  if (AFF_FLAGGED(ch, AFF_BLIND)) {
    send_to_char("You can't see a damned thing, you're blinded!\r\n", ch);
    return;
  }
  for (door = 0; door < NUM_OF_DIRS; door++)
    if (EXIT(ch, door) && EXIT(ch, door)->to_room != NOWHERE &&
        !EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED)) {
      if (GET_LEVEL(ch) >= LVL_IMMORT)
        sprintf(buf2, "%-5s - [%5d] %s\r\n", dirs[door],
                GET_ROOM_VNUM(EXIT(ch, door)->to_room),
                world[EXIT(ch, door)->to_room].name);
      else {
        sprintf(buf2, "%-5s - ", dirs[door]);
        if (IS_DARK(EXIT(ch, door)->to_room) && !CAN_SEE_IN_DARK(ch))
          strcat(buf2, "Too dark to tell\r\n");
        else {
          strcat(buf2, world[EXIT(ch, door)->to_room].name);
          strcat(buf2, "\r\n");
        }
      }
      strcat(buf, CAP(buf2));
    }
  send_to_char("Obvious exits:\r\n", ch);

  if (*buf)
    send_to_char(buf, ch);
  else
    send_to_char(" None.\r\n", ch);
}

#define ESIT(num, door)  (world[num].dir_option[door])

#define CAN_IR(num, door)(ESIT(num, door) && \
                         (ESIT(num, door)->to_room != NOWHERE) && \
                         !IS_SET(ESIT(num, door)->exit_info, EX_CLOSED))


int vai(struct char_data *ch, int dir)
{

   if(!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE || !CAN_GO(ch, dir))
    return 0;

   if(!ESIT(EXIT(ch, dir)->to_room, dir) ||
      (!ESIT(EXIT(ch, dir)->to_room, dir)->to_room == NOWHERE) ||
      !CAN_IR(EXIT(ch, dir)->to_room, dir))
    return 0;

   return 1;
}

void make_map(struct char_data *ch)
{
sprintf(buf3,
"\r\n"
"                        &C|      %s      &C|                \r\n"
"                        &C|      %s      &C|                \r\n"
"                        &C|      %s      &C|          &YN     \r\n"
"                        &C|      %s      &C|          &y|     \r\n"
"                        &C|  %s%s&R@%s%s  &C|      &YW &y- &R@ &y- &YE \r\n"
"                        &C|      %s      &C|          &y|     \r\n"
"                        &C|      %s      &C|          &YS     \r\n"
"                        &C|      %s      &C|                \r\n"
"                        &C|      %s      &C|                \r\n\r\n",
(vai(ch, 0) ? (CAN_IR(EXIT(ch, 0)->to_room, 0) ? "&Y^" : " ") : " "),
(vai(ch, 0) ? (CAN_IR(EXIT(ch, 0)->to_room, 0) ? "&y|" : " ") : " "),
(CAN_GO(ch, 0) ? "&Y?" : " "),
(CAN_GO(ch, 0) ? "&y|" : " "),
(vai(ch, 3) ? (CAN_IR(EXIT(ch, 3)->to_room, 3) ? "&Y<&y-" : "  ") : "  "),
(CAN_GO(ch, 3) ? "&Y?&y-" : "  "),
(CAN_GO(ch, 1) ? "&y-&Y?" : "  "),
(vai(ch, 1) ? (CAN_IR(EXIT(ch, 1)->to_room, 1) ? "&y-&Y>" : "  ") : "  "),
(CAN_GO(ch, 2) ? "&y|" : " "),
(CAN_GO(ch, 2) ? "&Y?" : " "),
(vai(ch, 2) ? (CAN_IR(EXIT(ch, 2)->to_room, 2) ? "&y|" : " ") : " "),
(vai(ch, 2) ? (CAN_IR(EXIT(ch, 2)->to_room, 2) ? "&Yo" : " ") : " "));

send_to_char(buf3, ch);

}

void look_at_room(struct char_data * ch, int ignore_brief)
{
  if (!ch->desc)
    return;

  if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch)) {
    send_to_char("It is pitch black...\r\n", ch);
    return;
  } else if (AFF_FLAGGED(ch, AFF_BLIND)) {
    send_to_char("You see nothing but infinite darkness...\r\n", ch);
    return;
  }
	if (!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_HOLYLIGHT) && ROOM_AFFECTED(ch->in_room, RAFF_FOG)) {
		/* NOTE: you might wish to change so that wizards,
		 * or the use of some 'see through fog' makes you see
		 * through the fog
		 */
		send_to_char("Your view is obscured by a thick fog.\r\n", ch);
		return;
	}

  send_to_char(CCCYN(ch, C_NRM), ch);
  if (!IS_NPC(ch) && GET_LEVEL(ch) >= LVL_ROOMFLAGS) {
    sprintbit(ROOM_FLAGS(ch->in_room), room_bits, buf);
    sprintf(buf2, "[%5d] %s &G[ %s]&n", GET_ROOM_VNUM(IN_ROOM(ch)),
            world[ch->in_room].name, buf);
    send_to_char(buf2, ch);
  } else
    send_to_char(world[ch->in_room].name, ch);

  send_to_char(CCNRM(ch, C_NRM), ch);
  send_to_char("\r\n", ch);

  if ((!IS_NPC(ch) && !PRF_FLAGGED(ch, PRF_BRIEF)) || ignore_brief ||
      ROOM_FLAGGED(ch->in_room, ROOM_DEATH))
    send_to_char(world[ch->in_room].description, ch);

  if (ROOM_AFFECTED(ch->in_room, RAFF_FIREWALL))
    send_to_char("&RYou see a large &Yfirewall&R here.&n\r\n", ch);
  if (ROOM_AFFECTED(ch->in_room, RAFF_ICEWALL))
    send_to_char("&CYou see a &Bicewall&C here.&n\r\n", ch);

  /* mini map */
  if (!IS_NPC(ch) && PRF2_FLAGGED(ch, PRF2_MAP))
    make_map(ch);

  /* autoexits */
  if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_AUTOEXIT))
    do_auto_exits(ch);

  /* now list characters & objects */
  send_to_char(CCGRN(ch, C_NRM), ch);
 /* if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE)) // Fenix - WHS
	  list_objs_in_house(ch);*/
  list_obj_to_char(world[ch->in_room].contents, ch, 0, FALSE);
  send_to_char(CCYEL(ch, C_NRM), ch);
  list_char_to_char(world[ch->in_room].people, ch);
  send_to_char(CCNRM(ch, C_NRM), ch);
}



void look_in_direction(struct char_data * ch, int dir)
{
  if (EXIT(ch, dir)) {
    if (EXIT(ch, dir)->general_description)
      send_to_char(EXIT(ch, dir)->general_description, ch);
    else
      send_to_char("You see nothing special.\r\n", ch);

    if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED) && EXIT(ch, dir)->keyword) {
      sprintf(buf, "The %s is closed.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf, ch);
    } else if (EXIT_FLAGGED(EXIT(ch, dir), EX_ISDOOR) && EXIT(ch, dir)->keyword) {
      sprintf(buf, "The %s is open.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf, ch);
    }
  } else
    send_to_char("Nothing special there...\r\n", ch);
}



void look_in_obj(struct char_data * ch, char *arg)
{
  struct obj_data *obj = NULL;
  struct char_data *dummy = NULL;
  int amt, bits;

  if (!*arg)
    send_to_char("Look in what?\r\n", ch);
  else if (!(bits = generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM |
                                 FIND_OBJ_EQUIP, ch, &dummy, &obj))) {
    sprintf(buf, "There doesn't seem to be %s %s here.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else if ((GET_OBJ_TYPE(obj) != ITEM_DRINKCON) &&
             (GET_OBJ_TYPE(obj) != ITEM_FOUNTAIN) &&
             (GET_OBJ_TYPE(obj) != ITEM_CONTAINER))
    send_to_char("There's nothing inside that!\r\n", ch);
  else {
    if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
      if (OBJVAL_FLAGGED(obj, CONT_CLOSED))
        send_to_char("It is closed.\r\n", ch);
      else {
        send_to_char(fname(obj->name), ch);
        switch (bits) {
        case FIND_OBJ_INV:
          send_to_char(" (carried): \r\n", ch);
          break;
        case FIND_OBJ_ROOM:
          send_to_char(" (here): \r\n", ch);
          break;
        case FIND_OBJ_EQUIP:
          send_to_char(" (used): \r\n", ch);
          break;
        }

        list_obj_to_char(obj->contains, ch, 2, TRUE);
      }
    } else {            /* item must be a fountain or drink container */
      if (GET_OBJ_VAL(obj, 1) <= 0)
        send_to_char("It is empty.\r\n", ch);
      else {
        if (GET_OBJ_VAL(obj,0) <= 0 || GET_OBJ_VAL(obj,1)>GET_OBJ_VAL(obj,0)) {
          sprintf(buf, "Its contents seem somewhat murky.\r\n"); /* BUG */
        } else {
          amt = (GET_OBJ_VAL(obj, 1) * 3) / GET_OBJ_VAL(obj, 0);
          sprinttype(GET_OBJ_VAL(obj, 2), color_liquid, buf2);
          sprintf(buf, "It's %sfull of a %s liquid.\r\n", fullness[amt], buf2);
        }
        send_to_char(buf, ch);
      }
    }
  }
}



char *find_exdesc(char *word, struct extra_descr_data * list)
{
  struct extra_descr_data *i;

  for (i = list; i; i = i->next)
    if (isname(word, i->keyword))
      return (i->description);

  return (NULL);
}


/*
 * Given the argument "look at <target>", figure out what object or char
 * matches the target.  First, see if there is another char in the room
 * with the name.  Then check local objs for exdescs.
 */

/*
 * BUG BUG: If fed an argument like '2.bread', the extra description
 *          search will fail when it works on 'bread'!
 * -gg 6/24/98 (I'd do a fix, but it's late and non-critical.)
 */
void look_at_target(struct char_data * ch, char *arg)
{
  int bits, found = FALSE, j, fnum, i = 0;
  struct char_data *found_char = NULL;
  struct obj_data *obj, *found_obj = NULL;
  char *desc;

  if (!ch->desc)
    return;

  if (!*arg) {
    send_to_char("Look at what?\r\n", ch);
    return;
  }

  bits = generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_OBJ_EQUIP |
                      FIND_CHAR_ROOM, ch, &found_char, &found_obj);

  /* Is the target a character? */
  if (found_char != NULL) {
    look_at_char(found_char, ch);
    if (ch != found_char) {
      if (CAN_SEE(found_char, ch))
        act("$n looks at you.", TRUE, ch, 0, found_char, TO_VICT);
      act("$n looks at $N.", TRUE, ch, 0, found_char, TO_NOTVICT);
    }
    return;
  }

  /* Strip off "number." from 2.foo and friends. */
  if (!(fnum = get_number(&arg))) {
    send_to_char("Look at what?\r\n", ch);
    return;
  }

  /* Does the argument match an extra desc in the room? */
  if ((desc = find_exdesc(arg, world[ch->in_room].ex_description)) != NULL && ++i == fnum) {
    page_string(ch->desc, desc, FALSE);
    return;
  }

  /* Does the argument match an extra desc in the char's equipment? */
  for (j = 0; j < NUM_WEARS && !found; j++)
    if (GET_EQ(ch, j) && CAN_SEE_OBJ(ch, GET_EQ(ch, j)))
      if ((desc = find_exdesc(arg, GET_EQ(ch, j)->ex_description)) != NULL && ++i == fnum) {
	send_to_char(desc, ch);
	found = TRUE;
      }

  /* Does the argument match an extra desc in the char's inventory? */
  for (obj = ch->carrying; obj && !found; obj = obj->next_content) {
    if (CAN_SEE_OBJ(ch, obj))
      if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum) {
	send_to_char(desc, ch);
	found = TRUE;
      }
  }

  /* Does the argument match an extra desc of an object in the room? */
  for (obj = world[ch->in_room].contents; obj && !found; obj = obj->next_content)
    if (CAN_SEE_OBJ(ch, obj))
      if ((desc = find_exdesc(arg, obj->ex_description)) != NULL && ++i == fnum) {
	send_to_char(desc, ch);
	found = TRUE;
      }

  /* If an object was found back in generic_find */
  if (bits) {
    if (!found)
      show_obj_to_char(found_obj, ch, 5);       /* Show no-description */
    else
      show_obj_to_char(found_obj, ch, 6);       /* Find hum, glow etc */
  } else if (!found)
    send_to_char("You do not see that here.\r\n", ch);
}


ACMD(do_look)
{
  char arg2[MAX_INPUT_LENGTH];
  int look_type;

  if (!ch->desc)
    return;

  if (GET_POS(ch) < POS_SLEEPING)
    send_to_char("You can't see anything but stars!\r\n", ch);
  else if (AFF_FLAGGED(ch, AFF_BLIND))
    send_to_char("You can't see a damned thing, you're blind!\r\n", ch);
  else if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch)) {
    send_to_char("It is pitch black...\r\n", ch);
    list_char_to_char(world[ch->in_room].people, ch);   /* glowing red eyes */
  } else {
    half_chop(argument, arg, arg2);

    if (subcmd == SCMD_READ) {
      if (!*arg)
        send_to_char("Read what?\r\n", ch);
      else
        look_at_target(ch, arg);
      return;
    }
    if (!*arg)                  /* "look" alone, without an argument at all */
      look_at_room(ch, 1);
    else if (is_abbrev(arg, "in"))
      look_in_obj(ch, arg2);
    /* did the char type 'look <direction>?' */
    else if ((look_type = search_block(arg, dirs, FALSE)) >= 0)
      look_in_direction(ch, look_type);
    else if (is_abbrev(arg, "at"))
      look_at_target(ch, arg2);
    else
      look_at_target(ch, arg);
  }
}



ACMD(do_examine)
{
  int bits;
  struct char_data *tmp_char;
  struct obj_data *tmp_object;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Examine what?\r\n", ch);
    return;
  }
  look_at_target(ch, arg);

  bits = generic_find(arg, FIND_OBJ_INV | FIND_OBJ_ROOM | FIND_CHAR_ROOM |
                      FIND_OBJ_EQUIP, ch, &tmp_char, &tmp_object);

  if (tmp_object) {
    if ((GET_OBJ_TYPE(tmp_object) == ITEM_DRINKCON) ||
        (GET_OBJ_TYPE(tmp_object) == ITEM_FOUNTAIN) ||
        (GET_OBJ_TYPE(tmp_object) == ITEM_CONTAINER)) {
      send_to_char("When you look inside, you see:\r\n", ch);
      look_in_obj(ch, arg);
    }
  }
}



ACMD(do_gold)
{
  if (GET_GOLD(ch) == 0)
    send_to_char("You're broke!\r\n", ch);
  else if (GET_GOLD(ch) == 1)
    send_to_char("You have one miserable little gold coin.\r\n", ch);
  else {
    sprintf(buf, "You have %s gold coins and %d roleplay points.\r\n", add_points(GET_GOLD(ch)), GET_RP(ch));
    send_to_char(buf, ch);
  }
}
#define GET_NEWSAVE(ch,x) (saving_throws(GET_CLASS(ch),x,GET_LEVEL(ch)) + GET_SAVE(ch,x))
#define MOSTRA_THACO1(ch) (thaco(GET_CLASS(ch), GET_LEVEL(ch)) - GET_HITROLL(ch)/2)
#define MOSTRA_THACO2(ch) (((GET_INT(ch) - 13) / 2) + ((GET_WIS(ch) - 13) / 2))
#define MOSTRA_THACO3(ch) (str_app[STRENGTH_APPLY_INDEX(ch)].tohit)
#define MOSTRA_THACO(ch) (MOSTRA_THACO1(ch) - MOSTRA_THACO2(ch) - (MOSTRA_THACO3(ch)))
char *howstat(int percent)
{
  static char buf[256];

  if (percent == 0)
    strcpy(buf, "&nnothing&n");
  else if (percent <= 4)
    strcpy(buf, " &cwicked&n");
  else if (percent <= 6)
    strcpy(buf, "    &ybad&n");
  else if (percent <= 8)
    strcpy(buf, "   &gless&n");
  else if (percent <= 10)
    strcpy(buf, "   &Gfair&n");
  else if (percent <= 12)
    strcpy(buf, " &Ymedium&n");
  else if (percent <= 14)
    strcpy(buf, "&Caverage&n");
  else if (percent <= 16)
    strcpy(buf, "   &Bgood&n");
  else
    strcpy(buf, "&Rmaximum&n");

  return (buf);
}

char *complete_char(char *string, int num)
{
   int y;

   y = num;
   y -= strlen(string);
   y += (conta_cores(string)+conta_cores(string));

   if(y >= num)
     return (string);

   strcpy(buf3, string);
   for(; y > 0; y--)
     strcat(buf3, " ");

   return(buf3);
}

ACMD(do_score)
{
  	double max, norm;
  	char nome_title[1000];

  if (IS_NPC(ch))
    return;

  max = CAN_CARRY_W(ch);
  norm = IS_CARRYING_W(ch);

  max /= 10;
  norm /= 10;
  sprintf(nome_title, "%s %s", GET_NAME(ch), GET_TITLE(ch));
  sprintf(buf, "\r\n       &w+----------------------------------------------------------------+\r\n");
  sprintf(buf + strlen(buf), "       &w|&BName/Title: &C%-s &C%3d &Byears old &w|\r\n", complete_char(reprimir(nome_title, 37+conta_cores(GET_TITLE(ch))+conta_cores(GET_TITLE(ch))), 37), GET_AGE(ch));
  sprintf(buf + strlen(buf), "       &w+=============+=======================+==========================+\r\n");
  sprintf(buf + strlen(buf), "       &w|&BArmor: &C%5d &w| &BRace : &C%14s &w|       &BPoints Scored      &w|\r\n", GET_AC(ch), pc_race_types[(int) GET_RACE(ch)]);
  sprintf(buf + strlen(buf), "       &w|&BLevel: &C%5d &w| &BClass: &C%14s &w| &mHoly Points :  &C%9s &w|\r\n", GET_LEVEL(ch), pc_class_types[(int) GET_CLASS(ch)], add_points(GET_POINTS(ch)));
  sprintf(buf + strlen(buf), "       &w|%s| &BSex  :     &C%10s &w| &mQuest Points:  &C%9s &w|\r\n", make_mbar(-1000, GET_ALIGNMENT(ch), 1000, 10, (clr(ch, C_CMP) ? TRUE : FALSE)), genders[(int) GET_SEX(ch)], add_points(GET_QP(ch)));
  sprintf(buf + strlen(buf), "       &w+=============+=======================+==========================+\r\n");
  sprintf(buf + strlen(buf), "       &w|&BStr: %s &w|&bQuest    :         &C%3d &w|      &BGeneral Stats       &w|\r\n", howstat(GET_STR(ch)), GET_QUEST(ch));
  sprintf(buf + strlen(buf), "       &w|&BInt: %s &w|&bRemorts  :         &C%3d &w| &bHit Points  &C%s &w|\r\n", howstat(GET_INT(ch)), GET_REMORT(ch), make_bar(GET_HIT(ch), GET_MAX_HIT(ch), 10, (clr(ch, C_CMP) ? TRUE : FALSE)));
  sprintf(buf + strlen(buf), "       &w|&BWis: %s &w|&bLucky    :     %s &w| &bMana Points &C%s &w|\r\n", howstat(GET_WIS(ch)), howstat(GET_LUK(ch)), make_bar(GET_MANA(ch), GET_MAX_MANA(ch), 10, (clr(ch, C_CMP) ? TRUE : FALSE)));
  sprintf(buf + strlen(buf), "       &w|&BCha: %s &w+-----------------------+ &bMove Points &C%s &w|\r\n", howstat(GET_CHA(ch)), make_bar(GET_MOVE(ch), GET_MAX_MOVE(ch), 10, (clr(ch, C_CMP) ? TRUE : FALSE)));
  sprintf(buf + strlen(buf), "       &w|&BDex: %s &w|&BGold : &C%15s &w| &bMental      &C%s &w|\r\n", howstat(GET_DEX(ch)), add_points(GET_GOLD(ch)), make_bar(GET_MENTAL(ch), GET_MAX_MENTAL(ch), 10, (clr(ch, C_CMP) ? TRUE : FALSE)));
  sprintf(buf + strlen(buf), "       &w|&BCon: %s &w|&BBank : &C%15s &w| &bBreath      &C%s &w|\r\n", howstat(GET_CON(ch)), add_points(GET_BANK_GOLD(ch)), make_bar(GET_OXI(ch), GET_MAX_OXI(ch), 10, (clr(ch, C_CMP) ? TRUE : FALSE)));
  sprintf(buf + strlen(buf), "       &w+=============+=======================+==========================+\r\n");
  sprintf(buf + strlen(buf), "       &w|             &BPontuation              &w|  &BPK &BInfo                 &w|\r\n");
  sprintf(buf + strlen(buf), "       &w|&bCurrent exp   :      &C%15s &w|&bKilled:&C%17d  &w|\r\n", add_points(GET_EXP(ch)), GET_KILLED(ch));
  sprintf(buf + strlen(buf), "       &w|&bExp to level  :      &C%15s &w|&bDied  :&C%17d  &w|\r\n", (GET_LEVEL(ch) >= LVL_IMMORT ? "0" : add_points(level_exp(GET_REMORT(ch), GET_LEVEL(ch)+1))), GET_DIED(ch));
  sprintf(buf + strlen(buf), "       &w+=====================================+==========================+\r\n");
  sprintf(buf + strlen(buf), "       &w|&bInventory     :                  &C%3d &w|          &BToggle          &w|\r\n", IS_CARRYING_N(ch));
  sprintf(buf + strlen(buf), "       &w|&bWeight Carried:         %s&C%4.1f&c/&C%4.1f&ckg &w|&bAutoassist    &C%s&w|\r\n", (CAN_CARRY_W(ch) > 999 ? "" : " "), norm, max, (PRF_FLAGGED(ch, PRF_AUTOASSIST) ? "(&c*&C)ON ( )OFF" : "( )ON (&c*&C)OFF"));
  sprintf(buf + strlen(buf), "       &w|&bHitroll       :                 &C%4d &w|&bAutoloot      &C%s&w|\r\n", GET_HITROLL(ch), (PRF_FLAGGED(ch, PRF_AUTOLOOT) ? "(&c*&C)ON ( )OFF" : "( )ON (&c*&C)OFF"));
  sprintf(buf + strlen(buf), "       &w|&bDamroll       :                 &C%4d &w|&bAutoexit      &C%s&w|\r\n", GET_DAMROLL(ch), (PRF_FLAGGED(ch, PRF_AUTOEXIT) ? "(&c*&C)ON ( )OFF" : "( )ON (&c*&C)OFF"));
  sprintf(buf + strlen(buf), "       &w|&bThaco         :                 &C%4d &w|&bAutodamage    &C%s&w|\r\n", MOSTRA_THACO(ch), (PRF_FLAGGED(ch, PRF_AUTOEXIT) ? "(&c*&C)ON ( )OFF" : "( )ON (&c*&C)OFF"));
  sprintf(buf + strlen(buf), "       &w|&bSaving throws : &C%3d&c/&C%3d&c/&C%3d&c/&C%3d&c/&C%3d&n  &w|                          |&n\r\n", GET_NEWSAVE(ch, 0),GET_NEWSAVE(ch, 1), GET_NEWSAVE(ch, 2), GET_NEWSAVE(ch, 3), GET_NEWSAVE(ch, 4));
  sprintf(buf + strlen(buf), "       &w+-------------------------------------+--------------------------+\r\n");

  send_to_char(buf, ch);
}

ACMD(do_summary)
{
    if(IS_NPC(ch)){
       send_to_char("You can't do this...", ch);
       return;
    }

    make_summary(ch);
}

ACMD(do_affections)
{
  struct affected_type *aff;

  if(IS_NPC(ch))
    return;

  if (ch->affected) {
    send_to_char("&WYou feel that you are affected by:&n\r\n", ch);
     for (aff = ch->affected; aff; aff = aff->next) {
       *buf2 = '\0';
		if(aff->duration == -1)
         sprintf(buf, "&RAFF&W: &n(innate) %s%-21s%s ", CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));
        else
         sprintf(buf, "&RAFF&W: &n(%4dhr) %s%-21s%s ", (aff->duration > 24 ? 24 : aff->duration + 1),
               CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));

       if (aff->modifier) {
         sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
         strcat(buf, buf2);
       }
       send_to_char(strcat(buf, "\r\n"), ch);
     }
   } else {
    send_to_char("&WYou feel yourself normal.&n\r\n", ch);
    return;
  }
}

ACMD(do_inventory)
{
  send_to_char("&GYou are carrying:&n\r\n", ch);
  list_obj_to_char(ch->carrying, ch, 1, TRUE);
}


ACMD(do_equipment)
{
  int i, found = 0, num = 0;

  send_to_char("&cYou are using:&n\r\n", ch);
  for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, wear_order_index[i])) {
      num++;
        if (CAN_SEE_OBJ(ch, GET_EQ(ch, wear_order_index[i]))) {
        send_to_char(where[wear_order_index[i]], ch);
        send_to_char("&y", ch);
        show_obj_to_char(GET_EQ(ch, wear_order_index[i]), ch, 1);
        send_to_char("&n", ch);
        found = TRUE;
       } else {
        send_to_char(where[wear_order_index[i]], ch);
        send_to_char("Something.\r\n", ch);
        found = TRUE;
      }
    }
  }
  if (!found)
    send_to_char("nothing.\r\n", ch);
  else
    if(num < (NUM_WEARS-2))
      send_to_char("\r\n&CYou still have places to wear equipments on.&n\r\n", ch);
}


ACMD(do_time)
{
  char suf[10];
  int weekday, day;

  sprintf(buf, "\r\n&cIt's &w%d &co'clock&n %s&c, on &w",
          ((time_info.hours % 12 == 0) ? 12 : ((time_info.hours) % 12)),
          ((time_info.hours >= 12) ? "&wpm&n" : "&wam&n"));

  day = time_info.day + 1;      // day in [1..35]

  weekday = ((35 * time_info.month) + day) % 7;// 35 days in a month, 7 days a week


  strcat(buf, weekdays[weekday]);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);


  if (day == 1)
    strcpy(suf,"&Wst&n");
  else if (day == 2)
    strcpy(suf,"&Wnd&n");
  else if (day == 3)
    strcpy(suf,"&Wrd&n");
  else if (day < 20)
    strcpy(suf,"&Wth&n");
  else if ((day % 10) == 1)
    strcpy(suf,"&Wst&n");
  else if ((day % 10) == 2)
    strcpy(suf,"&Wnd&n");
  else if ((day % 10) == 3)
    strcpy(suf,"&Wrd&n");
  else
    strcpy(suf,"&Wth&n");

  sprintf(buf, "&cThe &w%d%s &cDay of the &w%s&c, Year &w%d&n.\r\n",
          day, suf, month_name[(int) time_info.month], time_info.year);

  send_to_char(buf, ch);
}

ACMD(do_weather)
{
  const char *sky_look[] = {
    "cloudless",
    "cloudy",
    "rainy",
    "lit by flashes of lightning"
  };

  if (OUTSIDE(ch)) {
    sprintf(buf, "The sky is %s and %s.\r\n", sky_look[weather_info.sky],
            (weather_info.change >= 0 ? "you feel a warm wind from south" :
             "your foot tells you bad weather is due"));
    send_to_char(buf, ch);
  } else
    send_to_char("You have no feeling about the weather at all.\r\n", ch);
}

struct help_index_element *find_help(char *keyword)
{
  extern int top_of_helpt;
  int i;

  for (i = 0; i < top_of_helpt; i++)
    if (isname(keyword, help_table[i].keywords))
      return (help_table + i);

  return NULL;
}

struct help_index_element *find_exact_help(char *keyword)
{
  extern int top_of_helpt;
  int i;

  for (i = 0; i < top_of_helpt; i++)
    if (exact_isname(keyword, help_table[i].keywords))
      return (help_table + i);

  return NULL;
}

int contar_helps(char *palavra, struct char_data *ch)
{
  extern int top_of_helpt;
  int i, x = 0;

  for (i = 0; i < top_of_helpt; i++) {
    if (is_name(palavra, help_table[i].keywords))
     if (help_table[i].min_level <= GET_LEVEL(ch))
       x++;
  }
  return (x);
}

ACMD(do_help)
{
  extern char *help;
  struct help_index_element *this_help;
  char entry[MAX_STRING_LENGTH];
  extern int top_of_helpt;
  int i, x;

  if (!ch->desc)
    return;

  skip_spaces(&argument);

  if (!*argument) {
    send_to_char(help, ch);
    return;
  }
  if (!help_table) {
    send_to_char("No help available.\r\n", ch);
    return;
  }

  if (!(this_help = find_exact_help(argument)))
  {
    if((x=contar_helps(argument, ch)) > 1){
	  sprintf(buf, "  &C%d &ctopics related:\r\n\r\n", x);
	  for (i = 0; i < top_of_helpt; i++) {
	    if (is_name(argument, help_table[i].keywords))
	      if (help_table[i].min_level <= GET_LEVEL(ch))
		sprintf(buf+strlen(buf), "      &y%s&n\r\n", help_table[i].keywords);
	  }
	  send_to_char(buf, ch);
	  return;
    }

    if (!(this_help = find_help(argument))) {
       send_to_char("There is no help on that word.\r\n", ch);
       sprintf(buf, "HELP: %s tried to get help on %s", GET_NAME(ch), argument);
       log(buf);
       return;
    }
  }

  if (this_help->min_level > GET_LEVEL(ch)) {
     send_to_char("There is no help on that word.\r\n", ch);
     return;
  }
  sprintf(entry, "&y%s&n\r\n%s", this_help->keywords, this_help->entry);
  send_to_char("\r\n\r\n", ch);
  page_string(ch->desc, entry, 0);
//  send_to_char(entry, ch);
}


#define WHO_USAGE \
"Format: who [minlev[-maxlev]] [-n name] [-c classlist] [-o] [-q] [-r] [-z]\r\n"
/*
ACMD(do_who)
{
  struct descriptor_data *d;
  struct char_data *wch;
  char godbuf[MAX_STRING_LENGTH];
  char mortbuf[MAX_STRING_LENGTH];
  char name_search[MAX_NAME_LENGTH+1];
  char mode;

  int low = 0, high = LVL_IMPL, showclass = 0;//, boot_high = 0;
  bool who_room = FALSE, who_zone = FALSE, who_quest = 0;
  bool outlaws = FALSE, noimm = FALSE, nomort = FALSE;

  int gods = 0, morts = 0;
  size_t i;

  skip_spaces(&argument);
  strcpy(buf, argument);
  name_search[0] = '\0';

  while (*buf) {
    half_chop(buf, arg, buf1);
    if (isdigit(*arg)) {
      sscanf(arg, "%d-%d", &low, &high);
      strcpy(buf, buf1);
    } else if (*arg == '-') {
      mode = *(arg + 1);
      switch (mode) {
      case 'o':
	outlaws = TRUE;
	strcpy(buf, buf1);
	break;
      case 'z':
	who_zone = TRUE;
	strcpy(buf, buf1);
	break;
      case 'q':
	who_quest = TRUE;
	strcpy(buf, buf1);
	break;
      case 'l':
	half_chop(buf1, arg, buf);
	sscanf(arg, "%d-%d", &low, &high);
	break;
      case 'n':
	half_chop(buf1, name_search, buf);
	break;
      case 'r':
	who_room = TRUE;
	strcpy(buf, buf1);
	break;
      case 'c':
	half_chop(buf1, arg, buf);
	for (i = 0; i < strlen(arg); i++)
	  showclass |= find_class_bitvector(arg[i]);
	break;
      case 'i':
        nomort = TRUE;
        strcpy(buf, buf1);
        break;
      case 'm':
        noimm = TRUE;
        strcpy(buf, buf1);
        break;
      default:
	send_to_char(WHO_FORMAT, ch);
	return;
	break;
      }

    } else {
      send_to_char(WHO_FORMAT, ch);
      return;
    }
  }

  sprintf(godbuf,  "		 &b-------------------------------------------------&n \r\n"
  		   "		&b|   	           &CMasters&c of &CWar&n                 &b|&n\r\n"
  		   "		&b|   	                                          |&n\r\n");

  sprintf(mortbuf, "		 &b-------------------------------------------------&n \r\n"
  		   "		&b|   	        &CGladiators&c on &CWarDome&n             &b|&n\r\n"
  		   "		&b|   	                                          |&n\r\n");

  for (d = descriptor_list; d; d = d->next) {
    if (d->connected)
      continue;

    if (d->original)
      wch = d->original;
    else if (!(wch = d->character))
      continue;

    if (!CAN_SEE(ch, wch))
      continue;
    if (GET_LEVEL(wch) < low || GET_LEVEL(wch) > high)
      continue;
    if ((noimm && GET_LEVEL(wch) >= LVL_IMMORT) || (nomort && GET_LEVEL(wch) < LVL_IMMORT))
      continue;
    if (*name_search && str_cmp(GET_NAME(wch), name_search) && !strstr(GET_TITLE(wch), name_search))
      continue;
    if (outlaws && !PLR_FLAGGED(wch, PLR_KILLER) && !PLR_FLAGGED(wch, PLR_THIEF))
      continue;
    if (who_quest && !PRF_FLAGGED(wch, PRF_QUEST))
      continue;
    if (who_zone && world[ch->in_room].zone != world[wch->in_room].zone)
      continue;
    if (who_room && (wch->in_room != ch->in_room))
      continue;
    if (showclass && !(showclass & (1 << GET_CLASS(wch))))
      continue;

    if (GET_LEVEL(wch) >= LVL_IMMORT) {
	 gods++;
         sprintf(godbuf,  "%s		&b|&Y%s&C{&c%2s&C}&n &B%-12.12s&n  %4s %3s %5s %8s %3s  &b|&n", godbuf, (GET_OLC_ZONE(wch) != -1 ? "&Y*&n" : " "),
         GET_GOD_WIZNAME(wch), GET_NAME(wch), (GET_CLAN_RANK(wch) > 0 ? "&GClan&n" : "    "), (GET_INVIS_LEV(wch) > 0 ? "&mInv&n" : "   "),
         (IS_AFFECTED(wch, AFF_INVISIBLE) ? "&MInvis&n" : "     "), (PLR_FLAGGED(wch, PLR_KILLER) ? "&RAssassin&n" : "        "),
         (PRF_FLAGGED(wch, PRF_AFK) ? "&gAfk&n" : "   "));
    } else {
         morts++;
         sprintf(mortbuf, "%s		&b| &C[&c%2d&C]&n &B%-12.12s&n  %4s %3s %5s %8s %3s  &b|&n", mortbuf,
         GET_LEVEL(wch), GET_NAME(wch), (GET_CLAN_RANK(wch) > 0 ? "&GClan&n" : "    "), (GET_INVIS_LEV(wch) > 0 ? "&mInv&n" : "   "),
         (IS_AFFECTED(wch, AFF_INVISIBLE) ? "&MInvis&n" : "     "), (PLR_FLAGGED(wch, PLR_KILLER) ? "&RAssassin&n" : "        "),
         (PRF_FLAGGED(wch, PRF_AFK) ? "&gAfk&n" : "   "));

    }

    sprintf(buf, "%s\r\n", CCNRM(ch, C_NRM));

    if (GET_LEVEL(wch) >= LVL_IMMORT)
      strcat(godbuf, buf);
    else
      strcat(mortbuf, buf);

  }

  send_to_char("\r\n", ch);

  if (gods > 0)
    send_to_char(godbuf, ch);

  if (morts > 0)
    send_to_char(mortbuf, ch);

  sprintf(buf,  "		 &b-------------------------------------------------&n\r\n"
  		"\r\n"
  		"		    &bWe have &B%d&b Gladiator%s and &B%d&b God%s of War &BOnline&b.&n\r\n", morts, (morts > 1 ? "s" : ""), gods, (gods > 1 ? "s" : ""));
  send_to_char(buf, ch);
}
*/

struct who_list {
  char *name;
  int level;
  struct who_list *next;
};

struct who_list *add_to_who(struct who_list *head, char *str,
        struct char_data *ch)
{
  struct who_list *tmp, *prev = NULL, *to_add = NULL;

  if (str && ch) {
    CREATE(to_add, struct who_list, 1);
    to_add->name = str_dup(str);
    to_add->level = GET_LEVEL(ch);
    to_add->next = NULL;
  } else {
    log("SYSERR: NULL str or ch in add_to_who");
    return NULL;
  }

  if (!head)
    return to_add;

  for (tmp = head; tmp; tmp = tmp->next) {
    if (to_add->level > tmp->level) {   /* ok, add record */
      if (prev)
        prev->next = to_add;
      if (head == tmp)
        head = to_add;
      to_add->next = tmp;
      return head;
    }
    prev = tmp;
  }
  prev->next = to_add;
  return head;
}

void output_who(struct who_list *head, struct char_data *ch)
{
  struct who_list *tmp, *next;

  if (!head) {
    log("SYSERR: output_who: hey, no head?");
    return;
  }

  for (tmp = head; tmp; tmp = next) {
    next = tmp->next;
    send_to_char(tmp->name, ch);

    if (!tmp || !tmp->name)
      log("SYSERR: output_who: trying to free invalid tmp->name");
    else {
      free(tmp->name);
    }
    if (!tmp)
      log("SYSERR: output_who: trying to free invalid tmp struct");
    else {
      free(tmp);
    }
  }
}
/*
ACMD(do_who)
{
  struct descriptor_data *d;
  struct char_data *tch;
  struct who_list *who_head = NULL;
  char name_search[MAX_INPUT_LENGTH];
  char mode;
  size_t i;
  int low = 0, high = LVL_IMPL, localwho = 0, questwho = 0;
  int showclass = 0, outlaws = 0, imm = 0, mort = 0;
  int who_room = 0, clan_num = 0;

  skip_spaces(&argument);
  strcpy(buf, argument);
  name_search[0] = '\0';

  while (*buf) {
    half_chop(buf, arg, buf1);
    if (isdigit(*arg)) {
      sscanf(arg, "%d-%d", &low, &high);
      strcpy(buf, buf1);
    } else if (*arg == '-') {
      mode = *(arg + 1);
      switch (mode) {
      case 'o':
      case 'k':
	outlaws = 1;
	strcpy(buf, buf1);
	break;
      case 'z':
	localwho = 1;
	strcpy(buf, buf1);
	break;
      case 'q':
	questwho = 1;
	strcpy(buf, buf1);
	break;
      case 'l':
	half_chop(buf1, arg, buf);
	sscanf(arg, "%d-%d", &low, &high);
	break;
      case 'n':
	half_chop(buf1, name_search, buf);
	break;
      case 'r':
	who_room = 1;
	strcpy(buf, buf1);
	break;
      case 'c':
	half_chop(buf1, arg, buf);
	for (i = 0; i < strlen(arg); i++)
	  showclass |= find_class_bitvector(arg[i]);
	break;
      default:
	send_to_char(WHO_USAGE, ch);
	return;
      }

    } else {
      send_to_char(WHO_USAGE, ch);
      return;
    }
  }

  send_to_char("\r\n&WWardome &wOnline&W Players&n\r\n\r\n", ch);

  for (d = descriptor_list; d; d = d->next) {
    if (STATE(d) != CON_PLAYING && !(d->connected == CON_OEDIT || d->connected == CON_REDIT  ||
        d->connected == CON_ZEDIT || d->connected == CON_MEDIT || d->connected == CON_SEDIT ||
        d->connected == CON_TEXTED || d->connected == CON_QEDIT || d->connected == CON_TRIGEDIT ||
        d->connected == CON_AEDIT || d->connected == CON_HEDIT))
      continue;

    if (d->original)
      tch = d->original;
    else if (!(tch = d->character))
      continue;

    if (*name_search && str_cmp(GET_NAME(tch), name_search) &&
	!strstr(GET_TITLE(tch), name_search))
      continue;
    if (!CAN_SEE(ch, tch) || GET_LEVEL(tch) < low || GET_LEVEL(tch) > high)
      continue;
    if (outlaws && !PLR_FLAGGED(tch, PLR_KILLER) &&
	!PLR_FLAGGED(tch, PLR_THIEF))
      continue;
    if (questwho && !PRF_FLAGGED(tch, PRF_QUEST))
      continue;
    if (localwho && world[ch->in_room].zone != world[tch->in_room].zone)
      continue;
    if (who_room && (tch->in_room != ch->in_room))
      continue;
    if (showclass && !(showclass & (1 << GET_CLASS(tch))))
      continue;

    if(GET_LEVEL(tch) >= LVL_IMMORT){
        sprintf(buf, "&W[&y%s&W]&n %s&c%s&n%s",
	      GET_GOD_WIZNAME(tch), (GET_PRENAME(tch) != NULL ? GET_PRENAME(tch) : ""),
	      GET_NAME(tch), GET_TITLE(tch));
        imm++;
    } else {
       if(GET_REMORT(tch) > 0 && GET_REMORT(tch) <= 12) {
        sprintf(buf, "&W[&n&y%s&W]&n %s&c%s&n%s",
	      GET_REMORT_NAME(tch),
	      (GET_PRENAME(tch) != NULL ? GET_PRENAME(tch) : ""),
	      GET_NAME(tch), GET_TITLE(tch));
       } else {
        sprintf(buf, "&W[&n %2d %s &W]&n %s&c%s&n%s",
	      GET_LEVEL(tch), CLASS_ABBR(tch),
	      (GET_PRENAME(tch) != NULL ? GET_PRENAME(tch) : ""),
	      GET_NAME(tch), GET_TITLE(tch));
//       }
        mort++;
    }

      if (GET_LEVEL(tch) >= LVL_ELDER)
        strcat(buf, " &G(&YSTAFF&G)&n");

      if (!PLR_FLAGGED(tch, PLR_NOPK) && GET_LEVEL(tch) < LVL_ELDER)
	strcat(buf, " &B(&RPK&B)&n");

      if ((clan_num=find_clan_by_id(GET_CLAN(tch)))>=0&&clan_num<num_of_clans) {
        if(GET_CLAN_RANK(tch)>0)
          sprintf(buf + strlen(buf), " &w[&n%s&n of &W%s&w]&n",
		clan[clan_num].rank_name[GET_CLAN_RANK(tch) -1],
                clan[clan_num].name);
      }

      if (GET_INVIS_LEV(tch))
	sprintf(buf + strlen(buf), " &n(i%d)", GET_INVIS_LEV(tch));
      else if (AFF_FLAGGED(tch, AFF_INVISIBLE))
	strcat(buf, " &n(invis)");

      if (d->connected == CON_OEDIT || d->connected == CON_REDIT
        || d->connected == CON_ZEDIT || d->connected == CON_MEDIT
        || d->connected == CON_SEDIT || d->connected == CON_QEDIT
        || d->connected == CON_HEDIT || d->connected == CON_AEDIT
        || d->connected == CON_TEXTED || d->connected == CON_TRIGEDIT)
        strcat(buf, " &g(&GOLC&g)&n");

      if (tch->char_specials.timer > 5)
        sprintf(buf + strlen(buf), " &R(idle: %d)&n", tch->char_specials.timer);

      if (PLR_FLAGGED(tch, PLR_MAILING))
	strcat(buf, " &n(mailing)");
      else if (PLR_FLAGGED(tch, PLR_WRITING))
	strcat(buf, " &n(writing)");

      if (PRF_FLAGGED(tch, PRF_DEAF))
	strcat(buf, " &n(deaf)");
      if (PRF_FLAGGED(tch, PRF_NOTELL))
	strcat(buf, " &W(notell)&n");
      if (PRF_FLAGGED(tch, PRF_QUEST))
	strcat(buf, " &C(quest)&n");
      if (PLR_FLAGGED(tch, PLR_THIEF))
	strcat(buf, " &n(THIEF)");
      if (PLR_FLAGGED(tch, PLR_KILLER))
	strcat(buf, " &n(KILLER)");
      if (PRF_FLAGGED(tch, PRF_AFK))
	strcat(buf, " &R(AFK)&n");

      if (world[tch->in_room].number <= 0)
        strcat(buf, " &W(&wvoided&W)&n");

      strcat(buf, CCNRM(ch, C_SPR));
      strcat(buf, "\r\n");

	who_head = add_to_who(who_head, buf, tch);
//      send_to_char(buf, ch);

  }
  if (who_head)
    output_who(who_head, ch);

  sprintf(buf1, "\r\n&WWe have &w%d&W Gladiator%s and &w%d&W God%s of War Online.&n\r\n", mort, (mort != 1 ? "s" : ""), imm, (imm != 1 ? "s" : ""));
  send_to_char(buf1, ch);

}
*/

ACMD(do_who)
{
  struct descriptor_data *d;
  struct char_data *tch;
//  struct who_list *who_head = NULL;
  char name_search[MAX_INPUT_LENGTH];
  char mess_buf[MAX_STRING_LENGTH];
  char mode;
  size_t i;
  int low = 0, high = LVL_IMPL, localwho = 0, questwho = 0;
  int showclass = 0, outlaws = 0, imm = 0, mort = 0;
  int who_room = 0, clan_num = 0, is_pk = 0;
  int l;

  skip_spaces(&argument);
  strcpy(buf, argument);
  name_search[0] = '\0';
  *mess_buf = '\0';

  while (*buf) {
    half_chop(buf, arg, buf1);
    if (isdigit(*arg)) {
      sscanf(arg, "%d-%d", &low, &high);
      strcpy(buf, buf1);
    } else if (*arg == '-') {
      mode = *(arg + 1);       /* just in case; we destroy arg in the switch */
      switch (mode) {
      case 'o':
      case 'k':
	outlaws = 1;
	strcpy(buf, buf1);
	break;
      case 'z':
	localwho = 1;
	strcpy(buf, buf1);
	break;
      case 'q':
	questwho = 1;
	strcpy(buf, buf1);
	break;
      case 'l':
	half_chop(buf1, arg, buf);
	sscanf(arg, "%d-%d", &low, &high);
	break;
      case 'n':
	half_chop(buf1, name_search, buf);
	break;
      case 'r':
	who_room = 1;
	strcpy(buf, buf1);
	break;
      case 'c':
	half_chop(buf1, arg, buf);
	for (i = 0; i < strlen(arg); i++)
	  showclass |= find_class_bitvector(arg[i]);
	break;
      default:
	send_to_char(WHO_USAGE, ch);
	return;
      }				/* end of switch */

    } else {			/* endif */
      send_to_char(WHO_USAGE, ch);
      return;
    }
  }				/* end while (parser) */

  send_to_char("\r\n&WWardome &wOnline&W Players&n\r\n\r\n", ch);

for(l = LVL_IMPL+1; l >= 0; l--){
  for (d = descriptor_list; d; d = d->next) {
    if (STATE(d) != CON_PLAYING && !(d->connected == CON_OEDIT || d->connected == CON_REDIT  ||
        d->connected == CON_ZEDIT || d->connected == CON_MEDIT || d->connected == CON_SEDIT ||
        d->connected == CON_TEXTED || d->connected == CON_QEDIT || d->connected == CON_TRIGEDIT ||
        d->connected == CON_AEDIT || d->connected == CON_HEDIT))
      continue;

    if (d->original)
      tch = d->original;
    else if (!(tch = d->character))
      continue;

    if(l != GET_LEVEL(tch))
      continue;
    if (*name_search && str_cmp(GET_NAME(tch), name_search) &&
	!strstr(GET_TITLE(tch), name_search))
      continue;
    if (!CAN_SEE(ch, tch) || GET_LEVEL(tch) < low || GET_LEVEL(tch) > high)
      continue;
    if (outlaws && !PLR_FLAGGED(tch, PLR_KILLER) &&
	!PLR_FLAGGED(tch, PLR_THIEF))
      continue;
    if (questwho && !PRF_FLAGGED(tch, PRF_QUEST))
      continue;
    if (localwho && world[ch->in_room].zone != world[tch->in_room].zone)
      continue;
    if (who_room && (tch->in_room != ch->in_room))
      continue;
    if (showclass && !(showclass & (1 << GET_CLASS(tch))))
      continue;
    if (is_pk && !PLR_FLAGGED(tch, PLR_NOPK) && GET_LEVEL(tch) < LVL_ELDER)
      continue;

        if(GET_LEVEL(tch) >= LVL_IMMORT){
        sprintf(buf, "&W[&y%s&W]&n %s&r%s &n%s",
	      GET_GOD_WIZNAME(tch), (GET_PRENAME(tch) != NULL ? GET_PRENAME(tch) : ""),
	      GET_NAME(tch), GET_TITLE(tch));
        imm++;
    } else {
       if(PLR_FLAGGED(tch, PLR_KILLER)) {
       	sprintf(buf, "&W[&r&RKILLER&r&W%s]&n %s&c%s &n%s",
       	     (can_pk(ch, tch) && ch != tch ? "&R*&W" : " "),
       	     (GET_PRENAME(tch) !=NULL ? GET_PRENAME(tch) : ""),
       	     GET_NAME(tch), GET_TITLE(tch));
     }  else if(!AFF2_FLAGGED(tch, AFF2_TRANSFORM)) {
         sprintf(buf, "&W[&n%3d &Y%s&W%s]&n %s&c%s &n%s",
 	      GET_LEVEL(tch), CLASS_ABBR(tch),
 	      (can_pk(ch, tch) && ch != tch ? "&R*&W" : " "),
	      (GET_PRENAME(tch) != NULL ? GET_PRENAME(tch) : ""),
	      GET_NAME(tch), GET_TITLE(tch));

       } else  {
         sprintf(buf, "&W[&n%s&W]&n %s &Y%s &n%s",
 	      (IS_EVIL(tch) ? " &WDemon&n " : (IS_GOOD(tch) ? " &CLight&n " : "&nNeutral&n")),
	      cnome_trans[GET_TRANS(tch)],
	      GET_NAME(tch), GET_TITLE(tch));
       }
      mort++;
    }


	if(GET_CLAN(tch) && GET_CLAN_POS(tch))
	{
		clan_num = posicao_clan(GET_CLAN(tch));
		sprintf(buf + strlen(buf), " &W[&n%s&W:&n %s&W]&n",
			clans[clan_num].nome_clan, clans[clan_num].pos_nome[GET_CLAN_POS(tch)-1]);
	}


      if (GET_INVIS_LEV(tch))
	sprintf(buf + strlen(buf), " &n(i%d)", GET_INVIS_LEV(tch));
      else if (AFF_FLAGGED(tch, AFF_INVISIBLE))
	strcat(buf, " &n(invis)");

      if (d->connected == CON_OEDIT || d->connected == CON_REDIT
        || d->connected == CON_ZEDIT || d->connected == CON_MEDIT
        || d->connected == CON_SEDIT || d->connected == CON_QEDIT
        || d->connected == CON_HEDIT || d->connected == CON_AEDIT
        || d->connected == CON_TEXTED || d->connected == CON_TRIGEDIT)
        strcat(buf, " &g(&GOLC&g)&n");

      if (tch->char_specials.timer > 5)
        sprintf(buf + strlen(buf), " &R(idle: %d)&n", tch->char_specials.timer);

      if (PLR_FLAGGED(tch, PLR_MAILING))
	strcat(buf, " &n(mailing)");
      else if (PLR_FLAGGED(tch, PLR_WRITING))
	strcat(buf, " &n(writing)");

      if (PRF_FLAGGED(tch, PRF_DEAF))
	strcat(buf, " &n(deaf)");
      if (PRF_FLAGGED(tch, PRF_NOTELL))
	strcat(buf, " &W(notell)&n");
      if (PRF_FLAGGED(tch, PRF_QUEST))
	strcat(buf, " &C(quest)&n");
      if (PLR_FLAGGED(tch, PLR_THIEF))
	strcat(buf, " &n(THIEF)");
    /*  if (PLR_FLAGGED(tch, PLR_KILLER))
	strcat(buf, " &n(KILLER)");*/
      if (PRF_FLAGGED(tch, PRF_AFK))
	strcat(buf, " &R(AFK)&n");
      if (ROOM_FLAGGED(IN_ROOM(tch), ROOM_ARENA))
        strcat(buf, " &g(GLADIATOR)&n");
      if ((!PLR_FLAGGED(tch, PLR_NOPK)) && (GET_LEVEL(tch) < 202) && (GET_LEVEL(ch) < 202))
		  strcat(buf, " &W(&RPK&W)&n");

      if (world[tch->in_room].number <= 0)
        strcat(buf, " &W(&wvoided&W)&n");

      strcat(buf, CCNRM(ch, C_SPR));
      strcat(buf, "\r\n");

      send_to_char(buf, ch);

  }				/* end of for */
}
  sprintf(buf1, "\r\n&WWe have &w%d&W Gladiator%s and &w%d&W God%s of War Online.&n\r\n", mort, (mort != 1 ? "s" : ""), imm, (imm != 1 ? "s" : ""));
  send_to_char(buf1, ch);

  if((imm + mort) > total_p)
    total_p = (imm + mort);

  if(GET_LEVEL(ch) >= LVL_ELDER) {
    sprintf(buf1, "&WMax players on this boot: &R%d&n\r\n", total_p);
    send_to_char(buf1, ch);
  }
 if (*mess_info.message && *mess_info.writer && mess_info.time) {
    sprintf(mess_buf, "\r\n%s#wMessage from %s, written on %-20s",
            mess_info.message, mess_info.writer, ctime(&mess_info.time));
    strcat(buf, mess_buf);
  }
}

int count_ips(char *ip)
{
	struct descriptor_data *d;
	short int count = 0;

	for (d = descriptor_list; d; d = d->next)
		if(!strcmp(d->host, ip))
			count++;
	return (count);
}

#define USERS_FORMAT \
"Format: users [-l minlevel[-maxlevel]] [-n name] [-h host] [-c classlist] [-o] [-p]\r\n"

ACMD(do_users)
{
  const char *format = "%3d %-7s %-12s %-14s %-3s %-8s ";
  char line[200], line2[220], idletime[10], classname[20];
  char state[30], *timeptr, mode;
  char name_search[MAX_INPUT_LENGTH], host_search[MAX_INPUT_LENGTH];
  struct char_data *tch;
  struct descriptor_data *d;
  size_t i;
  int low = 0, high = LVL_IMPL, num_can_see = 0;
  int showclass = 0, outlaws = 0, playing = 0, deadweight = 0;

  host_search[0] = name_search[0] = '\0';

  strcpy(buf, argument);
  while (*buf) {
    half_chop(buf, arg, buf1);
    if (*arg == '-') {
      mode = *(arg + 1);  /* just in case; we destroy arg in the switch */
      switch (mode) {
      case 'o':
      case 'k':
        outlaws = 1;
        playing = 1;
        strcpy(buf, buf1);
        break;
      case 'p':
        playing = 1;
        strcpy(buf, buf1);
        break;
      case 'd':
        deadweight = 1;
        strcpy(buf, buf1);
        break;
      case 'l':
        playing = 1;
        half_chop(buf1, arg, buf);
        sscanf(arg, "%d-%d", &low, &high);
        break;
      case 'n':
        playing = 1;
        half_chop(buf1, name_search, buf);
        break;
      case 'h':
        playing = 1;
        half_chop(buf1, host_search, buf);
        break;
      case 'c':
        playing = 1;
        half_chop(buf1, arg, buf);
        for (i = 0; i < strlen(arg); i++)
          showclass |= find_class_bitvector(arg[i]);
        break;
      default:
        send_to_char(USERS_FORMAT, ch);
        return;
      }                         /* end of switch */

    } else {                    /* endif */
      send_to_char(USERS_FORMAT, ch);
      return;
    }
  }                             /* end while (parser) */
  strcpy(line,
         "Num Class    Name         State          Idl Login@   Site\r\n");
  strcat(line,
         "--- -------- ------------ -------------- --- -------- ------------------------\r\n");
  send_to_char(line, ch);

  one_argument(argument, arg);

  for (d = descriptor_list; d; d = d->next) {
    if (STATE(d) != CON_PLAYING && playing)
      continue;
    if (STATE(d) == CON_PLAYING && deadweight)
      continue;
    if (STATE(d) == CON_PLAYING) {
      if (d->original)
        tch = d->original;
      else if (!(tch = d->character))
        continue;

      if (*host_search && !strstr(d->host, host_search))
        continue;
      if (*name_search && str_cmp(GET_NAME(tch), name_search))
        continue;
      if (!CAN_SEE(ch, tch) || GET_LEVEL(tch) < low || GET_LEVEL(tch) > high)
        continue;
      if (outlaws && !PLR_FLAGGED(tch, PLR_KILLER) &&
          !PLR_FLAGGED(tch, PLR_THIEF))
        continue;
      if (showclass && !(showclass & (1 << GET_CLASS(tch))))
        continue;
      if (GET_INVIS_LEV(ch) > GET_LEVEL(ch))
        continue;

      if (d->original)
        sprintf(classname, "[%3d %s]", GET_LEVEL(d->original),
                CLASS_ABBR(d->original));
      else
        sprintf(classname, "[%3d %s]", GET_LEVEL(d->character),
                CLASS_ABBR(d->character));
    } else
      strcpy(classname, "   -   ");

    timeptr = asctime(localtime(&d->login_time));
    timeptr += 11;
    *(timeptr + 8) = '\0';

    if (STATE(d) == CON_PLAYING && d->original)
      strcpy(state, "Switched");
    else
      strcpy(state, connected_types[STATE(d)]);

    if (d->character && STATE(d) == CON_PLAYING && GET_LEVEL(d->character) < LVL_GOD)
      sprintf(idletime, "%3d", d->character->char_specials.timer *
              SECS_PER_MUD_HOUR / SECS_PER_REAL_MIN);
    else
      strcpy(idletime, "");

    if (d->character && d->character->player.name) {
      if (d->original)
        sprintf(line, format, d->desc_num, classname,
                d->original->player.name, state, idletime, timeptr);
      else
        sprintf(line, format, d->desc_num, classname,
                d->character->player.name, state, idletime, timeptr);
    } else
      sprintf(line, format, d->desc_num, "    -   ", "UNDEFINED",
              state, idletime, timeptr);

    if (d->host && *d->host)
      sprintf(line + strlen(line), "[%s%s&n]\r\n", (count_ips(d->host) > 1 ? "&R" : ""), d->host);
    else
      strcat(line, "[Hostname unknown]\r\n");

    if (STATE(d) != CON_PLAYING) {
      sprintf(line2, "%s%s%s", CCGRN(ch, C_SPR), line, CCNRM(ch, C_SPR));
      strcpy(line, line2);
    }
    if (STATE(d) != CON_PLAYING ||
                (STATE(d) == CON_PLAYING && CAN_SEE(ch, d->character))) {
      send_to_char(line, ch);
      num_can_see++;
    }
  }

  sprintf(line, "\r\n%d visible sockets connected.\r\n", num_can_see);
  send_to_char(line, ch);
}


/* Generic page_string function for displaying text */
ACMD(do_gen_ps)
{
  switch (subcmd) {
  case SCMD_CREDITS:
    page_string(ch->desc, credits, 0);
    break;
  case SCMD_NEWS:
    page_string(ch->desc, news, 0);
    break;
  case SCMD_INFO:
    if(PRF_FLAGGED(ch, PRF_INFO_START))
	REMOVE_BIT(PRF_FLAGS(ch), PRF_INFO_START);
    page_string(ch->desc, info, 0);
    break;
  case SCMD_WIZLIST:
    send_to_char(wizlist, ch);
    break;
  case SCMD_IMMLIST:
    send_to_char(immlist, ch);
    break;
  case SCMD_HANDBOOK:
    page_string(ch->desc, handbook, 0);
    break;
  case SCMD_POLICIES:
    page_string(ch->desc, policies, 0);
    break;
  case SCMD_MOTD:
    send_to_char(motd, ch);
    break;
  case SCMD_IMOTD:
    send_to_char(imotd, ch);
    break;
  case SCMD_CLEAR:
    send_to_char("\033[H\033[J", ch);
    break;
  case SCMD_VERSION:
    send_to_char(CIRCLEMUD_VERSION, ch);
    send_to_char("\r\n", ch);
    break;
  case SCMD_WHOAMI:
    send_to_char(strcat(strcpy(buf, GET_NAME(ch)), "\r\n"), ch);
    break;
  default:
    log("SYSERR: Unhandled case in do_gen_ps. (%d)", subcmd);
    return;
  }
}


void perform_mortal_where(struct char_data * ch, char *arg)
{
  struct char_data *i;
  struct descriptor_data *d;

  if (!*arg) {
    send_to_char("Players in your Zone\r\n--------------------\r\n", ch);
    for (d = descriptor_list; d; d = d->next) {
      if (STATE(d) != CON_PLAYING || d->character == ch)
        continue;
      if ((i = (d->original ? d->original : d->character)) == NULL)
        continue;
      if (i->in_room == NOWHERE || !CAN_SEE(ch, i))
        continue;
      if (world[ch->in_room].zone != world[i->in_room].zone)
        continue;
      sprintf(buf, "%-20s - %s\r\n", GET_NAME(i), world[i->in_room].name);
      send_to_char(buf, ch);
    }
  } else {                      /* print only FIRST char, not all. */
    for (i = character_list; i; i = i->next) {
      if (i->in_room == NOWHERE || i == ch)
        continue;
      if (!CAN_SEE(ch, i) || world[i->in_room].zone != world[ch->in_room].zone)
        continue;
      if (!isname(arg, i->player.name))
        continue;
      sprintf(buf, "%-25s - %s\r\n", GET_NAME(i), world[i->in_room].name);
      send_to_char(buf, ch);
      return;
    }
    send_to_char("No-one around by that name.\r\n", ch);
  }
}


void print_object_location(int num, struct obj_data * obj, struct char_data * ch,
                                int recur)
{

  if (num > 0)
    sprintf(buf, "O%3d. %-25s - ", num, obj->short_description);
  else
    sprintf(buf, "%33s", " - ");

  if (obj->in_room > NOWHERE) {
    sprintf(buf + strlen(buf), "[%5d] %s\r\n",
            GET_ROOM_VNUM(IN_ROOM(obj)), world[obj->in_room].name);
    send_to_char(buf, ch);
  } else if (obj->carried_by) {
    sprintf(buf + strlen(buf), "carried by %s\r\n",
            PERS(obj->carried_by, ch));
    send_to_char(buf, ch);
  } else if (obj->worn_by) {
    sprintf(buf + strlen(buf), "worn by %s\r\n",
            PERS(obj->worn_by, ch));
    send_to_char(buf, ch);
  } else if (obj->in_obj) {
    sprintf(buf + strlen(buf), "inside %s%s\r\n",
            obj->in_obj->short_description, (recur ? ", which is" : " "));
    send_to_char(buf, ch);
    if (recur)
      print_object_location(0, obj->in_obj, ch, recur);
  } else {
    sprintf(buf + strlen(buf), "in an unknown location\r\n");
    send_to_char(buf, ch);
  }

}

void perform_immort_where(struct char_data * ch, char *arg)
{
  struct char_data *i;
  struct obj_data *k;
  struct descriptor_data *d;
  int num = 0, found = 0;

  if (!*arg) {
    send_to_char("Players\r\n-------\r\n", ch);
    for (d = descriptor_list; d; d = d->next)
      if (STATE(d) == CON_PLAYING) {
        i = (d->original ? d->original : d->character);
        if (i && CAN_SEE(ch, i) && (i->in_room != NOWHERE)) {
          if (d->original)
            sprintf(buf, "%-20s - [%5d] %s (in %s)\r\n",
                    GET_NAME(i), GET_ROOM_VNUM(IN_ROOM(d->character)),
                 world[d->character->in_room].name, GET_NAME(d->character));
          else
            sprintf(buf, "%-20s - [%5d] %s\r\n", GET_NAME(i),
                    GET_ROOM_VNUM(IN_ROOM(i)), world[i->in_room].name);
          send_to_char(buf, ch);
        }
      }
  } else {
    for (i = character_list; i; i = i->next)
      if (CAN_SEE(ch, i) && i->in_room != NOWHERE && isname(arg, i->player.name)) {
        found = 1;
        sprintf(buf, "M%3d. %-25s - [%5d] %s\r\n", ++num, GET_NAME(i),
                GET_ROOM_VNUM(IN_ROOM(i)), world[IN_ROOM(i)].name);
        send_to_char(buf, ch);
      }
    for (num = 0, k = object_list; k; k = k->next)
      if (CAN_SEE_OBJ(ch, k) && isname(arg, k->name)) {
        found = 1;
        print_object_location(++num, k, ch, TRUE);
      }

    if (!found){
      sprintf(buf,"Couldn't find any such thing.\r\n");
      send_to_char(buf, ch);
      return;
    }
  }
}

ACMD(do_where)
{
  one_argument(argument, arg);

  if (GET_LEVEL(ch) >= LVL_ELDER)
    perform_immort_where(ch, arg);
  else
    perform_mortal_where(ch, arg);
}



ACMD(do_levels)
{
  int i;

  if (IS_NPC(ch)) {
    send_to_char("You ain't nothin' but a hound-dog.\r\n", ch);
    return;
  }
  strcpy(buf, "&cXP &WTable&n\r\n\r\n");

  for (i = 1; i < LVL_IMMORT; i++)
    sprintf(buf + strlen(buf), "&W[&c%3d&W] &C%12s&n%s", i,
            add_points(level_exp(GET_REMORT(ch), i+1)),
            ((!(i % 4)) ? "\r\n" : "  "));

  page_string(ch->desc, buf, 1);
}


/* Function to calculate a char's combat rating */
int combat_rating(struct char_data *ch)
{
    int rating;

    if (IS_NPC(ch))
	rating = GET_LEVEL(ch);
    else
	rating = GET_LEVEL(ch);

    rating = (int)(rating * (float)GET_HIT(ch)/(float)GET_MAX_HIT(ch));

    return rating;
}

ACMD(do_consider)
{
   struct char_data *victim;
   int	diff;

   one_argument(argument, buf);

   if (!(victim = get_char_room_vis(ch, buf))) {
      send_to_char("Consider killing who?\n\r", ch);
      return;
   }

   if (victim == ch) {
      send_to_char("Easy!  Very easy indeed!\n\r", ch);
      return;
   }

   if (!IS_NPC(victim)) {
      send_to_char("Would you like to borrow a cross and a shovel?\n\r", ch);
      return;
   }

    if (GET_HIT(victim) < 1) {
       send_to_char("I think it's dead already.\n\r", ch);
       return;
    }

    diff = GET_AC(victim) - GET_AC(ch);     /*Print AC comparison */
    if (diff <= -140)
        send_to_char("Your victim is massively better protected than you.\n\r", ch);
    else if (diff <= -80)
        send_to_char("Your victim is well better armored than you!\n\r", ch);
    else if (diff <= -20)
        send_to_char("Your victim is better armored than you.\n\r", ch);
    else if (diff <=  30)
        send_to_char("Your victim is about evenly armored with you.\n\r", ch);
    else if (diff <=  90)
        send_to_char("Your victim lacks some of your protection.\n\r", ch);
    else if (diff <= 150)
        send_to_char("Your victim lacks much of your protection.\n\r", ch);
    else
        send_to_char("Your victim is grossly under armored compared to you.\n\r", ch);


    diff = (int) (100 - GET_HIT(victim)*100/GET_HIT(ch)); /* HP % Compare */
    if (diff <= -49)
        send_to_char("Your victim is massively healthier than you!\n\r", ch);
    else if (diff <= -29)
        send_to_char("Your victim is considerably healthier than you.\n\r", ch);
    else if (diff <=  -9)
        send_to_char("Your victim is healthier than you.\n\r", ch);
    else if (diff <=  10)
        send_to_char("Your victim is about the same health as you.\n\r", ch);
    else if (diff <=  30)
        send_to_char("Your victim is not as healthy as you.\n\r", ch);
    else if (diff <=  50)
        send_to_char("Your victim lacks your vigor.\n\r", ch);
    else
        send_to_char("Your victim is puny in comparison.\n\r", ch);


   diff = (combat_rating(victim) - combat_rating(ch));

   if (diff <= -10)
       send_to_char("Now where did that chicken go?\n\r", ch);
   else if (diff <= -5)
       send_to_char("You could do it with a needle!\n\r", ch);
   else if (diff <= -2)
       send_to_char("Easy.\n\r", ch);
   else if (diff <= -1)
       send_to_char("Fairly easy.\n\r", ch);
   else if (diff == 0)
       send_to_char("The perfect match!\n\r", ch);
   else if (diff <= 1)
       send_to_char("You would need some luck!\n\r", ch);
   else if (diff <= 2)
       send_to_char("You would need a lot of luck!\n\r", ch);
   else if (diff <= 3)
       send_to_char("You would need a lot of luck and great equipment!\n\r", ch);
   else if (diff <= 5)
       send_to_char("Do you feel lucky, punk?\n\r", ch);
   else if (diff <= 10)
       send_to_char("Are you mad!?\n\r", ch);
   else if (diff <= 15)
       send_to_char("You ARE mad!\n\r", ch);
   else if (diff <= 20)
       send_to_char("Why not pretend you are dead instead?\n\r", ch);
   else if (diff <= 30)
       send_to_char("Your brain will be a nice decoration on the walls!!\n\r", ch);
   else
       send_to_char("You are a very dumb player for even considering.\n\r", ch);
}

ACMD(do_diagnose)
{
  struct char_data *vict;

  one_argument(argument, buf);

  if (*buf) {
    if (!(vict = get_char_room_vis(ch, buf)))
      send_to_char(NOPERSON, ch);
    else
      diag_char_to_char(vict, ch);
  } else {
    if (FIGHTING(ch))
      diag_char_to_char(FIGHTING(ch), ch);
    else
      send_to_char("Diagnose who?\r\n", ch);
  }
}

ACMD(do_color)
{
  if (IS_NPC(ch))
    return;

  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Usage: color <light|off>\r\n", ch);
    return;
  }

  if(isname(arg, "light")) {
    SET_BIT(PRF_FLAGS(ch), PRF_COLOR_1 | PRF_COLOR_2);
    sprintf(buf, "You light your %scolors%s.\r\n", CCBWHT(ch, C_SPR),
          CCNRM(ch, C_OFF));
  } else if(isname(arg, "off")) {
    REMOVE_BIT(PRF_FLAGS(ch), PRF_COLOR_1 | PRF_COLOR_2);
    sprintf(buf, "Your %scolor%s is now OFF.\r\n", CCBWHT(ch, C_SPR),
          CCNRM(ch, C_OFF));
  } else
      sprintf(buf, "Usage: color <light|off>\r\n");

  send_to_char(buf, ch);
}


ACMD(do_toggle)
{
  if (IS_NPC(ch))
    return;
  if (GET_WIMP_LEV(ch) == 0)
    strcpy(buf2, "OFF");
  else
    sprintf(buf2, "%-3d", GET_WIMP_LEV(ch));

  sprintf(buf,
  "&gHit Pnt Display: &c[&r%-3s&c]         &gBrief Mode: &c[&r%-3s&c]     &gSummon Protect: &c[&r%-3s&c]\r\n"
  "   &gMove Display: &c[&r%-3s&c]       &gCompact Mode: &c[&r%-3s&c]           &gOn Quest: &c[&r%-3s&c]\r\n"
  "   &gMana Display: &c[&r%-3s&c]             &gNoTell: &c[&r%-3s&c]       &gRepeat Comm.: &c[&r%-3s&c]\r\n"
  " &gAuto Show Exit: &c[&r%-3s&c]               &gDeaf: &c[&r%-3s&c]         &gWimp Level: &c[&r%-3s&c]\r\n"
  " &gGossip Channel: &c[&r%-3s&c]    &gAuction Channel: &c[&r%-3s&c]      &gGrats Channel: &c[&r%-3s&c]\r\n"
  "  &gAuto Get Gold: &c[&r%-3s&c]  &gAuto Loot Corpses: &c[&r%-3s&c]    &gAuto Split Gold: &c[&r%-3s&c]\r\n"
  "    &gAuto Assist: &c[&r%-3s&c]        &gColor Level: &c[&r%-3s&c]     &gNewbie Channel: &c[&r%-3s&c]\r\n",

      ONOFF(PRF_FLAGGED(ch, PRF_DISPHP)),
      ONOFF(PRF_FLAGGED(ch, PRF_BRIEF)),
      ONOFF(!PRF_FLAGGED(ch, PRF_SUMMONABLE)),

      ONOFF(PRF_FLAGGED(ch, PRF_DISPMOVE)),
      ONOFF(PRF_FLAGGED(ch, PRF_COMPACT)),
      YESNO(PRF_FLAGGED(ch, PRF_QUEST)),

      ONOFF(PRF_FLAGGED(ch, PRF_DISPMANA)),
      ONOFF(PRF_FLAGGED(ch, PRF_NOTELL)),
      YESNO(!PRF_FLAGGED(ch, PRF_NOREPEAT)),

      ONOFF(PRF_FLAGGED(ch, PRF_AUTOEXIT)),
      YESNO(PRF_FLAGGED(ch, PRF_DEAF)),
      buf2,

      ONOFF(!PRF_FLAGGED(ch, PRF_NOGOSS)),
      ONOFF(!PRF_FLAGGED(ch, PRF_NOAUCT)),
      ONOFF(!PRF_FLAGGED(ch, PRF_NOGRATZ)),

      ONOFF(PRF_FLAGGED(ch, PRF_AUTOGOLD)),
      ONOFF(PRF_FLAGGED(ch, PRF_AUTOLOOT)),
      ONOFF(PRF_FLAGGED(ch, PRF_AUTOSPLIT)),
      ONOFF(PRF_FLAGGED(ch, PRF_AUTOASSIST)),

      ONOFF(PRF_FLAGGED(ch, PRF_COLOR_1)),
      ONOFF(!PRF2_FLAGGED(ch, PRF2_NONEWBIE)));

  send_to_char(buf, ch);
}


struct sort_struct {
  int sort_pos;
  byte is_social;
} *cmd_sort_info = NULL;

int num_of_cmds;


void sort_commands(void){
  int a, b, tmp;

  num_of_cmds = 0;

  /*
   * first, count commands (num_of_commands is actually one greater than the
   * number of commands; it inclues the '\n'.
   */
  while (*complete_cmd_info[num_of_cmds].command != '\n')
    num_of_cmds++;

  /* check if there was an old sort info.. then free it -- aedit -- M. Scott*/
  if (cmd_sort_info)
   free(cmd_sort_info);

  /* create data array */
  CREATE(cmd_sort_info, struct sort_struct, num_of_cmds);

  /* initialize it */
  for (a = 1; a < num_of_cmds; a++) {
    cmd_sort_info[a].sort_pos = a;
    cmd_sort_info[a].is_social = (complete_cmd_info[a].command_pointer == do_action);
  }

  /* the infernal special case */
  cmd_sort_info[find_command("insult")].is_social = TRUE;

  /* Sort.  'a' starts at 1, not 0, to remove 'RESERVED' */
  for (a = 1; a < num_of_cmds - 1; a++)
    for (b = a + 1; b < num_of_cmds; b++)
      if (strcmp(complete_cmd_info[cmd_sort_info[a].sort_pos].command,
		complete_cmd_info[cmd_sort_info[b].sort_pos].command) > 0) {
         tmp = cmd_sort_info[a].sort_pos;
        cmd_sort_info[a].sort_pos = cmd_sort_info[b].sort_pos;
        cmd_sort_info[b].sort_pos = tmp;
      }
}



ACMD(do_commands)
{
  int no, i, cmd_num;
  int wizhelp = 0, socials = 0;
  struct char_data *vict;

  one_argument(argument, arg);

  if (*arg) {
    if (!(vict = get_char_vis(ch, arg)) || IS_NPC(vict)) {
      send_to_char("Who is that?\r\n", ch);
      return;
    }
    if (GET_LEVEL(ch) < GET_LEVEL(vict)) {
      send_to_char("You can't see the commands of people above your level.\r\n", ch);
      return;
    }
  } else
    vict = ch;

  if (subcmd == SCMD_SOCIALS)
    socials = 1;
  else if (subcmd == SCMD_WIZHELP)
    wizhelp = 1;

  sprintf(buf, "The following %s%s are available to %s:\r\n",
          wizhelp ? "privileged " : "",
          socials ? "socials" : "commands",
          vict == ch ? "you" : GET_NAME(vict));

  /* cmd_num starts at 1, not 0, to remove 'RESERVED' */
  for (no = 1, cmd_num = 1; cmd_num < num_of_cmds; cmd_num++) {
    i = cmd_sort_info[cmd_num].sort_pos;
    if (complete_cmd_info[i].minimum_level >= 0 &&
	GET_LEVEL(vict) >= complete_cmd_info[i].minimum_level &&
	(complete_cmd_info[i].minimum_level >= LVL_IMMORT) == wizhelp &&
        (wizhelp || socials == cmd_sort_info[i].is_social)) {
      if (wizhelp)
        sprintf(buf + strlen(buf), "[%-3d] %-12s ", complete_cmd_info[i].minimum_level, complete_cmd_info[i].command);
      else
        sprintf(buf + strlen(buf), "%-19s", complete_cmd_info[i].command);
      if (!(no % 4))
        strcat(buf, "\r\n");
      else
        strcat(buf, " ");
      no++;
    }
  }

  strcat(buf, "\r\n");
  page_string(ch->desc, buf, 1);
//  send_to_char(buf, ch);
}

/*
char *howgood(int percent)
{
  static char buf[256];

  if (percent == 0)
    strcpy(buf, " &R(error)&n");
  else if (percent <= 10)
    strcpy(buf, " &B( &R10%&B)&n");
  else if (percent <= 20)
    strcpy(buf, " &B( &R20%&B)&n");
  else if (percent <= 40)
    strcpy(buf, " &B( &R40%&B)&n");
  else if (percent <= 55)
    strcpy(buf, " &B( &R55%&B)&n");
  else if (percent <= 70)
    strcpy(buf, " &B( &R70%&B)&n");
  else if (percent <= 80)
    strcpy(buf, " &B( &R80%&B)&n");
  else if (percent <= 90)
    strcpy(buf, " &B( &R95%&B)&n");
  else
    strcpy(buf, " &B(&R100%&B)&n");

  return (buf);
}
*/

char *howgood(int percent)
{
  if (percent < 0)
    return " &R(error)&n";
  if (percent == 0)
    return " &B(&Rnot learned&B)&n";
  if (percent <= 10)
    return "     &B(&Rawful&B)&n";
  if (percent <= 20)
    return "       &B(&Rbad&B)&n";
  if (percent <= 40)
    return "      &B(&Rpoor&B)&n";
  if (percent <= 55)
    return "      &B(&Rfair&B)&n";
  if (percent <= 70)
    return "   &B(&Raverage&B)&n";
  if (percent <= 80)
    return "      &B(&Rgood&B)&n";
  if (percent <= 85)
    return " &B(&Rvery good&B)&n";

    return "    &B(&Rsuperb&B)&n";
}

ACMD(do_spell)
{
 extern char *spells[];
 int i, c=0, x=0;

 if(IS_NPC(ch)){
 	send_to_char("Mobs checking spells???\r\n", ch);
 	return;
 }

 send_to_char("&BThese are the spells you know: (&W*&B = Special/Extra Spell)&n\r\n", ch);

 *buf2 = '\0';
 for (i = 1; i < MAX_SPELLS+1; i++)
 {
  if (GET_SKILL(ch, i) > 0 && strncmp(spells[i], "!UNUSED!", strlen(spells[i]))) {
    x++;
    c++;
    sprintf(buf, "%s&c%-22s&n  &W%s&n %s", (((GET_LEVEL(ch) <= LVL_IMMORT) && (GET_LEVEL(ch) < spell_info[i].min_level[(int) GET_CLASS(ch)])) ? "&W*&n" : " "),
    spells[i], howgood(GET_SKILL(ch, i)), (((c == 2)) ? "&n\r\n" : "&w|&n "));
    strcat(buf2, buf);
    if(c==2)
       c=0;
  }
 }
 if(c % 2)
    strcat(buf2, "\r\n\r\n");

 if(!x)
   strcat(buf2, "\r\n&WYou have no &cspells&W learned yet.\r\n");

 page_string(ch->desc, buf2, 1);
}

ACMD(do_skill)
{
 extern char *spells[];
 int i, c=0, x=0;

 if(IS_NPC(ch)){
 	send_to_char("Mobs checking skills???\r\n", ch);
 	return;
 }

 send_to_char("&BThese are the skills you know: (&W*&B = Special/Extra Skill)&n\r\n", ch);

 *buf2 = '\0';
 for (i = MAX_SPELLS +1; i < MAX_SKILLS+1; i++)
 {
  if (GET_SKILL(ch, i) > 0 && strncmp(spells[i], "!UNUSED!", strlen(spells[i]))) {
    x++;
    c++;
    sprintf(buf, "%s&c%-22s&n  &W%s&n %s", (((GET_LEVEL(ch) <= LVL_IMMORT) && (GET_LEVEL(ch) < spell_info[i].min_level[(int) GET_CLASS(ch)])) ? "&W*&n" : " "),
    spells[i], howgood(GET_SKILL(ch, i)), (((c == 2)) ? "&n\r\n" : "&w|&n "));
    strcat(buf2, buf);
    if(c==2)
       c=0;
  }
 }
 if(c % 2)
    strcat(buf2, "\r\n\r\n");

 if(!x)
   strcat(buf2, "\r\n&WYou have no &cskills&W learned yet.\r\n");

 page_string(ch->desc, buf2, 1);
}

ACMD(do_scan)
{
  struct char_data *i;
  int is_in, dir, dis, maxdis, found = 0;

  const char *distance[] = {
    "right here",
    "immediately ",
    "nearby ",
    "a ways ",
    "far ",
    "very far ",
    "extremely far ",
    "impossibly far ",
  };

  if (IS_NPC(ch) || !GET_SKILL(ch, SKILL_SCAN)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  if (IS_AFFECTED(ch, AFF_BLIND)) {
    act("You can't see anything, you're blind!", TRUE, ch, 0, 0, TO_CHAR);
    return;
  }
  if ((GET_MOVE(ch) < 3) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    act("You are too exhausted.", TRUE, ch, 0, 0, TO_CHAR);
    return;
  }

  maxdis = (1 + ((GET_SKILL(ch, SKILL_SCAN) * 5) / 100));
  if (GET_LEVEL(ch) >= LVL_IMMORT)
    maxdis = 7;

  act("You quickly scan the area and see:", TRUE, ch, 0, 0, TO_CHAR);
  act("$n quickly scans the area.", FALSE, ch, 0, 0, TO_ROOM);
  if (GET_LEVEL(ch) < LVL_IMMORT)
    GET_MOVE(ch) -= GET_LEVEL(ch) / 9;

  is_in = ch->in_room;
  for (dir = 0; dir < NUM_OF_DIRS; dir++) {
    ch->in_room = is_in;
    for (dis = 0; dis <= maxdis; dis++) {
      if (((dis == 0) && (dir == 0)) || (dis > 0)) {
        for (i = world[ch->in_room].people; i; i = i->next_in_room) {
          if ((!((ch == i) && (dis == 0))) && CAN_SEE(ch, i)) {
            sprintf(buf, "%33s, %s%s%s%s", GET_NAME(i), distance[dis],
                    ((dis > 0) && (dir < (NUM_OF_DIRS - 2))) ? "to the " : "",
                    (dis > 0) ? dirs[dir] : "",
                    ((dis > 0) && (dir > (NUM_OF_DIRS - 3))) ? "wards" : "");
            act(buf, TRUE, ch, 0, 0, TO_CHAR);
            found++;
	    improve_skill(ch, SKILL_SCAN);
          }
        }
      }
      if (!CAN_GO(ch, dir) || (world[ch->in_room].dir_option[dir]->to_room == is_in))
        break;
      else
        ch->in_room = world[ch->in_room].dir_option[dir]->to_room;
    }
  }
  if (found == 0)
    act("Nobody anywhere near you.", TRUE, ch, 0, 0, TO_CHAR);
  ch->in_room = is_in;
}

ACMD(do_player)
{
  struct char_data *victim = NULL;

  skip_spaces(&argument);

  if (!*argument) {
      sprintf(buf, "Find info on which player?\r\n");
      send_to_char(buf, ch);
    } else {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      CREATE(victim->player_specials, struct player_special_data, 1);
      if (load_char(argument, victim) > -1) {
         if(PLR_FLAGGED(victim, PLR_DELETED)){
            send_to_char("Find info on which player?\r\n", ch);
            return;
         }
	sprintf(buf, "\r\n&C%s&n is a great &c%s&n with the race &c%s&n.\r\n", GET_NAME(victim), pc_class_types[(int) GET_CLASS(victim)], pc_race_types[(int) GET_RACE(victim)]);
	sprintf(buf + strlen(buf), "%s is at level &G%d&n. &GR&Y%d&n.\r\n", (GET_SEX(victim) ? (GET_SEX(victim)==SEX_MALE ? "He" :"She") : "It"), GET_LEVEL(victim), GET_REMORT(victim));
	//sprintf(buf + strlen(buf), "&RWAR&n -> Died [&g%d&n] Killed [&G%d&n]\r\n", GET_ARENA_DIED(victim), GET_ARENA_KILLED(victim));
	sprintf(buf + strlen(buf), "He has died &R%d&n times and killed &B%d&n opponents.\r\n%s", GET_DIED(victim), GET_KILLED(victim), (victim->player.whoisdesc == NULL ? "" : "\r\n"));
	if(victim->player.whoisdesc)
	  sprintf(buf + strlen(buf), "%s\r\n", victim->player.whoisdesc);
	send_to_char(buf, ch);
      } else {
	sprintf(buf, "There is no such player.\r\n");
	send_to_char(buf, ch);
      }
      free_char(victim);
    }

}

ACMD(do_slist)
{
 extern char *pc_class_types[];
 extern char *spells[];
 extern struct spell_info_type spell_info[];
 int i, j, class, x = 1;
 bool flag = FALSE;

 *buf = '\0';

 one_argument(argument, arg);

  if (!*arg) {
   class = GET_CLASS(ch);
 } else {
     class = search_block_case(arg, pc_class_types, FALSE);
     send_to_char(buf, ch);
     if (class < 0 || class >= NUM_CLASSES) {
       send_to_char("Not a valid class.\n\r", ch);
       return;
     }
 }
 send_to_char("\r\n", ch);
 for (j = 1; j < LVL_IMMORT; j++) {
   for (i = 1; i < MAX_SKILLS+1; i++)
   {
      if (spell_info[i].min_level[class] == j)
        {
          sprintf(buf+strlen(buf), "&w[&W%3d&w] &C%-19s&n%s", spell_info[i].min_level[class], reprimir(spells[i], 19), (!(x++ % 3) ? "\r\n" : " "));
          flag = TRUE;
         }
   }
 }

 if (flag == FALSE) {
   if (!*arg)
     sprintf(buf, "&CYou will not learn anything in this class.&n\r\n");
   else
      sprintf(buf, "&CThe %s class will not learn anything.&n\r\n", pc_class_types[class]);
 }

 send_to_char(buf, ch);
 send_to_char("\r\n", ch);
}

/*
ACMD(do_sklist)
{
 extern char *pc_class_types[];
 extern char *spells[];
 extern struct spell_info_type spell_info[];
 int i, j, class;
 bool flag = FALSE;

 *buf = '\0';
 *buf2 = '\0';

 class = GET_CLASS(ch);
 strcpy(buf, "&WYou will learn these skills:&n\r\n\r\n"
             "&gSkill                  Level&n\r\n");
 strcpy(buf2, buf);

 for (j = 1; j < LVL_IMMORT; j++) {
   for (i = MAX_SPELLS +1; i < MAX_SKILLS+1; i++)
   {
      if (spell_info[i].min_level[class] == j)
      {
        sprintf(buf, "&G%-20s&n   &g[&G%3d&g]&n\r\n", spells[i], spell_info[i].min_level[class]);
        strcat(buf2, buf);
        flag = TRUE;
      }
   }
 }

 if (flag == FALSE) {
   if (!*arg)
     sprintf(buf2, "You will not learn skills in this class.\r\n");
     else
      sprintf(buf2, "The %s class will not learn skills.\r\n", pc_class_types[class]);
 }

 page_string(ch->desc, buf2, 1);
}
*/
char *arena(int points)
{
  if (points == 0)
    return "No Fights";
  if (points < 10)
    return "Arena Winner";
  if (points < 20)
    return "Fighter";
  if (points <= 30)
    return "Knight";
  if (points <= 40)
    return "Great Knight";
  if (points <= 50)
    return "Prince of War";
  if (points <= 60)
    return "King of War";
  if (points <= 70)
    return "Master of War";
  if (points <= 80)
    return "Eliminator";
  else
    return "MAXIMUS";
}

ACMD(do_whois)
{
  struct char_data *victim = NULL;
  //struct char_data *ch = NULL;
  int clan_num = 0;

  skip_spaces(&argument);

if (!*argument)
 {
  send_to_char("Do a WhoIS on which player?\r\n", ch);
 }

   else
  {
    CREATE(victim, struct char_data, 1);
    clear_char(victim);
    CREATE(victim->player_specials, struct player_special_data, 1);

       if (load_char(argument, victim) > -1)
     {

       if(PLR_FLAGGED(victim, PLR_DELETED))
       {
         send_to_char("Do a WhoIS on which player?\r\n", ch);
         return;
       }

        sprintf(buf, "\r\n         &RWARDOME PERSONAL INFORMATION - &RW&rH&RO&rI&RS&r - \r\n");
        sprintf(buf + strlen(buf), "&wInformation of %s&C%s, &n%s. &w%s is at level &M%d.\r\n",(GET_PRENAME(victim) != NULL ? GET_PRENAME(victim) : ""), GET_NAME(victim),GET_TITLE(victim),(GET_SEX(victim) ? (GET_SEX(victim)==SEX_MALE ? "He" :"She") : "It"), GET_LEVEL(victim));
        sprintf(buf + strlen(buf), "&wThe greater &B%s &wwith the race &B%s &wand have &C%d &wyears old.\r\n", pc_class_types[(int) GET_CLASS(victim)], pc_race_types[(int) GET_RACE(victim)], GET_AGE(victim));
        sprintf(buf + strlen(buf), "&RPk&r Information        &RWar&r Information    \r\n");
        sprintf(buf + strlen(buf), "&wKills  : &Y%-5d          &wWins : &Y%-5d                 \r\n", GET_KILLED(victim),GET_ARENA_KILLED(victim));
//      sprintf(buf + strlen(buf), "&wDied   : &Y%-5d          &wLoses: &Y%-5d                 \r\n", GET_DIED(victim),GET_ARENA_DIED(victim));
        sprintf(buf + strlen(buf), "&wRemorts: &G%-2d&n        &wArena Flag: &R%s&n                         \r\n", GET_REMORT(victim), arena(GET_ARENA_KILLED(victim)));
		if(GET_CLAN(victim) && GET_CLAN_POS(victim))
		{
			clan_num = posicao_clan(GET_CLAN(victim));
			sprintf(buf + strlen(buf), "&W%s is a &n%s &Win the &n%s&W.&n\r\n",
				(GET_SEX(victim) ? (GET_SEX(victim)==SEX_MALE ? "He" :"She") : "It"),
				clans[clan_num].pos_nome[GET_CLAN_POS(victim)-1], clans[clan_num].nome_clan);
		}

	  if(victim->player.whoisdesc)
	  sprintf(buf + strlen(buf), "%s\r\n", victim->player.whoisdesc);
          send_to_char(buf, ch);
     }    else
        {
	  send_to_char("&RThere is no such player.\r\n", ch);
        }
         free_char(victim);
  }
}


#define W_ENTER				10

int check_wanted(struct char_data * ch)
{
 if(GET_LEVEL(ch) > LVL_IMMORT)
   return FALSE;
 if(GET_KILLED(ch) < W_ENTER)
   return FALSE;

 return TRUE;
}

int check_wanted_gain_gold(struct char_data * ch)
{
 int gold = 0;

 if(!check_wanted)
   return FALSE;

 gold = GET_KILLED(ch)*10000;

 return gold;
}

int check_wanted_gain_qp(struct char_data * ch)
{
 int qp = 0;

 if(!check_wanted)
   return FALSE;

 qp = GET_KILLED(ch)/2;

 return qp;
}

char *wanted_c(int percent)
{
  if (percent == 0)
    return NULL;
  if (percent < 20)
    return "Killer";
  if (percent < 30)
    return "Assassin";
  if (percent <= 40)
    return "Son of Carnage";
  if (percent <= 50)
    return "Butcher";
  if (percent <= 60)
    return "Death Messenger";
  if (percent <= 70)
    return "Terminator";
  if (percent <= 80)
    return "Eliminator";
  else
    return "Head Hunter";
}

ACMD(do_wanted)
{
 int j, w = 0;
 extern int top_of_p_table;
 extern struct player_index_element *player_table;
 struct char_data *victim = NULL;
 char wanted[MAX_STRING_LENGTH];

 skip_spaces(&argument);

 *buf = '\0';
 *wanted = '\0';

 if(!*argument){
  for (j = 0; j <= top_of_p_table; j++){
    CREATE(victim, struct char_data, 1);
    clear_char(victim);
    CREATE(victim->player_specials, struct player_special_data, 1);
    if(load_char((player_table + j)->name, victim) > -1)
     if(check_wanted(victim) && !PLR_FLAGGED(victim, PLR_DELETED)){
	sprintf(wanted + strlen(wanted), " |     &c%-40s&n    &g%6d    &y%13s&n    |\r\n", GET_NAME(victim), check_wanted_gain_qp(victim), add_points(check_wanted_gain_gold(victim)));
        w++;
     }
  }
  free_char(victim);
  if(!w)
    send_to_char("&WNo &ROut&BLaws&W at this moment&n.\r\n", ch);
  else {
	strcpy(buf, " .~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:\r\n"
		" | &WList of &RWANTED&Ws in the &cW&bar&cD&bome &WLands.&n                                      |\r\n"
		" | &WHunt them. &CAlive &Wor &RDEAD&W, and off course, &RDEAD&W is MUCH better!&n             |\r\n"
		" .~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:\r\n"
		" | -=- &CName&n -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- &GQuestPoints&n -=-=-=-=-= &YGold&n -=- |\r\n"
		" .~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:\r\n");
	strcat(buf, wanted);
	strcat(buf, " .~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:.~'~.:\r\n");
	send_to_char(buf, ch);
  }
 } else {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      CREATE(victim->player_specials, struct player_special_data, 1);
      if (load_char(argument, victim) > -1) {
       if(check_wanted(victim) && !PLR_FLAGGED(victim, PLR_DELETED)){
        sprintf(buf, "&CW&ca&Cr&cD&Co&cm&Ce&n &ROut&BLaw&n &GINFO&n\r\n\r\n");
        sprintf(buf + strlen(buf), "&WWith &c%s&W's head you can gain:\r\n", GET_NAME(victim));
        sprintf(buf + strlen(buf), "&gQP: &G%d        &yGold: &Y%s&n\r\n", check_wanted_gain_qp(victim), add_points(check_wanted_gain_gold(victim)));
		send_to_char(buf, ch);
       } else {
       	 send_to_char("Your target are not a OutLaw.\r\n", ch);
       	 return;
       }
      } else {
        send_to_char("There is no such player.\r\n", ch);
      }
      free_char(victim);
 }
}

const char *nome[] = {
	"&Bfirst&n",
	"&Csecond&n",
	"&Gthird&n",
	"&Yfourth&n",
	"&Rfifth&n",
	"\n"
};

ACMD(do_rskills)
{
   int x, i, quebra = 1;

          if(!GET_REMORT(ch)) {
            send_to_char("You have to remort first.\r\n", ch);
            return;
          }

          x = GET_REMORT(ch);
          strcpy(buf, "&WRemort Info&n\r\n\r\n");
          for(;x > 0;x--)
          {
	        if(GET_CLASS_REMORT(ch, x) < 0) {
	            	send_to_char("Call an implementor, you have no remort class.\r\n", ch);
	            	return;
	        }
          	sprintf(buf + strlen(buf), "&W[&g%d&W] &Cremort &Was %s &y%s&W:&n\r\n", x,
            	AN(pc_class_types[GET_CLASS_REMORT(ch, x)]),
          	pc_class_types[GET_CLASS_REMORT(ch, x)]);
          	for(i = 0; i < MAX_RSKILLS; i++)
          		if(GET_RSKILL(ch, x, i))
          			sprintf(buf + strlen(buf), "%s: &c%20s&n [%3d]%s", nome[i],
          			reprimir(spells[GET_RSKILL(ch, x, i)], 20),
           			spell_info[GET_RSKILL(ch, x, i)].min_level[(int)GET_CLASS_REMORT(ch, x)],
           			(!(quebra++ % 2) ? "\r\n" : "   "));
		strcat(buf, "\r\n\r\n");

	   }
           send_to_char(buf, ch);
}
::::::::::::::
act.item.c
::::::::::::::
/* ************************************************************************
*   File: act.item.c                                    Part of CircleMUD *
*  Usage: object handling routines -- get/drop and container handling     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "dg_scripts.h"
#include "quest.h"

/* extern variables */
extern sh_int donation_room_1;
#if 0
extern sh_int donation_room_2;  /* uncomment if needed! */
extern sh_int donation_room_3;  /* uncomment if needed! */
#endif
extern struct obj_data *obj_proto;
extern char *drinknames[];
extern struct str_app_type str_app[];
extern struct room_data *world;
extern char *drinks[];
extern int drink_aff[][3];
void save_char(struct char_data * ch, sh_int load_room);

/* local functions */
int can_take_obj(struct char_data * ch, struct obj_data * obj);
void get_check_money(struct char_data * ch, struct obj_data * obj);
int perform_get_from_room(struct char_data * ch, struct obj_data * obj);
void get_from_room(struct char_data * ch, char *arg, int amount);
void perform_give_gold(struct char_data * ch, struct char_data * vict, int amount);
void perform_give(struct char_data * ch, struct char_data * vict, struct obj_data * obj);
int perform_drop(struct char_data * ch, struct obj_data * obj, byte mode, const char *sname, room_rnum RDR);
void perform_drop_gold(struct char_data * ch, int amount, byte mode, room_rnum RDR);
struct char_data *give_find_vict(struct char_data * ch, char *arg);
void weight_change_object(struct obj_data * obj, int weight);
void perform_put(struct char_data * ch, struct obj_data * obj, struct obj_data * cont);
void name_from_drinkcon(struct obj_data * obj);
void get_from_container(struct char_data * ch, struct obj_data * cont, char *arg, int mode, int amount);
void name_to_drinkcon(struct obj_data * obj, int type);
void wear_message(struct char_data * ch, struct obj_data * obj, int where);
void perform_wear(struct char_data * ch, struct obj_data * obj, int where);
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);
void perform_get_from_container(struct char_data * ch, struct obj_data * obj, struct obj_data * cont, int mode);
void perform_remove(struct char_data * ch, int pos);
int count_objs_in_room(room_vnum rnum);
ACMD(do_remove);
ACMD(do_put);
ACMD(do_get);
ACMD(do_drop);
ACMD(do_give);
ACMD(do_drink);
ACMD(do_eat);
ACMD(do_pour);
ACMD(do_wear);
ACMD(do_wield);
ACMD(do_grab);
ACMD(do_compare);

void perform_put(struct char_data * ch, struct obj_data * obj,
                      struct obj_data * cont)
{
  if (!drop_otrigger(obj, ch))
    return;
  if(!obj)
    return;
  if (GET_OBJ_WEIGHT(cont) + GET_OBJ_WEIGHT(obj) > GET_OBJ_VAL(cont, 0))
    act("$p won't fit in $P.", FALSE, ch, obj, cont, TO_CHAR);
  else {
    obj_from_char(obj);
    obj_to_obj(obj, cont);

    act("$n puts $p in $P.", TRUE, ch, obj, cont, TO_ROOM);

    /* Yes, I realize this is strange until we have auto-equip on rent. -gg */
    if (IS_OBJ_STAT(obj, ITEM_NODROP) && !IS_OBJ_STAT(cont, ITEM_NODROP)) {
      SET_BIT(GET_OBJ_EXTRA(cont), ITEM_NODROP);
      act("You get a strange feeling as you put $p in $P.", FALSE,
                ch, obj, cont, TO_CHAR);
    } else
      act("You put $p in $P.", FALSE, ch, obj, cont, TO_CHAR);
  }
}


/* The following put modes are supported by the code below:

        1) put <object> <container>
        2) put all.<object> <container>
        3) put all <container>

        <container> must be in inventory or on ground.
        all objects to be put into container must be in inventory.
*/

ACMD(do_put)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH];
  struct obj_data *obj, *next_obj, *cont;
  struct char_data *tmp_char;
  int obj_dotmode, cont_dotmode, found = 0, howmany = 1;
  char *theobj, *thecont;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (*arg3 && is_number(arg1)) {
    howmany = atoi(arg1);
    theobj = arg2;
    thecont = arg3;
  } else {
    theobj = arg1;
    thecont = arg2;
  }
  obj_dotmode = find_all_dots(theobj);
  cont_dotmode = find_all_dots(thecont);

  if (!*theobj)
    send_to_char("Put what in what?\r\n", ch);
  else if (cont_dotmode != FIND_INDIV)
    send_to_char("You can only put things into one container at a time.\r\n", ch);
  else if (!*thecont) {
    sprintf(buf, "What do you want to put %s in?\r\n",
            ((obj_dotmode == FIND_INDIV) ? "it" : "them"));
    send_to_char(buf, ch);
  } else {
    generic_find(thecont, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
    if (!cont) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(thecont), thecont);
      send_to_char(buf, ch);
    } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
      act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
    else if (OBJVAL_FLAGGED(cont, CONT_CLOSED))
      send_to_char("You'd better open it first!\r\n", ch);
    else {
      if (obj_dotmode == FIND_INDIV) {  /* put <obj> <container> */
        if (!(obj = get_obj_in_list_vis(ch, theobj, ch->carrying))) {
          sprintf(buf, "You aren't carrying %s %s.\r\n", AN(theobj), theobj);
          send_to_char(buf, ch);
        } else if (obj == cont)
          send_to_char("You attempt to fold it into itself, but fail.\r\n", ch);
        else {
          while(obj && howmany--) {
            next_obj = obj->next_content;
            perform_put(ch, obj, cont);
            obj = get_obj_in_list_vis(ch, theobj, next_obj);
          }
        }
      } else {
        for (obj = ch->carrying; obj; obj = next_obj) {
          next_obj = obj->next_content;
          if (obj != cont && CAN_SEE_OBJ(ch, obj) &&
              (obj_dotmode == FIND_ALL || isname(theobj, obj->name))) {
            found = 1;
            perform_put(ch, obj, cont);
          }
        }
        if (!found) {
          if (obj_dotmode == FIND_ALL)
            send_to_char("You don't seem to have anything to put in it.\r\n", ch);
          else {
            sprintf(buf, "You don't seem to have any %ss.\r\n", theobj);
            send_to_char(buf, ch);
          }
        }
      }
    }
  }
}



int can_take_obj(struct char_data * ch, struct obj_data * obj)
{
  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)) {
    act("$p: you can't carry that many items.", FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  } else if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
    act("$p: you can't carry that much weight.", FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  } else if (!(CAN_WEAR(obj, ITEM_WEAR_TAKE))) {
    act("$p: you can't take that!", FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  }
  return (1);
}


void get_check_money(struct char_data * ch, struct obj_data * obj)
{
  int value = GET_OBJ_VAL(obj, 0);

  if (GET_OBJ_TYPE(obj) != ITEM_MONEY || value <= 0)
    return;

  extract_obj(obj);

  GET_GOLD(ch) += value;
  GET_GOLD_SUM(ch) += value;

  if (value == 1)
    send_to_char("There was 1 coin.\r\n", ch);
  else {
    sprintf(buf, "There were %s coins.\r\n", add_points(value));
    send_to_char(buf, ch);
  }
}


void perform_get_from_container(struct char_data * ch, struct obj_data * obj,
                                     struct obj_data * cont, int mode)
{
  if (mode == FIND_OBJ_INV || can_take_obj(ch, obj)) {
    if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      act("$p: you can't hold any more items.", FALSE, ch, obj, 0, TO_CHAR);
    else if (get_otrigger(obj, ch)) {
      obj_from_obj(obj);
      obj_to_char(obj, ch);
      act("You get $p from $P.", FALSE, ch, obj, cont, TO_CHAR);
      act("$n gets $p from $P.", TRUE, ch, obj, cont, TO_ROOM);
      get_check_money(ch, obj);
    }
  }
}


void get_from_container(struct char_data * ch, struct obj_data * cont,
                             char *arg, int mode, int howmany)
{
  struct obj_data *obj, *next_obj;
  int obj_dotmode, found = 0;

  obj_dotmode = find_all_dots(arg);

  if (OBJVAL_FLAGGED(cont, CONT_CLOSED))
    act("$p is closed.", FALSE, ch, cont, 0, TO_CHAR);
  else if (obj_dotmode == FIND_INDIV) {
    if (!(obj = get_obj_in_list_vis(ch, arg, cont->contains))) {
      sprintf(buf, "There doesn't seem to be %s %s in $p.", AN(arg), arg);
      act(buf, FALSE, ch, cont, 0, TO_CHAR);
    } else {
      struct obj_data *obj_next;
      while (obj && howmany--) {
        obj_next = obj->next_content;
        perform_get_from_container(ch, obj, cont, mode);
        obj = get_obj_in_list_vis(ch, arg, obj_next);
      }
    }
  } else {
    if (obj_dotmode == FIND_ALLDOT && !*arg) {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = cont->contains; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
          (obj_dotmode == FIND_ALL || isname(arg, obj->name))) {
        found = 1;
        perform_get_from_container(ch, obj, cont, mode);
      }
    }
    if (!found) {
      if (obj_dotmode == FIND_ALL)
        act("$p seems to be empty.", FALSE, ch, cont, 0, TO_CHAR);
      else {
        sprintf(buf, "You can't seem to find any %ss in $p.", arg);
        act(buf, FALSE, ch, cont, 0, TO_CHAR);
      }
    }
  }
}


int perform_get_from_room(struct char_data * ch, struct obj_data * obj)
{
  if (can_take_obj(ch, obj) && get_otrigger(obj, ch)) {
    obj_from_room(obj);
    obj_to_char(obj, ch);
    act("You get $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n gets $p.", TRUE, ch, obj, 0, TO_ROOM);
    save_char(ch, NOWHERE);
    get_check_money(ch, obj);
    return (1);
  }
  return (0);
}


void get_from_room(struct char_data * ch, char *arg, int howmany)
{
  struct obj_data *obj, *next_obj;
  int dotmode, found = 0;

  dotmode = find_all_dots(arg);

  if (dotmode == FIND_INDIV) {
    if (!(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
      sprintf(buf, "You don't see %s %s here.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
    } else {
      struct obj_data *obj_next;
      while(obj && howmany--) {
        obj_next = obj->next_content;
        perform_get_from_room(ch, obj);
        obj = get_obj_in_list_vis(ch, arg, obj_next);
      }
    }
  } else {
    if (dotmode == FIND_ALLDOT && !*arg) {
      send_to_char("Get all of what?\r\n", ch);
      return;
    }
    for (obj = world[ch->in_room].contents; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) &&
          (dotmode == FIND_ALL || isname(arg, obj->name))) {
        found = 1;
        perform_get_from_room(ch, obj);
      }
    }
    if (!found) {
      if (dotmode == FIND_ALL)
        send_to_char("There doesn't seem to be anything here.\r\n", ch);
      else {
        sprintf(buf, "You don't see any %ss here.\r\n", arg);
        send_to_char(buf, ch);
      }
    }
  }
}



ACMD(do_get)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char arg3[MAX_INPUT_LENGTH];

  int cont_dotmode, found = 0, mode;
  struct obj_data *cont;
  struct char_data *tmp_char;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
    send_to_char("Your arms are already full!\r\n", ch);
  else if (!*arg1)
    send_to_char("Get what?\r\n", ch);
  else if (!*arg2)
    get_from_room(ch, arg1, 1);
  else if (is_number(arg1) && !*arg3)
    get_from_room(ch, arg2, atoi(arg1));
  else {
    int amount = 1;
    if (is_number(arg1)) {
      amount = atoi(arg1);
      strcpy(arg1, arg2);
      strcpy(arg2, arg3);
    }
    cont_dotmode = find_all_dots(arg2);
    if (cont_dotmode == FIND_INDIV) {
      mode = generic_find(arg2, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &tmp_char, &cont);
      if (!cont) {
        sprintf(buf, "You don't have %s %s.\r\n", AN(arg2), arg2);
        send_to_char(buf, ch);
      } else if (GET_OBJ_TYPE(cont) != ITEM_CONTAINER)
        act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
      else
        get_from_container(ch, cont, arg1, mode, amount);
    } else {
      if (cont_dotmode == FIND_ALLDOT && !*arg2) {
        send_to_char("Get from all of what?\r\n", ch);
        return;
      }
      for (cont = ch->carrying; cont; cont = cont->next_content)
        if (CAN_SEE_OBJ(ch, cont) &&
            (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
          if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
            found = 1;
            get_from_container(ch, cont, arg1, FIND_OBJ_INV, amount);
          } else if (cont_dotmode == FIND_ALLDOT) {
            found = 1;
            act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
          }
        }
      for (cont = world[ch->in_room].contents; cont; cont = cont->next_content)
        if (CAN_SEE_OBJ(ch, cont) &&
            (cont_dotmode == FIND_ALL || isname(arg2, cont->name))) {
          if (GET_OBJ_TYPE(cont) == ITEM_CONTAINER) {
            get_from_container(ch, cont, arg1, FIND_OBJ_ROOM, amount);
            found = 1;
          } else if (cont_dotmode == FIND_ALLDOT) {
            act("$p is not a container.", FALSE, ch, cont, 0, TO_CHAR);
            found = 1;
          }
        }
      if (!found) {
        if (cont_dotmode == FIND_ALL)
          send_to_char("You can't seem to find any containers.\r\n", ch);
        else {
          sprintf(buf, "You can't seem to find any %ss here.\r\n", arg2);
          send_to_char(buf, ch);
        }
      }
    }
  }
}


void perform_drop_gold(struct char_data * ch, int amount,
                            byte mode, room_rnum RDR)
{
  struct obj_data *obj;

  if (amount <= 0)
    send_to_char("Heh heh heh.. we are jolly funny today, eh?\r\n", ch);
  else if (GET_GOLD(ch) < amount)
    send_to_char("You don't have that many coins!\r\n", ch);
  else {
    if (mode != SCMD_JUNK) {
      WAIT_STATE(ch, PULSE_VIOLENCE);   /* to prevent coin-bombing */
      obj = create_money(amount);
      if (mode == SCMD_DONATE) {
        send_to_char("You throw some gold into the air where it disappears in a puff of smoke!\r\n", ch);
        act("$n throws some gold into the air where it disappears in a puff of smoke!",
            FALSE, ch, 0, 0, TO_ROOM);
        obj_to_room(obj, RDR);
        act("$p suddenly appears in a puff of orange smoke!", 0, 0, obj, 0, TO_ROOM);
      } else {
        if (!drop_wtrigger(obj, ch)) {
          extract_obj(obj);
          return;
        }
        send_to_char("You drop some gold.\r\n", ch);
        sprintf(buf, "$n drops %s.", money_desc(amount));
        act(buf, TRUE, ch, 0, 0, TO_ROOM);
        obj_to_room(obj, ch->in_room);
      }
    } else {
      sprintf(buf, "$n drops %s which disappears in a puff of smoke!",
              money_desc(amount));
      act(buf, FALSE, ch, 0, 0, TO_ROOM);
      send_to_char("You drop some gold which disappears in a puff of smoke!\r\n", ch);
    }
    GET_GOLD(ch) -= amount;
  }
}

short int dropar_house(struct char_data *ch, struct obj_data *tobj)
{
	struct obj_data *obj;
	short int num = 0;


	if(ROOM_FLAGGED(ch->in_room, ROOM_HOUSE) && !ROOM_FLAGGED(ch->in_room, ROOM_DONATION))
	{
		if(tobj->contains)
		{
			send_to_char("You can drop only empty containers.\r\n", ch);
			return 0;
		}

		for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
			num++;

		if(num > MAX_DROP_HOUSE)
		{
			send_to_char("You can drop only 40 objs in your house.\r\n", ch);
			return 0;
		}
	}
	return (1);
}

#define VANISH(mode) ((mode == SCMD_DONATE || mode == SCMD_JUNK) ? \
                      "  It vanishes in a puff of smoke!" : "")

int perform_drop(struct char_data * ch, struct obj_data * obj,
                     byte mode, const char *sname, room_rnum RDR)
{
  int value;

  if (!drop_otrigger(obj, ch))
    return 0;
  if(!obj)
    return;
  if ((mode == SCMD_DROP) && !drop_wtrigger(obj, ch))
    return 0;
  if(mode == SCMD_DROP)
  	if(!dropar_house(ch, obj))
		return 0;

  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
    sprintf(buf, "You can't %s $p, it must be CURSED!", sname);
    act(buf, FALSE, ch, obj, 0, TO_CHAR);
    return (0);
  }

  sprintf(buf, "You %s $p.%s", sname, VANISH(mode));
  act(buf, FALSE, ch, obj, 0, TO_CHAR);
  sprintf(buf, "$n %ss $p.%s", sname, VANISH(mode));
  act(buf, TRUE, ch, obj, 0, TO_ROOM);
  obj_from_char(obj);
  save_char(ch, NOWHERE);

  if ((mode == SCMD_DONATE) && IS_OBJ_STAT(obj, ITEM_NODONATE))
    mode = SCMD_JUNK;

  switch (mode) {
  case SCMD_DROP:
    obj_to_room(obj, ch->in_room);
    save_char(ch, NOWHERE);
    return (0);
  case SCMD_DONATE:
    obj_to_room(obj, RDR);
    save_char(ch, NOWHERE);
    act("$p suddenly appears in a puff a smoke!", FALSE, 0, obj, 0, TO_ROOM);
    return (0);
  case SCMD_JUNK:
    value = MAX(1, MIN(200, GET_OBJ_COST(obj) / 16));
    extract_obj(obj);
    save_char(ch, NOWHERE);
    return (value);
  default:
    log("SYSERR: Incorrect argument %d passed to perform_drop.", mode);
    break;
  }

  return (0);
}



ACMD(do_drop)
{
  struct obj_data *obj, *next_obj;
  room_rnum RDR = 0;
  byte mode = SCMD_DROP;
  int dotmode, amount = 0, multi;
  const char *sname;

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  switch (subcmd) {
  case SCMD_JUNK:
    sname = "junk";
    mode = SCMD_JUNK;
    break;
  case SCMD_DONATE:
    sname = "donate";
    mode = SCMD_DONATE;
    switch (number(0, 2)) {
    case 0:
      mode = SCMD_JUNK;
      break;
    case 1:
    case 2:
      RDR = real_room(donation_room_1);
      break;
/*    case 3: RDR = real_room(donation_room_2); break;
      case 4: RDR = real_room(donation_room_3); break;
*/
    }
    if (RDR == NOWHERE) {
      send_to_char("Sorry, you can't donate anything right now.\r\n", ch);
      return;
    }
    break;
  default:
    sname = "drop";
    break;
  }

  argument = one_argument(argument, arg);

  if (!*arg) {
    sprintf(buf, "What do you want to %s?\r\n", sname);
    send_to_char(buf, ch);
    return;
  } else if (is_number(arg)) {
    multi = atoi(arg);
    one_argument(argument, arg);
    if (!str_cmp("coins", arg) || !str_cmp("coin", arg)) {
      if(GET_REMORT(ch) == 0 && GET_LEVEL(ch) < 2) {
        send_to_char("You don't have level to perform this movement.\r\n", ch);
        return;
      }
      perform_drop_gold(ch, multi, mode, RDR);
      amount = multi;
    } else if (multi <= 0)
      send_to_char("Yeah, that makes sense.\r\n", ch);
    else if (!*arg) {
      sprintf(buf, "What do you want to %s %d of?\r\n", sname, multi);
      send_to_char(buf, ch);
    } else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
      send_to_char(buf, ch);
    } else {
      do {
        next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
        amount += perform_drop(ch, obj, mode, sname, RDR);
        obj = next_obj;
      } while (obj && --multi);
    }
  } else {
    dotmode = find_all_dots(arg);

    /* Can't junk or donate all */
    if ((dotmode == FIND_ALL) && (subcmd == SCMD_JUNK || subcmd == SCMD_DONATE)) {
      if (subcmd == SCMD_JUNK)
        send_to_char("Go to the dump if you want to junk EVERYTHING!\r\n", ch);
      else
        send_to_char("Go do the donation room if you want to donate EVERYTHING!\r\n", ch);
      return;
    }
    if (dotmode == FIND_ALL) {
      if (!ch->carrying)
        send_to_char("You don't seem to be carrying anything.\r\n", ch);
      else
        for (obj = ch->carrying; obj; obj = next_obj) {
          next_obj = obj->next_content;
          amount += perform_drop(ch, obj, mode, sname, RDR);
        }
    } else if (dotmode == FIND_ALLDOT) {
      if (!*arg) {
        sprintf(buf, "What do you want to %s all of?\r\n", sname);
        send_to_char(buf, ch);
        return;
      }
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
        send_to_char(buf, ch);
      }
      while (obj) {
        next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
        amount += perform_drop(ch, obj, mode, sname, RDR);
        obj = next_obj;
      }
    } else {
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
        send_to_char(buf, ch);
      } else
        amount += perform_drop(ch, obj, mode, sname, RDR);
    }
  }

  if (amount && (subcmd == SCMD_JUNK) && (!(!str_cmp("coins", arg) || !str_cmp("coin", arg)))) {
    send_to_char("You have been rewarded by the gods!\r\n", ch);
    act("$n has been rewarded by the gods!", TRUE, ch, 0, 0, TO_ROOM);
    GET_GOLD(ch) += amount;
    GET_GOLD_SUM(ch) += amount;
  }
}


void perform_give(struct char_data * ch, struct char_data * vict,
                       struct obj_data * obj)
{
  if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
    act("You can't let go of $p!!  Yeech!", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }
  if (IS_CARRYING_N(vict) >= CAN_CARRY_N(vict)) {
    act("$N seems to have $S hands full.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (GET_OBJ_WEIGHT(obj) + IS_CARRYING_W(vict) > CAN_CARRY_W(vict)) {
    act("$E can't carry that much weight.", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (!give_otrigger(obj, ch, vict) || !receive_mtrigger(vict, ch, obj))
    return;

  obj_from_char(obj);
  obj_to_char(obj, vict);
  act("You give $p to $N.", FALSE, ch, obj, vict, TO_CHAR);
  act("$n gives you $p.", FALSE, ch, obj, vict, TO_VICT);
  act("$n gives $p to $N.", TRUE, ch, obj, vict, TO_NOTVICT);
  autoquest_trigger_check(ch, vict, obj, AQ_RETURN_OBJ);
  save_char(ch, NOWHERE);
  save_char(vict, NOWHERE);
}

/* utility function for give */
struct char_data *give_find_vict(struct char_data * ch, char *arg)
{
  struct char_data *vict;

  if (!*arg) {
    send_to_char("To who?\r\n", ch);
    return (NULL);
  } else if (!(vict = get_char_vis(ch, arg))) {
    send_to_char(NOPERSON, ch);
    return (NULL);
  } else if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char(NOPERSON, ch);
    return (NULL);
  } else if (vict == ch) {
    send_to_char("What's the point of that?\r\n", ch);
    return (NULL);
  } else
    return (vict);
}


void perform_give_gold(struct char_data * ch, struct char_data * vict,
                            int amount)
{
  if (amount <= 0) {
    send_to_char("Heh heh heh ... we are jolly funny today, eh?\r\n", ch);
    return;
  }
  if ((GET_GOLD(ch) < amount) && (IS_NPC(ch) || (GET_LEVEL(ch) < LVL_GOD))) {
    send_to_char("You don't have that many coins!\r\n", ch);
    return;
  }
  send_to_char(OK, ch);
  sprintf(buf, "$n gives you %s gold coin%s.", add_points(amount), amount == 1 ? "" : "s");
  act(buf, FALSE, ch, 0, vict, TO_VICT);
  sprintf(buf, "$n gives %s to $N.", money_desc(amount));
  act(buf, TRUE, ch, 0, vict, TO_NOTVICT);
  if (IS_NPC(ch) || (GET_LEVEL(ch) < LVL_GOD))
    GET_GOLD(ch) -= amount;
  GET_GOLD(vict) += amount;
  GET_GOLD_SUM(vict) += amount;

  bribe_mtrigger(vict, ch, amount);
}


ACMD(do_give)
{
  int amount, dotmode;
  struct char_data *vict;
  struct obj_data *obj, *next_obj;

  argument = one_argument(argument, arg);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg)
    send_to_char("Give what to who?\r\n", ch);
  else if (is_number(arg)) {
    amount = atoi(arg);
    argument = one_argument(argument, arg);
    if (!str_cmp("coins", arg) || !str_cmp("coin", arg)) {
      if(GET_REMORT(ch) == 0 && GET_LEVEL(ch) < 2) {
        send_to_char("You don't have level to perform this movement.\r\n", ch);
        return;
      }
      one_argument(argument, arg);
      if ((vict = give_find_vict(ch, arg)) != NULL)
        perform_give_gold(ch, vict, amount);
      return;
    } else if (!*arg) { /* Give multiple code. */
      sprintf(buf, "What do you want to give %d of?\r\n", amount);
      send_to_char(buf, ch);
    } else if (!(vict = give_find_vict(ch, argument))) {
      return;
    } else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg);
      send_to_char(buf, ch);
    } else {
      while (obj && amount--) {
        next_obj = get_obj_in_list_vis(ch, arg, obj->next_content);
        perform_give(ch, vict, obj);
        obj = next_obj;
      }
    }
  } else {
    one_argument(argument, buf1);
    if (!(vict = give_find_vict(ch, buf1)))
      return;
    dotmode = find_all_dots(arg);
    if (dotmode == FIND_INDIV) {
      if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
        send_to_char(buf, ch);
      } else
        perform_give(ch, vict, obj);
    } else {
      if (dotmode == FIND_ALLDOT && !*arg) {
        send_to_char("All of what?\r\n", ch);
        return;
      }
      if (!ch->carrying)
        send_to_char("You don't seem to be holding anything.\r\n", ch);
      else
        for (obj = ch->carrying; obj; obj = next_obj) {
          next_obj = obj->next_content;
          if (CAN_SEE_OBJ(ch, obj) &&
              ((dotmode == FIND_ALL || isname(arg, obj->name))))
            perform_give(ch, vict, obj);
        }
    }
  }
}



void weight_change_object(struct obj_data * obj, int weight)
{
  struct obj_data *tmp_obj;
  struct char_data *tmp_ch;

  if (obj->in_room != NOWHERE) {
    GET_OBJ_WEIGHT(obj) += weight;
  } else if ((tmp_ch = obj->carried_by)) {
    obj_from_char(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_char(obj, tmp_ch);
  } else if ((tmp_obj = obj->in_obj)) {
    obj_from_obj(obj);
    GET_OBJ_WEIGHT(obj) += weight;
    obj_to_obj(obj, tmp_obj);
  } else {
    log("SYSERR: Unknown attempt to subtract weight from an object.");
  }
}



void name_from_drinkcon(struct obj_data * obj)
{
  char *new_name, *cur_name, *next;
  const char *liqname;
  int liqlen, cpylen;

  if (!obj || (GET_OBJ_TYPE(obj) != ITEM_DRINKCON && GET_OBJ_TYPE(obj) != ITEM_FOUNTAIN))
    return;

  liqname = drinknames[GET_OBJ_VAL(obj, 2)];
  if (!isname(liqname, obj->name)) {
    log("SYSERR: Can't remove liquid '%s' from '%s' (%d) item.", liqname, obj->name, obj->item_number);
    return;
  }

  liqlen = strlen(liqname);
  CREATE(new_name, char, strlen(obj->name) - strlen(liqname)); /* +1 for NUL, -1 for space */

  for (cur_name = obj->name; cur_name; cur_name = next) {
    if (*cur_name == ' ')
      cur_name++;

    if ((next = strchr(cur_name, ' ')))
      cpylen = next - cur_name;
    else
      cpylen = strlen(cur_name);

    if (!strn_cmp(cur_name, liqname, liqlen))
      continue;

    if (*new_name)
      strcat(new_name, " ");
    strncat(new_name, cur_name, cpylen);
  }

  if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
    free(obj->name);
  obj->name = new_name;
}



void name_to_drinkcon(struct obj_data * obj, int type)
{
  char *new_name;

  if (!obj || (GET_OBJ_TYPE(obj) != ITEM_DRINKCON && GET_OBJ_TYPE(obj) != ITEM_FOUNTAIN))
    return;

  CREATE(new_name, char, strlen(obj->name) + strlen(drinknames[type]) + 2);
  sprintf(new_name, "%s %s", drinknames[type], obj->name);
  if (GET_OBJ_RNUM(obj) < 0 || obj->name != obj_proto[GET_OBJ_RNUM(obj)].name)
    free(obj->name);
  obj->name = new_name;
}



ACMD(do_drink)
{
  struct obj_data *temp;
  struct affected_type af;
  int amount, weight;
  int on_ground = 0;

  one_argument(argument, arg);

  if (IS_NPC(ch))       /* Cannot use GET_COND() on mobs. */
    return;

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg) {
    send_to_char("Drink from what?\r\n", ch);
    return;
  }
  if (!(temp = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    if (!(temp = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents))) {
      send_to_char("You can't find it!\r\n", ch);
      return;
    } else
      on_ground = 1;
  }
  if ((GET_OBJ_TYPE(temp) != ITEM_DRINKCON) &&
      (GET_OBJ_TYPE(temp) != ITEM_FOUNTAIN)) {
    send_to_char("You can't drink from that!\r\n", ch);
    return;
  }
  if (on_ground && (GET_OBJ_TYPE(temp) == ITEM_DRINKCON)) {
    send_to_char("You have to be holding that to drink from it.\r\n", ch);
    return;
  }
  if ((GET_COND(ch, DRUNK) > 10) && (GET_COND(ch, THIRST) > 0)) {
    /* The pig is drunk */
    send_to_char("You can't seem to get close enough to your mouth.\r\n", ch);
    act("$n tries to drink but misses $s mouth!", TRUE, ch, 0, 0, TO_ROOM);
    return;
  }
  if ((GET_COND(ch, FULL) > 20) && (GET_COND(ch, THIRST) > 0)) {
    send_to_char("Your stomach can't contain anymore!\r\n", ch);
    return;
  }
  if (!GET_OBJ_VAL(temp, 1)) {
    send_to_char("It's empty.\r\n", ch);
    return;
  }
  if (subcmd == SCMD_DRINK) {
    sprintf(buf, "$n drinks %s from $p.", drinks[GET_OBJ_VAL(temp, 2)]);
    act(buf, TRUE, ch, temp, 0, TO_ROOM);

    sprintf(buf, "You drink the %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
    send_to_char(buf, ch);

    if (drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] > 0)
      amount = (25 - GET_COND(ch, THIRST)) / drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK];
    else
      amount = number(3, 10);

  } else {
    act("$n sips from $p.", TRUE, ch, temp, 0, TO_ROOM);
    sprintf(buf, "It tastes like %s.\r\n", drinks[GET_OBJ_VAL(temp, 2)]);
    send_to_char(buf, ch);
    amount = 1;
  }

  amount = MIN(amount, GET_OBJ_VAL(temp, 1));

  /* You can't subtract more than the object weighs */
  weight = MIN(amount, GET_OBJ_WEIGHT(temp));

  weight_change_object(temp, -weight);  /* Subtract amount */

  gain_condition(ch, DRUNK,
         (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][DRUNK] * amount) / 4);

  gain_condition(ch, FULL,
          (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][FULL] * amount) / 4);

  gain_condition(ch, THIRST,
        (int) ((int) drink_aff[GET_OBJ_VAL(temp, 2)][THIRST] * amount) / 4);

  if (GET_COND(ch, DRUNK) > 10)
    send_to_char("You feel drunk.\r\n", ch);

  if (GET_COND(ch, THIRST) > 20)
    send_to_char("You don't feel thirsty any more.\r\n", ch);

  if (GET_COND(ch, FULL) > 20)
    send_to_char("You are full.\r\n", ch);

  if (GET_OBJ_VAL(temp, 3)) {   /* The shit was poisoned ! */
    send_to_char("Oops, it tasted rather strange!\r\n", ch);
    act("$n chokes and utters some strange sounds.", TRUE, ch, 0, 0, TO_ROOM);

    af.type = SPELL_POISON;
    af.duration = amount * 3;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    af.bitvector2 = 0;
    af.bitvector3 = 0;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE);
  }
  /* empty the container, and no longer poison. */
  GET_OBJ_VAL(temp, 1) -= amount;
  if (!GET_OBJ_VAL(temp, 1)) {  /* The last bit */
    name_from_drinkcon(temp);
    GET_OBJ_VAL(temp, 2) = 0;
    GET_OBJ_VAL(temp, 3) = 0;
  }
  return;
}



ACMD(do_eat)
{
  struct obj_data *food;
  struct affected_type af;
  int amount;

  one_argument(argument, arg);

  if (IS_NPC(ch))       /* Cannot use GET_COND() on mobs. */
    return;

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg) {
    send_to_char("Eat what?\r\n", ch);
    return;
  }
  if (!(food = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
    return;
  }
  if (subcmd == SCMD_TASTE && ((GET_OBJ_TYPE(food) == ITEM_DRINKCON) ||
                               (GET_OBJ_TYPE(food) == ITEM_FOUNTAIN))) {
    do_drink(ch, argument, 0, SCMD_SIP);
    return;
  }
  if ((GET_OBJ_TYPE(food) != ITEM_FOOD) && (GET_LEVEL(ch) < LVL_GOD)) {
    send_to_char("You can't eat THAT!\r\n", ch);
    return;
  }
  if (GET_COND(ch, FULL) > 20) {/* Stomach full */
    send_to_char("You are too full to eat more!\r\n", ch);
    return;
  }
  if (subcmd == SCMD_EAT) {
    act("You eat $p.", FALSE, ch, food, 0, TO_CHAR);
    act("$n eats $p.", TRUE, ch, food, 0, TO_ROOM);
  } else {
    act("You nibble a little bit of $p.", FALSE, ch, food, 0, TO_CHAR);
    act("$n tastes a little bit of $p.", TRUE, ch, food, 0, TO_ROOM);
  }

  amount = (subcmd == SCMD_EAT ? GET_OBJ_VAL(food, 0) : 1);

  gain_condition(ch, FULL, amount);

  if (GET_COND(ch, FULL) > 20)
    send_to_char("You are full.\r\n", ch);

  if (GET_OBJ_VAL(food, 3) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    /* The shit was poisoned ! */
    send_to_char("Oops, that tasted rather strange!\r\n", ch);
    act("$n coughs and utters some strange sounds.", FALSE, ch, 0, 0, TO_ROOM);

    af.type = SPELL_POISON;
    af.duration = amount * 2;
    af.modifier = 0;
    af.location = APPLY_NONE;
    af.bitvector = AFF_POISON;
    af.bitvector2 = 0;
    af.bitvector3 = 0;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE);
  }
  if (subcmd == SCMD_EAT)
    extract_obj(food);
  else {
    if (!(--GET_OBJ_VAL(food, 0))) {
      send_to_char("There's nothing left now.\r\n", ch);
      extract_obj(food);
    }
  }
}


ACMD(do_pour)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *from_obj = NULL, *to_obj = NULL;
  int amount;

  two_arguments(argument, arg1, arg2);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (subcmd == SCMD_POUR) {
    if (!*arg1) {               /* No arguments */
      send_to_char("From what do you want to pour?\r\n", ch);
      return;
    }
    if (!(from_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_DRINKCON) {
      send_to_char("You can't pour from that!\r\n", ch);
      return;
    }
  }
  if (subcmd == SCMD_FILL) {
    if (!*arg1) {               /* no arguments */
      send_to_char("What do you want to fill?  And what are you filling it from?\r\n", ch);
      return;
    }
    if (!(to_obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if (GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) {
      act("You can't fill $p!", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!*arg2) {               /* no 2nd argument */
      act("What do you want to fill $p from?", FALSE, ch, to_obj, 0, TO_CHAR);
      return;
    }
    if (!(from_obj = get_obj_in_list_vis(ch, arg2, world[ch->in_room].contents))) {
      sprintf(buf, "There doesn't seem to be %s %s here.\r\n", AN(arg2), arg2);
      send_to_char(buf, ch);
      return;
    }
    if (GET_OBJ_TYPE(from_obj) != ITEM_FOUNTAIN) {
      act("You can't fill something from $p.", FALSE, ch, from_obj, 0, TO_CHAR);
      return;
    }
  }
  if (GET_OBJ_VAL(from_obj, 1) == 0) {
    act("The $p is empty.", FALSE, ch, from_obj, 0, TO_CHAR);
    return;
  }
  if (subcmd == SCMD_POUR) {    /* pour */
    if (!*arg2) {
      send_to_char("Where do you want it?  Out or in what?\r\n", ch);
      return;
    }
    if (!str_cmp(arg2, "out")) {
      act("$n empties $p.", TRUE, ch, from_obj, 0, TO_ROOM);
      act("You empty $p.", FALSE, ch, from_obj, 0, TO_CHAR);

      weight_change_object(from_obj, -GET_OBJ_VAL(from_obj, 1)); /* Empty */

      name_from_drinkcon(from_obj);
      GET_OBJ_VAL(from_obj, 1) = 0;
      GET_OBJ_VAL(from_obj, 2) = 0;
      GET_OBJ_VAL(from_obj, 3) = 0;

      return;
    }
    if (!(to_obj = get_obj_in_list_vis(ch, arg2, ch->carrying))) {
      send_to_char("You can't find it!\r\n", ch);
      return;
    }
    if ((GET_OBJ_TYPE(to_obj) != ITEM_DRINKCON) &&
        (GET_OBJ_TYPE(to_obj) != ITEM_FOUNTAIN)) {
      send_to_char("You can't pour anything into that.\r\n", ch);
      return;
    }
  }
  if (to_obj == from_obj) {
    send_to_char("A most unproductive effort.\r\n", ch);
    return;
  }
  if ((GET_OBJ_VAL(to_obj, 1) != 0) &&
      (GET_OBJ_VAL(to_obj, 2) != GET_OBJ_VAL(from_obj, 2))) {
    send_to_char("There is already another liquid in it!\r\n", ch);
    return;
  }
  if (!(GET_OBJ_VAL(to_obj, 1) < GET_OBJ_VAL(to_obj, 0))) {
    send_to_char("There is no room for more.\r\n", ch);
    return;
  }
  if (subcmd == SCMD_POUR) {
    sprintf(buf, "You pour the %s into the %s.",
            drinks[GET_OBJ_VAL(from_obj, 2)], arg2);
    send_to_char(buf, ch);
  }
  if (subcmd == SCMD_FILL) {
    act("You gently fill $p from $P.", FALSE, ch, to_obj, from_obj, TO_CHAR);
    act("$n gently fills $p from $P.", TRUE, ch, to_obj, from_obj, TO_ROOM);
  }
  /* New alias */
  if (GET_OBJ_VAL(to_obj, 1) == 0)
    name_to_drinkcon(to_obj, GET_OBJ_VAL(from_obj, 2));

  /* First same type liq. */
  GET_OBJ_VAL(to_obj, 2) = GET_OBJ_VAL(from_obj, 2);

  /* Then how much to pour */
  GET_OBJ_VAL(from_obj, 1) -= (amount =
                         (GET_OBJ_VAL(to_obj, 0) - GET_OBJ_VAL(to_obj, 1)));

  GET_OBJ_VAL(to_obj, 1) = GET_OBJ_VAL(to_obj, 0);

  if (GET_OBJ_VAL(from_obj, 1) < 0) {   /* There was too little */
    GET_OBJ_VAL(to_obj, 1) += GET_OBJ_VAL(from_obj, 1);
    amount += GET_OBJ_VAL(from_obj, 1);
    name_from_drinkcon(from_obj);
    GET_OBJ_VAL(from_obj, 1) = 0;
    GET_OBJ_VAL(from_obj, 2) = 0;
    GET_OBJ_VAL(from_obj, 3) = 0;
  }
  /* Then the poison boogie */
  GET_OBJ_VAL(to_obj, 3) =
    (GET_OBJ_VAL(to_obj, 3) || GET_OBJ_VAL(from_obj, 3));

  /* And the weight boogie */
  weight_change_object(from_obj, -amount);
  weight_change_object(to_obj, amount); /* Add weight */
}



void wear_message(struct char_data * ch, struct obj_data * obj, int where)
{
  const char *wear_messages[][2] = {
    {"$n lights $p and holds it.",
    "You light $p and hold it."},

    {"$n slides $p on to $s right ring finger.",
    "You slide $p on to your right ring finger."},

    {"$n slides $p on to $s left ring finger.",
    "You slide $p on to your left ring finger."},

    {"$n wears $p around $s neck.",
    "You wear $p around your neck."},

    {"$n wears $p around $s neck.",
    "You wear $p around your neck."},

    {"$n wears $p on $s body.",
    "You wear $p on your body."},

    {"$n wears $p on $s head.",
    "You wear $p on your head."},

    {"$n puts $p on $s legs.",
    "You put $p on your legs."},

    {"$n wears $p on $s feet.",
    "You wear $p on your feet."},

    {"$n puts $p on $s hands.",
    "You put $p on your hands."},

    {"$n wears $p on $s arms.",
    "You wear $p on your arms."},

    {"$n straps $p around $s arm as a shield.",
    "You start to use $p as a shield."},

    {"$n wears $p about $s body.",
    "You wear $p around your body."},

    {"$n wears $p around $s waist.",
    "You wear $p around your waist."},

    {"$n puts $p on around $s right wrist.",
    "You put $p on around your right wrist."},

    {"$n puts $p on around $s left wrist.",
    "You put $p on around your left wrist."},

    {"$n wields $p.",
    "You wield $p."},

    {"$n grabs $p.",
    "You grab $p."},

    {"$n wields as a secondary weapon $p.",
    "You wield as a secondary weapon $p."},

    {"$n puts $p on around $s left ear.",
    "You put $p on around your left ear."},

    {"$n puts $p on around $s right ear.",
    "You put $p on around your right ear."},

    {"$n wears $p on $s face.",
    "You wear $p on your face."},

    {"$n levitates $p and it stay floating arround $s head.",
    "You levitate $p and it stay floating arround your head."}
  };

  act(wear_messages[where][0], TRUE, ch, obj, 0, TO_ROOM);
  act(wear_messages[where][1], FALSE, ch, obj, 0, TO_CHAR);
}



void perform_wear(struct char_data * ch, struct obj_data * obj, int where)
{
  /*
   * ITEM_WEAR_TAKE is used for objects that do not require special bits
   * to be put into that position (e.g. you can hold any object, not just
   * an object with a HOLD bit.)
   */

  int wear_bitvectors[] = {
    ITEM_WEAR_TAKE, ITEM_WEAR_FINGER, ITEM_WEAR_FINGER, ITEM_WEAR_NECK,
    ITEM_WEAR_NECK, ITEM_WEAR_BODY, ITEM_WEAR_HEAD, ITEM_WEAR_LEGS,
    ITEM_WEAR_FEET, ITEM_WEAR_HANDS, ITEM_WEAR_ARMS, ITEM_WEAR_SHIELD,
    ITEM_WEAR_ABOUT, ITEM_WEAR_WAIST, ITEM_WEAR_WRIST, ITEM_WEAR_WRIST,
    ITEM_WEAR_WIELD, ITEM_WEAR_TAKE, ITEM_WEAR_WIELD, ITEM_WEAR_EAR,
    ITEM_WEAR_EAR, ITEM_WEAR_FACE, ITEM_WEAR_FLOAT
  };

  const char *already_wearing[] = {
    "You're already using a light.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something on both of your ring fingers.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You can't wear anything else around your neck.\r\n",
    "You're already wearing something on your body.\r\n",
    "You're already wearing something on your head.\r\n",
    "You're already wearing something on your legs.\r\n",
    "You're already wearing something on your feet.\r\n",
    "You're already wearing something on your hands.\r\n",
    "You're already wearing something on your arms.\r\n",
    "You're already using a shield.\r\n",
    "You're already wearing something about your body.\r\n",
    "You already have something around your waist.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something around both of your wrists.\r\n",
    "You're already wielding a weapon.\r\n",
    "You're already holding something.\r\n",
    "You're already wielding a secondary weapon.\r\n",
    "YOU SHOULD NEVER SEE THIS MESSAGE.  PLEASE REPORT.\r\n",
    "You're already wearing something on both of your ears.\r\n",
    "You're already wearing something on your face.\r\n",
    "You've already something floating on your head.\r\n"
  };

  /* first, make sure that the wear position is valid. */
  if (!CAN_WEAR(obj, wear_bitvectors[where])) {
    act("You can't wear $p there.", FALSE, ch, obj, 0, TO_CHAR);
    return;
  }
  /* for neck, finger, and wrist, try pos 2 if pos 1 is already full */
  if ((where == WEAR_FINGER_R) || (where == WEAR_NECK_1) || (where == WEAR_WRIST_R) || (where == WEAR_EAR_R))
    if (GET_EQ(ch, where))
      where++;

  if (GET_EQ(ch, where)) {
    send_to_char(already_wearing[where], ch);
    return;
  }

  if (!wear_otrigger(obj, ch, where))
    return;

  wear_message(ch, obj, where);
  obj_from_char(obj);
  equip_char(ch, obj, where);
}



int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg)
{
  int where = -1;

  /* \r to prevent explicit wearing. Don't use \n, it's end-of-array marker. */
  const char *keywords[] = {
    "!RESERVED!",
    "finger",
    "!RESERVED!",
    "neck",
    "!RESERVED!",
    "body",
    "head",
    "legs",
    "feet",
    "hands",
    "arms",
    "shield",
    "about",
    "waist",
    "wrist",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "!RESERVED!",
    "ear",
    "!RESERVED!",
    "face",
    "floating",
    "\n"
  };

  if (!arg || !*arg) {
    if (CAN_WEAR(obj, ITEM_WEAR_FINGER))      where = WEAR_FINGER_R;
    if (CAN_WEAR(obj, ITEM_WEAR_NECK))        where = WEAR_NECK_1;
    if (CAN_WEAR(obj, ITEM_WEAR_BODY))        where = WEAR_BODY;
    if (CAN_WEAR(obj, ITEM_WEAR_HEAD))        where = WEAR_HEAD;
    if (CAN_WEAR(obj, ITEM_WEAR_LEGS))        where = WEAR_LEGS;
    if (CAN_WEAR(obj, ITEM_WEAR_FEET))        where = WEAR_FEET;
    if (CAN_WEAR(obj, ITEM_WEAR_HANDS))       where = WEAR_HANDS;
    if (CAN_WEAR(obj, ITEM_WEAR_ARMS))        where = WEAR_ARMS;
    if (CAN_WEAR(obj, ITEM_WEAR_SHIELD))      where = WEAR_SHIELD;
    if (CAN_WEAR(obj, ITEM_WEAR_ABOUT))       where = WEAR_ABOUT;
    if (CAN_WEAR(obj, ITEM_WEAR_WAIST))       where = WEAR_WAIST;
    if (CAN_WEAR(obj, ITEM_WEAR_WRIST))       where = WEAR_WRIST_R;
    if (CAN_WEAR(obj, ITEM_WEAR_EAR))         where = WEAR_EAR_R;
    if (CAN_WEAR(obj, ITEM_WEAR_FACE))        where = WEAR_FACE;
    if (CAN_WEAR(obj, ITEM_WEAR_FLOAT))       where = WEAR_FLOAT;
  } else {
    if (((where = search_block(arg, keywords, FALSE)) < 0) ||
        (*arg=='!')) {
      sprintf(buf, "'%s'?  What part of your body is THAT?\r\n", arg);
      send_to_char(buf, ch);
      return -1;
    }
  }

  if(where == WEAR_FLOAT && (IS_NPC(ch) || !GET_SKILL(ch, SKILL_LEVITATE))) {
    send_to_char("You do not know how.\r\n", ch);
    where = -1;
  }

  return (where);
}



ACMD(do_wear)
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  struct obj_data *obj, *next_obj;
  int where, dotmode, items_worn = 0;
  int remort, level;


  two_arguments(argument, arg1, arg2);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg1) {
    send_to_char("Wear what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(arg1);

  if (*arg2 && (dotmode != FIND_INDIV)) {
    send_to_char("You can't specify the same body location for more than one item!\r\n", ch);
    return;
  }

  if (dotmode == FIND_ALL) {
    for (obj = ch->carrying; obj; obj = next_obj) {
      next_obj = obj->next_content;
      if (CAN_SEE_OBJ(ch, obj) && (where = find_eq_pos(ch, obj, 0)) >= 0) {
       level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
       if ((level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
        level = (LVL_IMMORT - 1);
        remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
       }
       else{
        remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
       }
       if ((GET_LEVEL(ch) < level) || (GET_REMORT(ch) < remort)){
         send_to_char("You can't wear the equipment, you need more level for that!\r\n", ch);
        } else {
         items_worn++;
         perform_wear(ch, obj, where);
        }
      }
    }
    if (!items_worn)
      send_to_char("You don't seem to have anything wearable.\r\n", ch);
  } else if (dotmode == FIND_ALLDOT) {
    if (!*arg1) {
      send_to_char("Wear all of what?\r\n", ch);
      return;
    }
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      sprintf(buf, "You don't seem to have any %ss.\r\n", arg1);
      send_to_char(buf, ch);
    } else
      while (obj) {
        next_obj = get_obj_in_list_vis(ch, arg1, obj->next_content);
        if ((where = find_eq_pos(ch, obj, 0)) >= 0){
         level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
         if ((level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
          level = (LVL_IMMORT - 1);
          remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
         }
         else{
          remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
         }
         if ((GET_LEVEL(ch) < level) || (GET_REMORT(ch) < remort)){
          send_to_char("You can't wear the equipment, you need more level for that!\r\n", ch);
         }
         else {
          perform_wear(ch, obj, where);
         }
        }
        else
          act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
        obj = next_obj;
      }
  } else {
    if (!(obj = get_obj_in_list_vis(ch, arg1, ch->carrying))) {
      sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg1), arg1);
      send_to_char(buf, ch);
    } else {
      if ((where = find_eq_pos(ch, obj, arg2)) >= 0){
        level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
        if ((level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
         level = (LVL_IMMORT - 1);
         remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
        }
        else{
         remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
        }
        if ((GET_LEVEL(ch) < level) || (GET_REMORT(ch) < remort)){
         send_to_char("You can't wear the equipment, you need more level for that!\r\n", ch);
        }
        else {
          perform_wear(ch, obj, where);
        }
       }
      else if (!*arg2)
        act("You can't wear $p.", FALSE, ch, obj, 0, TO_CHAR);
    }
  }
}


ACMD(do_wield)
{
  struct obj_data *obj;
  int remort, level;

  one_argument(argument, arg);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg)
    send_to_char("Wield what?\r\n", ch);
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else {
    level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
    if ((level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
     level = (LVL_IMMORT - 1);
     remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
    }
    else{
     remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
    }
    if (!CAN_WEAR(obj, ITEM_WEAR_WIELD))
      send_to_char("You can't wield that.\r\n", ch);
    else if (GET_OBJ_WEIGHT(obj) > str_app[STRENGTH_APPLY_INDEX(ch)].wield_w)
      send_to_char("It's too heavy for you to use.\r\n", ch);
    else if ((GET_LEVEL(ch) < level) || (GET_REMORT(ch) < remort))
      send_to_char("You can't wear the equipment, you need more level for that!\r\n", ch);
    else if ((IS_NPC(ch) && GET_EQ(ch, WEAR_WIELD)) || ((GET_EQ(ch, WEAR_WIELD)) && (!GET_SKILL(ch, SKILL_DUAL_WIELD))))
      send_to_char("You don't know how to wield secondary weapons.\r\n", ch);
    else if ((GET_EQ(ch, WEAR_WIELD)) && (!GET_SKILL(ch, SKILL_DUAL_WIELD)))
      send_to_char("You don't know how to wield secondary weapons.\r\n", ch);
    else if ((GET_EQ(ch, WEAR_WIELD)) && (GET_SKILL(ch, SKILL_DUAL_WIELD)) && (GET_EQ(ch, WEAR_HOLD)))
      send_to_char("You can't wield secondary weapons when your holding something.\r\n", ch);
    else if (GET_EQ(ch, WEAR_WIELD) && (GET_SKILL(ch, SKILL_DUAL_WIELD)))
      perform_wear(ch, obj, WEAR_DWIELD);
    else
      perform_wear(ch, obj, WEAR_WIELD);

  }
}


ACMD(do_grab)
{
  struct obj_data *obj;
  int remort, level;

  one_argument(argument, arg);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg)
    send_to_char("Hold what?\r\n", ch);
  else if (!(obj = get_obj_in_list_vis(ch, arg, ch->carrying))) {
    sprintf(buf, "You don't seem to have %s %s.\r\n", AN(arg), arg);
    send_to_char(buf, ch);
  } else if (GET_OBJ_TYPE(obj) != ITEM_LIGHT && GET_EQ(ch, WEAR_DWIELD)) {
     send_to_char ("You cannot dual wield and hold something.\n\r", ch);
  }
  else{
       level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
       if ((level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
        level = (LVL_IMMORT - 1);
        remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
       }
       else{
        remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
       }
       if ((GET_LEVEL(ch) < level) || (GET_REMORT(ch) < remort)) {
        send_to_char("You can't wear the equipment, you need more level for that!\r\n", ch);
       } else {
          if (GET_OBJ_TYPE(obj) == ITEM_LIGHT)
            perform_wear(ch, obj, WEAR_LIGHT);
          else {
           if (!CAN_WEAR(obj, ITEM_WEAR_HOLD) && GET_OBJ_TYPE(obj) != ITEM_WAND &&
            GET_OBJ_TYPE(obj) != ITEM_STAFF && GET_OBJ_TYPE(obj) != ITEM_SCROLL &&
            GET_OBJ_TYPE(obj) != ITEM_POTION)
             send_to_char("You can't hold that.\r\n", ch);
           else
            perform_wear(ch, obj, WEAR_HOLD);
          }
         }
      }
}



void perform_remove(struct char_data * ch, int pos)
{
  struct obj_data *obj;

  if (!(obj = GET_EQ(ch, pos)))
    log("SYSERR: perform_remove: bad pos %d passed.", pos);
  else if (IS_OBJ_STAT(obj, ITEM_NODROP))
    act("You can't remove $p, it must be CURSED!", FALSE, ch, obj, 0, TO_CHAR);
  else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
    act("$p: you can't carry that many items!", FALSE, ch, obj, 0, TO_CHAR);
  else {
    if (!remove_otrigger(obj, ch))
      return;
    obj_to_char(unequip_char(ch, pos), ch);
    act("You stop using $p.", FALSE, ch, obj, 0, TO_CHAR);
    act("$n stops using $p.", TRUE, ch, obj, 0, TO_ROOM);
  }
}



ACMD(do_remove)
{
  int i, dotmode, found;

  one_argument(argument, arg);

  if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
  {
	send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	return;
  }

  if (!*arg) {
    send_to_char("Remove what?\r\n", ch);
    return;
  }
  dotmode = find_all_dots(arg);

  if (dotmode == FIND_ALL) {
    found = 0;
    for (i = 0; i < NUM_WEARS; i++)
      if (GET_EQ(ch, i)) {
        perform_remove(ch, i);
        found = 1;
      }
    if (!found)
      send_to_char("You're not using anything.\r\n", ch);
  } else if (dotmode == FIND_ALLDOT) {
    if (!*arg)
      send_to_char("Remove all of what?\r\n", ch);
    else {
      found = 0;
      for (i = 0; i < NUM_WEARS; i++)
        if (GET_EQ(ch, i) && CAN_SEE_OBJ(ch, GET_EQ(ch, i)) &&
            isname(arg, GET_EQ(ch, i)->name)) {
          perform_remove(ch, i);
          found = 1;
        }
      if (!found) {
        sprintf(buf, "You don't seem to be using any %ss.\r\n", arg);
        send_to_char(buf, ch);
      }
    }
  } else {
    /* Returns object pointer but we don't need it, just true/false. */
    if (!get_object_in_equip_vis(ch, arg, ch->equipment, &i)) {
      sprintf(buf, "You don't seem to be using %s %s.\r\n", AN(arg), arg);
      send_to_char(buf, ch);
    } else
      perform_remove(ch, i);
	if (!GET_EQ(ch, WEAR_WIELD) && (GET_EQ(ch, WEAR_DWIELD))) {
                    send_to_char("Since you are not wielding a weapon, you can't dual wield too!\r\n", ch);
	  perform_remove(ch, WEAR_DWIELD);
	}
  }
}

ACMD(do_compare)
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    struct obj_data *obj1, *obj2;
    int value1;
    int value2;
    char *msg;

    two_arguments(argument, arg1, arg2);

    if(ROOM_AFFECTED(ch->in_room, RAFF_FOG))
    {
	  send_to_char("Your view is obscured by a thick fog.\r\n", ch);
	  return;
    }

    if ( arg1[0] == '\0' )
    {
	send_to_char( "Compare what to what?\n\r", ch );
	return;
    }


    if (!(obj1 = get_obj_in_list_vis(ch, arg1, ch->carrying)))
    {
	send_to_char( "You do not have that item.\n\r", ch );
	return;
    }

    if (arg2[0] == '\0')
    {
	for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
	{
	    if (obj2->worn_on != NOWHERE
	    &&  CAN_SEE_OBJ(ch,obj2)
            &&  GET_OBJ_TYPE(obj1) == GET_OBJ_TYPE(obj2)
            &&  CAN_WEAR(obj1 ,ITEM_WEAR_TAKE)
            &&  CAN_WEAR(obj2 ,ITEM_WEAR_TAKE) != 0)
		break;
	}

	if (obj2 == NULL)
	{
	    send_to_char("You aren't wearing anything comparable.\n\r",ch);
	    return;
	}
    }

    else if (!(obj2 = get_obj_in_list_vis(ch, arg2, ch->carrying)))
    {
	send_to_char("You do not have that item.\n\r",ch);
	return;
    }

    msg		= NULL;
    value1	= 0;
    value2	= 0;

    if ( obj1 == obj2 )
    {
	msg = "You compare $p to itself.  It looks about the same.";
    }
    else if (GET_OBJ_TYPE(obj1) != GET_OBJ_TYPE(obj2))
    {
	msg = "You can't compare $p and $P.";
    }
    else
    {
	switch ( GET_OBJ_TYPE(obj1) )
	{
	default:
	    msg = "You can't compare $p and $P.";
	    break;

	case ITEM_ARMOR:
	    value1 = GET_OBJ_VAL(obj1, 0);
	    value2 = GET_OBJ_VAL(obj2, 0);;
	    break;

	case ITEM_WEAPON:
		value1 = (1 + GET_OBJ_VAL(obj1, 2)) * GET_OBJ_VAL(obj1, 1);
		value2 = (1 + GET_OBJ_VAL(obj2, 2)) * GET_OBJ_VAL(obj2, 1);
	    break;
	}
    }

    if ( msg == NULL )
    {
	     if ( value1 == value2 ) msg = "$p and $P look about the same.";
	else if ( value1  > value2 ) msg = "$p looks better than $P.";
	else                         msg = "$p looks worse than $P.";
    }

    act( msg, FALSE, ch, obj1, obj2, TO_CHAR );
    return;
}
::::::::::::::
act.movement.c
::::::::::::::
/* ************************************************************************
*   File: act.movement.c                                Part of CircleMUD *
*  Usage: movement commands, door handling, & sleep/rest/etc state        *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "house.h"
#include "constants.h"
#include "dg_scripts.h"

/* external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *obj_index;
extern int top_of_world;
extern sh_int r_mortal_start_room;
extern int no_specials;

/* external functs */
void add_follower(struct char_data *ch, struct char_data *leader);
int special(struct char_data *ch, int cmd, char *arg);
void death_cry(struct char_data *ch);
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);
void die_in_dt(struct char_data * ch);
extern const char *from_dir[];
int level_exp(int chclass, int level);

/* local functions */
int has_boat(struct char_data *ch);
int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname);
int has_key(struct char_data *ch, int key);
void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd);
int ok_pick(struct char_data *ch, int keynum, int pickproof, int scmd);
ACMD(do_gen_door);
ACMD(do_enter);
ACMD(do_leave);
ACMD(do_stand);
ACMD(do_sit);
ACMD(do_rest);
ACMD(do_sleep);
ACMD(do_wake);
ACMD(do_follow);

char *leave_enter_string(struct char_data *ch)
{
    if (IS_AFFECTED(ch, AFF_FLY))
	return ("flies");
    else if (!IS_AFFECTED(ch, AFF_FLY) && ((SECT(ch->in_room) == SECT_WATER_NOSWIM) || (SECT(ch->in_room) == SECT_WATER_SWIM)) && IS_AFFECTED(ch, AFF_WATERWALK))
        return ("walks over water");
    else if (!IS_NPC(ch) && !IS_AFFECTED(ch, AFF_FLY) && !IS_AFFECTED(ch, AFF_WATERWALK) && ((SECT(ch->in_room) == SECT_WATER_NOSWIM) || (SECT(ch->in_room) == SECT_WATER_SWIM)) && GET_SKILL(ch, SKILL_SWIM))
        return ("swims");
    else
	return ("walks");

}
/* simple function to determine if char can walk on water */
int has_boat(struct char_data *ch)
{
  struct obj_data *obj;
  int i;
/*
  if (ROOM_IDENTITY(ch->in_room) == DEAD_SEA)
    return 1;
*/
  if (GET_LEVEL(ch) > LVL_IMMORT)
    return (1);

  if (AFF_FLAGGED(ch, AFF_WATERWALK))
    return (1);

  if (AFF_FLAGGED(ch, AFF_FLY))
    return (1);

  if (!IS_NPC(ch) && (GET_LEVEL(ch) < LVL_IMMORT) && (!AFF_FLAGGED(ch, AFF_WATERWALK) && !AFF_FLAGGED(ch, AFF_FLY)) && (GET_SKILL(ch, SKILL_SWIM) > number(1, 101))) {
    improve_skill(ch, SKILL_SWIM);
    return (1);
  }

  /* non-wearable boats in inventory will do it */
  for (obj = ch->carrying; obj; obj = obj->next_content)
    if (GET_OBJ_TYPE(obj) == ITEM_BOAT && (find_eq_pos(ch, obj, NULL) < 0))
      return (1);

  /* and any boat you're wearing will do it too */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i) && GET_OBJ_TYPE(GET_EQ(ch, i)) == ITEM_BOAT)
      return (1);

  return (0);
}

/* do_simple_move assumes
 *    1. That there is no master and no followers.
 *    2. That the direction exists.
 *
 *   Returns :
 *   1 : If succes.
 *   0 : If fail
 */
int do_simple_move(struct char_data *ch, int dir, int need_specials_check)
{
  int was_in, need_movement;

  /*
   * Check for special routines (North is 1 in command list, but 0 here) Note
   * -- only check if following; this avoids 'double spec-proc' bug
   */
  if (need_specials_check && special(ch, dir + 1, "")) /* XXX: Evaluate NULL */
    return (0);

  /* charmed? */
  if (AFF_FLAGGED(ch, AFF_CHARM) && ch->master && ch->in_room == ch->master->in_room) {
    send_to_char("The thought of leaving your master makes you weep.\r\n", ch);
    act("$n bursts into tears.", FALSE, ch, 0, 0, TO_ROOM);
    return (0);
  }

  /* if this room or the one we're going to needs a boat, check for one */
  if (((SECT(ch->in_room) == SECT_WATER_NOSWIM) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_WATER_NOSWIM)) ||
      ((SECT(ch->in_room) == SECT_WATER_SWIM) ||
      (SECT(EXIT(ch, dir)->to_room) == SECT_WATER_SWIM))) {
    if (!has_boat(ch)) {
      send_to_char("You need a boat or need learn how to swim to go there.\r\n", ch);
      return 0;
    }
  }

  if (!IS_NPC(ch) && GET_COND(ch, DRUNK) > 0) {
	  if (number(1, 24) < --GET_COND(ch, DRUNK)) {
	  send_to_char("You feel dizzy! Cannot move correctly..\r\n", ch);
	  switch (number(1, 4)) {
	  case 1:
		  command_interpreter(ch, "n");
	  break;
	  case 2:
		  command_interpreter(ch, "s");
	  break;
	  case 3:
		  command_interpreter(ch, "w");
	  break;
	  case 4:
		  command_interpreter(ch, "e");
	  break;
	  default:
	  break;
	  }
	  return (0);
	  }
  }


  /* move points needed is avg. move loss for src and destination sect type */
  need_movement = (movement_loss[SECT(ch->in_room)] +
                   movement_loss[SECT(EXIT(ch, dir)->to_room)]) / 2;

  if (GET_MOVE(ch) < need_movement && !IS_NPC(ch) && GET_OXI(ch) > 5) {
    if (need_specials_check && ch->master)
      send_to_char("You are too exhausted to follow.\r\n", ch);
    else
      send_to_char("You are too exhausted.\r\n", ch);

    return (0);
  }

  if (ROOM_FLAGGED(ch->in_room, ROOM_ATRIUM)) {
    if (!House_can_enter(ch, GET_ROOM_VNUM(EXIT(ch, dir)->to_room))) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return (0);
    }
  }
  if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_TUNNEL) &&
      num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) > 1) {
    send_to_char("There isn't enough room there for more than one person!\r\n", ch);
    return (0);
  }
  /* Mortals and low level gods cannot enter greater god rooms. */
  if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_GODROOM) &&
        GET_LEVEL(ch) < LVL_GRGOD) {
    send_to_char("You aren't godly enough to use that room!\r\n", ch);
    return (0);
  }

  if (ROOM_AFFECTED(EXIT(ch, dir)->to_room, RAFF_ICEWALL) && GET_LEVEL(ch) < LVL_ELDER) {
    send_to_char("&bYou can not enter the room, there is a &Cice wall&b in your way!\r\n", ch);
    return (0);
  }

  if (AFF_FLAGGED(ch, AFF_HIDE))
    REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);

  if (ROOM_AFFECTED(EXIT(ch, dir)->to_room, RAFF_FIREWALL) && GET_LEVEL(ch) < LVL_ELDER)
    send_to_char("&rWhen you cross the &Yfire wall&r, your feel your skin &Rburn&r!\r\n", ch);


  /* Now we know we're allow to go into the room. */
  if (GET_LEVEL(ch) < LVL_IMMORT && !IS_NPC(ch) && !AFF_FLAGGED(ch, AFF_FLY))
    GET_MOVE(ch) -= need_movement;

  if (!AFF_FLAGGED(ch, AFF_SNEAK) && !ROOM_AFFECTED(ch->in_room, RAFF_FOG)) {
    sprintf(buf2, "$n %s to %s.", leave_enter_string(ch), dirs[dir]);
    act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  }
/*  if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED) && AFF2_FLAGGED(ch, AFF2_PASSDOOR))
 sprintf(buf2, "$n %s straight through the closed door.", leave_enter_string(ch));
    act(buf2, TRUE, ch, 0, 0, TO_ROOM);   */

  /* see if an entry trigger disallows the move */
  if (!entry_mtrigger(ch))
    return 0;
  if (!enter_wtrigger(&world[EXIT(ch, dir)->to_room], ch, dir))
    return 0;

  was_in = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, world[was_in].dir_option[dir]->to_room);

  if (ROOM_AFFECTED(ch->in_room, RAFF_FIREWALL) && GET_LEVEL(ch) < LVL_ELDER) {
    send_to_char("&rWhen you enter the room, your feel your skin &Rburn&r!\r\n", ch);
    if(GET_HIT(ch) > (GET_MAX_HIT(ch)*0.05))
       GET_HIT(ch) -= (GET_MAX_HIT(ch)*0.05);
    else
       GET_HIT(ch) = -1;
  }

  if (!AFF_FLAGGED(ch, AFF_SNEAK) && !ROOM_AFFECTED(ch->in_room, RAFF_FOG)) {
    sprintf(buf2, "$n comes from %s.", from_dir[dir]);
    act(buf2, TRUE, ch, 0, 0, TO_ROOM);
  }

  if (ch->desc != NULL)
    look_at_room(ch, 0);

  if (ROOM_FLAGGED(ch->in_room, ROOM_DEATH) && GET_LEVEL(ch) < LVL_IMMORT) {
    log_death_trap(ch);
    die_in_dt(ch);
    return (0);
  }

  entry_memory_mtrigger(ch);
  if (!greet_mtrigger(ch, dir)) {
    char_from_room(ch);
    char_to_room(ch, was_in);
    look_at_room(ch, 0);
  } else
   greet_memory_mtrigger(ch);

  return (1);
}


int perform_move(struct char_data *ch, int dir, int need_specials_check)
{
  int was_in;
  struct follow_type *k, *next;

  if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS || FIGHTING(ch))
    return (0);
  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
    send_to_char("Alas, you cannot go that way...\r\n", ch);
  else if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED) && !(!IS_NPC(ch) &&
      (PRF_FLAGGED(ch, PRF_CROSSDOORS) || AFF2_FLAGGED(ch, AFF2_PASSDOOR)))) {
    if (EXIT(ch, dir)->keyword) {
      sprintf(buf2, "The %s seems to be closed.\r\n", fname(EXIT(ch, dir)->keyword));
      send_to_char(buf2, ch);
    }
    else
      send_to_char("It seems to be closed.\r\n", ch);
  }
  else {
    if (!ch->followers)
      return (do_simple_move(ch, dir, need_specials_check));

    was_in = ch->in_room;
    if (!do_simple_move(ch, dir, need_specials_check))
      return (0);

    for (k = ch->followers; k; k = next) {
      next = k->next;
      if ((k->follower->in_room == was_in) &&
          (GET_POS(k->follower) >= POS_STANDING)) {
        act("You follow $N.\r\n", FALSE, k->follower, 0, ch, TO_CHAR);
        perform_move(k->follower, dir, 1);
      }
    }
    return (1);
  }
  return (0);
}


ACMD(do_move)
{
  /*
   * This is basically a mapping of cmd numbers to perform_move indices.
   * It cannot be done in perform_move because perform_move is called
   * by other functions which do not require the remapping.
   */
  perform_move(ch, subcmd - 1, 0);
}

int find_door(struct char_data *ch, const char *type, char *dir, const char *cmdname)
{
  int door;

  if (*dir) {                   /* a direction was specified */
    if ((door = search_block(dir, dirs, FALSE)) == -1) {        /* Partial Match */
      send_to_char("That's not a direction.\r\n", ch);
      return (-1);
    }
    if (EXIT(ch, door)) {       /* Braces added according to indent. -gg */
      if (EXIT(ch, door)->keyword) {
        if (isname(type, EXIT(ch, door)->keyword))
          return (door);
        else {
          sprintf(buf2, "I see no %s there.\r\n", type);
          send_to_char(buf2, ch);
          return (-1);
        }
      } else
        return (door);
    } else {
      sprintf(buf2, "I really don't see how you can %s anything there.\r\n", cmdname);
      send_to_char(buf2, ch);
      return (-1);
    }
  } else {                      /* try to locate the keyword */
    if (!*type) {
      sprintf(buf2, "What is it you want to %s?\r\n", cmdname);
      send_to_char(buf2, ch);
      return (-1);
    }
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
        if (EXIT(ch, door)->keyword)
          if (isname(type, EXIT(ch, door)->keyword))
            return (door);

    sprintf(buf2, "There doesn't seem to be %s %s here.\r\n", AN(type), type);
    send_to_char(buf2, ch);
    return (-1);
  }
}


int has_key(struct char_data *ch, int key)
{
  struct obj_data *o;

  for (o = ch->carrying; o; o = o->next_content)
    if (GET_OBJ_VNUM(o) == key)
      return (1);

  if (GET_EQ(ch, WEAR_HOLD))
    if (GET_OBJ_VNUM(GET_EQ(ch, WEAR_HOLD)) == key)
      return (1);

  return (0);
}



#define NEED_OPEN	(1 << 0)
#define NEED_CLOSED	(1 << 1)
#define NEED_UNLOCKED	(1 << 2)
#define NEED_LOCKED	(1 << 3)

const char *cmd_door[] =
{
  "open",
  "close",
  "unlock",
  "lock",
  "pick"
};

const int flags_door[] =
{
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_OPEN,
  NEED_CLOSED | NEED_LOCKED,
  NEED_CLOSED | NEED_UNLOCKED,
  NEED_CLOSED | NEED_LOCKED
};


#define EXITN(room, door)               (world[room].dir_option[door])
#define OPEN_DOOR(room, obj, door)      ((obj) ?\
                (TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_CLOSED)) :\
                (TOGGLE_BIT(EXITN(room, door)->exit_info, EX_CLOSED)))
#define LOCK_DOOR(room, obj, door)      ((obj) ?\
                (TOGGLE_BIT(GET_OBJ_VAL(obj, 1), CONT_LOCKED)) :\
                (TOGGLE_BIT(EXITN(room, door)->exit_info, EX_LOCKED)))

void do_doorcmd(struct char_data *ch, struct obj_data *obj, int door, int scmd)
{
  int other_room = 0;
  struct room_direction_data *back = 0;

  sprintf(buf, "$n %ss ", cmd_door[scmd]);
  if (!obj && ((other_room = EXIT(ch, door)->to_room) != NOWHERE))
    if ((back = world[other_room].dir_option[rev_dir[door]]) != NULL)
      if (back->to_room != ch->in_room)
        back = 0;

  switch (scmd) {
  case SCMD_OPEN:
  case SCMD_CLOSE:
    OPEN_DOOR(ch->in_room, obj, door);
    if (back)
      OPEN_DOOR(other_room, obj, rev_dir[door]);
    send_to_char(OK, ch);
    break;
  case SCMD_UNLOCK:
  case SCMD_LOCK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("*Click*\r\n", ch);
    break;
  case SCMD_PICK:
    LOCK_DOOR(ch->in_room, obj, door);
    if (back)
      LOCK_DOOR(other_room, obj, rev_dir[door]);
    send_to_char("The lock quickly yields to your skills.\r\n", ch);
    strcpy(buf, "$n skillfully picks the lock on ");
    improve_skill(ch, SKILL_PICK_LOCK);
    break;
  }

  /* Notify the room */
  sprintf(buf + strlen(buf), "%s%s.", ((obj) ? "" : "the "), (obj) ? "$p" :
          (EXIT(ch, door)->keyword ? "$F" : "door"));
  if (!(obj) || (obj->in_room != NOWHERE))
    act(buf, FALSE, ch, obj, obj ? 0 : EXIT(ch, door)->keyword, TO_ROOM);

  /* Notify the other room */
  if ((scmd == SCMD_OPEN || scmd == SCMD_CLOSE) && back) {
    sprintf(buf, "The %s is %s%s from the other side.",
         (back->keyword ? fname(back->keyword) : "door"), cmd_door[scmd],
            (scmd == SCMD_CLOSE) ? "d" : "ed");
    if (world[EXIT(ch, door)->to_room].people) {
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_ROOM);
      act(buf, FALSE, world[EXIT(ch, door)->to_room].people, 0, 0, TO_CHAR);
    }
  }
}


int ok_pick(struct char_data *ch, int keynum, int pickproof, int scmd)
{
  int percent;

  percent = number(1, 101);

  if (scmd == SCMD_PICK) {
    if (keynum < 0)
      send_to_char("Odd - you can't seem to find a keyhole.\r\n", ch);
    else if (pickproof)
      send_to_char("It resists your attempts to pick it.\r\n", ch);
    else if (percent > GET_SKILL(ch, SKILL_PICK_LOCK))
      send_to_char("You failed to pick the lock.\r\n", ch);
    else
      return (1);
    return (0);
  }
  return (1);
}


#define DOOR_IS_OPENABLE(ch, obj, door) ((obj) ? \
                        ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && \
                        OBJVAL_FLAGGED(obj, CONT_CLOSEABLE)) :\
                        (EXIT_FLAGGED(EXIT(ch, door), EX_ISDOOR)))
#define DOOR_IS_OPEN(ch, obj, door)     ((obj) ? \
                        (!OBJVAL_FLAGGED(obj, CONT_CLOSED)) :\
                        (!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED)))
#define DOOR_IS_UNLOCKED(ch, obj, door) ((obj) ? \
                        (!OBJVAL_FLAGGED(obj, CONT_LOCKED)) :\
                        (!EXIT_FLAGGED(EXIT(ch, door), EX_LOCKED)))
#define DOOR_IS_PICKPROOF(ch, obj, door) ((obj) ? \
                        (OBJVAL_FLAGGED(obj, CONT_PICKPROOF)) : \
                        (EXIT_FLAGGED(EXIT(ch, door), EX_PICKPROOF)))

#define DOOR_IS_CLOSED(ch, obj, door)   (!(DOOR_IS_OPEN(ch, obj, door)))
#define DOOR_IS_LOCKED(ch, obj, door)   (!(DOOR_IS_UNLOCKED(ch, obj, door)))
#define DOOR_KEY(ch, obj, door)         ((obj) ? (GET_OBJ_VAL(obj, 2)) : \
                                        (EXIT(ch, door)->key))
#define DOOR_LOCK(ch, obj, door)        ((obj) ? (GET_OBJ_VAL(obj, 1)) : \
                                        (EXIT(ch, door)->exit_info))

ACMD(do_gen_door)
{
  int door = -1, keynum;
  char type[MAX_INPUT_LENGTH], dir[MAX_INPUT_LENGTH];
  struct obj_data *obj = NULL;
  struct char_data *victim = NULL;

  skip_spaces(&argument);
  if (!*argument) {
    sprintf(buf, "%s what?\r\n", cmd_door[subcmd]);
    send_to_char(CAP(buf), ch);
    return;
  }
  two_arguments(argument, type, dir);
  if (!generic_find(type, FIND_OBJ_INV | FIND_OBJ_ROOM, ch, &victim, &obj))
    door = find_door(ch, type, dir, cmd_door[subcmd]);

  if ((obj) || (door >= 0)) {
    keynum = DOOR_KEY(ch, obj, door);
    if (!(DOOR_IS_OPENABLE(ch, obj, door)))
      act("You can't $F that!", FALSE, ch, 0, cmd_door[subcmd], TO_CHAR);
    else if (!DOOR_IS_OPEN(ch, obj, door) &&
             IS_SET(flags_door[subcmd], NEED_OPEN))
      send_to_char("But it's already closed!\r\n", ch);
    else if (!DOOR_IS_CLOSED(ch, obj, door) &&
             IS_SET(flags_door[subcmd], NEED_CLOSED))
      send_to_char("But it's currently open!\r\n", ch);
    else if (!(DOOR_IS_LOCKED(ch, obj, door)) &&
             IS_SET(flags_door[subcmd], NEED_LOCKED))
      send_to_char("Oh.. it wasn't locked, after all..\r\n", ch);
    else if (!(DOOR_IS_UNLOCKED(ch, obj, door)) &&
             IS_SET(flags_door[subcmd], NEED_UNLOCKED))
      send_to_char("It seems to be locked.\r\n", ch);
    else if (!has_key(ch, keynum) && (GET_LEVEL(ch) < LVL_GOD) &&
             ((subcmd == SCMD_LOCK) || (subcmd == SCMD_UNLOCK)))
      send_to_char("You don't seem to have the proper key.\r\n", ch);
    else if (ok_pick(ch, keynum, DOOR_IS_PICKPROOF(ch, obj, door), subcmd))
      do_doorcmd(ch, obj, door, subcmd);
  }
  return;
}



ACMD(do_enter)
{
  int door;

  one_argument(argument, buf);

  if (*buf) {                   /* an argument was supplied, search for door
                                 * keyword */
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
        if (EXIT(ch, door)->keyword)
          if (!str_cmp(EXIT(ch, door)->keyword, buf)) {
            perform_move(ch, door, 1);
            return;
          }
    sprintf(buf2, "There is no %s here.\r\n", buf);
    send_to_char(buf2, ch);
  } else if (ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
    send_to_char("You are already indoors.\r\n", ch);
  else {
    /* try to locate an entrance */
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
        if (EXIT(ch, door)->to_room != NOWHERE)
          if (!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED) &&
              ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS)) {
            perform_move(ch, door, 1);
            return;
          }
    send_to_char("You can't seem to find anything to enter.\r\n", ch);
  }
}


ACMD(do_leave)
{
  int door;

  if (!ROOM_FLAGGED(ch->in_room, ROOM_INDOORS))
    send_to_char("You are outside.. where do you want to go?\r\n", ch);
  else {
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (EXIT(ch, door))
        if (EXIT(ch, door)->to_room != NOWHERE)
          if (!EXIT_FLAGGED(EXIT(ch, door), EX_CLOSED) &&
            !ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_INDOORS)) {
            perform_move(ch, door, 1);
            return;
          }
    send_to_char("I see no obvious exits to the outside.\r\n", ch);
  }
}


ACMD(do_stand)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
    send_to_char("You are already standing.\r\n", ch);
    break;
  case POS_SITTING:
    send_to_char("You stand up.\r\n", ch);
    act("$n clambers to $s feet.", TRUE, ch, 0, 0, TO_ROOM);
    /* Will be sitting after a successful bash and may still be fighting. */
    GET_POS(ch) = FIGHTING(ch) ? POS_FIGHTING : POS_STANDING;
    break;
  case POS_RESTING:
    send_to_char("You stop resting, and stand up.\r\n", ch);
    act("$n stops resting, and clambers on $s feet.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    break;
  case POS_SLEEPING:
    send_to_char("You have to wake up first!\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Do you not consider fighting as standing?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and put your feet on the ground.\r\n", ch);
    act("$n stops floating around, and puts $s feet on the ground.",
        TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
    break;
  }
}


ACMD(do_sit)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
    send_to_char("You sit down.\r\n", ch);
    act("$n sits down.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
  case POS_SITTING:
    send_to_char("You're sitting already.\r\n", ch);
    break;
  case POS_RESTING:
    send_to_char("You stop resting, and sit up.\r\n", ch);
    act("$n stops resting.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
  case POS_SLEEPING:
    send_to_char("You have to wake up first.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Sit down while fighting? Are you MAD?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and sit down.\r\n", ch);
    act("$n stops floating around, and sits down.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
  }
}


ACMD(do_rest)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
    send_to_char("You sit down and rest your tired bones.\r\n", ch);
    act("$n sits down and rests.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    break;
  case POS_SITTING:
    send_to_char("You rest your tired bones.\r\n", ch);
    act("$n rests.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_RESTING;
    break;
  case POS_RESTING:
    send_to_char("You are already resting.\r\n", ch);
    break;
  case POS_SLEEPING:
    send_to_char("You have to wake up first.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Rest while fighting?  Are you MAD?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and stop to rest your tired bones.\r\n", ch);
    act("$n stops floating around, and rests.", FALSE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SITTING;
    break;
  }
}


ACMD(do_sleep)
{
  switch (GET_POS(ch)) {
  case POS_STANDING:
  case POS_SITTING:
  case POS_RESTING:
    send_to_char("You go to sleep.\r\n", ch);
    act("$n lies down and falls asleep.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    break;
  case POS_SLEEPING:
    send_to_char("You are already sound asleep.\r\n", ch);
    break;
  case POS_FIGHTING:
    send_to_char("Sleep while fighting?  Are you MAD?\r\n", ch);
    break;
  default:
    send_to_char("You stop floating around, and lie down to sleep.\r\n", ch);
    act("$n stops floating around, and lie down to sleep.",
        TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_SLEEPING;
    break;
  }
}


ACMD(do_wake)
{
  struct char_data *vict;
  int self = 0;

  one_argument(argument, arg);
  if (*arg) {
    if (GET_POS(ch) == POS_SLEEPING)
      send_to_char("Maybe you should wake yourself up first.\r\n", ch);
    else if ((vict = get_char_room_vis(ch, arg)) == NULL)
      send_to_char(NOPERSON, ch);
    else if (vict == ch)
      self = 1;
    else if (GET_POS(vict) > POS_SLEEPING)
      act("$E is already awake.", FALSE, ch, 0, vict, TO_CHAR);
    else if (AFF_FLAGGED(vict, AFF_SLEEP))
      act("You can't wake $M up!", FALSE, ch, 0, vict, TO_CHAR);
    else if (GET_POS(vict) < POS_SLEEPING)
      act("$E's in pretty bad shape!", FALSE, ch, 0, vict, TO_CHAR);
    else {
      act("You wake $M up.", FALSE, ch, 0, vict, TO_CHAR);
      act("You are awakened by $n.", FALSE, ch, 0, vict, TO_VICT | TO_SLEEP);
      GET_POS(vict) = POS_SITTING;
    }
    if (!self)
      return;
  }
  if (AFF_FLAGGED(ch, AFF_SLEEP))
    send_to_char("You can't wake up!\r\n", ch);
  else if (GET_POS(ch) > POS_SLEEPING)
    send_to_char("You are already awake...\r\n", ch);
  else {
    send_to_char("You awaken, and stand up.\r\n", ch);
    act("$n awakens.", TRUE, ch, 0, 0, TO_ROOM);
    GET_POS(ch) = POS_STANDING;
  }

}

ACMD(do_follow)
{
  struct char_data *leader;

  one_argument(argument, buf);

  if (*buf) {
    if (!(leader = get_char_room_vis(ch, buf))) {
      send_to_char(NOPERSON, ch);
      return;
    }
  } else {
    send_to_char("Whom do you wish to follow?\r\n", ch);
    return;
  }

  if (ch->master == leader) {
    act("You are already following $M.", FALSE, ch, 0, leader, TO_CHAR);
    return;
  }
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master)) {
    act("But you only feel like following $N!", FALSE, ch, 0, ch->master, TO_CHAR);
  } else {                      /* Not Charmed follow person */
    if (leader == ch) {
      if (!ch->master) {
        send_to_char("You are already following yourself.\r\n", ch);
        return;
      }
      stop_follower(ch);
    } else {
      if (circle_follow(ch, leader)) {
        send_to_char("Sorry, but following in loops is not allowed.\r\n", ch);
        return;
      }
      if (ch->master)
        stop_follower(ch);
      REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
      add_follower(ch, leader);
    }
  }
}

ACMD(do_recall)
{

  int exp;

  if (IS_NPC(ch)) {
    send_to_char("Hehehe... Too fun...\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA)) {
    send_to_char("Hehehe... Too fun... Looser!\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(ch->in_room, ROOM_LEARN)) {
    send_to_char("Must be level 2 to get out here!\r\n", ch);
    return;
  }
  if (PLR_FLAGGED(ch, PLR_DEAD)) {
    send_to_char("Are you alive?\r\n", ch);
    return;
  }

  exp = level_exp(GET_REMORT(ch), GET_LEVEL(ch))/2;
  if(GET_LEVEL(ch) > LVL_NEWBIE && GET_LEVEL(ch) < LVL_IMMORT) {
    if(GET_EXP(ch) > exp) {
       sprintf(buf, "&WYou loss &R%s&W experience.&n\r\n", add_points(exp));
       send_to_char(buf, ch);
       GET_EXP(ch) -= exp;
       GET_EXP(ch) = MAX(0,GET_EXP(ch));
    } else {
       send_to_char("You can not recall.\r\n", ch);
       return;
    }
  }

  send_to_char("You pray to the gods for your safety.\r\n"
               "You start fading and appear in The Wardome Preparation Room.\r\n"
               "\r\n", ch);
  act("$n mumbles a pray and disappears.", TRUE, ch, 0, 0, TO_ROOM);
  char_from_room(ch);
  char_to_room(ch, r_mortal_start_room);
  act("The gods drop $n in the middle of the room.", TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);

  if (GET_LEVEL(ch) > LVL_NEWBIE_WARN && GET_LEVEL(ch) < LVL_NEWBIE)
    send_to_char("\r\nBeware, you are getting more experienced, some day you'll not get free recall.\r\n", ch);
}


#define MAX_PATH_LENGTH 25
int do_run(struct char_data *ch, char argument[MAX_PATH_LENGTH])
{
  int times = 0, i, pos = 0, total = 0, step = 0, map = 0;
  char path[MAX_PATH_LENGTH+1];
  char comando[20];

  skip_spaces(&argument);

  strcpy(path, "");
  strcpy(comando, "");

  for (pos=0; argument[pos] != '\0'; pos++) {
    switch (argument[pos]) {
      case 'n': if (argument[pos] == 'n') step = 0;
      case 'e': if (argument[pos] == 'e') step = 1;
      case 's': if (argument[pos] == 's') step = 2;
      case 'w': if (argument[pos] == 'w') step = 3;
      case 'u': if (argument[pos] == 'u') step = 4;
      case 'd': if (argument[pos] == 'd') step = 5;
        if (times == 0)
         times = 1;
        for (i=0; i!=times; i++) {
          if ((total++) == MAX_PATH_LENGTH) {
            sprintf(buf, "Path too long. Limit your pathes to %d steps.\r\n", MAX_PATH_LENGTH);
            send_to_char(buf, ch);
            return (TRUE);
          }
          sprintf(path + strlen(path), "%d", step);
        }
        times = 0;
        break;
      case '1': times = times * 10 + 1; break;
      case '2': times = times * 10 + 2; break;
      case '3': times = times * 10 + 3; break;
      case '4': times = times * 10 + 4; break;
      case '5': times = times * 10 + 5; break;
      case '6': times = times * 10 + 6; break;
      case '7': times = times * 10 + 7; break;
      case '8': times = times * 10 + 8; break;
      case '9': times = times * 10 + 9; break;
      case '0': times = times * 10;     break;
      default:
//        sprintf(buf, "Unrecognized direction in path (%d:'%c').\r\n", pos+1, argument[pos]);
//        send_to_char(buf, ch);
        return (FALSE);
        break;
    }
  }

  if (GET_POS(ch) == POS_FIGHTING) {
	send_to_char("No way, stay right here and fight for your glory!\r\n", ch);
	return (TRUE);
  }

  if (GET_POS(ch) != POS_STANDING) {
	send_to_char("Nah... You feel too relaxed to do that..\r\n", ch);
	return (TRUE);
  }

  for (pos=0; path[pos] != '\0'; pos++) {
    sprintf(buf, "%c", path[pos]);
    if (path[pos] == '0') strcpy(comando,"north\0");
    if (path[pos] == '1') strcpy(comando,"east\0");
    if (path[pos] == '2') strcpy(comando,"south\0");
    if (path[pos] == '3') strcpy(comando,"west\0");
    if (path[pos] == '4') strcpy(comando,"up\0");
    if (path[pos] == '5') strcpy(comando,"down\0");

    if (no_specials || !special(ch, find_command(comando), comando)) {
	  if (total > 1 && PRF2_FLAGGED(ch, PRF2_MAP)) {
		REMOVE_BIT(PRF2_FLAGS(ch), PRF2_MAP);
	  	map = 1;
	  }
     perform_move(ch, atoi(buf), 0);
    } else
     return (TRUE);

    if (path[pos+1] != '\0')
     send_to_char("\r\n", ch);
  }
  if(map)
     SET_BIT(PRF2_FLAGS(ch), PRF2_MAP);

  return (TRUE);
}
/*
#define MAX_PATH_LENGTH 25
ACMD(do_run) {
  int times = 0, i, pos = 0, total = 0, step = 0;
  char path[MAX_PATH_LENGTH+1];

  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Run to where?\r\n", ch);
    return;
  }

  strcpy(path, "");

  for (pos=0; argument[pos] != '\0'; pos++) {
    switch (LOWER(argument[pos])) {
      case 'n': if (argument[pos] == 'n') step = 0;
      case 'e': if (argument[pos] == 'e') step = 1;
      case 's': if (argument[pos] == 's') step = 2;
      case 'w': if (argument[pos] == 'w') step = 3;
      case 'u': if (argument[pos] == 'u') step = 4;
      case 'd': if (argument[pos] == 'd') step = 5;
        if (times == 0)
         times = 1;
        for (i=0; i!=times; i++) {
          if ((total++) == MAX_PATH_LENGTH) {
            sprintf(buf, "Path too long. Limit your pathes to %d steps.\r\n", MAX_PATH_LENGTH);
            send_to_char(buf, ch);
            return;
          }
          sprintf(path + strlen(path), "%d", step);
        }
        times = 0;
        break;
      case '1': times = times * 10 + 1; break;
      case '2': times = times * 10 + 2; break;
      case '3': times = times * 10 + 3; break;
      case '4': times = times * 10 + 4; break;
      case '5': times = times * 10 + 5; break;
      case '6': times = times * 10 + 6; break;
      case '7': times = times * 10 + 7; break;
      case '8': times = times * 10 + 8; break;
      case '9': times = times * 10 + 9; break;
      case '0': times = times * 10;     break;
      default:
        sprintf(buf, "Unrecognized direction in path (%d:'%c').\r\n", pos+1, argument[pos]);
        send_to_char(buf, ch);
        return;
        break;
    }
  }

  for (pos=0; path[pos] != '\0'; pos++) {
    sprintf(buf, "%c", path[pos]);
    perform_move(ch, atoi(buf), 0);
    if (path[pos+1] != '\0')
     send_to_char("\r\n", ch);
  }
}
*/
::::::::::::::
act.offensive.c
::::::::::::::
/* ************************************************************************
*   File: act.offensive.c                               Part of CircleMUD *
*  Usage: player-level commands of an offensive nature                    *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "buffer.h"

/* extern variables */
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern int pk_allowed;
extern struct obj_data *object_list;
int level_exp(int remort, int level);
extern int can_pk(struct char_data * ch, struct char_data * vt);

/* extern functions */
void check_killer(struct char_data * ch, struct char_data * vict);
void raw_kill(struct char_data * ch, struct char_data * killer);
extern const char *dirs[];
int can_pk(struct char_data * ch, struct char_data * vt);
extern int top_of_world;

/* local functions */
ACMD(do_assist);
ACMD(do_hit);
ACMD(do_kill);
ACMD(do_backstab);
ACMD(do_order);
ACMD(do_flee);
ACMD(do_bash);
ACMD(do_rescue);
ACMD(do_kick);
ACMD(do_disarm);
ACMD(do_berzerk);
ACMD(do_headbash);
ACMD(do_stroke);
ACMD(do_escape);
ACMD(do_suicide);
ACMD(do_knockout);
ACMD(do_throw);
ACMD(do_gut);
ACMD(do_drown);
ACMD(do_chop);
ACMD(do_kickflip);
ACMD(do_whirlwind);
//ACMD(do_slang);

ACMD(do_assist)
{
  struct char_data *helpee, *opponent;

  if (FIGHTING(ch)) {
    send_to_char("You're already fighting!  How can you assist someone else?\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Whom do you wish to assist?\r\n", ch);
  else if (!(helpee = get_char_room_vis(ch, arg)))
    send_to_char(NOPERSON, ch);
  else if (helpee == ch)
    send_to_char("You can't help yourself any more than this!\r\n", ch);
  else {
    /*
     * Hit the same enemy the person you're helping is.
     */
    if (FIGHTING(helpee))
      opponent = FIGHTING(helpee);
    else
      for (opponent = world[ch->in_room].people;
           opponent && (FIGHTING(opponent) != helpee);
           opponent = opponent->next_in_room)
                ;

    if (!opponent)
      act("But nobody is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
    else if (!CAN_SEE(ch, opponent))
      act("You can't see who is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
    else if (!pk_allowed && !IS_NPC(opponent))  /* prevent accidental pkill */
      act("Use 'murder' if you really want to attack $N.", FALSE,
          ch, 0, opponent, TO_CHAR);
    else {
      send_to_char("&YYou join the fight!\r\n", ch);
      act("$N assists you!", 0, helpee, 0, ch, TO_CHAR);
      act("$n assists $N.", FALSE, ch, 0, helpee, TO_NOTVICT);
      hit(ch, opponent, TYPE_UNDEFINED);
    }
  }
}


ACMD(do_hit)
{
  struct char_data *vict;

  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Hit who?\r\n", ch);
  else if (!(vict = get_char_room_vis(ch, arg)))
    send_to_char("They don't seem to be here.\r\n", ch);
  else if (vict == ch) {
    send_to_char("You hit yourself...OUCH!.\r\n", ch);
    act("$n hits $mself, and says OUCH!", FALSE, ch, 0, vict, TO_ROOM);
  } else if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master == vict))
    act("$N is just such a good friend, you simply can't hit $M.", FALSE, ch, 0, vict, TO_CHAR);
  else {
   if (!ROOM_FLAGGED(ch->in_room, ROOM_ARENA)){
    if (!IS_NPC(vict) && !IS_NPC(ch) && can_pk(ch, vict)) {
    	 sprintf(buf2, "%s (%d) attacks %s (%d) at %s [%d]",
    	 GET_NAME(ch), GET_LEVEL(ch), GET_NAME(vict), GET_LEVEL(vict),
         world[vict->in_room].name, GET_ROOM_VNUM(vict->in_room));
      mudlog(buf2, BRF, LVL_ELDER, TRUE);
    }
    if (!pk_allowed) {
      if (!IS_NPC(vict) && !IS_NPC(ch)) {
        if (subcmd != SCMD_MURDER) {
          send_to_char("Use 'murder' to hit another player.\r\n", ch);
          return;
        } else {
          check_killer(ch, vict);
        }
      }
      if (AFF_FLAGGED(ch, AFF_CHARM) && !IS_NPC(ch->master) && !IS_NPC(vict))
        return;                 /* you can't order a charmed pet to attack a
                                 * player */
    }
   }
    if ((GET_POS(ch) == POS_STANDING) && (vict != FIGHTING(ch))) {
      hit(ch, vict, TYPE_UNDEFINED);

      WAIT_STATE(ch, PULSE_VIOLENCE + 2);
    } else
      send_to_char("You do the best you can!\r\n", ch);
  }
}



ACMD(do_kill)
{
  struct char_data *vict;

  if ((GET_LEVEL(ch) < LVL_MJGOD) || IS_NPC(ch)) {
    do_hit(ch, argument, cmd, subcmd);
    return;
  }
  one_argument(argument, arg);

  if (!*arg) {
    send_to_char("Kill who?\r\n", ch);
  } else {
    if (!(vict = get_char_room_vis(ch, arg)))
      send_to_char("They aren't here.\r\n", ch);
    else if (ch == vict)
      send_to_char("Your mother would be so sad.. :(\r\n", ch);
    else if (GET_LEVEL(ch) <= GET_LEVEL(vict))
      do_hit(ch, argument, cmd, subcmd);
    else {
      act("&RYou chop $M to pieces!  Ah!  The blood!", FALSE, ch, 0, vict, TO_CHAR);
      act("&R$N chops you to pieces!", FALSE, vict, 0, ch, TO_CHAR);
      act("&R$n brutally slays $N!", FALSE, ch, 0, vict, TO_NOTVICT);
      raw_kill(vict, ch);
    }
  }
}



ACMD(do_backstab)
{
  struct char_data *vict;
  int percent, prob, prob2;

  one_argument(argument, buf);

  if (!GET_SKILL(ch, SKILL_BACKSTAB)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  if (!(vict = get_char_room_vis(ch, buf))) {
    send_to_char("Backstab who?\r\n", ch);
    return;
  }

  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }

  if (vict == ch) {
    send_to_char("How can you sneak up on yourself?\r\n", ch);
    return;
  }
  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
    send_to_char("Only piercing weapons can be used for backstabbing.\r\n", ch);
    return;
  }
  if (FIGHTING(vict)) {
    send_to_char("&wYou can't backstab a fighting person -- they're too alert!\r\n", ch);
    return;
  }

  if (MOB_FLAGGED(vict, MOB_AWARE)) {
    act("&rYou notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("&r$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("&r$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
    return;
  }

  percent = number(1, 101);     /* 101% is a complete failure */
  prob = GET_SKILL(ch, SKILL_BACKSTAB);
  prob2 = GET_SKILL(ch, SKILL_SECOND_STAB);

  if (AWAKE(vict) && (percent > prob))
    damage(ch, vict, 0, SKILL_BACKSTAB);
  else {
    hit(ch, vict, SKILL_BACKSTAB);
    improve_skill(ch, SKILL_BACKSTAB);
      if (AWAKE(vict) && prob2 && percent < (prob2 / 2 + GET_DEX(ch) / 2 )){
        hit(ch, vict, SKILL_BACKSTAB);
	improve_skill(ch, SKILL_SECOND_STAB);
      }
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
  }
}



ACMD(do_order)
{
  char name[MAX_INPUT_LENGTH], message[MAX_INPUT_LENGTH];
  bool found = FALSE;
  int org_room;
  struct char_data *vict;
  struct follow_type *k;

  half_chop(argument, name, message);

  if (!*name || !*message)
    send_to_char("Order who to do what?\r\n", ch);
  else if (!(vict = get_char_room_vis(ch, name)) && !is_abbrev(name, "followers"))
    send_to_char("That person isn't here.\r\n", ch);
  else if (ch == vict)
    send_to_char("You obviously suffer from skitzofrenia.\r\n", ch);

  else {
    if (AFF_FLAGGED(ch, AFF_CHARM)) {
      send_to_char("Your superior would not aprove of you giving orders.\r\n", ch);
      return;
    }
    if (vict) {
      sprintf(buf, "$N orders you to '%s'", message);
      act(buf, FALSE, vict, 0, ch, TO_CHAR);
      act("$n gives $N an order.", FALSE, ch, 0, vict, TO_ROOM);

      if ((vict->master != ch) || !AFF_FLAGGED(vict, AFF_CHARM))
        act("$n has an indifferent look.", FALSE, vict, 0, 0, TO_ROOM);
      else {
        send_to_char(OK, ch);
        command_interpreter(vict, message);
      }
    } else {                    /* This is order "followers" */
      sprintf(buf, "$n issues the order '%s'.", message);
      act(buf, FALSE, ch, 0, vict, TO_ROOM);

      org_room = ch->in_room;

      for (k = ch->followers; k; k = k->next) {
        if (org_room == k->follower->in_room)
          if (AFF_FLAGGED(k->follower, AFF_CHARM)) {
            found = TRUE;
            command_interpreter(k->follower, message);
          }
      }
      if (found)
        send_to_char(OK, ch);
      else
        send_to_char("Nobody here is a loyal subject of yours!\r\n", ch);
    }
  }
}



ACMD(do_flee)
{
  int i, attempt, loss_exp;
  struct char_data *was_fighting;

  if (IS_AFFECTED(ch, AFF_TANGLED)) {
    send_to_char("You would flee, but you're all tied up...\r\n", ch);
    return;
  }

  if (!FIGHTING(ch)){
    send_to_char("You are not fighting!\r\n", ch);
    return;
  }

  if (GET_POS(ch) < POS_FIGHTING) {
    send_to_char("You are in pretty bad shape, unable to flee!\r\n", ch);
    return;
  }

  if(GET_LEVEL(ch) > 1 && GET_LEVEL(ch) < LVL_IMMORT)
	loss_exp = ((level_exp(GET_REMORT(ch), GET_LEVEL(ch)) - level_exp(GET_REMORT(ch), GET_LEVEL(ch) - 1))/100);
  else
	loss_exp = 0;

  for (i = 0; i < 6; i++) {
    attempt = number(0, NUM_OF_DIRS - 1);       /* Select a random direction */
    if (CAN_GO(ch, attempt)) {
      act("$n panics, and attempts to flee!", TRUE, ch, 0, 0, TO_ROOM);
      was_fighting = FIGHTING(ch);
      if (do_simple_move(ch, attempt, TRUE)) {
        send_to_char("You flee head over heels.\r\n", ch);
	if(!ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
		GET_EXP(ch) -= loss_exp;
      } else {
        act("$n tries to flee, but can't!", TRUE, ch, 0, 0, TO_ROOM);
      }
      return;
    }
  }
  send_to_char("&RPANIC!  You couldn't escape!&n\r\n", ch);
}


ACMD(do_bash)
{
  struct char_data *vict;
  int percent, prob;
  sh_int x;

  one_argument(argument, arg);

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_BASH) : 0);

  if (!x) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }
  if (!IS_NPC(ch) && !GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Bash who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  percent = number(1, 101);     /* 101% is a complete failure */
  prob = ((x/2)+(GET_DEX(ch)*2));

  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = 101;

  if (percent > prob) {
    damage(ch, vict, 0, SKILL_BASH);
    GET_POS(ch) = POS_SITTING;
  } else {
    /*
     * If we bash a player and they wimp out, they will move to the previous
     * room before we set them sitting.  If we try to set the victim sitting
     * first to make sure they don't flee, then we can't bash them!  So now
     * we only set them sitting if they didn't flee. -gg 9/21/98
     */
    if (damage(ch, vict, 1, SKILL_BASH) > 0) {	/* -1 = dead, 0 = miss */
      WAIT_STATE(vict, PULSE_VIOLENCE);
      if (IN_ROOM(ch) == IN_ROOM(vict)) {
        GET_POS(vict) = POS_SITTING;
        improve_skill(ch, SKILL_BASH);
      }
    }
  }
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
}


ACMD(do_rescue)
{
  struct char_data *vict, *tmp_ch ;
  int percent, prob;

  one_argument(argument, arg);

  if (!*arg){
  	send_to_char("Rescue who?\r\n", ch);
  	return;
}

  if (!(vict = get_char_room_vis(ch, arg))) {
    send_to_char("Whom do you want to rescue?\r\n", ch);
    return;
  }

if (IS_NPC(vict)){
  	send_to_char("You can't rescue mobs.\r\n", ch);
  	return;
}

  if (PLR_FLAGGED(ch, PLR_NOPK) && (!(PLR_FLAGGED(vict, PLR_NOPK)))){
  send_to_char("You can only rescue NOPK players.\r\n", ch);
  return;
}
  if (!(PLR_FLAGGED(ch, PLR_NOPK)) && (PLR_FLAGGED(vict, PLR_NOPK))){
  	send_to_char("You can only rescue PK players.\r\n", ch);
  	return;
}

  if ((GET_LEVEL(ch) > GET_LEVEL(vict)) && (GET_LEVEL(ch) - GET_LEVEL(vict)> 10)){
  	send_to_char("You can't rescue someone out of your range.\r\n", ch);
  	return;
}
  if ((GET_LEVEL(vict) > GET_LEVEL(ch)) && ((GET_LEVEL(ch)- GET_LEVEL(vict) * -1) > 10)){
  	send_to_char("You can't rescue someone out of your range.\r\n", ch);
  	return;
}

  if (vict == ch) {
    send_to_char("What about fleeing instead?\r\n", ch);
    return;
  }
  if (FIGHTING(ch) == vict) {
    send_to_char("How can you rescue someone you are trying to kill?\r\n", ch);
    return;
  }
  for (tmp_ch = world[ch->in_room].people; tmp_ch &&
       (FIGHTING(tmp_ch) != vict); tmp_ch = tmp_ch->next_in_room);

  if (!tmp_ch) {
    act("But nobody is fighting $M!", FALSE, ch, 0, vict, TO_CHAR);
    return;
  }
  if (!GET_SKILL(ch, SKILL_RESCUE))
    send_to_char("But you have no idea how!\r\n", ch);
  else {
    percent = number(1, 101);   /* 101% is a complete failure */
    prob = GET_SKILL(ch, SKILL_RESCUE);

    if (percent > prob) {
      send_to_char("You fail the rescue!\r\n", ch);
      return;
    }
    send_to_char("Banzai!  To the rescue...\r\n", ch);
    act("You are rescued by $N, you are confused!", FALSE, vict, 0, ch, TO_CHAR);
    act("$n heroically rescues $N!", FALSE, ch, 0, vict, TO_NOTVICT);
    improve_skill(ch, SKILL_RESCUE);

    if (FIGHTING(vict) == tmp_ch)
      stop_fighting(vict);
    if (FIGHTING(tmp_ch))
      stop_fighting(tmp_ch);
    if (FIGHTING(ch))
      stop_fighting(ch);

    set_fighting(ch, tmp_ch);
    set_fighting(tmp_ch, ch);

    WAIT_STATE(vict, 2 * PULSE_VIOLENCE);
  }

}

ACMD(do_kick)
{
  struct char_data *vict;
  int percent, prob;
  sh_int x;

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_KICK) : 0);

  if (!x) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Kick who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  percent = ((10 - (GET_AC(vict) / 10)) * 2) + number(1, 101);  /* 101% is a complete
                                                                 * failure */
  prob = x;

  if (AWAKE(vict) && percent > prob) {
    damage(ch, vict, 0, SKILL_KICK);
  } else
    damage(ch, vict, GET_LEVEL(ch) + 10, SKILL_KICK);
    improve_skill(ch, SKILL_KICK);

  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
}

ACMD(do_sabre)
{
  struct char_data *vict;
  sh_int maxc, percent, prob, i, level, j = 0;

  prob = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_SABRE) : 0);

  if (!prob) {
    send_to_char("You'd better leave all the martial arts to samurais.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }
  if (!IS_NPC(ch) && !GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (!IS_NPC(ch) && (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_SLASH - TYPE_HIT)) {
    send_to_char("Only slash weapons can be used for the sabre skill.\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Sabre who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  level = MAX(30, GET_LEVEL(ch));
  maxc = level / 28.5 + 1;
  j = 0;
  for (i = 1; i <= maxc; i++) {
    percent = number(1, 101);
    if (percent <= prob) {
      improve_skill(ch, SKILL_SABRE);
      if (GET_POS(vict) > POS_DEAD)
        hit(ch, vict, SKILL_SABRE);
      j++;
    }
  }
  if (j == 0) send_to_char("You need to practice your sabre.\r\n", ch);
  if (GET_POS(vict) > POS_DEAD)
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
    improve_skill(ch, SKILL_SLASH);
}

ACMD(do_combo)
{
  struct char_data *vict;
  int maxc, percent, prob, i, level, j = 0;
  sh_int x;

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_COMBO) : 0);

  if (!x) {
    send_to_char("You'd better leave all the martial arts to fighters.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }
  one_argument(argument, arg);
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Combo who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  level = MAX(20, GET_LEVEL(ch));
  maxc = level / 27 + 1;
  j = 0;
  prob = x;
  for (i = 1; i <= maxc; i++) {
    percent = number(1, 101);
    if (percent <= prob) {
      improve_skill(ch, SKILL_COMBO);
      if (GET_POS(vict) > POS_DEAD)
        hit(ch, vict, SKILL_COMBO);
      j++;
    }
  }
  if (j == 0)
   send_to_char("You need to practice your combo!\r\n", ch);

  if (GET_POS(vict) > POS_DEAD)
    WAIT_STATE(ch, PULSE_VIOLENCE * 4);
}

ACMD(do_suicide)
{
  struct char_data *vict;
  vict = FIGHTING(ch);


  if (!GET_SKILL(ch, SKILL_SUICIDE)) {
    send_to_char("You need know the skill to use them.\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    send_to_char("Why you will kill yourself?\r\n", ch);
    return;
  }

  if (vict == NULL ||(ch->in_room != vict->in_room) )
     return ;      // para evitar bugs

  send_to_char("You slash yourself on the heart and you die.", ch);
  act("$n slashes himself on the heart and finally die.", TRUE, ch, 0, FALSE, TO_ROOM);
  act("$n suffers the wraith of the dead.", TRUE, vict, 0, FALSE, TO_ROOM);

  GET_HIT(vict) = MAX(1, GET_HIT(vict) - GET_HIT(ch)/6) ;

  raw_kill(ch, NULL);
  improve_skill(ch, SKILL_SUICIDE);
}

ACMD(do_circle)
{
  struct char_data *vict;
  int percent, prob;

  one_argument(argument, buf);

  if (!GET_SKILL(ch, SKILL_CIRCLE_ARROUND)) {
    send_to_char("You do not know how.\r\n", ch);
    return;
  }

  if (!(vict = get_char_room_vis(ch, buf))) {
    send_to_char("Circle arround who?\r\n", ch);
    return;
  }
  if (vict == ch) {
    send_to_char("How can you sneak up on yourself?\r\n", ch);
    return;
  }
  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_PIERCE - TYPE_HIT) {
    send_to_char("Only piercing weapons can be used for backstabbing.\r\n", ch);
    return;
  }

  if (MOB_FLAGGED(vict, MOB_AWARE)) {
    act("&rYou notice $N lunging at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("&r$e notices you lunging at $m!", FALSE, vict, 0, ch, TO_VICT);
    act("&r$n notices $N lunging at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
    return;
  }

  percent = number(1, 101);     /* 101% is a complete failure */
  prob = GET_SKILL(ch, SKILL_CIRCLE_ARROUND);

  if (AWAKE(vict) && (percent > prob))
    damage(ch, vict, 0, SKILL_BACKSTAB);
  else {
    hit(ch, vict, SKILL_BACKSTAB);
    improve_skill(ch, SKILL_CIRCLE_ARROUND);
    WAIT_STATE(ch, PULSE_VIOLENCE * 4);
  }
}

ACMD(do_disarm)
{
  struct char_data *victim;
  byte percent, prob;

  victim = FIGHTING(ch);
  percent = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_DISARM) : 0);

  if (!victim) {
    send_to_char("You are not fighting anyone.\n\r", ch);
    return;
  }

  if (!percent) {
    send_to_char("You don't know how!\n\r", ch);
    return;
  }

  if (MOB_FLAGGED(victim, MOB_NODISARM))
  {
	  send_to_char("This mob can not be disarmed.\r\n", ch);
	  return;
  }

  if (!GET_EQ(victim, WEAR_WIELD) || (GET_EQ(victim, WEAR_WIELD) &&
      !CAN_SEE_OBJ(ch, GET_EQ(victim, WEAR_WIELD)))) {
    act("$N isn't wielding anything.", FALSE, ch, 0, victim, TO_CHAR);
    return;
  }

  prob = number(1,101);
  if ((prob < percent) && (GET_LEVEL(victim) <= GET_LEVEL(ch))) {
    act("$n makes a quick manouver, disarming you.",
	TRUE, ch, 0, victim, TO_VICT);
    act("$n easily disarms $N, sending $p flying.",
	TRUE, ch, GET_EQ(victim, WEAR_WIELD), victim, TO_NOTVICT);
    act("You send $S weapon flying.", TRUE, ch, 0, victim, TO_CHAR);
    obj_to_room(unequip_char(victim, WEAR_WIELD), victim->in_room);
    improve_skill(ch, SKILL_DISARM);
  } else
    send_to_char("You try to disarm your opponent but fail.\n\r", ch);

  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
}

ACMD(do_berzerk)
{
  sh_int x;

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_BERZERK) : 0);

  if (!x) {
    send_to_char("You don't know how!\n\r", ch);
    return;
  }

  if (FIGHTING(ch) &&
      number(1, 101) < x) {
    send_to_char("You work up a frenzy and will fight to death!\n\r", ch);
    act("$n works up a frenzy and charges you!", TRUE, ch, 0, FIGHTING(ch), TO_VICT);
    act("$n works up a frenzy and charges $N.", TRUE, ch, 0, FIGHTING(ch), TO_ROOM);
    SET_BIT(AFF_FLAGS(ch), AFF_BERZERK);
    improve_skill(ch, SKILL_BERZERK);
  } else {
    send_to_char("You can't find the energy.\n\r", ch);
    act("$n hops around like a frenzied pig...", TRUE, ch, 0, 0, TO_ROOM);
  }

  WAIT_STATE(ch, PULSE_VIOLENCE);
}

ACMD(do_headbash)
{
  struct char_data *vict;
  int percent, prob;
  sh_int x;

  one_argument(argument, arg);

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_HEADBASH) : 0);

  if (!x) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }
  if (!IS_NPC(ch) && !GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (!FIGHTING(ch)) {
    send_to_char("You can't do this if you aren't fighting...\r\n", ch);
    return;
  }
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Headbash who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  percent = number(1, 150);     /* 101% is a complete failure */
  prob = x/2;

  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = 101;

  if (percent > prob ) {
    send_to_char("You miss your power hit.\r\n", ch);
    act("$n miss the power hit.", TRUE, ch, 0, 0, TO_ROOM);
    WAIT_STATE(ch, PULSE_VIOLENCE);
  } else {
    WAIT_STATE(vict, PULSE_VIOLENCE);
    WAIT_STATE(ch, PULSE_VIOLENCE * 3);
    if (IN_ROOM(ch) == IN_ROOM(vict)){
       act("You hit $S head forcing a fainting.", TRUE, ch, 0, FIGHTING(ch), TO_CHAR);
       act("$n hits your head and you fall down fainted! ZzZzzZZz.", TRUE, ch, 0, FIGHTING(ch), TO_VICT);
       act("$n hits $N's head forcing a fainting.", TRUE, ch, 0, FIGHTING(ch), TO_NOTVICT);
       GET_POS(vict) = POS_SLEEPING;
       improve_skill(ch, SKILL_HEADBASH);
    }
  }
}

ACMD(do_stroke)
{
  struct char_data *vict;
  int percent, prob;
  sh_int x;

  one_argument(argument, arg);

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_STROKE) : 0);

  if (!x) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }
  if (!IS_NPC(ch) && !GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (!FIGHTING(ch)) {
    send_to_char("You can't do this if you aren't fighting...\r\n", ch);
    return;
  }
  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Stroke who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }
  percent = number(1, 150);     /* 101% is a complete failure */
  prob = (x/6)*3;

  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = 101;

  if (percent > prob) {
    send_to_char("You miss your crafty hit.\r\n", ch);
    act("$n miss the crafty hit.", TRUE, ch, 0, 0, TO_ROOM);
    WAIT_STATE(ch, PULSE_VIOLENCE);
  } else {
    WAIT_STATE(vict, PULSE_VIOLENCE);
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    if (IN_ROOM(ch) == IN_ROOM(vict)){
       act("You hit $S strongly forcing a gidiness.", TRUE, ch, 0, FIGHTING(ch), TO_CHAR);
       act("$n hits you strongly, you are stunned! ZzZzzZZz.", TRUE, ch, 0, FIGHTING(ch), TO_VICT);
       sprintf(buf1, "$n hits $N's strongly and now %s is stunned.", HSSH(FIGHTING(ch)));
       act(buf1, TRUE, ch, 0, FIGHTING(ch), TO_NOTVICT);
       GET_POS(vict) = POS_STUNNED;
       improve_skill(ch, SKILL_STROKE);
    }
  }
}

ACMD(do_escape)
{
 int prob, percent, loss_exp;
 int retreat_type;

 one_argument(argument, arg);

 if (!FIGHTING(ch)){
   send_to_char("You are not fighting!\r\n", ch);
   return;
 }

 if (!*arg){
   send_to_char("Escape to?\r\n", ch);
   return;
 }

 if (!GET_SKILL(ch, SKILL_ESCAPE)){
   send_to_char("You do not know how.\r\n", ch);
   return;
 }

 retreat_type = search_block(argument + 1, dirs, FALSE);

 if (retreat_type < 0 || !EXIT(ch, retreat_type) ||
   EXIT(ch, retreat_type)->to_room == NOWHERE)
   {
   send_to_char("Escape to?\r\n", ch);
   return;
   }

 percent = GET_SKILL(ch, SKILL_ESCAPE);
 prob = number(0, 101);

 if(GET_LEVEL(ch) < LVL_IMMORT)
	loss_exp = ((level_exp(GET_CLASS(ch), GET_LEVEL(ch)) - level_exp(GET_CLASS(ch), GET_LEVEL(ch) - 1))/110);
 else
	loss_exp = 0;

 if (prob < percent){
    if (CAN_GO(ch, retreat_type) && !IS_SET(ROOM_FLAGS(EXIT(ch,retreat_type)->to_room), ROOM_DEATH)) {
       act("$n skillfully escape from combat.", TRUE, ch, 0, 0, TO_ROOM);
       send_to_char("You skillfully escape from combat.\r\n\r\n", ch);
       WAIT_STATE(ch, PULSE_VIOLENCE);
       improve_skill(ch, SKILL_ESCAPE);
       do_simple_move(ch, retreat_type, TRUE);
       if(!ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
	  GET_EXP(ch) -= loss_exp;
      if (FIGHTING(ch)){
       stop_fighting(FIGHTING(ch));
       stop_fighting(ch);
      }
     } else {
      act("$n tries to escape from combat but has no where to go!", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You cannot escape in that direction!\r\n", ch);
      return;
     }
 } else {
    send_to_char("You fail your attempt to escape!\r\n", ch);
    WAIT_STATE(ch, PULSE_VIOLENCE);
    return;
  }
}

ACMD(do_knockout)
{
  struct char_data *vict;
  int percent, prob;

  one_argument(argument, buf);

  if (!GET_SKILL(ch, SKILL_KNOCKOUT)) {
    send_to_char("You don't know how!\r\n", ch);
    return;
  }

  if (!(vict = get_char_room_vis(ch, buf))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Knockout who?\r\n", ch);
      return;
    }
  }

  if (vict == ch) {
    send_to_char("That would be funny to see.\r\n", ch);
    return;
  }
  if (!GET_EQ(ch, WEAR_WIELD)) {
    send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
    return;
  }
  if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_BLUDGEON - TYPE_HIT) {
    send_to_char("Only bludgeoning weapons can be used for knockingout.\r\n", ch);
    return;
  }
  if (FIGHTING(vict)) {
    send_to_char("You can't knock out a fighting person -- they're too alert!\r\n", ch);
    return;
  }

  if (MOB_FLAGGED(vict, MOB_AWARE)) {
    act("You notice $N raising $s weapon at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you raising your weapon!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N raising $s weapon at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(vict, ch, TYPE_UNDEFINED);
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    return;
  }

  percent = number(1, 101);	/* 101% is a complete failure */
  prob = GET_SKILL(ch, SKILL_KNOCKOUT);
  percent = percent + (GET_CON(vict) * 4) ;
  percent = percent + (GET_LEVEL(vict) - GET_LEVEL(ch));

  if (AWAKE(vict) && (percent < prob)) {
    act("You are knocked out when $N hits you upside your head.", FALSE, vict, 0, ch, TO_CHAR);
    act("$n sees stars, and slumps over, knocked out.", FALSE, vict, 0, ch, TO_VICT);
    act("$n sees stars, and slumps over, knocked out, after $N brains $m.", FALSE, vict, 0, ch, TO_NOTVICT);

    if(!IS_NPC(ch) && !IS_NPC(vict)){
      if(!can_pk(ch, vict)){
       send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch) ;
       return;
      }
    }

   if (GET_POS(vict) > POS_SLEEPING) {
      act("You feel very sleepy...  Zzzz......", FALSE, vict, 0, 0,TO_CHAR);
      act("$n goes to sleep.", TRUE, vict, 0, 0, TO_ROOM);
      GET_POS(vict) = POS_SLEEPING;
    }

    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
    improve_skill(ch, SKILL_KNOCKOUT);
  }  else {
    act("You notice $N raising $s weapon at you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$e notices you raising your weapon!", FALSE, vict, 0, ch, TO_VICT);
    act("$n notices $N raising $s weapon at $m!", FALSE, vict, 0, ch, TO_NOTVICT);
    hit(ch, vict, SKILL_KNOCKOUT);
    WAIT_STATE(ch, PULSE_VIOLENCE * 2);
  }
}

ACMD(do_throw)
{

  struct char_data *vict;
  struct obj_data *obj;
  int percent, prob;
  int damage_val;
  two_arguments(argument, buf, buf2);


  if (!GET_SKILL(ch, SKILL_THROW)) {
    send_to_char("You don't know how!\r\n", ch);
    return;
  }

  if (!(vict = get_char_room_vis(ch, buf2))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Throw what at who?\r\n", ch);
      return;
    }
  }

 if (!(obj = get_obj_in_list_vis(ch, buf, ch->carrying))) {
    send_to_char("Throw what at who?\r\n", ch);
    return;
  }

  if (vict == ch) {
    send_to_char("That would be funny to see.\r\n", ch);
    return;
  }

  percent = number(1, 101);	/* 101% is a complete failure */
  prob = GET_SKILL(ch, SKILL_THROW);

  damage_val = GET_STR(ch) / 2 + GET_OBJ_WEIGHT(obj)  + GET_LEVEL(ch);

  if (percent > prob) {
    /* miss like a mother fucker. */
      damage(ch, vict, 0, SKILL_THROW);
        /* victim */
      act("$N throws $p at you and misses by a long shot.", FALSE, vict, obj, ch, TO_CHAR);
        /* ch */
      act("You throw $p at $n but, miss by a long shot.", FALSE, vict, obj, ch, TO_VICT);
        /* everyone else */
      act("$N throws $p at $n but, misses by a long shot.", FALSE, vict, obj, ch, TO_NOTVICT);
      return;
  }

  else {
      if (GET_OBJ_TYPE(obj) == ITEM_SCROLL || (GET_OBJ_TYPE(obj) == ITEM_NOTE)) {
        /* victim */
        act("$N hits you upside the head with $p and exclaims, Bad Doggie!", FALSE, vict, obj, ch, TO_CHAR);
        /* ch */
        act("You hit $n in the head with $p and exclaim, Bad Doggie!", FALSE, vict, obj, ch, TO_VICT);
        /* everyone else */
        act("$N hits $n in the head with $p and exclaims, Bad Doggie!", FALSE, vict, obj, ch, TO_NOTVICT);
        extract_obj(obj);

      }

      else if (GET_OBJ_TYPE(obj) == ITEM_WEAPON) {
       /* victim */
        act("$N throws $p at you and cuts your chest.", FALSE, vict, obj, ch, TO_CHAR);
        /* ch */
        act("You throw $p at $n and cut $m chest.", FALSE, vict, obj, ch, TO_VICT);
        /* everyone else */
        act("$N throws $p at $n and cuts $m chest.", FALSE, vict, obj, ch, TO_NOTVICT);
        extract_obj(obj);
      }

      else if (GET_OBJ_TYPE(obj) == ITEM_POTION) {

         /* victim */
        act("$N throws $p at you and it goes right down your throat!", FALSE, vict, obj, ch, TO_CHAR);
        /* ch */
        act("You throw $p at $n and it goes right down $m throat!", FALSE, vict, obj, ch, TO_VICT);
        /* everyone else */
        act("$N throws $p at $n and it goes right down $m throat!", FALSE, vict, obj, ch, TO_NOTVICT);

        if (prob == 50) {

           mag_objectmagic(vict, obj, buf);
	}
	else {

        /* victim */
        act("You gag and spit out $p.", FALSE, vict, obj, ch, TO_CHAR);
        /* ch */
        act("$n gags and spits out $p.", FALSE, vict, obj, ch, TO_VICT);
        /* everyone else */
        act("$n gags and spits out $p.", FALSE, vict, obj, ch, TO_NOTVICT);

	}
      }

      else {
        act("$N throws $p and hits you square in the chest.", FALSE, vict, obj, ch, TO_CHAR);
        /* ch */
        act("You throw $p at $n and hit $m in the chest.", FALSE, vict, obj, ch, TO_VICT);
        /* everyone else */
        act("$N throws $p at $n and hits $m in the chest.", FALSE, vict, obj, ch, TO_NOTVICT);
       extract_obj(obj);
      }

  }

  damage(ch, vict, damage_val, SKILL_THROW);
  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
  improve_skill(ch, SKILL_THROW);
  /* all done */

}


ACMD(do_gut)
{
  struct char_data *vict;
  int percent, prob, healthpercent;
  struct obj_data *piece;

  one_argument(argument, arg);

     if (!GET_SKILL(ch, SKILL_GUT))
   {
     send_to_char("You don't know how!\r\n", ch);
     return;
   }

     if (!(vict = get_char_room_vis(ch, arg)))
   {
       if (FIGHTING(ch))
      {
        vict = FIGHTING(ch);
      }
        else
      {
        send_to_char("Gut who?\r\n", ch);
       return;
      }
   }

     if (vict == ch)
   {
     send_to_char("Aren't we funny today...\r\n", ch);
     return;
   }
     if (!GET_EQ(ch, WEAR_WIELD))
   {
     send_to_char("You need to wield a weapon to make it a success.\r\n", ch);
     return;
   }
     if (GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 3) != TYPE_SLASH - TYPE_HIT)
   {
    send_to_char("Only slashing weapons can be used for gutting.\r\n", ch);
    return;
   }
     percent = number(1, 101);	/* 101% is a complete failure */
     prob = ((GET_SKILL(ch, SKILL_GUT)/2)+GET_DEX(ch)*2);

     if (GET_MAX_HIT(vict) > 0)
     healthpercent = (100 * GET_HIT(vict)) / GET_MAX_HIT(vict);

     else
     healthpercent = -1;

     if (healthpercent >= 5)
   {
     send_to_char("They are not hurt enough for you to attempt that.\r\n", ch);
     hit(vict, ch, TYPE_UNDEFINED);
     WAIT_STATE(ch, PULSE_VIOLENCE * 2);
     return;
   }

     if (percent > prob)
   {
    sprintf(buf, "Even in %s's bad state, they manage to avoid your wild slash.\r\n", GET_NAME(vict));
    send_to_char(buf, ch);
    send_to_char("You avoid a wild slash at your midsection.\r\n", ch);
   }
    else
   {

    /* EWWWW */
    GET_HIT(vict) = -10;

    act("You gut $N!", FALSE, ch, 0, vict, TO_CHAR);
    act("$N guts you!", FALSE, vict, 0, ch, TO_CHAR);
    act("$n brutally guts $N!", FALSE, ch, 0, vict, TO_NOTVICT);

    act("$N looks down in horror as their intestines spill out!", FALSE, ch, 0, vict, TO_ROOM);
    act("$N looks down in horror as their intestines spill out!", FALSE, ch, 0, vict, TO_CHAR);
    act("$N looks down in horror as their intestines spill out!", FALSE, vict, 0, ch, TO_CHAR);
    hit(vict, ch, TYPE_UNDEFINED);

    piece = create_obj();

    piece->item_number = NOTHING;
    piece->in_room = NOWHERE;
    piece->name = strdup("intestine");

    piece->short_description = strdup("An icky pile of intestines");
    piece->description = strdup("An icky pile of intestines is here, colon and all.");

    SET_BIT(GET_OBJ_WEAR(piece), ITEM_WEAR_TAKE);
    GET_OBJ_TYPE(piece) = ITEM_FOOD;
    GET_OBJ_VAL(piece, 0) = 1;
    GET_OBJ_VAL(piece, 3) = 1;   /* watch what you eat. */
    SET_BIT(GET_OBJ_EXTRA(piece), ITEM_NODONATE);
    GET_OBJ_WEIGHT(piece) = 23;
    GET_OBJ_RENT(piece) = 100000;
    obj_to_room(piece, ch->in_room);

    WAIT_STATE(vict, PULSE_VIOLENCE * 2);
    improve_skill(ch, SKILL_GUT);
    improve_skill(ch, SKILL_SLASH);
    update_pos(vict);
  }

}
ACMD(do_drown)
{

  struct char_data *vict;
  int flail, prob;

  if (!GET_SKILL(ch, SKILL_DROWN)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  if(IS_NPC(ch))
  {
   send_to_char("Mobs cannot do this.\r\n", ch) ;
   return ;
  }

  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Drown who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }

  if ((SECT(ch->in_room) != SECT_WATER_NOSWIM) &&
      (SECT(ch->in_room) != SECT_WATER_SWIM)) {
    send_to_char("Drowning someone on dry land is pretty damn hard.\r\n", ch);
    return;
  }
   if (GET_RACE(vict) == RACE_SEA_ELF) {
   send_to_char(" Drowning a Sea Elf? I Don't Think so!\r\n", ch);
   return;
  }
  if (IS_NPC(vict)) {
    flail = number(1, 130);
  }
  else {
    flail = GET_SKILL(vict, SKILL_SWIM) + GET_STR(vict) + GET_DEX(vict);
  }
  prob = GET_SKILL(ch, SKILL_DROWN) + GET_STR(ch) + GET_DEX(ch);

  if (flail > prob) {
    damage(ch, vict, 0, SKILL_CHOP);
  } else
    damage(ch, vict, GET_SKILL(ch, SKILL_DROWN), SKILL_CHOP);


  WAIT_STATE(ch, PULSE_VIOLENCE);
  improve_skill(ch, SKILL_DROWN);
}


ACMD(do_chop)
{
  struct char_data *vict;
  int percent, prob;

if (IS_NPC(ch));{
return;
}
 if (!GET_SKILL(ch, SKILL_CHOP)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Chop who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }

  percent = number(1, 101);
  prob = (GET_SKILL(ch, SKILL_CHOP)/2)+GET_DEX(ch)*3;

  if (percent > prob) {
    damage(vict, ch, GET_LEVEL(ch), SKILL_CHOP);
  } else
    damage(ch, vict, GET_LEVEL(ch), SKILL_CHOP);

  WAIT_STATE(ch, PULSE_VIOLENCE * 2);
  improve_skill(ch, SKILL_CHOP);
}

ACMD(do_kickflip)
{
  struct char_data *vict;
  int percent, prob;

  one_argument(argument, arg);

  if (!GET_SKILL(ch, SKILL_KICKFLIP)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch)) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Kickflip who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Aren't we funny today...\r\n", ch);
    return;
  }

  if(!can_pk(ch, vict) && !IS_NPC(vict))
   return ;

  percent = number(1, 101);	/* 109% is a complete failure */
  prob = (GET_SKILL(ch, SKILL_KICKFLIP)/2) + GET_DEX(ch)*2;

  if (MOB_FLAGGED(vict, MOB_NOBASH))
    percent = 101;

  if (percent > prob) {
    GET_POS(ch) = POS_SITTING;
    damage(vict, ch, GET_LEVEL(vict)*2, SKILL_KICKFLIP);
  } else {
      if (IN_ROOM(ch) == IN_ROOM(vict)) {
        GET_POS(vict) = POS_SITTING;
        damage(ch, vict, GET_LEVEL(ch)*2, SKILL_KICKFLIP);
        WAIT_STATE(vict, PULSE_VIOLENCE);
        improve_skill(ch, SKILL_KICKFLIP);
      }
  }
  WAIT_STATE(ch, PULSE_VIOLENCE * 2);

}

ACMD(do_whirlwind)
{
  struct char_data *tch, *next_tch;
  int percent, prob, x = 0;

  /* If player is a mob or skill isn't learned, we can't do this. */
  if (IS_NPC(ch) || !GET_SKILL(ch, SKILL_WHIRLWIND)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  /* Neither can we do this in a peaceful room */
  if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("No, not in here...\r\n", ch);
    return;
  }

  /* And finally, the show costs 30 moves, so the player must be able to pay */
  if (GET_MOVE(ch) < 100) {
    send_to_char("You don't have the energy to do that just now!\r\n", ch);
    return;
  }

  /* Now we just need to calculate the chance for sucess before we begin. */
  percent = number(1, 101);	            /* 101% is a complete failure */
  prob = GET_SKILL(ch, SKILL_WHIRLWIND);

  if (percent > prob) {
    send_to_char("You fail to complete your whirlwind!\r\n", ch);
    return;
  } else

  /* Find first target, hit it, then move on to next one */
  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;

  /*  We'll leave out immortals, players (for !pk muds) and pets from the
   *  hit list
   */
    if (tch == ch)
      continue;
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
      continue;
    if (!pk_allowed && !IS_NPC(ch) && !IS_NPC(tch))
      continue;
    if (!IS_NPC(ch) && IS_NPC(tch) && AFF_FLAGGED(tch, AFF_CHARM))
      continue;

    /* GET_LEVEL(ch) is the damage value, change if you like */
    if(damage(ch, tch, GET_LEVEL(ch), SKILL_WHIRLWIND)) {
      x = TRUE;
      GET_MOVE(ch) -= 30;
    }
   }
   if(x) {
     improve_skill(ch, SKILL_WHIRLWIND);
     WAIT_STATE(ch, PULSE_VIOLENCE * 2);
   } else
     send_to_char("You can not whirlwind without targets.\r\n", ch);
 }



/*
ACMD(do_slang)
{
  struct char_data *vict;
  int percent, prob;
  sh_int x;

  x = (!IS_NPC(ch) ? GET_SKILL(ch, SKILL_SLANG) : 0);

  if (!x) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!(vict = get_char_room_vis(ch, arg))) {
    if (FIGHTING(ch) && IN_ROOM(ch) == IN_ROOM(FIGHTING(ch))) {
      vict = FIGHTING(ch);
    } else {
      send_to_char("Slang who?\r\n", ch);
      return;
    }
  }
  if (vict == ch) {
    send_to_char("Oh yes, veeery smart.\r\n", ch);
    return;
  }
  percent = ((15 - (GET_AC(vict) / 10)) * 2) + number(1, 101);  // 101% is a complete
                                                                 * failure
  prob = x;

  if (AWAKE(vict) && percent > prob) {
    damage(ch, vict, 0, SKILL_SLANG);
  } else
    damage(ch, vict, GET_LEVEL(ch) / 2, SKILL_SLANG);
    improve_skill(ch, SKILL_SLANG);

  WAIT_STATE(ch, PULSE_VIOLENCE * 3);
}


*/






::::::::::::::
act.other.c
::::::::::::::
/* ************************************************************************
*   File: act.other.c                                   Part of CircleMUD *
*  Usage: Miscellaneous player-level commands                             *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __ACT_OTHER_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "house.h"
#include "dg_scripts.h"
#include "buffer.h"

/* extern variables */
extern struct str_app_type str_app[];
extern struct room_data *world;
extern struct index_data *obj_index;
extern struct obj_data *obj_proto;
extern struct descriptor_data *descriptor_list;
extern struct dex_skill_type dex_app_skill[];
extern struct spell_info_type spell_info[];
extern const char *dirs[];
extern struct index_data *mob_index;
extern char *class_abbrevs[];
extern int free_rent;
extern int pt_allowed;
extern int max_filesize;
extern int nameserver_is_slow;
extern int top_of_world;
extern int auto_save;
extern char *npc_class_abbrevs[];

/* extern procedures */
void appear(struct char_data * ch);
void perform_immort_vis(struct char_data *ch);
SPECIAL(shop_keeper);
ACMD(do_gen_comm);
void die(struct char_data * ch, struct char_data * killer);
void Crash_rentsave(struct char_data * ch, int cost);
void write_aliases(struct char_data *ch);
void extract_char_to_quit(struct char_data * ch);
int can_pk(struct char_data * ch, struct char_data * vt);



/* local functions */
ACMD(do_quit);
ACMD(do_save);
ACMD(do_not_here);
ACMD(do_aid);
ACMD(do_sneak);
ACMD(do_hide);
ACMD(do_steal);
ACMD(do_practice);
ACMD(do_visible);
int perform_group(struct char_data *ch, struct char_data *vict);
void print_group(struct char_data *ch);
ACMD(do_group);
ACMD(do_ungroup);
ACMD(do_report);
ACMD(do_split);
ACMD(do_use);
ACMD(do_wimpy);
ACMD(do_display);
ACMD(do_gen_write);
ACMD(do_gen_tog);
ACMD(do_sacrifice);
ACMD(do_title);
ACMD(do_meditate);
ACMD(do_listen);
ACMD(do_transform);
ACMD(do_blood_ritual);
ACMD(do_recharge);
ACMD(do_message);

ACMD(do_quit)
{
  struct descriptor_data *d, *next_d;

  if (IS_NPC(ch) || !ch->desc)
    return;

  if (subcmd != SCMD_QUIT && GET_LEVEL(ch) < LVL_IMMORT)
    send_to_char("You have to type quit--no less, to quit!\r\n", ch);
  else if (GET_POS(ch) == POS_FIGHTING)
    send_to_char("No way!  You're fighting for your life!\r\n", ch);
  else if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
    send_to_char("Are you trying to get out the WAR? Looser.\r\n", ch);
  else if (GET_LEVEL(ch) < LVL_ELDER && !PLR_FLAGGED(ch, PLR_NOPK) && !ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL))
    send_to_char("&RPlayer killers&W can &GQUIT&W only in &CPEACEFUL&W rooms.&n\r\n", ch);
  else if (GET_POS(ch) < POS_STUNNED) {
    send_to_char("You die before your time...\r\n", ch);
    die(ch, NULL);
  } else {

    if (!GET_INVIS_LEV(ch))
      act("$n leaves from the WarDome.", TRUE, ch, 0, 0, TO_ROOM);
    sprintf(buf, "%s has quit the game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);

    /*
     * kill off all sockets connected to the same player as the one who is
     * trying to quit.  Helps to maintain sanity as well as prevent duping.
     */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (d == ch->desc)
        continue;
      if (d->character && (GET_IDNUM(d->character) == GET_IDNUM(ch)))
        STATE(d) = CON_DISCONNECT;
    }

   save_char(ch, ch->in_room);
   write_aliases(ch);
   if (free_rent)
      Crash_rentsave(ch, 0);
/*   sprintf(buf, "\r\n&CA strange voice whispers, 'The WarDome will wait for you, &c%s&C...'&n\r\n", GET_NAME(ch));
   send_to_char(buf, ch);
   make_summary(ch);*/
   extract_char(ch);           /* Char is saved in extract char */
  }
}



ACMD(do_save)
{
  if (IS_NPC(ch) || !ch->desc)
    return;

  /* Only tell the char we're saving if they actually typed "save" */
  if (cmd) {
    /*
     * This prevents item duplication by two PC's using coordinated saves
     * (or one PC with a house) and system crashes. Note that houses are
     * still automatically saved without this enabled.
     */
    if (auto_save) {
      send_to_char("Only the WarDome can save your character.\r\n", ch);
      return;
    }
    sprintf(buf, "Saving %s.\r\n", GET_NAME(ch));
    send_to_char(buf, ch);
  }

  write_aliases(ch);
  save_char(ch, ch->in_room);
  Crash_crashsave(ch);
  if (ROOM_FLAGGED(ch->in_room, ROOM_HOUSE_CRASH))
    House_crashsave(GET_ROOM_VNUM(IN_ROOM(ch)));
}


/* generic function for commands which are normally overridden by
   special procedures - i.e., shop commands, mail commands, etc. */
ACMD(do_not_here)
{
  send_to_char("Sorry, but you cannot do that here!\r\n", ch);
}

ACMD(do_aid)
{
  struct char_data *victim;
  char victim_name[240];

  one_argument(argument, victim_name);

  if (!GET_SKILL(ch, SKILL_FIRST_AID)) {
    send_to_char("You don't know how!\r\n", ch);
    return;
  }

  if (!(victim = get_char_room_vis(ch, victim_name))) {
    send_to_char("Can't aid someone not here!\r\n", ch);
    return;
  }

  if (number(1, 200) < GET_SKILL(ch, SKILL_FIRST_AID)) {
    GET_HIT(victim) += number (1, 4);
    update_pos(victim);
    send_to_char("You succeed to stop some of the bleeding.\r\n", ch);
    act("$n bandages your wounds.", TRUE, ch, 0, victim, TO_VICT);
    improve_skill(ch, SKILL_FIRST_AID);
  } else {
    send_to_char("You can't stop the bleeding!  Panic!\r\n", ch);
  }

  WAIT_STATE(ch, PULSE_VIOLENCE * 1);
}

void warshout(struct char_data *tch)
{
  struct affected_type af;

    if(affected_by_spell(tch, SKILL_WARSHOUT)) {
      affect_from_char(tch, SKILL_WARSHOUT);
      return;
    }

    af.type = SKILL_WARSHOUT;
    af.location = APPLY_DAMROLL;
    af.duration = 1;
    af.bitvector = 0;
    af.bitvector2 = AFF2_WARSHOUT;
    af.bitvector3 = 0;
    af.modifier = 5;
    affect_to_char(tch, &af);

}

int mandar_warshout(struct char_data * ch)
{
  struct char_data *tch, *k;
  struct follow_type *f, *f_next;
  bool i = 0;

  if (ch == NULL)
    return (0);

  if (!AFF_FLAGGED(ch, AFF_GROUP)) {
    send_to_char("You need to be in a group to shout.\r\n", ch);
    return (0);
  }
  if (ch->master != NULL) {
    send_to_char("You need to be the group leader to shout.\r\n", ch);
    return (0);
  } else
    k = ch;
  for (f = k->followers; f; f = f_next) {
    f_next = f->next;
    tch = f->follower;
    if (tch->in_room != ch->in_room)
      continue;
    if (!AFF_FLAGGED(tch, AFF_GROUP))
      continue;
    if (AFF2_FLAGGED(tch, AFF2_TRANSFORM))
      continue;
    if (ch == tch)
      continue;
    warshout(tch);
  }

  if(!i) {
     if ((k != ch) && AFF_FLAGGED(k, AFF_GROUP))
           warshout(k);
     warshout(ch);
  } else {
     send_to_char("Alone in a group? Is not good.\r\n", ch);
     return (0);
  }

  return (1);
}

/* terminar */
ACMD(do_warshout)
{
  if (!GET_SKILL(ch, SKILL_WARSHOUT)){
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  if(GET_MOVE(ch) < 80)
  {
   send_to_char("You have no move.\r\n", ch) ;
   return ;
  }

  if(mandar_warshout(ch)) {
	  GET_MOVE(ch) -= 75;
  	  send_to_char("&RYou yell, 'WWWWWWAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR!'&n\r\n",ch);
  	  act("&R$n yells, 'WWWWWWAAAAAAAAAAAARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR!'&n", FALSE, ch, 0, 0, TO_ROOM);
	  improve_skill(ch, SKILL_WARSHOUT);
  }
}

ACMD(do_sneak)
{
  struct affected_type af;
  byte percent;

  if (!GET_SKILL(ch, SKILL_SNEAK)){
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  send_to_char("Okay, you'll try to move silently for a while.\r\n", ch);
  if (AFF_FLAGGED(ch, AFF_SNEAK)){
    send_to_char("You are already sneaking.\r\n", ch);
    return;
  }

  percent = number(1, 101);     /* 101% is a complete failure */

  if (percent > GET_SKILL(ch, SKILL_SNEAK) + dex_app_skill[GET_DEX(ch)].sneak)
    return;

  improve_skill(ch, SKILL_SNEAK);

  af.type = SKILL_SNEAK;
  af.duration = GET_LEVEL(ch)/6;
  af.modifier = 0;
  af.location = APPLY_NONE;
  af.bitvector = AFF_SNEAK;
  af.bitvector2 = 0;
  af.bitvector3 = 0;
  affect_to_char(ch, &af);

}

ACMD(do_hide)
{
  byte percent;

  if (!GET_SKILL(ch, SKILL_HIDE)){
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  send_to_char("You attempt to hide yourself.\r\n", ch);

  if (AFF_FLAGGED(ch, AFF_HIDE))
    REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);

  percent = number(1, 101);     /* 101% is a complete failure */

  if (percent > GET_SKILL(ch, SKILL_HIDE) + dex_app_skill[GET_DEX(ch)].hide)
    return;

  send_to_char("You are hide on the room now.\r\n", ch);
  SET_BIT(AFF_FLAGS(ch), AFF_HIDE);
  improve_skill(ch, SKILL_HIDE);
}

ACMD(do_steal)
{
  struct char_data *vict;
  struct obj_data *obj;
  char vict_name[MAX_INPUT_LENGTH], obj_name[MAX_INPUT_LENGTH];
  int percent, gold, eq_pos, pcsteal = 0, ohoh = 0;

  if (!GET_SKILL(ch, SKILL_STEAL)){
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

   if (ROOM_FLAGGED(IN_ROOM(ch), ROOM_PEACEFUL)) {
    send_to_char("This room just has such a peaceful, easy feeling...\r\n", ch);
    return;
  }

  argument = one_argument(argument, obj_name);
  one_argument(argument, vict_name);

  if (!(vict = get_char_room_vis(ch, vict_name))) {
    send_to_char("Steal what from who?\r\n", ch);
    return;
  } else if (vict == ch) {
    send_to_char("Come on now, that's rather stupid!\r\n", ch);
    return;
  }

  if(!IS_NPC(vict))
  {
   if(!can_pk(ch,vict))
   {
    send_to_char("This person is out of your PK range.\r\n", ch);
    return ;
   }
  }

  if (MOB_FLAGGED(vict, MOB_NOSTEAL))
  {
	  send_to_char("This mob can not be stolen.\r\n", ch);
	  return;
  }

  /* 101% is a complete failure */
  percent = number(1, 110) - dex_app_skill[GET_DEX(ch)].p_pocket;

  if (GET_POS(vict) < POS_SLEEPING)
    percent = -1;               /* ALWAYS SUCCESS */

  /* NO NO With Imp's and Shopkeepers, and if player thieving is not allowed */
  if (GET_LEVEL(vict) >= LVL_IMMORT || pcsteal ||
      GET_MOB_SPEC(vict) == shop_keeper)
    percent = 101;              /* Failure */

  if (str_cmp(obj_name, "coins") && str_cmp(obj_name, "gold")) {

    if (!(obj = get_obj_in_list_vis(vict, obj_name, vict->carrying))) {

      for (eq_pos = 0; eq_pos < NUM_WEARS; eq_pos++)
        if (GET_EQ(vict, eq_pos) &&
            (isname(obj_name, GET_EQ(vict, eq_pos)->name)) &&
            CAN_SEE_OBJ(ch, GET_EQ(vict, eq_pos))) {
          obj = GET_EQ(vict, eq_pos);
          break;
        }
      if (!obj) {
      	sprintf(buf,"%s hasn't got that item.\r\n",HSSH(ch));
        send_to_char(buf, ch);
        return;
      } else {                  /* It is equipment */
        if ((GET_POS(vict) > POS_SLEEPING)) {
          send_to_char("Steal the equipment now?  Impossible!\r\n", ch);
          return;
        } else {
          sprintf(buf,"You unequip %s and steal it.\r\n",(obj)->short_description);
          send_to_char(buf, ch);
          act("$n steals $p from $N.", FALSE, ch, obj, vict, TO_NOTVICT);
          obj_to_char(unequip_char(vict, eq_pos), ch);
	  improve_skill(ch, SKILL_STEAL);
//	  SET_BIT(PLR_FLAGS(ch), PLR_THIEF);
        }
      }
    } else {                    /* obj found in inventory */

      percent += GET_OBJ_WEIGHT(obj);   /* Make heavy harder */

      if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
        ohoh = TRUE;
        send_to_char("Oops..\r\n",ch);
        act("$n tried to steal something from you!", FALSE, ch, 0, vict, TO_VICT);
        act("$n tries to steal something from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
      } else {                  /* Steal the item */
        if ((IS_CARRYING_N(ch) + 1 < CAN_CARRY_N(ch))) {
          if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) < CAN_CARRY_W(ch)) {
            obj_from_char(obj);
            obj_to_char(obj, ch);
            send_to_char("Got it!\r\n", ch);
	    improve_skill(ch, SKILL_STEAL);
//	    SET_BIT(PLR_FLAGS(ch), PLR_THIEF);
          }
        } else
          send_to_char("You cannot carry that much.\r\n", ch);
      }
    }
  } else {                      /* Steal some coins */
    if (AWAKE(vict) && (percent > GET_SKILL(ch, SKILL_STEAL))) {
      ohoh = TRUE;
      send_to_char("Oops..\r\n", ch);
      act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, vict, TO_VICT);
      act("$n tries to steal gold from $N.", TRUE, ch, 0, vict, TO_NOTVICT);
    } else {
      /* Steal some gold coins */
      gold = (int) ((GET_GOLD(vict) * number(1, 10)) / 100);
      gold = MIN(1782, gold);
      if (gold > 0) {
        GET_GOLD(ch) += gold;
	GET_GOLD_SUM(ch) += gold;
        GET_GOLD(vict) -= gold;
        improve_skill(ch, SKILL_STEAL);
        if (gold > 1) {
          sprintf(buf, "Bingo!  You got %d gold coins.\r\n", gold);
          send_to_char(buf, ch);
        } else {
          send_to_char("You manage to swipe a solitary gold coin.\r\n", ch);
        }
      } else {
        send_to_char("You couldn't get any gold...\r\n", ch);
      }
    }
  }

  if(ohoh && !IS_NPC(vict))
   SET_BIT(PLR_FLAGS(ch), PLR_THIEF);

  if (ohoh && IS_NPC(vict) && AWAKE(vict))
    hit(vict, ch, TYPE_UNDEFINED);
}



ACMD(do_visible)
{
  if (GET_LEVEL(ch) >= LVL_IMMORT) {
    perform_immort_vis(ch);
    return;
  }

  if AFF_FLAGGED(ch, AFF_INVISIBLE) {
    appear(ch);
    send_to_char("You break the spell of invisibility.\r\n", ch);
  } else
    send_to_char("You are already visible.\r\n", ch);
}



ACMD(do_title)
{
  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (IS_NPC(ch))
    send_to_char("Your title is fine... go away.\r\n", ch);
  else if (PLR_FLAGGED(ch, PLR_NOTITLE))
    send_to_char("You can't title yourself -- you shouldn't have abused it!\r\n", ch);
  else if (strstr(argument, "{") || strstr(argument, "}"))
    send_to_char("Titles can't contain the { or } characters.\r\n", ch);
  else if (strstr(argument, "[") || strstr(argument, "]"))
    send_to_char("Titles can't contain the [ or ] characters.\r\n", ch);
  else if (strstr(argument, "(") || strstr(argument, ")"))
    send_to_char("Titles can't contain the ( or ) characters.\r\n", ch);
  else if (strlen(argument) > (MAX_TITLE_LENGTH - 1))  {
    sprintf(buf, "Sorry, titles can't be longer than %d characters.\r\n",
            (MAX_TITLE_LENGTH - 1));
    send_to_char(buf, ch);
  }
  else {
    set_title(ch, (!*argument ? "the wardome player" : argument));
    sprintf(buf, "Okay, you're now %s%s %s.\r\n",
    (GET_PRENAME(ch) != NULL ? GET_PRENAME(ch) : ""),
    GET_NAME(ch), GET_TITLE(ch));
    send_to_char(buf, ch);
  }
}

ACMD(do_prename)
{
  char argbkp[MAX_TITLE_LENGTH];

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (IS_NPC(ch))
    send_to_char("Your prename is fine... go away.\r\n", ch);
  else if (GET_LEVEL(ch) < LVL_ELDER && GET_REMORT(ch) < 1)
    send_to_char("You need be more experienced to set your prename.\r\n", ch);
  else if (strstr(argument, " "))
    send_to_char("Titles can't contain spaces. \r\n", ch);
  else if (PLR_FLAGGED(ch, PLR_NOTITLE))
    send_to_char("You can't title yourself -- you shouldn't have abused it!\r\n", ch);
  else if (strstr(argument, "{") || strstr(argument, "}"))
    send_to_char("Titles can't contain the { or } characters.\r\n", ch);
  else if (strstr(argument, "[") || strstr(argument, "]"))
    send_to_char("Titles can't contain the [ or ] characters.\r\n", ch);
  else if (strstr(argument, "(") || strstr(argument, ")"))
    send_to_char("Titles can't contain the ( or ) characters.\r\n", ch);
  else if (strlen(argument) > MAX_TITLE_LENGTH) {
    sprintf(buf, "Sorry, prenames can't be longer than %d characters.\r\n",
            MAX_TITLE_LENGTH);
    send_to_char(buf, ch);
  } else {
   if(!*argument) {
    set_prename(ch, NULL);
    sprintf(buf, "Okay, you're now %s %s.\r\n", GET_NAME(ch), GET_TITLE(ch));
    send_to_char(buf, ch);
   } else {
    strcpy(argbkp, argument);
    sprintf(argument, "%s&n ", argbkp);
    set_prename(ch, argument);
    sprintf(buf, "Okay, you're now %s%s %s.\r\n", GET_PRENAME(ch), GET_NAME(ch), GET_TITLE(ch));
    send_to_char(buf, ch);
   }
  }
}

int perform_group(struct char_data *ch, struct char_data *vict)
{
  if (AFF_FLAGGED(vict, AFF_GROUP) || !CAN_SEE(ch, vict))
    return (0);

  SET_BIT(AFF_FLAGS(vict), AFF_GROUP);
  if (ch != vict)
    act("$N is now a member of your group.", FALSE, ch, 0, vict, TO_CHAR);
  act("You are now a member of $n's group.", FALSE, ch, 0, vict, TO_VICT);
  act("$N is now a member of $n's group.", FALSE, ch, 0, vict, TO_NOTVICT);
  return (1);
}


void print_group(struct char_data *ch)
{
  struct char_data *k;
  struct follow_type *f;

  if (!AFF_FLAGGED(ch, AFF_GROUP))
    send_to_char("But you are not the member of a group!\r\n", ch);
  else {
    send_to_char("&WYour &ggroup&W consists of:&n\r\n", ch);

    k = (ch->master ? ch->master : ch);

    if (AFF_FLAGGED(k, AFF_GROUP)) {
      sprintf(buf, "     &n[&W%9d &RHp &W%9d &MMn &W%9d &GMv&n] &C[&n%4d %s&C] &g$N &M(Captain)&n", GET_HIT(k),
	      GET_MANA(k), GET_MOVE(k), GET_LEVEL(k), CLASS_ABBR(k));
      act(buf, FALSE, ch, 0, k, TO_CHAR);
    }

    for (f = k->followers; f; f = f->next) {
      if (!AFF_FLAGGED(f->follower, AFF_GROUP))
	continue;

      sprintf(buf, "     &n[&W%9d &RHp &W%9d &MMn &W%9d &GMv&n] &C[&n%4d %s&C] &g$N&n", GET_HIT(f->follower),
	      GET_MANA(f->follower), GET_MOVE(f->follower),
	      GET_LEVEL(f->follower), CLASS_ABBR(f->follower));
      act(buf, FALSE, ch, 0, f->follower, TO_CHAR);
    }
  }
}

ACMD(do_group)
{
  struct char_data *vict;
  struct follow_type *f;
  int found;

  one_argument(argument, buf);

  if (!*buf) {
    print_group(ch);
    return;
  }

  if (ch->master) {
    send_to_char("You can not enroll group members without being head of a group.\r\n", ch);
    return;
  }

  if (!str_cmp(buf, "all")) {
    for (found = 0, f = ch->followers; f; f = f->next)
      if (((ch->player.level - f->follower->player.level) <= 20) && ((ch->player.level - f->follower->player.level) >= -20)){
	if(!IS_NPC(f->follower))
          found += perform_group(ch, f->follower);
      }
      else{
        sprintf(buf,"&W%s &wis don't have level to enter in your group.&n\r\n",PERS(f->follower, ch));
        send_to_char(buf, ch);
        act("You don't have level to enter in the &W$n's &wgroup.&n", FALSE, ch, 0, f->follower, TO_VICT);
      }
    if (!found)
      send_to_char("You need someone following you to perform a group.\r\n", ch);
    else
      perform_group(ch, ch);
    return;
  }

  if (!(vict = get_char_room_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (ch == vict)
    send_to_char("Use 'group all' to create a group.\r\n", ch);
  else if (IS_NPC(vict))
    send_to_char("MOBs grouping?\r\n", ch);
  else if ((vict->master != ch) && (vict != ch)) {
    sprintf(buf,"%s must follow you to enter your group.\r\n",PERS(vict, ch));
    send_to_char(buf, ch);
    }
  else {
    if (!AFF_FLAGGED(vict, AFF_GROUP))
      if (((ch->player.level - vict->player.level) <= 20) && ((ch->player.level - vict->player.level) >= -20)){
       perform_group(ch, ch);
       perform_group(ch, vict);
      }
      else{
        sprintf(buf,"&W%s &wis don't have level to enter in your group.&n\r\n",PERS(vict, ch));
        send_to_char(buf, ch);
        act("You don't have level to enter in the &W$n's &wgroup.&n", FALSE, ch, 0, vict, TO_VICT);
      }
    else {
      if (ch != vict)
        sprintf(buf,"%s is no longer a member of your group.\r\n",PERS(vict, ch));
        send_to_char(buf, ch);
      act("You have been kicked out of $n's group!", FALSE, ch, 0, vict, TO_VICT);
      act("$N has been kicked out of $n's group!", FALSE, ch, 0, vict, TO_NOTVICT);
      REMOVE_BIT(AFF_FLAGS(vict), AFF_GROUP);
    }
  }
}



ACMD(do_ungroup)
{
  struct follow_type *f, *next_fol;
  struct char_data *tch;

  one_argument(argument, buf);

  if (!*buf) {
    if (ch->master || !(AFF_FLAGGED(ch, AFF_GROUP))) {
      send_to_char("But you lead no group!\r\n", ch);
      return;
    }
    sprintf(buf2, "%s has disbanded the group.\r\n", GET_NAME(ch));
    for (f = ch->followers; f; f = next_fol) {
      next_fol = f->next;
      if (AFF_FLAGGED(f->follower, AFF_GROUP)) {
        REMOVE_BIT(AFF_FLAGS(f->follower), AFF_GROUP);
        send_to_char(buf2, f->follower);
        if (!AFF_FLAGGED(f->follower, AFF_CHARM))
          stop_follower(f->follower);
      }
    }

    REMOVE_BIT(AFF_FLAGS(ch), AFF_GROUP);
    send_to_char("&wYou disband the group.&n\r\n", ch);
    return;
  }
  if (!(tch = get_char_room_vis(ch, buf))) {
    send_to_char("There is no such person!\r\n", ch);
    return;
  }
  if (tch->master != ch) {
    send_to_char("That person is not following you!\r\n", ch);
    return;
  }

  if (!AFF_FLAGGED(tch, AFF_GROUP)) {
    send_to_char("That person isn't in your group.\r\n", ch);
    return;
  }

  REMOVE_BIT(AFF_FLAGS(tch), AFF_GROUP);


  sprintf(buf,"%s is no longer a member of your group.\r\n",PERS(tch, ch));
  send_to_char(buf, ch);
  act("You have been kicked out of $n's group!", FALSE, ch, 0, tch, TO_VICT);
  act("$N has been kicked out of $n's group!", FALSE, ch, 0, tch, TO_NOTVICT);

  if (!AFF_FLAGGED(tch, AFF_CHARM))
    stop_follower(tch);
}




ACMD(do_report)
{
  struct char_data *k;
  struct follow_type *f;

  if (!AFF_FLAGGED(ch, AFF_GROUP)) {
    send_to_char("But you are not a member of any group!\r\n", ch);
    return;
  }
  sprintf(buf, "&W%s &wreports: &w%d&c[&wHp&c], &w%d&c[&wMn&c], &w%d&c[&wMv&c], &w%d%%&c[&wOxi&c]\r\n",
          GET_NAME(ch), GET_HIT(ch), GET_MANA(ch),
          GET_MOVE(ch), GET_OXI(ch));
  CAP(buf);

  k = (ch->master ? ch->master : ch);

  for (f = k->followers; f; f = f->next)
    if (AFF_FLAGGED(f->follower, AFF_GROUP) && f->follower != ch)
      send_to_char(buf, f->follower);
  if (k != ch)
    send_to_char(buf, k);
  send_to_char("You report to the group.\r\n", ch);
}

ACMD(do_split)
{
  int amount, num, share, rest;
  struct char_data *k;
  struct follow_type *f;

  if (IS_NPC(ch))
    return;

  one_argument(argument, buf);

  if (is_number(buf)) {
    amount = atoi(buf);
    if (amount <= 0) {
      send_to_char("Sorry, you can't do that.\r\n", ch);
      return;
    }
    if (amount > GET_GOLD(ch)) {
      send_to_char("You don't seem to have that much gold to split.\r\n", ch);
      return;
    }
    k = (ch->master ? ch->master : ch);

    if (AFF_FLAGGED(k, AFF_GROUP) && (k->in_room == ch->in_room))
      num = 1;
    else
      num = 0;

    for (f = k->followers; f; f = f->next)
      if (AFF_FLAGGED(f->follower, AFF_GROUP) &&
	  (!IS_NPC(f->follower)) &&
	  (f->follower->in_room == ch->in_room))
	num++;

    if (num && AFF_FLAGGED(ch, AFF_GROUP)) {
      share = amount / num;
      rest = amount % num;
    } else {
      send_to_char("With whom do you wish to share your gold?\r\n", ch);
      return;
    }

    GET_GOLD(ch) -= share * (num - 1);

    sprintf(buf, "%s splits %d coins; you receive %d.\r\n", GET_NAME(ch),
            amount, share);
    if (rest) {
      sprintf(buf + strlen(buf), "%d coin%s %s not splitable, so %s "
              "keeps the money.\r\n", rest,
              (rest == 1) ? "" : "s",
              (rest == 1) ? "was" : "were",
              GET_NAME(ch));
    }
    if (AFF_FLAGGED(k, AFF_GROUP) && (k->in_room == ch->in_room)
	&& !(IS_NPC(k)) && k != ch) {
      GET_GOLD(k) += share;
      send_to_char(buf, k);
    }
    for (f = k->followers; f; f = f->next) {
      if (AFF_FLAGGED(f->follower, AFF_GROUP) &&
	  (!IS_NPC(f->follower)) &&
	  (f->follower->in_room == ch->in_room) &&
	  f->follower != ch) {
	GET_GOLD(f->follower) += share;
	send_to_char(buf, f->follower);
      }
    }
    sprintf(buf, "You split %d coins among %d members -- %d coins each.\r\n",
	    amount, num, share);
    if (rest) {
      sprintf(buf + strlen(buf), "%d coin%s %s not splitable, so you keep "
                                 "the money.\r\n", rest,
                                 (rest == 1) ? "" : "s",
                                 (rest == 1) ? "was" : "were");
      GET_GOLD(ch) += rest;
    }
    send_to_char(buf, ch);
  } else {
    send_to_char("How many coins do you wish to split with your group?\r\n", ch);
    return;
  }
}

ACMD(do_use)
{
  struct obj_data *mag_item;
  int equipped = 1;

  half_chop(argument, arg, buf);
  if (!*arg) {
    sprintf(buf2, "What do you want to %s?\r\n", CMD_NAME);
    send_to_char(buf2, ch);
    return;
  }
  mag_item = GET_EQ(ch, WEAR_HOLD);

  if (!mag_item || !isname(arg, mag_item->name)) {
    switch (subcmd) {
    case SCMD_RECITE:
    case SCMD_QUAFF:
      equipped = 0;
      if (!(mag_item = get_obj_in_list_vis(ch, arg, ch->carrying))) {
        sprintf(buf2, "You don't seem to have %s %s.\r\n", AN(arg), arg);
        send_to_char(buf2, ch);
        return;
      }
      break;
    case SCMD_USE:
      sprintf(buf2, "You don't seem to be holding %s %s.\r\n", AN(arg), arg);
      send_to_char(buf2, ch);
      return;
    default:
      log("SYSERR: Unknown subcmd %d passed to do_use.", subcmd);
      return;
    }
  }
  switch (subcmd) {
  case SCMD_QUAFF:
    if (GET_OBJ_TYPE(mag_item) != ITEM_POTION) {
      send_to_char("You can only quaff potions.\r\n", ch);
      return;
    }
    break;
  case SCMD_RECITE:
    if (GET_OBJ_TYPE(mag_item) != ITEM_SCROLL) {
      send_to_char("You can only recite scrolls.\r\n", ch);
      return;
    }
    break;
  case SCMD_USE:
    if ((GET_OBJ_TYPE(mag_item) != ITEM_WAND) &&
        (GET_OBJ_TYPE(mag_item) != ITEM_STAFF)) {
      send_to_char("You can't seem to figure out how to use it.\r\n", ch);
      return;
    }
    break;
  }

  mag_objectmagic(ch, mag_item, buf);
}



ACMD(do_wimpy)
{
  int wimp_lev;

  /* 'wimp_level' is a player_special. -gg 2/25/98 */
  if (IS_NPC(ch))
    return;

  one_argument(argument, arg);

  if (!*arg) {
    if (GET_WIMP_LEV(ch)) {
      sprintf(buf, "Your current wimp level is %s hit points.\r\n",
              add_points(GET_WIMP_LEV(ch)));
      send_to_char(buf, ch);
      return;
    } else {
      send_to_char("At the moment, you're not a wimp.  (sure, sure...)\r\n", ch);
      return;
    }
  }
  if (isdigit(*arg)) {
    if ((wimp_lev = atoi(arg)) != 0) {
      if (wimp_lev < 0)
        send_to_char("Heh, heh, heh.. we are jolly funny today, eh?\r\n", ch);
      else if (wimp_lev > GET_MAX_HIT(ch))
        send_to_char("That doesn't make much sense, now does it?\r\n", ch);
      else if (wimp_lev > (GET_MAX_HIT(ch)/2))
        send_to_char("You can't set your wimp level above half hit points.\r\n", ch);
      else {
        sprintf(buf, "Okay, you'll wimp out if you drop below %s hit points.\r\n",
                add_points(wimp_lev));
        send_to_char(buf, ch);
        GET_WIMP_LEV(ch) = wimp_lev;
      }
    } else {
      send_to_char("Okay, you'll now tough out fights to the bitter end.\r\n", ch);
      GET_WIMP_LEV(ch) = 0;
    }
  } else
    send_to_char("Specify at how many hit points you want to wimp out at.  (0 to disable)\r\n", ch);

  return;

}


#define USAGE "Usage: prompt H M V T\r\n" \
              "  use H for Health, M for Mana Points, T to Mental Points,\r\n" \
	      " V to Movement and E to experience.\r\n" \
              "\r\n" \
              "Example: prompt HV  for [x]Hp [x]Mv >\r\n" \
              "         prompt all for [x]Xp [x]Hp [x]Mn [x]Mp [x]Mv >\r\n" \
              "You can use any combination of HMTVE, ALL to all of them, and NONE for no one.\r\n" \

ACMD(do_display)
{
  size_t i;

  if (IS_NPC(ch)) {
    send_to_char("Mosters don't need displays.  Go away.\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    send_to_char(USAGE, ch);
    return;
  }
  if ((!str_cmp(argument, "on")) || (!str_cmp(argument, "all"))) {
    SET_BIT(PRF_FLAGS(ch), PRF_DISPHP | PRF_DISPMANA | PRF_DISPMOVE | PRF_DISPMENT);
    SET_BIT(PRF2_FLAGS(ch), PRF2_DISPEXP);
  }
  else {
    REMOVE_BIT(PRF_FLAGS(ch), PRF_DISPHP | PRF_DISPMANA | PRF_DISPMOVE | PRF_DISPMENT);
    REMOVE_BIT(PRF2_FLAGS(ch), PRF2_DISPEXP);

  if ((!str_cmp(argument, "off")) || (!str_cmp(argument, "none"))) {
    send_to_char(OK, ch);
    return;
  }

    for (i = 0; i < strlen(argument); i++) {
      switch (LOWER(argument[i])) {
      case 'h':
        SET_BIT(PRF_FLAGS(ch), PRF_DISPHP);
        break;
      case 'm':
        SET_BIT(PRF_FLAGS(ch), PRF_DISPMANA);
        break;
      case 't':
        SET_BIT(PRF_FLAGS(ch), PRF_DISPMENT);
        break;
      case 'v':
        SET_BIT(PRF_FLAGS(ch), PRF_DISPMOVE);
        break;
      case 'e':
        SET_BIT(PRF2_FLAGS(ch), PRF2_DISPEXP);
        break;
      default:
        send_to_char(USAGE, ch);
        return;
        break;
      }
    }
  }

  send_to_char(OK, ch);
}



ACMD(do_gen_write)
{
  FILE *fl;
  char *tmp, buf[MAX_STRING_LENGTH];
  const char *filename;
  struct stat fbuf;
  time_t ct;

  switch (subcmd) {
  case SCMD_BUG:
    filename = BUG_FILE;
    break;
  case SCMD_TYPO:
    filename = TYPO_FILE;
    break;
  case SCMD_IDEA:
    filename = IDEA_FILE;
    break;
  default:
    return;
  }

  ct = time(0);
  tmp = asctime(localtime(&ct));

  if (IS_NPC(ch)) {
    send_to_char("Monsters can't have ideas - Go away.\r\n", ch);
    return;
  }

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument) {
    send_to_char("That must be a mistake...\r\n", ch);
    return;
  }
  sprintf(buf, "%s %s: %s", GET_NAME(ch), CMD_NAME, argument);
  mudlog(buf, CMP, LVL_IMMORT, FALSE);

  if (stat(filename, &fbuf) < 0) {
    perror("Error statting file");
    return;
  }
  if (fbuf.st_size >= max_filesize) {
    send_to_char("Sorry, the file is full right now.. try again later.\r\n", ch);
    return;
  }
  if (!(fl = fopen(filename, "a"))) {
    perror("do_gen_write");
    send_to_char("Could not open the file.  Sorry.\r\n", ch);
    return;
  }
  fprintf(fl, "%-8s (%6.6s) [%5d] %s\n", GET_NAME(ch), (tmp + 4),
          GET_ROOM_VNUM(IN_ROOM(ch)), argument);
  fclose(fl);
  send_to_char("Okay.  Thanks!\r\n", ch);
}



#define TOG_OFF 0
#define TOG_ON  1

#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))
#define PRF2_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF2_FLAGS(ch), (flag))) & (flag))

ACMD(do_gen_tog)
{
  long result;

  const char *tog_messages[][2] = {
    {"You are now safe from summoning by other players.\r\n",
     "You may now be summoned by other players.\r\n"},
    {"Nohassle disabled.\r\n",
     "Nohassle enabled.\r\n"},
    {"Brief mode off.\r\n",
     "Brief mode on.\r\n"},
    {"Compact mode off.\r\n",
     "Compact mode on.\r\n"},
    {"You can now hear tells.\r\n",
     "You are now deaf to tells.\r\n"},
    {"You can now hear auctions.\r\n",
     "You are now deaf to auctions.\r\n"},
    {"You can now hear shouts.\r\n",
     "You are now deaf to shouts.\r\n"},
    {"You can now hear gossip.\r\n",
     "You are now deaf to gossip.\r\n"},
    {"You can now hear the congratulation messages.\r\n",
     "You are now deaf to the congratulation messages.\r\n"},
    {"You can now hear the chat channel.\r\n",
     "You are now deaf to the chat channel.\r\n"},
    {"You can now hear the Wiz-channel.\r\n",
     "You are now deaf to the Wiz-channel.\r\n"},
    {"You are no longer part of the Quest.\r\n",
     "Okay, you are part of the Quest!\r\n"},
    {"You will no longer cross doors without opening them.\r\n",
     "You will now cross doors without opening them.\r\n"},
    {"You will now have your communication repeated.\r\n",
     "You will no longer have your communication repeated.\r\n"},
    {"HolyLight mode off.\r\n",
     "HolyLight mode on.\r\n"},
    {"Nameserver_is_slow changed to NO; IP addresses will now be resolved.\r\n",
     "Nameserver_is_slow changed to YES; sitenames will no longer be resolved.\r\n"},
    {"Autoexits disabled.\r\n",
     "Autoexits enabled.\r\n"},
    {"Autoloot off.\r\n",
     "Autoloot on.\r\n"},
    {"Autogold off.\r\n",
     "Autogold on.\r\n"},
    {"Autosplit off.\r\n",
     "Autosplit on.\r\n"},
    {"You are back.\r\n",
     "You are away from keyboard now.\r\n"},
    {"Autoassist off.\r\n",
     "Autoassist on.\r\n"},
    {"WarDome special protocol off.\r\n",
     "WarDome special protocol on.\r\n"},
    {"Mini map off.\r\n",
     "Mini map on.\r\n"},
    {"You can be replied now.\r\n",
     "You can not be replied.\r\n"},
	{"Your recall will point to your house now.\r\n",
	 "Your recall will not point to your house now.\r\n"},
    {"You can now hear de newbie chat.\r\n",
     "You are deaf to newbie chat.\r\n"},
  };


  if (IS_NPC(ch))
    return;

  switch (subcmd) {
  case SCMD_NOSUMMON:
    result = PRF_TOG_CHK(ch, PRF_SUMMONABLE);
    break;
  case SCMD_NOHASSLE:
    result = PRF_TOG_CHK(ch, PRF_NOHASSLE);
    break;
  case SCMD_BRIEF:
    result = PRF_TOG_CHK(ch, PRF_BRIEF);
    break;
  case SCMD_COMPACT:
    result = PRF_TOG_CHK(ch, PRF_COMPACT);
    break;
  case SCMD_NOTELL:
    result = PRF_TOG_CHK(ch, PRF_NOTELL);
    break;
  case SCMD_NOAUCTION:
    result = PRF_TOG_CHK(ch, PRF_NOAUCT);
    break;
  case SCMD_DEAF:
    result = PRF_TOG_CHK(ch, PRF_DEAF);
    break;
  case SCMD_NOGOSSIP:
    result = PRF_TOG_CHK(ch, PRF_NOGOSS);
    break;
  case SCMD_NOGRATZ:
    result = PRF_TOG_CHK(ch, PRF_NOGRATZ);
    break;
  case SCMD_NOWIZ:
    result = PRF_TOG_CHK(ch, PRF_NOWIZ);
    break;
  case SCMD_QUEST:
    result = PRF_TOG_CHK(ch, PRF_QUEST);
    break;
  case SCMD_CROSSDOORS:
    result = PRF_TOG_CHK(ch, PRF_CROSSDOORS);
    break;
  case SCMD_NOREPEAT:
    result = PRF_TOG_CHK(ch, PRF_NOREPEAT);
    break;
  case SCMD_HOLYLIGHT:
    result = PRF_TOG_CHK(ch, PRF_HOLYLIGHT);
    break;
  case SCMD_SLOWNS:
    result = (nameserver_is_slow = !nameserver_is_slow);
    break;
  case SCMD_AUTOEXIT:
    result = PRF_TOG_CHK(ch, PRF_AUTOEXIT);
    break;
  case SCMD_AUTOLOOT:
    result = PRF_TOG_CHK(ch, PRF_AUTOLOOT);
    break;
  case SCMD_AUTOGOLD:
    result = PRF_TOG_CHK(ch, PRF_AUTOGOLD);
    break;
  case SCMD_AUTOSPLIT:
    result = PRF_TOG_CHK(ch, PRF_AUTOSPLIT);
    break;
  case SCMD_AFK:
    result = PRF_TOG_CHK(ch, PRF_AFK);
    break;
  case SCMD_AUTOASSIST:
    result = PRF_TOG_CHK(ch, PRF_AUTOASSIST);
    break;
  case SCMD_NOCHAT:
    result = PRF_TOG_CHK(ch, PRF_NOCHAT);
    break;
  case SCMD_WDPROTOCOL:
    result = PRF2_TOG_CHK(ch, PRF2_WDPROTOCOL);
    break;
  case SCMD_MAP:
    result = PRF2_TOG_CHK(ch, PRF2_MAP);
    break;
  case SCMD_NOREPLY:
    result = PRF2_TOG_CHK(ch, PRF2_NOREPEAT);
    break;
  case SCMD_HOUSE_RECALL:
	if (ch->player_specials->saved.house_vnum > 0)
		result = PRF2_TOG_CHK(ch, PRF2_HOUSE_RECALL);
	else {
		send_to_char("You cannot tog this if you don't have a house.\r\n", ch);
		return;
	}
    break;
   case SCMD_NONEWBIE:
	result = PRF2_TOG_CHK(ch, PRF2_NONEWBIE);
    break;

  default:
    log("SYSERR: Unknown subcmd %d in do_gen_toggle.", subcmd);
    return;
  }

  if (result)
    send_to_char(tog_messages[subcmd][TOG_ON], ch);
  else
    send_to_char(tog_messages[subcmd][TOG_OFF], ch);

  return;
}

// codigo funcionando perfeito, recoloqueio-o (Archangel)
ACMD(do_sacrifice)
{
   struct obj_data *obj;

   one_argument(argument, arg);

   if (!*arg)
   {
     send_to_char("Sacrifice what?\r\n",ch);
     return;
   }

   if (!(obj = get_obj_in_list_vis(ch, arg, world[ch->in_room].contents)))
   {
     send_to_char("You can't start to sacrifice!\r\n",ch);
     return;
   }

   if (!CAN_WEAR(obj, ITEM_WEAR_TAKE) || !IS_CORPSE(obj))
   {
     send_to_char("You can't sacrifice that!\r\n",ch);
     return;
   }

   if(IS_PC_CORPSE(obj))
   {
   	send_to_char("You can not sacrifice a player corpse.\r\n", ch);
   	return;
   }

   act("$n sacrifices $p.", FALSE, ch, obj, 0, TO_ROOM);
   sprintf(buf,"You sacrifice %s to your god.\r\nYou have been rewarded by your deity.\r\n",(obj)->short_description);
   send_to_char(buf, ch);
   extract_obj(obj);
   GET_GOLD(ch) += 10;
   GET_GOLD_SUM(ch) += 10;
}

ACMD(do_gas)
{
  byte percent;

  if (!GET_SKILL(ch, SKILL_WHITE_GAS)) {
	  send_to_char("You don't know how.\r\n", ch);
	  return;
  }

  if (AFF_FLAGGED(ch, AFF_GAS))
    REMOVE_BIT(AFF_FLAGS(ch), AFF_GAS);

  percent = number(1, 101);     /* 101% is a complete failure */

  if (percent > GET_SKILL(ch, SKILL_WHITE_GAS)/2 + GET_DEX(ch)*2)
    return;

  act("$n attempts to drop gas on the room.", FALSE, ch, 0, 0, TO_ROOM);
  act("$n disappears on the middle of the white gas.", FALSE, ch, 0, 0, TO_ROOM);
  send_to_char("You are hide on the room now.\r\n", ch);
  SET_BIT(AFF_FLAGS(ch), AFF_GAS);
  improve_skill(ch, SKILL_WHITE_GAS);
}

ACMD(do_meditate)
{
  byte percent;

  if (IS_NPC(ch) || !GET_SKILL(ch, SKILL_MEDITATE)){
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }

  send_to_char("You try to start meditate.\r\n", ch);

  percent = number(1, 101);     /* 101% is a complete failure */

  if (GET_POS(ch) != POS_SITTING){
    send_to_char("You can't do this when you aren't sitting.\r\n", ch);
    return;
  }

  if (percent > GET_SKILL(ch, SKILL_MEDITATE)){
    send_to_char("You fail trying to meditate.\r\n", ch);
    return;
  }

  send_to_char("You start to meditate.\r\n", ch);
  SET_BIT(PLR_FLAGS(ch), PLR_MEDITATE);
  improve_skill(ch, SKILL_MEDITATE);
}

#define CAN_LISTEN_BEHIND_DOOR(ch,dir)  \
                (EXIT(ch, dir) && EXIT(ch, dir)->to_room != NOWHERE && \
                 IS_SET(EXIT(ch, dir)->exit_info, EX_CLOSED)))


ACMD(do_listen)
{
   struct char_data *tch, *tch_next;
   int percent, found = 0;
   char *heard_nothing = "You don't hear anything unusual.\r\n";
   char *room_spiel    = "$n seems to listen intently for something.";

   percent = number(1,101);

   if(!GET_SKILL(ch, SKILL_LISTEN) || GET_SKILL(ch, SKILL_LISTEN) < percent) {
      send_to_char(heard_nothing, ch);
      return;
   }

      /* no argument means that the character is listening for
       * hidden or invisible beings in the room he/she is in
       */
      for(tch = world[ch->in_room].people; tch; tch = tch_next) {
         tch_next = tch->next_in_room;
         if((tch != ch) && !CAN_SEE(ch, tch) && (GET_LEVEL(tch) < LVL_IMMORT))
            found++;
      }
      if(found) {
	 improve_skill(ch, SKILL_LISTEN);
         if(GET_SKILL(ch, SKILL_LISTEN) >= 70) {
            /* being a higher level is better */
            sprintf(buf, "You hear what might be %d creatures invisible, or hiding.\r\n", MAX(1,(found+number(0,1)-number(0,1))));
         }
         else
            sprintf(buf, "You hear an odd rustling in the immediate area.\r\n");

         send_to_char(buf, ch);
      }
      else
       send_to_char(heard_nothing, ch);
       act(room_spiel, TRUE, ch, 0, 0, TO_ROOM);
       return;

}


/* transformacao em ordem */
#define MAX_TRANS		7

const char *nome_trans[] = {
    "kaiser",
    "sprite",
    "werewolf",
    "sucubus",
    "behemoth",
    "tyrael",
    "slayer"
};

const char *cnome_trans[] = {
    "&gKaiser&n",
    "&ySprite&n",
    "&rWerewolf&n",
    "&mSucubus&n",
    "&bBehemoth&n",
    "&wTyrael&n",
    "&cSlayer&n"
};

const char *ctitle_trans[] = {
    "&Wwith &ggreen&W scales and huge &cwings&n",
    "&ywith big nose and a tiny pair of wings&n",
    "&rwith hair all over the body and a wolf appearance&n",
    "&mwith a very pleasant feminine appareance&n",
    "&bwith demon face and a fat and ugly but powerful body&n",
    "&wwith white-shinning wings and tentacles&n",
    "&cwith a very ugly demon aspect and very powerful muscles&n"
};

#define HP		0
#define MANA		1
#define MOVE		2
#define DAM		3
#define HIT		4
#define AC		5
#define VNUM_EQ		6
#define MENTAL		7
#define MT_GAST		8
#define SKILLT		9
#define MENTMIN		10

int trans_aff[][11] = {
/* qual hp(x)mana(x)move(x)dam(+)hit(+) ac(+)vnumeq mental  mcosttick skill   qtd minima*/
      {  4,    1,     3,    450,  400,  -150, 1266,    175,  -50, SKILL_KAISER,    90},
      {  1,    1,     1,     40,   25,   -20,    0,      5,   -5, SKILL_SPRITE,    10},
      {  2,    1,     1,    100,   70,   -40,    0,     25,  -10, SKILL_WEREWOLF,  20},
      {  2,    1,     1,    140,  100,   -60,    0,     50,  -20, SKILL_SUCUBUS,   30},
      {  2,    1,     2,    220,  170,   -80,    0,    100,  -30, SKILL_BEHEMOTH,  50},
      {  3,    1,     2,    250,  240,  -100,    0,    150,  -40, SKILL_TYRAEL,    60},
      {  4,    1,     3,    400,  300,  -100,    0,    200,  -50, SKILL_SLAYER,    70},
      {  0,    0,     0,      0,    0,     0,    0,      0,    0, 	     0,     0}
};

#define	CHARAC			0
#define ROOM			1

const char *mens_trans[][2] = {
 {
  "&WYou feel a &Cgodly &Rpower &Wchanging your body.&n\r\n&WYou got the hybrid dragon form &gKaiser&W!&n\r\n",
  "&c$n &Wtransforms into a &Rdragon&W!&n"
 },
 {
  "You feel a funny power changing your body.\r\nYou got the form of a tiny but smart sprite!\r\n",
  "$n transforms into a sprite!"
 },
 {
  "You feel the powers of moon changing your body.\r\nYou transform into a werewolf!\r\n",
  "$n transforms into a werewolf!"
 },
 {
  "You feel a magic power changing your body.\r\nYou got the form of the ancient demoness sucubus!\r\n",
  "$n transforms into a sucubus!"
 },
 {
  "You feel a wicked power changing your body.\r\nYou got the form of the fat demon behemoth!\r\n",
  "$n transforms into a behemoth!"
 },
 {
  "You feel a holy power changing your body.\r\nYou got the angel form of the archangel Tyrael, with light tentacles!\r\n",
  "$n transforms into a angel with light tentacles!"
 },
 {
  "You feel a devil power changing your body.\r\nYou got the form of Slayer, the destroyer of humankind!\r\n",
  "$n transforms into the Slayer!"
 }
};

void aumenta_poder(struct char_data * ch)
{
  int door;

  send_to_char("&RYou yell, 'AAAAAAAAAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'&n\r\n", ch);
  act("&R$n yells, 'AAAAAAAAAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'&n", FALSE, ch, 0, 0, TO_ROOM);

  sprintf(buf, "&R%s yells, 'AAAAAAAAAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH'&n\r\n", GET_NAME(ch));
  for (door = 0; door < NUM_OF_DIRS; door++)
    if (CAN_GO(ch, door))
      send_to_room(buf, world[ch->in_room].dir_option[door]->to_room);
}

int tem_eq(struct char_data *ch, int trans)
{
	int j = 0;

	if(trans_aff[trans][VNUM_EQ] == 0)
		return FALSE;

    for (j = 0; j < NUM_WEARS; j++)
		if(GET_EQ(ch, j))
			if(GET_OBJ_VNUM(GET_EQ(ch, j)) == trans_aff[trans][VNUM_EQ])
				return TRUE;

	return FALSE;
}

int transformar(struct char_data *ch, int trans)
{
	struct affected_type af[6];
	obj_rnum r_num;
	short int eq = 0;

	if(!(eq = tem_eq(ch, trans)))
		if(!GET_SKILL(ch, trans_aff[trans][SKILLT]))
		   return (FALSE);

	if(GET_MENTAL(ch) < trans_aff[trans][MENTAL])
	   return (FALSE);

	if(GET_MENTAL(ch) < (GET_MAX_MENTAL(ch)*trans_aff[trans][MENTMIN])/100)
	   return (FALSE);

	GET_MENTAL(ch) -= trans_aff[trans][MENTAL];
	GET_TRANS(ch) = trans;

	SET_BIT(AFF2_FLAGS(ch), AFF2_TRANSFORM);

	if (ch->affected)
          while (ch->affected)
            affect_remove(ch, ch->affected);

	af[0].type = trans_aff[trans][SKILLT];
	af[0].duration = -1;
	af[0].modifier = (GET_MAX_HIT(ch)*(trans_aff[trans][HP]-1)+1);
	af[0].location = APPLY_HIT;
	af[0].bitvector = 0;
	af[0].bitvector2 = AFF2_TRANSFORM;
	af[0].bitvector3 = 0;
	affect_to_char(ch, &af[0]);

	af[1].type = trans_aff[trans][SKILLT];
	af[1].duration = -1;
	af[1].modifier = (GET_MAX_MANA(ch)*(trans_aff[trans][MANA]-1)+1);
	af[1].location = APPLY_MANA;
	af[1].bitvector = 0;
	af[1].bitvector2 = AFF2_TRANSFORM;
	af[1].bitvector3 = 0;
	affect_to_char(ch, &af[1]);

	af[2].type = trans_aff[trans][SKILLT];
	af[2].duration = -1;
	af[2].modifier = (GET_MAX_MOVE(ch)*(trans_aff[trans][MOVE]-1)+1);
	af[2].location = APPLY_MOVE;
	af[2].bitvector = 0;
	af[2].bitvector2 = AFF2_TRANSFORM;
	af[2].bitvector3 = 0;
	affect_to_char(ch, &af[2]);

	af[3].type = trans_aff[trans][SKILLT];
	af[3].duration = -1;
	af[3].modifier = trans_aff[trans][DAM]+1;
	af[3].location = APPLY_DAMROLL;
	af[3].bitvector = 0;
	af[3].bitvector2 = AFF2_TRANSFORM;
	af[3].bitvector3 = 0;
	affect_to_char(ch, &af[3]);

	af[4].type = trans_aff[trans][SKILLT];
	af[4].duration = -1;
	af[4].modifier = trans_aff[trans][HIT]+1;
	af[4].location = APPLY_HITROLL;
	af[4].bitvector = 0;
	af[4].bitvector2 = AFF2_TRANSFORM;
	af[4].bitvector3 = 0;
	affect_to_char(ch, &af[4]);

	af[5].type = trans_aff[trans][SKILLT];
	af[5].duration = -1;
	af[5].modifier = trans_aff[trans][AC]-1;
	af[5].location = APPLY_AC;
	af[5].bitvector = 0;
	af[5].bitvector2 = AFF2_TRANSFORM;
	af[5].bitvector3 = 0;
	affect_to_char(ch, &af[5]);

/*	GET_TRANS_HP(ch) = GET_HIT(ch);
	GET_TRANS_MANA(ch) = GET_MANA(ch);
	GET_TRANS_MOVE(ch) = GET_MOVE(ch);*/

	GET_HIT(ch) = GET_MAX_HIT(ch);
	GET_MANA(ch) = GET_MAX_MANA(ch);
	GET_MOVE(ch) = GET_MAX_MOVE(ch);

  	save_char(ch, ch->in_room);
	Crash_crashsave(ch);

	aumenta_poder(ch);
    if(eq)
    {
		r_num = real_object(trans_aff[trans][VNUM_EQ]);
    	sprintf(buf, "&WYou use as your &csource &Wof &Rpower &n%s&W.&n\r\n", obj_proto[r_num].short_description);
    	send_to_char(buf, ch);
	}
	send_to_char(mens_trans[trans][CHARAC], ch);
	act(mens_trans[trans][ROOM], TRUE, ch, 0, 0, TO_NOTVICT);

  return (TRUE);
}

const char *mens2_trans[][2] = {
 {"&WYou feel yourself &Rweak&W. Lost the &gKaiser &Rpower&W!&n\r\n",
  "&c$n &Wcomes back to the normal form&n!"},

 {"You feel yourself bored. Lost the sprite's power!\r\n",
  "$n comes back to the normal form!"},

 {"You feel the moon too far... Lost the werewolf's power!\r\n",
  "$n comes back to the normal form!"},

 {"You feel your sexuality decreasing. Lost the sucubus power!\r\n",
  "$n comes back to the normal form!"},

 {"You feel yourself weak and thin. Lost Behemoth's power!\r\n",
  "$n comes back to the normal form!"},

 {"You lost the light tentacles. Lost Tyrael's power!\r\n",
  "$n comes back to the normal form!"},

 {"You feel yourself useless, worthless and a trash. Lost the Slayer power!\r\n",
  "$n comes back to the normal form!"}
};

int destransformar(struct char_data *ch, int trans)
{
/*	GET_MAX_HIT(ch) /= trans_aff[trans][HP];
	GET_MAX_MANA(ch) /= trans_aff[trans][MANA];
	GET_MAX_MOVE(ch) /= trans_aff[trans][MOVE];
	GET_DAMROLL(ch) =  0;
	GET_HITROLL(ch) =  0;
	GET_AC(ch) =  100;

	GET_HIT(ch) = GET_TRANS_HP(ch);
	GET_MANA(ch) = GET_TRANS_MANA(ch);
	GET_MOVE(ch) = GET_TRANS_MOVE(ch);

	GET_TRANS_HP(ch) = 0;
	GET_TRANS_MANA(ch) = 0;
	GET_TRANS_MOVE(ch) = 0;*/

	REMOVE_BIT(AFF2_FLAGS(ch), AFF2_TRANSFORM);

	if (ch->affected)
          while (ch->affected)
            affect_remove(ch, ch->affected);

	GET_TRANS(ch) = 0;

	save_char(ch, ch->in_room);
	Crash_crashsave(ch);

	send_to_char(mens2_trans[trans][CHARAC], ch);
	act(mens2_trans[trans][ROOM], TRUE, ch, 0, 0, TO_NOTVICT);

  return (TRUE);
}

const char *retorno[] = {
       "&WYou are already &ctransformed&W!&n\r\n",
       "&WYou aren't &ctransformed&W!&n\r\n",
       "&WYou can not &ctransform&C!&n\r\n"
};

ACMD(do_transform)
{
  int men = -1, x = 0, t = 1, y = 0;
  char nome[80];

  one_argument(argument, nome);

  if(!*nome)
	t = 3;
  else {
       for(; y < MAX_TRANS && t; y++) {
	  if(isname(nome, nome_trans[x])) {
		t = 0;
		if(!AFF2_FLAGGED(ch, AFF2_TRANSFORM)) {
			if(!transformar(ch, x))
			   men = 3;
		} else
			men = 1;
	  } else if(exact_isname(nome, "normal")) {
		t = 0;
		if(AFF2_FLAGGED(ch, AFF2_TRANSFORM)) {
			destransformar(ch, GET_TRANS(ch));
			t = 0;
		} else
			men = 2;
	  } else
		t = 3;
	  x++;
       }
  }

  if(men < 4  && men > 0)
  	send_to_char(retorno[men-1], ch);

  if (t == 3) {
    strcpy(buf2, "&CUse&W: &Btransform &c<");
    for(x = 0; x < MAX_TRANS; x++)
	sprintf(buf2 + strlen(buf2), "&C%s&c/", nome_trans[x]);
    strcat(buf2, "&Wnormal&c>&n\r\n");
    send_to_char(buf2, ch);
  }
}

ACMD(do_blood_ritual)
{
  int percent, cont;

  if (IS_NPC(ch) || !GET_SKILL(ch, SKILL_BLOOD_RITUAL)) {
    send_to_char("You have no idea how to do that.\r\n", ch);
    return;
  }

  cont = number(0, GET_LEVEL(ch)*2);

  if(GET_HIT(ch) <= cont)
  {
   send_to_char("You are too weak.\r\n", ch);
   return;
  }

  send_to_char("You called out the darkness.\r\n",ch);

  percent = number(1, 101);	/* 101% is a complete failure */

  if (percent > GET_SKILL(ch, SKILL_BLOOD_RITUAL))
  {
   send_to_char("But there were no answers.\r\n", ch);
   return;
  }

  GET_MANA(ch) = MIN(GET_MAX_MANA(ch), GET_MANA(ch) + (cont/4));
  GET_HIT(ch) = GET_HIT(ch) - cont;
  improve_skill(ch, SKILL_BLOOD_RITUAL);
  send_to_char("Darkness answered your call. Your blood turns into power.\r\n", ch);
}

ACMD(do_recharge)
{
	struct obj_data *wand;
	int level;
        long price ;

	one_argument(argument, arg);

	if (IS_NPC(ch))
		return;

	if (GET_ROOM_VNUM(ch->in_room) != 1127) {
		send_to_char("You cannot do that here.\r\n", ch);
		return;
	}

	if (!*arg) {
		send_to_char("&gMaltzabor tells you, 'Recharge what?'&n\r\n", ch);
		return;
	}

	if (!(wand = get_obj_in_list_vis(ch, arg, ch->carrying))) {
		send_to_char("&gMaltzabor tells you, 'Recharge what?!'&n\r\n", ch);
		return;
	}

	if ((GET_OBJ_TYPE(wand) != ITEM_WAND) && (GET_OBJ_TYPE(wand) != ITEM_STAFF)) {
		send_to_char("&gMaltzabor tells you, 'This item doesn't seem to be a &cWand&g or &cStaff&g.'&n\r\n", ch);
		return;
	}

	level = (GET_OBJ_LEVEL(wand)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(wand)/(LVL_IMMORT - 1))));
    if ((level == 0) && (GET_OBJ_LEVEL(wand) > 0))
		level = (LVL_IMMORT - 1);

// 	price = (level * 900); desequilibrado demais
        price = 5000000 ;

	if (GET_GOLD(ch) < price) {
		send_to_char("&gMaltzabor tells you, 'You don't have money!'&n\r\n", ch);
		return;
	}

	if (wand->obj_flags.value[1] == wand->obj_flags.value[2]) {
		send_to_char("&gMaltzabor tells you, 'This object is already recharged!'&n\r\n", ch);
		return;
	}

	GET_GOLD(ch) -= price;
	wand->obj_flags.value[2]++;
	send_to_char("&gMaltzabor tells you, 'One charge restored.'&n\r\n", ch);
}
#define MAX_WMOTD_LENGTH        255
ACMD(do_message)
{
  extern struct message_data mess_info;
  extern void write_message_to_file();

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (IS_NPC(ch))
    send_to_char("The message of the day is fine... go away.\r\n", ch);
  else if ((PLR_FLAGGED(ch, PLR_NOTITLE)) || (PLR_FLAGGED(ch, PLR_NOSHOUT)))
    send_to_char("You can't post a message -- you shouldn't have abused it!\r\n", ch);
   else if (GET_LEVEL(ch) < LVL_IMMORT)/* Feel free to change the level.*/
    send_to_char("You can't change the message yet. Sit here and wait a while.\r\n",ch);
  else if (!str_cmp(argument, "remove")) {
    mess_info.writer[0] = '\0';        /*  ROD WAS HERE!!! 09/04/1999  */
    mess_info.message[0] = '\0';
    mess_info.time = 0;
    write_message_to_file();
    send_to_char("Message removed.\r\n",ch);
  }else {
    SET_BIT(PLR_FLAGS(ch), PLR_MESSAGING | PLR_WRITING);
    send_to_char("Write your message. End with '/s' on a new line.\r\n"
                 "If you want to remove the message just type: message remove.\r\n", ch);
    act("$n begins to jot down a message.", TRUE, ch, 0, 0, TO_ROOM);
    ch->desc->str = (char **) malloc(sizeof(char *));
    *(ch->desc->str) = NULL;
    ch->desc->max_str = MAX_WMOTD_LENGTH;
  }
}
::::::::::::::
act.social.c
::::::::::::::
/* ************************************************************************
*   File: act.social.c                                  Part of CircleMUD *
*  Usage: Functions to handle socials                                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"

/* extern variables */
extern struct room_data *world;
extern struct descriptor_data *descriptor_list;

/* extern functions */
char *fread_action(FILE * fl, int nr);

/* local functions */
int find_action(int cmd);
ACMD(do_action);
ACMD(do_insult);
void boot_social_messages(void);
ACMD(do_gmote);

/* local globals */
int top_of_socialt = -1;

struct social_messg *soc_mess_list = NULL;

#define NUM_RESERVED_CMDS	15

void free_action(struct social_messg *mess)  {
  if (mess->command) free(mess->command);
  if (mess->sort_as) free(mess->sort_as);
  if (mess->char_no_arg) free(mess->char_no_arg);
  if (mess->others_no_arg) free(mess->others_no_arg);
  if (mess->char_found) free(mess->char_found);
  if (mess->others_found) free(mess->others_found);
  if (mess->vict_found) free(mess->vict_found);
  if (mess->char_body_found) free(mess->char_body_found);
  if (mess->others_body_found) free(mess->others_body_found);
  if (mess->vict_body_found) free(mess->vict_body_found);
  if (mess->not_found) free(mess->not_found);
  if (mess->char_auto) free(mess->char_auto);
  if (mess->others_auto) free(mess->others_auto);
  if (mess->char_obj_found) free(mess->char_obj_found);
  if (mess->others_obj_found) free(mess->others_obj_found);
  memset(mess, 0, sizeof(struct social_messg));
}

int find_action(int cmd)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_socialt;

  if (top < 0)
    return (-1);

  for (;;) {
    mid = (bot + top) / 2;

    if (soc_mess_list[mid].act_nr == cmd)
      return (mid);
    if (bot >= top)
      return (-1);

    if (soc_mess_list[mid].act_nr > cmd)
      top = --mid;
    else
      bot = ++mid;
  }
}



ACMD(do_action)
{
  int act_nr;
  struct social_messg *action;
  struct char_data *vict;
  struct obj_data *targ;

  if ((act_nr = find_action(cmd)) < 0) {
    send_to_char("That action is not supported.\r\n", ch);
    return;
  }
  action = &soc_mess_list[act_nr];

  two_arguments(argument, buf, buf2);
  if ((!action->char_body_found) && (*buf2)) {
     send_to_char("Sorry, this social does not support body parts.\r\n", ch);
     return;
  }
  if (!action->char_found)
     *buf = '\0';

  if (!*buf) {
    send_to_char(action->char_no_arg, ch);
    send_to_char("\r\n", ch);
    act(action->others_no_arg, action->hide, ch, 0, 0, TO_ROOM);
    return;
  }
    if (!(vict = get_char_room_vis(ch, buf))) {
	if ((action->char_obj_found) &&
	      ((targ = get_obj_in_list_vis(ch, buf, ch->carrying)) ||
	      (targ = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents)))) {
	   act(action->char_obj_found, action->hide, ch, targ, 0, TO_CHAR);
	   act(action->others_obj_found, action->hide, ch, targ, 0, TO_ROOM);
	return;
     }
    send_to_char(action->not_found, ch);
    send_to_char("\r\n", ch);
    return;
    }
    else if (vict == ch) {
    send_to_char(action->char_auto, ch);
    send_to_char("\r\n", ch);
    act(action->others_auto, action->hide, ch, 0, 0, TO_ROOM);
  } else {
    if (GET_POS(vict) < action->min_victim_position)
      act("$N is not in a proper position for that.",
          FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else {
	 if (*buf2)  {
	    act(action->char_body_found, 0, ch, (struct obj_data *)buf2, vict, TO_CHAR | TO_SLEEP);
	    act(action->others_body_found, action->hide, ch, (struct obj_data *)buf2, vict, TO_NOTVICT);
	    act(action->vict_body_found, action->hide, ch, (struct obj_data *)buf2, vict, TO_VICT);
	 }
	 else  {
	    act(action->char_found, 0, ch, 0, vict, TO_CHAR | TO_SLEEP);
      	    act(action->others_found, action->hide, ch, 0, vict, TO_NOTVICT);
      	    act(action->vict_found, action->hide, ch, 0, vict, TO_VICT);
   }
  }
 }
}



ACMD(do_insult)
{
  struct char_data *victim;

  one_argument(argument, arg);

  if (*arg) {
    if (!(victim = get_char_room_vis(ch, arg)))
      send_to_char("Can't hear you!\r\n", ch);
    else {
      if (victim != ch) {
        sprintf(buf, "You insult %s.\r\n", GET_NAME(victim));
        send_to_char(buf, ch);

        switch (number(0, 2)) {
        case 0:
          if (GET_SEX(ch) == SEX_MALE) {
            if (GET_SEX(victim) == SEX_MALE)
              act("$n accuses you of fighting like a woman!", FALSE, ch, 0, victim, TO_VICT);
            else
              act("$n says that women can't fight.", FALSE, ch, 0, victim, TO_VICT);
          } else {              /* Ch == Woman */
            if (GET_SEX(victim) == SEX_MALE)
              act("$n accuses you of having the smallest... (brain?)",
                  FALSE, ch, 0, victim, TO_VICT);
            else
              act("$n tells you that you'd lose a beauty contest against a troll.",
                  FALSE, ch, 0, victim, TO_VICT);
          }
          break;
        case 1:
          act("$n calls your mother a bitch!", FALSE, ch, 0, victim, TO_VICT);
          break;
        default:
          act("$n tells you to get lost!", FALSE, ch, 0, victim, TO_VICT);
          break;
        }                       /* end switch */

        act("$n insults $N.", TRUE, ch, 0, victim, TO_NOTVICT);
      } else {                  /* ch == victim */
        send_to_char("You feel insulted.\r\n", ch);
      }
    }
  } else
    send_to_char("I'm sure you don't want to insult *everybody*...\r\n", ch);
}

char *fread_action(FILE *fl, int nr)
{
  char buf[MAX_STRING_LENGTH];

  fgets(buf, MAX_STRING_LENGTH, fl);
  if (feof(fl)) {
    log("SYSERR: fread_action: unexpected EOF near action #%d", nr);
    exit(1);
  }
  if (*buf == '#')
    return (NULL);

  buf[strlen(buf) - 1] = '\0';
  return (strdup(buf));
}

void boot_social_messages(void){
  FILE *fl;
  int nr = 0, hide, min_char_pos, min_pos, min_lvl, curr_soc = -1;
  char next_soc[MAX_STRING_LENGTH], sorted[MAX_INPUT_LENGTH];

  /* open social file */
  if (!(fl = fopen(SOCMESS_FILE, "r"))) {
    sprintf(buf, "SYSERR: can't open socials file '%s'", SOCMESS_FILE);
    perror(buf);
    exit(1);
  }
  /* count socials & allocate space */
  *next_soc = '\0';
  while (!feof(fl)) {
     fgets(next_soc, MAX_STRING_LENGTH, fl);
     if (*next_soc == '~') top_of_socialt++;
  }
  sprintf(buf, "Social table contains %d socials.", top_of_socialt);
  log(buf);
  rewind(fl);
  
  CREATE(soc_mess_list, struct social_messg, top_of_socialt + 1);

  /* now read 'em */
  for (;;) {
    fscanf(fl, " %s ", next_soc);
      if (*next_soc == '$') break;
      if (fscanf(fl, " %s %d %d %d %d \n",
		 sorted, &hide, &min_char_pos, &min_pos, &min_lvl) != 5) {
      log("SYSERR: format error in social file near social '%s'\n", next_soc);
      exit(1);
    }
    /* read the stuff */
    curr_soc++;
    soc_mess_list[curr_soc].command = str_dup(next_soc+1);
    soc_mess_list[curr_soc].sort_as = str_dup(sorted);
    soc_mess_list[curr_soc].hide = hide;
    soc_mess_list[curr_soc].min_char_position = min_char_pos;
    soc_mess_list[curr_soc].min_victim_position = min_pos;
    soc_mess_list[curr_soc].min_level_char = min_lvl;

#ifdef CIRCLE_ACORN
    if (fgetc(fl) != '\n')
      log("SYSERR: Acorn bug workaround failed.");
#endif

    soc_mess_list[curr_soc].char_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_no_arg = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_found = fread_action(fl, nr);

    soc_mess_list[curr_soc].others_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].vict_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].not_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_auto = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_auto = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_body_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_body_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].vict_body_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].char_obj_found = fread_action(fl, nr);
    soc_mess_list[curr_soc].others_obj_found = fread_action(fl, nr);
  }

  /* close file & set top */
  fclose(fl);
  top_of_socialt = curr_soc;
}

/* this function adds in the loaded socials and assigns them a command # */
void create_command_list(void)  {
   int i, j, k, x;
   struct social_messg temp;
   extern struct command_info cmd_info[];

   /* free up old command list */
   if (complete_cmd_info) free(complete_cmd_info);
   complete_cmd_info = NULL;

   /* re check the sort on the socials */
   for (j = 0; j < top_of_socialt; j++) {
       k = j;
     for (i = j + 1; i <= top_of_socialt; i++)
       	if (str_cmp(soc_mess_list[i].sort_as, soc_mess_list[k].sort_as) < 0)
      	k = i;
      if (j != k) {
	 temp = soc_mess_list[j];
	 soc_mess_list[j] = soc_mess_list[k];
	 soc_mess_list[k] = temp;
        }
     }
 
    /* count the commands in the command list */
    i = 0;
    while(*cmd_info[i].command != '\n') i++;
    i++;
 
    CREATE(complete_cmd_info, struct command_info, top_of_socialt + i + 2);
    
    x = i;
   /* this loop sorts the socials and commands together into one big list */
    i = 0;
    j = 0;
    k = 0;
    while ((*cmd_info[i].command != '\n') || (j <= top_of_socialt))  {
/*       if ((i < NUM_RESERVED_CMDS) || (j > top_of_socialt) ||
 	  (is_name(cmd_info[i].sort_as, soc_mess_list[j].sort_as)))*/
       if(k < x-1)
       	complete_cmd_info[k++] = cmd_info[i++];
       else  {
 	 soc_mess_list[j].act_nr		= k;
 	 complete_cmd_info[k].command		= soc_mess_list[j].command;
 	 complete_cmd_info[k].sort_as		= soc_mess_list[j].sort_as;
 	 complete_cmd_info[k].minimum_position	= soc_mess_list[j].min_char_position;
	 complete_cmd_info[k].command_pointer	= do_action;
	 complete_cmd_info[k].minimum_level    	= soc_mess_list[j++].min_level_char;
	 complete_cmd_info[k++].subcmd		= 0;
      }
   }
   complete_cmd_info[k].command		= str_dup("\n");
   complete_cmd_info[k].sort_as		= str_dup("zzzzzzz");
   complete_cmd_info[k].minimum_position = 0;
   complete_cmd_info[k].command_pointer	= 0;
   complete_cmd_info[k].minimum_level	= 0;
   complete_cmd_info[k].subcmd		= 0;
   sprintf(buf, "Command info rebuilt, %d total commands.", k);
   log(buf);
}

ACMD(do_gmote)
{
  int act_nr, length;
  char arg[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH];
  struct social_messg *action;
  struct char_data *vict = NULL;

  half_chop(argument, buf, arg);

  if(subcmd)
    for (length = strlen(buf), cmd = 0; *complete_cmd_info[cmd].command != '\n'; cmd++)
      if (!strncmp(complete_cmd_info[cmd].command, buf, length))
 	break;

  if ((act_nr = find_action(cmd)) < 0) {
    send_to_char("That's not a social!\r\n", ch);
    return;
  }
  action = &soc_mess_list[act_nr];

  if (!action->char_found)
    *arg = '\0';

  if (!*arg) {
    if(!action->others_no_arg || !*action->others_no_arg) {
      send_to_char("Who are you going to do that to?\r\n", ch);
      return;
    }
    sprintf(buf, "&W[GEMOTE]&w %s", action->others_no_arg);
//  } else if (IS_NPC(vict)) {
//    send_to_char("You can't use socials with mobs...", ch);
//    return;
  } else if (!(vict = get_char_vis(ch, arg)) || IS_NPC(vict)) {
    send_to_char(action->not_found, ch);
    return;
  } else if (vict == ch) {
    if(!action->others_auto || !*action->others_auto) {
      send_to_char(action->char_auto, ch);
      return;
    }
    sprintf(buf, "&W[GEMOTE]&w %s", action->others_auto);
  } else {
    if (GET_POS(vict) < action->min_victim_position)
      act("$N is not in a proper position for that.",
	  FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
    else {
      sprintf(buf, "&W[GEMOTE]&w %s", action->others_found);
    }
  }
  act(buf, FALSE, ch, 0, vict, TO_GMOTE);
}
::::::::::::::
act.wizard.c
::::::::::::::
/* ************************************************************************
*   File: act.wizard.c                                  Part of CircleMUD *
*  Usage: Player-level god commands and other goodies                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "house.h"
#include "screen.h"
#include "constants.h"
#include "olc.h"
#include "dg_scripts.h"
#include "teleport.h"

/*   external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct zone_data *zone_table;
extern struct attack_hit_type attack_hit_text[];
extern char *class_abbrevs[];
extern char *race_abbrevs[];
extern const char *dirs[];
extern time_t boot_time;
extern int top_of_zone_table;
extern int circle_shutdown, circle_reboot;
extern int circle_restrict;
extern int load_into_inventory;
extern int top_of_world;
extern int buf_switches, buf_largecount, buf_overflows;
extern int top_of_mobt;
extern int top_of_objt;
extern int top_of_p_table;
extern int free_rent;
extern struct player_index_element *player_table;
extern struct obj_data *obj_proto;
extern int top_of_objt;
extern struct char_data *mob_proto;

/* for chars */
extern const char *spells[];
extern const char *pc_class_types[];
extern const char *pc_race_types[];
extern const char *god_wiznames[];

/* extern functions */
int level_exp(int remort, int level);
void Read_Invalid_List(void);
void show_shops(struct char_data * ch, char *value);
void hcontrol_list_houses(struct char_data *ch);
void do_start(struct char_data *ch);
void appear(struct char_data *ch);
void reset_zone(int zone);
void roll_real_abils(struct char_data *ch);
int parse_class(char arg);
int parse_race(char arg);
char *add_points(int value);
void actualize_splskl(struct char_data *ch);
int breath_gain(struct char_data * ch);
struct char_data *find_char(int n);
void Crash_rentsave(struct char_data * ch, int cost);
void display_classes(struct descriptor_data *d);
int allow_class(struct char_data *ch, int i);
void perform_remove(struct char_data * ch, int pos);
void check_autowiz(struct char_data * ch);
void die_follower(struct char_data * ch);
extern int allowed_classes(int x, int i);
int real_zone(int number);
int find_name(char *name);
void write_aliases(struct char_data *ch);

/* local functions */
int perform_set(struct char_data *ch, struct char_data *vict, int mode, char *val_arg);
void perform_immort_invis(struct char_data *ch, int level);
ACMD(do_echo);
ACMD(do_send);
room_rnum find_target_room(struct char_data * ch, char *rawroomstr);
ACMD(do_at);
ACMD(do_goto);
ACMD(do_trans);
ACMD(do_teleport);
ACMD(do_vnum);
void do_stat_room(struct char_data * ch);
void do_stat_object(struct char_data * ch, struct obj_data * j);
void do_stat_character(struct char_data * ch, struct char_data * k);
ACMD(do_stat);
ACMD(do_shutdown);
void stop_snooping(struct char_data * ch);
ACMD(do_snoop);
ACMD(do_switch);
ACMD(do_return);
ACMD(do_load);
ACMD(do_vstat);
ACMD(do_purge);
ACMD(do_syslog);
ACMD(do_advance);
ACMD(do_restore);
void perform_immort_vis(struct char_data *ch);
ACMD(do_invis);
ACMD(do_gecho);
ACMD(do_poofset);
ACMD(do_dc);
ACMD(do_wizlock);
ACMD(do_date);
ACMD(do_last);
ACMD(do_force);
ACMD(do_wiznet);
ACMD(do_zreset);
ACMD(do_wizutil);
void print_zone_to_buf(char *bufptr, int zone);
ACMD(do_show);
ACMD(do_set);
ACMD(do_remort);
ACMD(do_chown);
ACMD(do_tedit);
void show_mreport(struct char_data *ch);
ACMD(do_playerlink);
ACMD(do_veq);

ACMD(do_echo)
{
  skip_spaces(&argument);

  if (IS_NPC(ch)) {
    send_to_char("You are a mob. Can not do this.\r\n", ch);
    return;
  }

  if (!*argument)
    send_to_char("Yes.. but what?\r\n", ch);
  else {
    if (subcmd == SCMD_EMOTE)
      sprintf(buf, "$n %s", argument);
    else
      strcpy(buf, argument);
    act(buf, FALSE, ch, 0, 0, TO_ROOM);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      act(buf, FALSE, ch, 0, 0, TO_CHAR);
  }
}


ACMD(do_send)
{
  struct char_data *vict;

  half_chop(argument, arg, buf);

  if (!*arg) {
    send_to_char("Send what to who?\r\n", ch);
    return;
  }
  if (!(vict = get_char_vis(ch, arg))) {
    send_to_char(NOPERSON, ch);
    return;
  }
  send_to_char(buf, vict);
  send_to_char("\r\n", vict);
  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char("Sent.\r\n", ch);
  else {
    sprintf(buf2, "You send '%s' to %s.\r\n", buf, GET_NAME(vict));
    send_to_char(buf2, ch);
  }
}



/* take a string, and return an rnum.. used for goto, at, etc.  -je 4/6/93 */
room_rnum find_target_room(struct char_data * ch, char *rawroomstr)
{
  int tmp;
  sh_int location;
  struct char_data *target_mob;
  struct obj_data *target_obj;
  char roomstr[MAX_INPUT_LENGTH];

  one_argument(rawroomstr, roomstr);

  if (!*roomstr) {
    send_to_char("You must supply a room number or name.\r\n", ch);
    return NOWHERE;
  }
  if (isdigit(*roomstr) && !strchr(roomstr, '.')) {
    tmp = atoi(roomstr);
    if ((location = real_room(tmp)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return NOWHERE;
    }
  } else if ((target_mob = get_char_vis(ch, roomstr)))
    location = target_mob->in_room;
  else if ((target_obj = get_obj_vis(ch, roomstr))) {
    if (target_obj->in_room != NOWHERE)
      location = target_obj->in_room;
    else {
      send_to_char("That object is not available.\r\n", ch);
      return NOWHERE;
    }
  } else {
    send_to_char("No such creature or object around.\r\n", ch);
    return NOWHERE;
  }

  /* a location has been found -- if you're < GRGOD, check restrictions. */
  if (GET_LEVEL(ch) < LVL_GRGOD) {
    if (ROOM_FLAGGED(location, ROOM_GODROOM)) {
      send_to_char("You are not godly enough to use that room!\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
        world[location].people && world[location].people->next_in_room) {
      send_to_char("There's a private conversation going on in that room.\r\n", ch);
      return NOWHERE;
    }
    if (ROOM_FLAGGED(location, ROOM_HOUSE) &&
        !House_can_enter(ch, GET_ROOM_VNUM(location))) {
      send_to_char("That's private property -- no trespassing!\r\n", ch);
      return NOWHERE;
    }
  }
  return location;
}



ACMD(do_at)
{
  char command[MAX_INPUT_LENGTH];
  int location, original_loc;

  half_chop(argument, buf, command);
  if (!*buf) {
    send_to_char("You must supply a room number or a name.\r\n", ch);
    return;
  }

  if (!*command) {
    send_to_char("What do you want to do there?\r\n", ch);
    return;
  }

  if ((location = find_target_room(ch, buf)) < 0)
    return;

  /* a location has been found. */
  original_loc = ch->in_room;
  char_from_room(ch);
  char_to_room(ch, location);
  command_interpreter(ch, command);

  /* check if the char is still there */
  if (ch->in_room == location) {
    char_from_room(ch);
    char_to_room(ch, original_loc);
  }
}


ACMD(do_goto)
{
  sh_int location;

  if ((location = find_target_room(ch, argument)) < 0)
    return;

  if (POOFOUT(ch))
    sprintf(buf, "$n %s", POOFOUT(ch));
  else
    strcpy(buf, "$n disappears in a puff of smoke.");

  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  char_from_room(ch);
  char_to_room(ch, location);

  if (POOFIN(ch))
    sprintf(buf, "$n %s", POOFIN(ch));
  else
    strcpy(buf, "$n appears with an ear-splitting bang.");

  act(buf, TRUE, ch, 0, 0, TO_ROOM);
  look_at_room(ch, 0);
}



ACMD(do_trans)
{
  struct descriptor_data *i;
  struct char_data *victim;

  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to transfer?\r\n", ch);
  else if (str_cmp("all", buf)) {
    if (!(victim = get_char_vis(ch, buf)))
      send_to_char(NOPERSON, ch);
    else if (victim == ch)
      send_to_char("That doesn't make much sense, does it?\r\n", ch);
    else {
      if ((GET_LEVEL(ch) < GET_LEVEL(victim)) && !IS_NPC(victim)) {
        send_to_char("Go transfer someone your own size.\r\n", ch);
        return;
      }
      act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
      char_from_room(victim);
      char_to_room(victim, ch->in_room);
      act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
      act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
      look_at_room(victim, 0);
    }
  } else {                      /* Trans All */
    if (GET_LEVEL(ch) < LVL_GRGOD) {
      send_to_char("I think not.\r\n", ch);
      return;
    }

    for (i = descriptor_list; i; i = i->next)
      if (STATE(i) == CON_PLAYING && i->character && i->character != ch) {
        victim = i->character;
        if (GET_LEVEL(victim) >= GET_LEVEL(ch))
          continue;
        act("$n disappears in a mushroom cloud.", FALSE, victim, 0, 0, TO_ROOM);
        char_from_room(victim);
        char_to_room(victim, ch->in_room);
        act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
        act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
        look_at_room(victim, 0);
      }
    send_to_char(OK, ch);
  }
}



ACMD(do_teleport)
{
  struct char_data *victim;
  sh_int target;

  two_arguments(argument, buf, buf2);

  if (!*buf)
    send_to_char("Whom do you wish to teleport?\r\n", ch);
  else if (!(victim = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else if (victim == ch)
    send_to_char("Use 'goto' to teleport yourself.\r\n", ch);
  else if (GET_LEVEL(victim) >= GET_LEVEL(ch))
    send_to_char("Maybe you shouldn't do that.\r\n", ch);
  else if (!*buf2)
    send_to_char("Where do you wish to send this person?\r\n", ch);
  else if ((target = find_target_room(ch, buf2)) >= 0) {
    send_to_char(OK, ch);
    act("$n disappears in a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    char_from_room(victim);
    char_to_room(victim, target);
    act("$n arrives from a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
    act("$n has teleported you!", FALSE, ch, 0, (char *) victim, TO_VICT);
    look_at_room(victim, 0);
  }
}



ACMD(do_vnum)
{
  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || (!is_abbrev(buf, "mob") && !is_abbrev(buf, "obj"))) {
    send_to_char("Usage: vnum { obj | mob } <name>\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob"))
    if (!vnum_mobile(buf2, ch))
      send_to_char("No mobiles by that name.\r\n", ch);

  if (is_abbrev(buf, "obj"))
    if (!vnum_object(buf2, ch))
      send_to_char("No objects by that name.\r\n", ch);
}



void do_stat_room(struct char_data * ch)
{
  struct extra_descr_data *desc;
  struct room_data *rm = &world[ch->in_room];
  int i, found = 0;
  struct obj_data *j = 0;
  struct char_data *k = 0;

  sprintf(buf, "Room name: %s%s%s\r\n", CCCYN(ch, C_NRM), rm->name,
          CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprinttype(rm->sector_type, sector_types, buf2);
  sprintf(buf, "Zone: [%3d], VNum: [%s%5d%s], RNum: [%5d], Type: %s\r\n",
          zone_table[rm->zone].number, CCGRN(ch, C_NRM), rm->number,
          CCNRM(ch, C_NRM), ch->in_room, buf2);
  send_to_char(buf, ch);

  sprintbit((long) rm->room_flags, room_bits, buf2);
  sprintf(buf, "SpecProc: %s, Flags: %s\r\n",
          (rm->func == NULL) ? "None" : "Exists", buf2);
  send_to_char(buf, ch);

  sprintbit((long) rm->room_affections, room_affections, buf2);
  sprintf(buf, "Room affections: %s\r\n", buf2);
  send_to_char(buf, ch);

  send_to_char("Description:\r\n", ch);
  if (rm->description)
    send_to_char(rm->description, ch);
  else
    send_to_char("  None.\r\n", ch);

  if (rm->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = rm->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
  sprintf(buf, "Chars present:%s", CCYEL(ch, C_NRM));
  for (found = 0, k = rm->people; k; k = k->next_in_room) {
    if (!CAN_SEE(ch, k))
      continue;
    sprintf(buf2, "%s %s(%s)", found++ ? "," : "", GET_NAME(k),
            (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (k->next_in_room)
        send_to_char(strcat(buf, ",\r\n"), ch);
      else
        send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }

  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);
  send_to_char(CCNRM(ch, C_NRM), ch);

  if (rm->contents) {
    sprintf(buf, "Contents:%s", CCGRN(ch, C_NRM));
    for (found = 0, j = rm->contents; j; j = j->next_content) {
      if (!CAN_SEE_OBJ(ch, j))
        continue;
      sprintf(buf2, "%s %s", found++ ? "," : "", j->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
        if (j->next_content)
          send_to_char(strcat(buf, ",\r\n"), ch);
        else
          send_to_char(strcat(buf, "\r\n"), ch);
        *buf = found = 0;
      }
    }

    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
  }

  if (rm->tele != NULL) {
        sprintf(buf, "Teleports every %d0 (current %d0) seconds to %20s (Room %d)\r\n",
                rm->tele->time, rm->tele->cnt,
                world[real_room(rm->tele->targ)].name,  rm->tele->targ);
        send_to_char(buf, ch);
        send_to_char("Teleport Flags   :", ch);
        sprintbit(rm->tele->mask, teleport_bits, buf);
        send_to_char(buf, ch);
        send_to_char("\r\n",ch);
        if (IS_SET(rm->tele->mask, TELE_OBJ) ||
            IS_SET(rm->tele->mask, TELE_NOOBJ)) {
          j = read_object(rm->tele->obj, VIRTUAL);
          sprintf(buf, "Teleport Object : %s\r\n", j->short_description);
          send_to_char(buf, ch);
          extract_obj(j);
        }
  }

  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (rm->dir_option[i]) {
      if (rm->dir_option[i]->to_room == NOWHERE)
        sprintf(buf1, " %sNONE%s", CCCYN(ch, C_NRM), CCNRM(ch, C_NRM));
      else
        sprintf(buf1, "%s%5d%s", CCCYN(ch, C_NRM),
                GET_ROOM_VNUM(rm->dir_option[i]->to_room), CCNRM(ch, C_NRM));
      sprintbit(rm->dir_option[i]->exit_info, exit_bits, buf2);
      sprintf(buf, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n ",
              CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, rm->dir_option[i]->key,
           rm->dir_option[i]->keyword ? rm->dir_option[i]->keyword : "None",
              buf2);
      send_to_char(buf, ch);
      if (rm->dir_option[i]->general_description)
        strcpy(buf, rm->dir_option[i]->general_description);
      else
        strcpy(buf, "  No exit description.\r\n");
      send_to_char(buf, ch);
    }
  }

  /* check the room for a script */
  do_sstat_room(ch);
}



void do_stat_object(struct char_data * ch, struct obj_data * j)
{
  int i, vnum, found;
  struct obj_data *j2;
  struct extra_descr_data *desc;
  int remort, level;

  vnum = GET_OBJ_VNUM(j);
  sprintf(buf, "Name: '%s%s%s', Aliases: %s\r\n", CCYEL(ch, C_NRM),
          ((j->short_description) ? j->short_description : "<None>"),
          CCNRM(ch, C_NRM), j->name);
  send_to_char(buf, ch);
  sprinttype(GET_OBJ_TYPE(j), item_types, buf1);
  if (GET_OBJ_RNUM(j) >= 0)
    strcpy(buf2, (obj_index[GET_OBJ_RNUM(j)].func ? "Exists" : "None"));
  else
    strcpy(buf2, "None");
  sprintf(buf, "VNum: [%s%5d%s], RNum: [%5d], Type: %s, SpecProc: %s\r\n",
   CCGRN(ch, C_NRM), vnum, CCNRM(ch, C_NRM), GET_OBJ_RNUM(j), buf1, buf2);
  send_to_char(buf, ch);
  sprintf(buf, "L-Des: %s\r\n", ((j->description) ? j->description : "None"));
  send_to_char(buf, ch);

  if (j->ex_description) {
    sprintf(buf, "Extra descs:%s", CCCYN(ch, C_NRM));
    for (desc = j->ex_description; desc; desc = desc->next) {
      strcat(buf, " ");
      strcat(buf, desc->keyword);
    }
    strcat(buf, CCNRM(ch, C_NRM));
    send_to_char(strcat(buf, "\r\n"), ch);
  }
  send_to_char("Can be worn on: ", ch);
  sprintbit(j->obj_flags.wear_flags, wear_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Set char bits : ", ch);
  sprintbit(j->obj_flags.bitvector, affected_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  send_to_char("Extra flags   : ", ch);
  sprintbit(GET_OBJ_EXTRA(j), extra_bits, buf);
  strcat(buf, "\r\n");
  send_to_char(buf, ch);


  level = (GET_OBJ_LEVEL(j)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(j)/(LVL_IMMORT - 1))));
    if ((level == 0) && (GET_OBJ_LEVEL(j) > 0)){
     level = (LVL_IMMORT - 1);
     remort = (GET_OBJ_LEVEL(j)/(LVL_IMMORT - 1)) - 1;
    }
    else{
       remort = (GET_OBJ_LEVEL(j)/(LVL_IMMORT - 1));
    }

  sprintf(buf, "Weight: %d, Value: %s, Cost/day: %d, Timer: %d, Min_Level: %d, Remorts: %d\r\n",
     GET_OBJ_WEIGHT(j), add_points(GET_OBJ_COST(j)), GET_OBJ_RENT(j), GET_OBJ_TIMER(j),
     level, remort);
  send_to_char(buf, ch);

  strcpy(buf, "In room: ");
  if (j->in_room == NOWHERE)
    strcat(buf, "Nowhere");
  else {
    sprintf(buf2, "%d", GET_ROOM_VNUM(IN_ROOM(j)));
    strcat(buf, buf2);
  }
  /*
   * NOTE: In order to make it this far, we must already be able to see the
   *       character holding the object. Therefore, we do not need CAN_SEE().
   */
  strcat(buf, ", In object: ");
  strcat(buf, j->in_obj ? j->in_obj->short_description : "None");
  strcat(buf, ", Carried by: ");
  strcat(buf, j->carried_by ? GET_NAME(j->carried_by) : "Nobody");
  strcat(buf, ", Worn by: ");
  strcat(buf, j->worn_by ? GET_NAME(j->worn_by) : "Nobody");
  strcat(buf, "\r\n");
  send_to_char(buf, ch);

  switch (GET_OBJ_TYPE(j)) {
  case ITEM_LIGHT:
    if (GET_OBJ_VAL(j, 2) == -1)
      strcpy(buf, "Hours left: Infinite");
    else
      sprintf(buf, "Hours left: [%d]", GET_OBJ_VAL(j, 2));
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    sprintf(buf, "Spells: (Level %d) %s, %s, %s", GET_OBJ_VAL(j, 0),
            skill_name(GET_OBJ_VAL(j, 1)), skill_name(GET_OBJ_VAL(j, 2)),
            skill_name(GET_OBJ_VAL(j, 3)));
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    sprintf(buf, "Spell: %s at level %d, %d (of %d) charges remaining",
            skill_name(GET_OBJ_VAL(j, 3)), GET_OBJ_VAL(j, 0),
            GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_WEAPON:
    sprintf(buf, "Todam: %dd%d (%.1f average), Message type: %d",
            GET_OBJ_VAL(j, 1), GET_OBJ_VAL(j, 2),
            ((GET_OBJ_VAL(j, 2) + 1) / 2.0) * GET_OBJ_VAL(j, 1),
            GET_OBJ_VAL(j, 3));
    break;
  case ITEM_ARMOR:
    sprintf(buf, "AC-apply: [%d]", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_TRAP:
    sprintf(buf, "Spell: %d, - Hitpoints: %d",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1));
    break;
  case ITEM_CONTAINER:
    sprintbit(GET_OBJ_VAL(j, 1), container_bits, buf2);
    sprintf(buf, "Weight capacity: %d, Lock Type: %s, Key Num: %d, Corpse: %s",
            GET_OBJ_VAL(j, 0), buf2, GET_OBJ_VAL(j, 2),
            YESNO(GET_OBJ_VAL(j, 3)));
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    sprinttype(GET_OBJ_VAL(j, 2), drinks, buf2);
    sprintf(buf, "Capacity: %d, Contains: %d, Poisoned: %s, Liquid: %s",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1), YESNO(GET_OBJ_VAL(j, 3)),
            buf2);
    break;
  case ITEM_NOTE:
    sprintf(buf, "Tongue: %d", GET_OBJ_VAL(j, 0));
    break;
  case ITEM_KEY:
    strcpy(buf, "");
    break;
  case ITEM_FOOD:
    sprintf(buf, "Makes full: %d, Poisoned: %s", GET_OBJ_VAL(j, 0),
            YESNO(GET_OBJ_VAL(j, 3)));
    break;
  case ITEM_MONEY:
    sprintf(buf, "Coins: %d", GET_OBJ_VAL(j, 0));
    break;
  default:
    sprintf(buf, "Values 0-3: [%d] [%d] [%d] [%d]",
            GET_OBJ_VAL(j, 0), GET_OBJ_VAL(j, 1),
            GET_OBJ_VAL(j, 2), GET_OBJ_VAL(j, 3));
    break;
  }
  send_to_char(strcat(buf, "\r\n"), ch);

  /*
   * I deleted the "equipment status" code from here because it seemed
   * more or less useless and just takes up valuable screen space.
   */

  if (j->contains) {
    sprintf(buf, "\r\nContents:%s", CCGRN(ch, C_NRM));
    for (found = 0, j2 = j->contains; j2; j2 = j2->next_content) {
      sprintf(buf2, "%s %s", found++ ? "," : "", j2->short_description);
      strcat(buf, buf2);
      if (strlen(buf) >= 62) {
        if (j2->next_content)
          send_to_char(strcat(buf, ",\r\n"), ch);
        else
          send_to_char(strcat(buf, "\r\n"), ch);
        *buf = found = 0;
      }
    }

    if (*buf)
      send_to_char(strcat(buf, "\r\n"), ch);
    send_to_char(CCNRM(ch, C_NRM), ch);
  }
  found = 0;
  send_to_char("Affections:", ch);
  for (i = 0; i < MAX_OBJ_AFFECT; i++)
    if (j->affected[i].modifier) {
      sprinttype(j->affected[i].location, apply_types, buf2);
      sprintf(buf, "%s %+d to %s", found++ ? "," : "",
              j->affected[i].modifier, buf2);
      send_to_char(buf, ch);
    }
  if (!found)
    send_to_char(" None", ch);

  send_to_char("\r\n", ch);

  /* check the object for a script */
  do_sstat_object(ch, j);
}


void do_stat_character(struct char_data * ch, struct char_data * k)
{
  int i, i2, found = 0;
  struct obj_data *j;
  struct follow_type *fol;
  struct affected_type *aff;

  switch (GET_SEX(k)) {
  case SEX_NEUTRAL:    strcpy(buf, "NEUTRAL-SEX");   break;
  case SEX_MALE:       strcpy(buf, "MALE");          break;
  case SEX_FEMALE:     strcpy(buf, "FEMALE");        break;
  default:             strcpy(buf, "ILLEGAL-SEX!!"); break;
  }

  sprintf(buf2, " %s '%s'  IDNum: [%s], In room [%5d] House [%d]\r\n",
          (!IS_NPC(k) ? "PC" : (!IS_MOB(k) ? "NPC" : "MOB")),
          GET_NAME(k), add_points(GET_IDNUM(k)), GET_ROOM_VNUM(IN_ROOM(k)), HOUSE(k));
  send_to_char(strcat(buf, buf2), ch);
  if (IS_MOB(k)) {
    sprintf(buf, "Alias: %s, VNum: [%5d], RNum: [%5d]\r\n",
            k->player.name, GET_MOB_VNUM(k), GET_MOB_RNUM(k));
    send_to_char(buf, ch);
  }
  sprintf(buf, "Title: &n%s&n\r\n", (k->player.title ? k->player.title : "<None>"));
  send_to_char(buf, ch);

  sprintf(buf, "L-Des: %s", (k->player.long_descr ? k->player.long_descr : "<None>\r\n"));
  send_to_char(buf, ch);

  if (!IS_NPC(k)) {      /* Use GET_CLASS() macro? */
    sprintf(buf, "The race is %s with class %s.\r\n", pc_race_types[(int) GET_RACE(k)], pc_class_types[(int) GET_CLASS(k)]);
  } else {
    sprintf(buf, "The monster race is %s with class %s.\r\n", race_types[(int)(GET_RACE(k) + 1)],  class_types[(int)(GET_CLASS(k) + 1)]);
  }
  send_to_char(buf, ch);

  sprintf(buf, "Lev: [%s%3d%s], XP: [%s%d%s], Align: [%s%d%s], Points: [%s%d%s], QP: [%s%d%s], R: [%s%d%s]\r\n",
          CCYEL(ch, C_NRM), GET_LEVEL(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_EXP(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_ALIGNMENT(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_POINTS(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_QP(k), CCNRM(ch, C_NRM),
          CCYEL(ch, C_NRM), GET_REMORT(k), CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  if (!IS_NPC(k)) {
    strcpy(buf1, (char *) asctime(localtime(&(k->player.time.birth))));
    strcpy(buf2, (char *) asctime(localtime(&(k->player.time.logon))));
    buf1[10] = buf2[10] = '\0';

    sprintf(buf, "Created: [%s], Last Logon: [%s], Played [%dh %dm], Age [%d]\r\n",
            buf1, buf2, k->player.time.played / 3600,
            ((k->player.time.played % 3600) / 60), age(k)->year);
    send_to_char(buf, ch);

    sprintf(buf, "Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])",
         k->player.hometown, GET_TALK(k, 0), GET_TALK(k, 1), GET_TALK(k, 2),
            GET_PRACTICES(k), int_app[GET_INT(k)].learn,
            wis_app[GET_WIS(k)].bonus);

    sprintf(buf+strlen(buf), ", OLC[%d]", GET_OLC_ZONE(k));
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }
  sprintf(buf, "Str: [%s%d/%d%s]  Int: [%s%d%s]  Wis: [%s%d%s]  "
          "Dex: [%s%d%s]  Con: [%s%d%s]  Cha: [%s%d%s]  Luck:[%s%d%s]\r\n",
          CCCYN(ch, C_NRM), GET_STR(k), GET_ADD(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_INT(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_WIS(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_DEX(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_CON(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_CHA(k), CCNRM(ch, C_NRM),
          CCCYN(ch, C_NRM), GET_LUK(k), CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprintf(buf, "Hit p.:[%s%d/%d+%d%s]  Mana p.:[%s%d/%d+%d%s]  Move p.:[%s%d/%d+%d%s]\r\nBreath: [%s%d/%d+%d%s]  Mental:[%s%d/%d%s]\r\n",
          CCGRN(ch, C_NRM), GET_HIT(k), GET_MAX_HIT(k), hit_gain(k), CCNRM(ch, C_NRM),
          CCGRN(ch, C_NRM), GET_MANA(k), GET_MAX_MANA(k), mana_gain(k), CCNRM(ch, C_NRM),
          CCGRN(ch, C_NRM), GET_MOVE(k), GET_MAX_MOVE(k), move_gain(k), CCNRM(ch, C_NRM),
          CCGRN(ch, C_NRM), GET_OXI(k), GET_MAX_OXI(k), breath_gain(k), CCNRM(ch, C_NRM),
          CCGRN(ch, C_NRM), GET_MENTAL(k), GET_MAX_MENTAL(k), CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  /* check mobiles for a script */
  if (IS_NPC(k)) {
    do_sstat_character(ch, k);
    if (SCRIPT_MEM(k)) {
      struct script_memory *mem = SCRIPT_MEM(k);
      send_to_char("Script memory:\r\n  Remember             Command\r\n", ch);
      while (mem) {
        struct char_data *mc = find_char(mem->id);
        if (!mc) send_to_char("  ** Corrupted!\r\n", ch);
        else {
          if (mem->cmd) sprintf(buf,"  %-20.20s%s\r\n",GET_NAME(mc),mem->cmd);
          else sprintf(buf,"  %-20.20s <default>\r\n",GET_NAME(mc));
          send_to_char(buf, ch);
        }
      mem = mem->next;
      }
    }
  }

  sprintf(buf, "Coins: [%d], Bank: [%d] (Total: %s)\r\n",
          GET_GOLD(k), GET_BANK_GOLD(k), add_points(GET_GOLD(k) + GET_BANK_GOLD(k)));
  send_to_char(buf, ch);

  if(!IS_NPC(k)){
    sprintf(buf, "Clan: [%d], Rank: [%d]\r\n",
          GET_CLAN(k), GET_CLAN_POS(k));
    send_to_char(buf, ch);
  }
  sprintf(buf, "AC: [%d/10], Hitroll: [%4d], Damroll: [%4d], Saving throws: [%d/%d/%d/%d/%d]\r\n",
          GET_AC(k), k->points.hitroll, k->points.damroll, GET_SAVE(k, 0),
          GET_SAVE(k, 1), GET_SAVE(k, 2), GET_SAVE(k, 3), GET_SAVE(k, 4));
  send_to_char(buf, ch);

  if(!IS_NPC(k)){
    sprintf(buf, "Actual Quest: [%5d]\r\n", GET_QUEST(k));
    send_to_char(buf, ch);
  }

  sprinttype(GET_POS(k), position_types, buf2);
  sprintf(buf, "Pos: %s, Fighting: %s", buf2,
          (FIGHTING(k) ? GET_NAME(FIGHTING(k)) : "Nobody"));

  if (IS_NPC(k)) {
    strcat(buf, ", Attack type: ");
    strcat(buf, attack_hit_text[k->mob_specials.attack_type].singular);
  }
  if (k->desc) {
    sprinttype(STATE(k->desc), connected_types, buf2);
    strcat(buf, ", Connected: ");
    strcat(buf, buf2);
  }
  send_to_char(strcat(buf, "\r\n"), ch);

  strcpy(buf, "Default position: ");
  sprinttype((k->mob_specials.default_pos), position_types, buf2);
  strcat(buf, buf2);

  sprintf(buf2, ", Idle Timer (in tics) [%d]\r\n", k->char_specials.timer);
  strcat(buf, buf2);
  send_to_char(buf, ch);

  if (IS_NPC(k)) {
    sprintbit(MOB_FLAGS(k), action_bits, buf2);
    sprintf(buf, "NPC flags: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
  } else {
    sprintbit(PLR_FLAGS(k), player_bits, buf2);
    sprintf(buf, "PLR: %s%s%s\r\n", CCCYN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
    sprintbit(PRF_FLAGS(k), preference_bits, buf2);
    sprintf(buf, "PRF: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
    sprintbit(PRF2_FLAGS(k), preference2_bits, buf2);
    sprintf(buf, "PRF2: %s%s%s\r\n", CCGRN(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
    send_to_char(buf, ch);
  }

  if (IS_MOB(k)) {
    sprintf(buf, "Mob Spec-Proc: %s, NPC Bare Hand Dam: %dd%d\r\n",
            (mob_index[GET_MOB_RNUM(k)].func ? "Exists" : "None"),
            k->mob_specials.damnodice, k->mob_specials.damsizedice);
    send_to_char(buf, ch);
  }
  sprintf(buf, "Carried: weight: %d, items: %d; ",
          IS_CARRYING_W(k), IS_CARRYING_N(k));

  for (i = 0, j = k->carrying; j; j = j->next_content, i++);
  sprintf(buf + strlen(buf), "Items in: inventory: %d, ", i);

  for (i = 0, i2 = 0; i < NUM_WEARS; i++)
    if (GET_EQ(k, i))
      i2++;
  sprintf(buf2, "eq: %d\r\n", i2);
  strcat(buf, buf2);
  send_to_char(buf, ch);

  if (!IS_NPC(k)) {
    sprintf(buf, "Hunger: %d, Thirst: %d, Drunk: %d\r\n",
          GET_COND(k, FULL), GET_COND(k, THIRST), GET_COND(k, DRUNK));
    send_to_char(buf, ch);
  }

  sprintf(buf, "Master is: %s, Followers are:",
          ((k->master) ? GET_NAME(k->master) : "<none>"));

  for (fol = k->followers; fol; fol = fol->next) {
    sprintf(buf2, "%s %s", found++ ? "," : "", PERS(fol->follower, ch));
    strcat(buf, buf2);
    if (strlen(buf) >= 62) {
      if (fol->next)
        send_to_char(strcat(buf, ",\r\n"), ch);
      else
        send_to_char(strcat(buf, "\r\n"), ch);
      *buf = found = 0;
    }
  }

  if (*buf)
    send_to_char(strcat(buf, "\r\n"), ch);

  /* Showing the bitvector */
  sprintbit(AFF_FLAGS(k), affected_bits, buf2);
  sprintf(buf, "AFF: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprintbit(AFF2_FLAGS(k), affected2_bits, buf2);
  sprintf(buf, "AFF2: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  sprintbit(AFF3_FLAGS(k), affected3_bits, buf2);
  sprintf(buf, "AFF3: %s%s%s\r\n", CCYEL(ch, C_NRM), buf2, CCNRM(ch, C_NRM));
  send_to_char(buf, ch);

  /* Routine to show what spells a char is affected by */
  if (k->affected) {
    for (aff = k->affected; aff; aff = aff->next) {
      *buf2 = '\0';
        sprintf(buf, "SPL: (%3dhr) %s%-21s%s ", aff->duration + 1,
              CCCYN(ch, C_NRM), spells[aff->type], CCNRM(ch, C_NRM));

      if (aff->modifier) {
        sprintf(buf2, "%+d to %s", aff->modifier, apply_types[(int) aff->location]);
        strcat(buf, buf2);
      }
      if (aff->bitvector) {
        if (*buf2)
          strcat(buf, ", sets ");
        else
          strcat(buf, "sets ");
        sprintbit(aff->bitvector, affected_bits, buf2);
        strcat(buf, buf2);
      }
      if (aff->bitvector2) {
        if (*buf2)
          strcat(buf, ", sets ");
        else
          strcat(buf, "sets ");
        sprintbit(aff->bitvector2, affected2_bits, buf2);
        strcat(buf, buf2);
      }
      if (aff->bitvector3) {
        if (*buf2)
          strcat(buf, ", sets ");
        else
          strcat(buf, "sets ");
        sprintbit(aff->bitvector3, affected3_bits, buf2);
        strcat(buf, buf2);
      }
      send_to_char(strcat(buf, "\r\n"), ch);
    }
  }
}


ACMD(do_stat)
{
  struct char_data *victim = 0;
  struct obj_data *object = 0;
  int tmp;

  half_chop(argument, buf1, buf2);

  if (!*buf1) {
    do_stat_character(ch, ch);
    return;
  } else if (is_abbrev(buf1, "room")) {
    do_stat_room(ch);
  } else if (is_abbrev(buf1, "mob")) {
    if (!*buf2)
      send_to_char("Stats on which mobile?\r\n", ch);
    else {
      if ((victim = get_char_vis(ch, buf2)))
        do_stat_character(ch, victim);
      else
        send_to_char("No such mobile around.\r\n", ch);
    }
  } else if (is_abbrev(buf1, "player")) {
    if (!*buf2) {
      send_to_char("Stats on which player?\r\n", ch);
    } else {
      if ((victim = get_player_vis(ch, buf2, 0)))
        do_stat_character(ch, victim);
      else
        send_to_char("No such player around.\r\n", ch);
    }
  } else if (is_abbrev(buf1, "file")) {
    if (!*buf2) {
      send_to_char("Stats on which player?\r\n", ch);
    } else {
      CREATE(victim, struct char_data, 1);
      clear_char(victim);
      CREATE(victim->player_specials, struct player_special_data, 1);
      if (load_char(buf2, victim) > -1) {
        char_to_room(victim, 0);
        if (GET_LEVEL(victim) > GET_LEVEL(ch))
          send_to_char("Sorry, you can't do that.\r\n", ch);
        else
          do_stat_character(ch, victim);
        extract_char(victim);
      } else {
        send_to_char("There is no such player.\r\n", ch);
        free_char(victim);
      }
    }
  } else if (is_abbrev(buf1, "object")) {
    if (!*buf2)
      send_to_char("Stats on which object?\r\n", ch);
    else {
      if ((object = get_obj_vis(ch, buf2)))
        do_stat_object(ch, object);
      else
        send_to_char("No such object around.\r\n", ch);
    }
  } else {
    if ((object = get_object_in_equip_vis(ch, buf1, ch->equipment, &tmp)))
      do_stat_object(ch, object);
    else if ((object = get_obj_in_list_vis(ch, buf1, ch->carrying)))
      do_stat_object(ch, object);
    else if ((victim = get_char_room_vis(ch, buf1)))
      do_stat_character(ch, victim);
    else if ((object = get_obj_in_list_vis(ch, buf1, world[ch->in_room].contents)))
      do_stat_object(ch, object);
    else if ((victim = get_char_vis(ch, buf1)))
      do_stat_character(ch, victim);
    else if ((object = get_obj_vis(ch, buf1)))
      do_stat_object(ch, object);
    else
      send_to_char("Nothing around by that name.\r\n", ch);
  }
}


ACMD(do_shutdown)
{
  if (subcmd != SCMD_SHUTDOWN) {
    send_to_char("If you want to shut something down, say so!\r\n", ch);
    return;
  }
  one_argument(argument, arg);

  if (!*arg) {
    log("(GC) Shutdown by %s.", GET_NAME(ch));
    send_to_all("Shutting down.\r\n");
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "reboot")) {
    log("(GC) Reboot by %s.", GET_NAME(ch));
    send_to_all("Rebooting.. come back in a minute or two.\r\n");
    touch(FASTBOOT_FILE);
    circle_shutdown = circle_reboot = 1;
  } else if (!str_cmp(arg, "now")) {
    sprintf(buf, "(GC) Shutdown NOW by %s.", GET_NAME(ch));
    log(buf);
    send_to_all("Rebooting.. come back in a minute or two.\r\n");
    circle_shutdown = 1;
    circle_reboot = 2;
  } else if (!str_cmp(arg, "die")) {
    log("(GC) Shutdown by %s.", GET_NAME(ch));
    send_to_all("Shutting down for maintenance.\r\n");
    touch(KILLSCRIPT_FILE);
    circle_shutdown = 1;
  } else if (!str_cmp(arg, "pause")) {
    log("(GC) Shutdown by %s.", GET_NAME(ch));
    send_to_all("Shutting down for maintenance.\r\n");
    touch(PAUSE_FILE);
    circle_shutdown = 1;
  } else
    send_to_char("Unknown shutdown option.\r\n", ch);
}


void stop_snooping(struct char_data * ch)
{
  if (!ch->desc->snooping)
    send_to_char("You aren't snooping anyone.\r\n", ch);
  else {
    send_to_char("You stop snooping.\r\n", ch);
    ch->desc->snooping->snoop_by = NULL;
    ch->desc->snooping = NULL;
  }
}


ACMD(do_snoop)
{
  struct char_data *victim, *tch;

  if (!ch->desc)
    return;

  one_argument(argument, arg);

  if (!*arg)
    stop_snooping(ch);
  else if (!(victim = get_char_vis(ch, arg)))
    send_to_char("No such person around.\r\n", ch);
  else if (!victim->desc)
    send_to_char("There's no link.. nothing to snoop.\r\n", ch);
  else if (victim == ch)
    stop_snooping(ch);
  else if (victim->desc->snoop_by)
    send_to_char("Busy already. \r\n", ch);
  else if (victim->desc->snooping == ch->desc)
    send_to_char("Don't be stupid.\r\n", ch);
  else {
    if (victim->desc->original)
      tch = victim->desc->original;
    else
      tch = victim;

    if (GET_LEVEL(tch) >= GET_LEVEL(ch)) {
      send_to_char("You can't.\r\n", ch);
      return;
    }
    send_to_char(OK, ch);

    if (ch->desc->snooping)
      ch->desc->snooping->snoop_by = NULL;

    ch->desc->snooping = victim->desc;
    victim->desc->snoop_by = ch->desc;
  }
}



ACMD(do_switch)
{
  struct char_data *victim;

  one_argument(argument, arg);

  if (ch->desc->original)
    send_to_char("You're already switched.\r\n", ch);
  else if (!*arg)
    send_to_char("Switch with who?\r\n", ch);
  else if (!(victim = get_char_vis(ch, arg)))
    send_to_char("No such character.\r\n", ch);
  else if (ch == victim)
    send_to_char("Hee hee... we are jolly funny today, eh?\r\n", ch);
  else if (victim->desc)
    send_to_char("You can't do that, the body is already in use!\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_SUBIMPL) && !IS_NPC(victim))
    send_to_char("You aren't holy enough to use a mortal's body.\r\n", ch);
  else {
    send_to_char(OK, ch);

    ch->desc->character = victim;
    ch->desc->original = ch;

    victim->desc = ch->desc;
    ch->desc = NULL;
  }
}


ACMD(do_return)
{
  if (ch->desc && ch->desc->original) {
    send_to_char("You return to your original body.\r\n", ch);

    /* JE 2/22/95 */
    /* if someone switched into your original body, disconnect them */
    if (ch->desc->original->desc)
      STATE(ch->desc->original->desc) = CON_DISCONNECT;

    ch->desc->character = ch->desc->original;
    ch->desc->original = NULL;

    ch->desc->character->desc = ch->desc;
    ch->desc = NULL;
  }
}

#define LOAD_USAGE "Usage: load { obj | mob } <vnum>\r\n"

ACMD(do_load)
{
  struct char_data *mob;
  struct obj_data *obj;
  int number, r_num;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 /*|| !isdigit(*buf2)*/) {
    send_to_char(LOAD_USAGE, ch);
    return;
  }
  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if (!isdigit(*buf2)) {
      send_to_char(LOAD_USAGE , ch);
      return;
    }
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, ch->in_room);

    act("$n makes a quaint, magical gesture with one hand.", TRUE, ch,
        0, 0, TO_ROOM);
    act("$n has created $N!", FALSE, ch, 0, mob, TO_ROOM);
    act("You create $N.", FALSE, ch, 0, mob, TO_CHAR);
    sprintf(buf, "(GC) %s loads mob \"%s\" (%d)", GET_NAME(ch), GET_NAME(mob), number);
    mudlog(buf, BRF, LVL_GOD, TRUE);
    load_mtrigger(mob);
  }
  else if (is_abbrev(buf, "obj")) {
    if (!isdigit(*buf2)) {
      send_to_char(LOAD_USAGE , ch);
      return;
    }
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    if (load_into_inventory)
      obj_to_char(obj, ch);
    else
      obj_to_room(obj, ch->in_room);
    act("$n makes a strange magical gesture.", TRUE, ch, 0, 0, TO_ROOM);
    act("$n has created $p!", FALSE, ch, obj, 0, TO_ROOM);
    act("You create $p.", FALSE, ch, obj, 0, TO_CHAR);
    sprintf(buf, "(GC) %s loads obj \"%s\" (%d)", GET_NAME(ch), obj->short_description, number);
    mudlog(buf, BRF, LVL_GOD, TRUE);
    load_otrigger(obj);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}



ACMD(do_vstat)
{
  struct char_data *mob;
  struct obj_data *obj;
  int number, r_num;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2 || !isdigit(*buf2)) {
    send_to_char("Usage: vstat { obj | mob } <number>\r\n", ch);
    return;
  }
  if ((number = atoi(buf2)) < 0) {
    send_to_char("A NEGATIVE number??\r\n", ch);
    return;
  }
  if (is_abbrev(buf, "mob")) {
    if ((r_num = real_mobile(number)) < 0) {
      send_to_char("There is no monster with that number.\r\n", ch);
      return;
    }
    mob = read_mobile(r_num, REAL);
    char_to_room(mob, 0);
    do_stat_character(ch, mob);
    extract_char(mob);
  } else if (is_abbrev(buf, "obj")) {
    if ((r_num = real_object(number)) < 0) {
      send_to_char("There is no object with that number.\r\n", ch);
      return;
    }
    obj = read_object(r_num, REAL);
    do_stat_object(ch, obj);
    extract_obj(obj);
  } else
    send_to_char("That'll have to be either 'obj' or 'mob'.\r\n", ch);
}




/* clean a room of all mobiles and objects */
ACMD(do_purge)
{
  struct char_data *vict, *next_v;
  struct obj_data *obj, *next_o;

  one_argument(argument, buf);

  if (*buf) {                   /* argument supplied. destroy single object
                                 * or char */
    if ((vict = get_char_room_vis(ch, buf))) {
      if (!IS_NPC(vict) && (GET_LEVEL(ch) <= GET_LEVEL(vict))) {
        send_to_char("Fuuuuuuuuu!\r\n", ch);
        return;
      }
      act("$n disintegrates $N.", FALSE, ch, 0, vict, TO_NOTVICT);

      if (!IS_NPC(vict)) {
        sprintf(buf, "(GC) %s has purged %s.", GET_NAME(ch), GET_NAME(vict));
        mudlog(buf, BRF, LVL_GOD, TRUE);
        if (vict->desc) {
          STATE(vict->desc) = CON_CLOSE;
          vict->desc->character = NULL;
          vict->desc = NULL;
        }
      }
      extract_char(vict);
    } else if ((obj = get_obj_in_list_vis(ch, buf, world[ch->in_room].contents))) {
      act("$n destroys $p.", FALSE, ch, obj, 0, TO_ROOM);
      extract_obj(obj);
    } else {
      send_to_char("Nothing here by that name.\r\n", ch);
      return;
    }

    send_to_char(OK, ch);
  } else {                      /* no argument. clean out the room */
    act("$n gestures... You are surrounded by scorching flames!",
        FALSE, ch, 0, 0, TO_ROOM);
    send_to_room("The world seems a little cleaner.\r\n", ch->in_room);

    for (vict = world[ch->in_room].people; vict; vict = next_v) {
      next_v = vict->next_in_room;
      if (IS_NPC(vict))
        extract_char(vict);
    }

    for (obj = world[ch->in_room].contents; obj; obj = next_o) {
      next_o = obj->next_content;
      extract_obj(obj);
    }
  }
}



const char *logtypes[] = {
  "off", "brief", "normal", "complete", "\n"
};

ACMD(do_syslog)
{
  int tp;

  one_argument(argument, arg);

  if (!*arg) {
    tp = ((PRF_FLAGGED(ch, PRF_LOG1) ? 1 : 0) +
          (PRF_FLAGGED(ch, PRF_LOG2) ? 2 : 0));
    sprintf(buf, "Your syslog is currently %s.\r\n", logtypes[tp]);
    send_to_char(buf, ch);
    return;
  }
  if (((tp = search_block(arg, logtypes, FALSE)) == -1)) {
    send_to_char("Usage: syslog { Off | Brief | Normal | Complete }\r\n", ch);
    return;
  }
  REMOVE_BIT(PRF_FLAGS(ch), PRF_LOG1 | PRF_LOG2);
  SET_BIT(PRF_FLAGS(ch), (PRF_LOG1 * (tp & 1)) | (PRF_LOG2 * (tp & 2) >> 1));

  sprintf(buf, "Your syslog is now %s.\r\n", logtypes[tp]);
  send_to_char(buf, ch);
}


ACMD(do_advance)
{
  struct char_data *victim;
  char *name = arg, *level = buf2;
  int newlevel, oldlevel;

  two_arguments(argument, name, level);

  if (*name) {
    if (!(victim = get_char_vis(ch, name))) {
      send_to_char("That player is not here.\r\n", ch);
      return;
    }
  } else {
    send_to_char("Advance who?\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) <= GET_LEVEL(victim)) {
    send_to_char("Maybe that's not such a great idea.\r\n", ch);
    return;
  }
  if (IS_NPC(victim)) {
    send_to_char("NO!  Not on NPC's.\r\n", ch);
    return;
  }
  if (!*level || (newlevel = atoi(level)) <= 0) {
    send_to_char("That's not a level!\r\n", ch);
    return;
  }
  if (newlevel > LVL_IMPL) {
    sprintf(buf, "%d is the highest possible level.\r\n", LVL_IMPL);
    send_to_char(buf, ch);
    return;
  }
  if (newlevel > GET_LEVEL(ch)) {
    send_to_char("Yeah, right.\r\n", ch);
    return;
  }
  if (newlevel == GET_LEVEL(victim)) {
    send_to_char("They are already at that level.\r\n", ch);
    return;
  }
  oldlevel = GET_LEVEL(victim);

  if (newlevel < GET_LEVEL(victim)) {
    do_start(victim);
    GET_LEVEL(victim) = newlevel;
    send_to_char("You are momentarily enveloped by darkness!\r\n"
		 "You feel somewhat diminished.\r\n", victim);
    GET_EXP(victim) = 0;
  } else {
    act("$n makes some strange gestures.\r\n"
	"A strange feeling comes upon you,\r\n"
	"Like a giant hand, light comes down\r\n"
	"from above, grabbing your body, that\r\n"
	"begins to pulse with colored lights\r\n"
	"from inside.\r\n\r\n"
	"Your head seems to be filled with demons\r\n"
	"from another plane as your body dissolves\r\n"
	"to the elements of time and space itself.\r\n"
	"Suddenly a silent explosion of light\r\n"
	"snaps you back to reality.\r\n\r\n"
	"You feel slightly different.", FALSE, ch, 0, victim, TO_VICT);
  }

  send_to_char(OK, ch);

  if (newlevel < oldlevel) {
    log("(GC) %s demoted %s from level %d to %d.",
		GET_NAME(ch), GET_NAME(victim), oldlevel, newlevel);
  } else {
    log("(GC) %s has advanced %s to level %d (from %d)",
		GET_NAME(ch), GET_NAME(victim), newlevel, oldlevel);
    gain_exp_regardless(victim, (newlevel - oldlevel));
  }
  save_char(victim, NOWHERE);
}


ACMD(do_restore)
{
  struct descriptor_data *pt;
  struct char_data *vict;
  int i;
  bool found = FALSE;

  one_argument(argument, buf);
  if (!*buf)
    send_to_char("Whom do you wish to restore?\r\n", ch);
  else if (!strcmp(buf, "all")) {
    send_to_char("You restore", ch);
    for (pt = descriptor_list; pt; pt = pt->next)
      if (!pt->connected && pt->character && pt->character != ch) {
        vict = pt->character;
        GET_HIT(vict) = GET_MAX_HIT(vict);
        GET_MANA(vict) = GET_MAX_MANA(vict);
        GET_MOVE(vict) = GET_MAX_MOVE(vict);
	GET_MENTAL(vict) = GET_MAX_MENTAL(vict);
	GET_OXI(vict) = GET_MAX_OXI(vict);
        update_pos(vict);
        act("$N makes strange gestures and restores your life!", FALSE, vict, 0, ch, TO_CHAR);
        sprintf(buf, "%s %s", (found?",":""), GET_NAME(vict));
        if (!found)
          found = TRUE;
        send_to_char(buf, ch);
      }
    if (!found) send_to_char(" nobody", ch);
    send_to_char(".\r\n", ch);
  }
  else if (!(vict = get_char_vis(ch, buf)))
    send_to_char(NOPERSON, ch);
  else {
    GET_HIT(vict) = GET_MAX_HIT(vict);
    GET_MANA(vict) = GET_MAX_MANA(vict);
    GET_MOVE(vict) = GET_MAX_MOVE(vict);
    GET_MENTAL(vict) = GET_MAX_MENTAL(vict);
    GET_OXI(vict) = GET_MAX_OXI(vict);
    if (!IS_NPC(vict) && (GET_LEVEL(ch) >= LVL_GRGOD) && (GET_LEVEL(vict) >= LVL_ELDER)) {
      for (i = 1; i <= MAX_SKILLS; i++)
        SET_SKILL(vict, i, 100);

      if (GET_LEVEL(vict) >= LVL_GRGOD) {
        vict->real_abils.str_add = 100;
        vict->real_abils.intel = 25;
        vict->real_abils.wis = 25;
        vict->real_abils.dex = 25;
        vict->real_abils.str = 25;
        vict->real_abils.con = 25;
        vict->real_abils.cha = 25;
      }
      vict->aff_abils = vict->real_abils;
    }
    update_pos(vict);
    send_to_char(OK, ch);
    act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
  }
}


void perform_immort_vis(struct char_data *ch)
{
  if (GET_INVIS_LEV(ch) == 0 && !AFF_FLAGGED(ch, AFF_HIDE | AFF_INVISIBLE)) {
    send_to_char("You are already fully visible.\r\n", ch);
    return;
  }

  GET_INVIS_LEV(ch) = 0;
  appear(ch);
  send_to_char("You are now fully visible.\r\n", ch);
}


void perform_immort_invis(struct char_data *ch, int level)
{
  struct char_data *tch;

  if (IS_NPC(ch))
    return;

  GET_INVIS_LEV(ch) = level;
  sprintf(buf, "Your invisibility level is %d.\r\n", level);
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (tch == ch)
      continue;
    if (GET_LEVEL(tch) >= GET_INVIS_LEV(ch) && GET_LEVEL(tch) < level)
      act("You blink and suddenly realize that $n is gone.", FALSE, ch, 0,
          tch, TO_VICT);
    if (GET_LEVEL(tch) < GET_INVIS_LEV(ch) && GET_LEVEL(tch) >= level)
      act("You suddenly realize that $n is standing beside you.", FALSE, ch, 0,
          tch, TO_VICT);
  }

  send_to_char(buf, ch);
}


ACMD(do_invis)
{
  int level;

  if (IS_NPC(ch)) {
    send_to_char("You can't do that!\r\n", ch);
    return;
  }

  one_argument(argument, arg);
  if (!*arg) {
    if (GET_INVIS_LEV(ch) > 0)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, GET_LEVEL(ch));
  } else {
    level = atoi(arg);
    if (level > GET_LEVEL(ch))
      send_to_char("You can't go invisible above your own level.\r\n", ch);
    else if (level < 1)
      perform_immort_vis(ch);
    else
      perform_immort_invis(ch, level);
  }
}


ACMD(do_gecho)
{
  struct descriptor_data *pt;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument)
    send_to_char("That must be a mistake...\r\n", ch);
  else {
    sprintf(buf, "%s\r\n", argument);
    for (pt = descriptor_list; pt; pt = pt->next)
      if (STATE(pt) == CON_PLAYING && pt->character && pt->character != ch)
        send_to_char(buf, pt->character);
    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
      send_to_char(OK, ch);
    else
      send_to_char(buf, ch);
  }
}


ACMD(do_poofset)
{
  char **msg;

  switch (subcmd) {
  case SCMD_POOFIN:    msg = &(POOFIN(ch));    break;
  case SCMD_POOFOUT:   msg = &(POOFOUT(ch));   break;
  default:    return;
  }

  skip_spaces(&argument);

  if (*msg)
    free(*msg);

  if (!*argument)
    *msg = NULL;
  else
    *msg = str_dup(argument);

  send_to_char(OK, ch);
}



ACMD(do_dc)
{
  struct descriptor_data *d;
  int num_to_dc;

  one_argument(argument, arg);
  if (!(num_to_dc = atoi(arg))) {
    send_to_char("Usage: DC <user number> (type USERS for a list)\r\n", ch);
    return;
  }
  for (d = descriptor_list; d && d->desc_num != num_to_dc; d = d->next);

  if (!d) {
    send_to_char("No such connection.\r\n", ch);
    return;
  }
  if (d->character && GET_LEVEL(d->character) >= GET_LEVEL(ch)) {
    if (!CAN_SEE(ch, d->character))
      send_to_char("No such connection.\r\n", ch);
    else
      send_to_char("Umm.. maybe that's not such a good idea...\r\n", ch);
    return;
  }

  /* We used to just close the socket here using close_socket(), but
   * various people pointed out this could cause a crash if you're
   * closing the person below you on the descriptor list.  Just setting
   * to CON_CLOSE leaves things in a massively inconsistent state so I
   * had to add this new flag to the descriptor.
   *
   * It is a much more logical extension for a CON_DISCONNECT to be used
   * for in-game socket closes and CON_CLOSE for out of game closings.
   * This will retain the stability of the close_me hack while being
   * neater in appearance. -gg 12/1/97
   */
  STATE(d) = CON_DISCONNECT;
  sprintf(buf, "Connection #%d closed.\r\n", num_to_dc);
  send_to_char(buf, ch);
  log("(GC) Connection closed by %s.", GET_NAME(ch));
}



ACMD(do_wizlock)
{
  int value;
  const char *when;

  one_argument(argument, arg);
  if (*arg) {
    value = atoi(arg);
    if (value < 0 || value > GET_LEVEL(ch)) {
      send_to_char("Invalid wizlock value.\r\n", ch);
      return;
    }
    circle_restrict = value;
    when = "now";
  } else
    when = "currently";

  switch (circle_restrict) {
  case 0:
    sprintf(buf, "The game is %s completely open.\r\n", when);
    break;
  case 1:
    sprintf(buf, "The game is %s closed to new players.\r\n", when);
    break;
  default:
    sprintf(buf, "Only level %d and above may enter the game %s.\r\n",
            circle_restrict, when);
    break;
  }
  send_to_char(buf, ch);
}


ACMD(do_date)
{
  char *tmstr;
  time_t mytime;
  int d, h, m;

  if (subcmd == SCMD_DATE)
    mytime = time(0);
  else
    mytime = boot_time;

  tmstr = (char *) asctime(localtime(&mytime));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  if (subcmd == SCMD_DATE)
    sprintf(buf, "Current machine time: %s\r\n", tmstr);
  else {
    mytime = time(0) - boot_time;
    d = mytime / 86400;
    h = (mytime / 3600) % 24;
    m = (mytime / 60) % 60;

    sprintf(buf, "Up since %s: %d day%s, %d:%02d\r\n", tmstr, d,
            ((d == 1) ? "" : "s"), h, m);
  }

  send_to_char(buf, ch);
}



ACMD(do_last)
{
  struct char_data *vict = NULL;

  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("For whom do you wish to search?\r\n", ch);
    return;
  }
  CREATE(vict, struct char_data, 1);
  clear_char(vict);
  CREATE(vict->player_specials, struct player_special_data, 1);
  if (load_char(arg, vict) <  0) {
    send_to_char("There is no such player.\r\n", ch);
    free_char(vict);
    return;
  }
  if ((GET_LEVEL(vict) > GET_LEVEL(ch)) && (GET_LEVEL(ch) < LVL_IMPL)) {
    send_to_char("You are not sufficiently godly for that!\r\n", ch);
    return;
  }
  sprintf(buf, "[%5ld] [%2d %s] %-12s : %-18s : %-20s\r\n",
	GET_IDNUM(vict), (int) GET_LEVEL(vict),
	class_abbrevs[(int) GET_CLASS(vict)], GET_NAME(vict),
	vict->player_specials->host && *vict->player_specials->host
	? vict->player_specials->host : "(NOHOST)",
	ctime(&vict->player.time.logon));
   send_to_char(buf, ch);
   free_char(vict);
}


ACMD(do_force)
{
  struct descriptor_data *i, *next_desc;
  struct char_data *vict, *next_force;
  char to_force[MAX_INPUT_LENGTH + 2];

  half_chop(argument, arg, to_force);

  sprintf(buf1, "$n has forced you to '%s'.", to_force);

  if (!*arg || !*to_force)
    send_to_char("Whom do you wish to force do what?\r\n", ch);
  else if ((GET_LEVEL(ch) < LVL_GRGOD) || (str_cmp("all", arg) && str_cmp("room", arg))) {
    if (!(vict = get_char_vis(ch, arg)))
      send_to_char(NOPERSON, ch);
    else if (GET_LEVEL(ch) <= GET_LEVEL(vict))
      send_to_char("No, no, no!\r\n", ch);
    else {
      send_to_char(OK, ch);
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      sprintf(buf, "(GC) %s forced %s to %s", GET_NAME(ch), GET_NAME(vict), to_force);
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      command_interpreter(vict, to_force);
    }
  } else if (!str_cmp("room", arg)) {
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced room %d to %s",
                GET_NAME(ch), GET_ROOM_VNUM(IN_ROOM(ch)), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (vict = world[ch->in_room].people; vict; vict = next_force) {
      next_force = vict->next_in_room;
      if (GET_LEVEL(vict) >= GET_LEVEL(ch))
        continue;
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  } else { /* force all */
    send_to_char(OK, ch);
    sprintf(buf, "(GC) %s forced all to %s", GET_NAME(ch), to_force);
    mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

    for (i = descriptor_list; i; i = next_desc) {
      next_desc = i->next;

      if (STATE(i) != CON_PLAYING || !(vict = i->character) || GET_LEVEL(vict) >= GET_LEVEL(ch))
        continue;
      act(buf1, TRUE, ch, NULL, vict, TO_VICT);
      command_interpreter(vict, to_force);
    }
  }
}



ACMD(do_wiznet)
{
  struct descriptor_data *d;
  char any = FALSE;
  int level = LVL_IMMORT;

  skip_spaces(&argument);
  delete_doubledollar(argument);

  if (!*argument) {
    send_to_char("Usage: wiznet <text> | #<level> <text> | wiznet @\r\n "
                 "Type HELP WIZNET for more detailed information.\r\n", ch);
    return;
  }
  switch (*argument) {
  case '#':
    one_argument(argument + 1, buf1);
    if (is_number(buf1)) {
      half_chop(argument+1, buf1, argument);
      level = MAX(atoi(buf1), LVL_IMMORT);
      if (level > GET_LEVEL(ch)) {
        send_to_char("You can't wizline above your own level.\r\n", ch);
        return;
      }
    }
    break;
  case '@':
    for (d = descriptor_list; d; d = d->next) {
      if (STATE(d) == CON_PLAYING && GET_LEVEL(d->character) >= LVL_IMMORT &&
          !PRF_FLAGGED(d->character, PRF_NOWIZ) &&
          (CAN_SEE(ch, d->character) || GET_LEVEL(ch) == LVL_IMPL)) {
        if (!any) {
          strcpy(buf1, "Gods online:\r\n");
          any = TRUE;
        }
        sprintf(buf1 + strlen(buf1), "  %s", GET_NAME(d->character));
        if (PLR_FLAGGED(d->character, PLR_WRITING))
          strcat(buf1, " (Writing)\r\n");
        else if (PLR_FLAGGED(d->character, PLR_MAILING))
          strcat(buf1, " (Writing mail)\r\n");
        else
          strcat(buf1, "\r\n");

      }
    }
    any = FALSE;
    for (d = descriptor_list; d; d = d->next) {
      if (STATE(d) == CON_PLAYING && GET_LEVEL(d->character) >= LVL_IMMORT &&
          PRF_FLAGGED(d->character, PRF_NOWIZ) &&
          CAN_SEE(ch, d->character)) {
        if (!any) {
          strcat(buf1, "Gods offline:\r\n");
          any = TRUE;
        }
        sprintf(buf1 + strlen(buf1), "  %s\r\n", GET_NAME(d->character));
      }
    }
    send_to_char(buf1, ch);
    return;
  case '\\':
    ++argument;
    break;
  default:
    break;
  }
  if (PRF_FLAGGED(ch, PRF_NOWIZ)) {
    send_to_char("You are offline!\r\n", ch);
    return;
  }
  skip_spaces(&argument);

  if (!*argument) {
    send_to_char("Don't bother the gods like that!\r\n", ch);
    return;
  }
  if (level > LVL_IMMORT) {
    sprintf(buf1, "[%d] %s: %s\r\n", level, GET_NAME(ch), argument);
    sprintf(buf2, "[%d] Someone: %s\r\n", level, argument);
  } else {
    sprintf(buf1, "%s: %s\r\n", GET_NAME(ch), argument);
    sprintf(buf2, "Someone: %s\r\n", argument);
  }

  for (d = descriptor_list; d; d = d->next) {
    if ((STATE(d) == CON_PLAYING) && (GET_LEVEL(d->character) >= level) &&
        (!PRF_FLAGGED(d->character, PRF_NOWIZ)) &&
        (!PLR_FLAGGED(d->character, PLR_WRITING | PLR_MAILING))
        && (d != ch->desc || !(PRF_FLAGGED(d->character, PRF_NOREPEAT)))) {
      send_to_char(CCBCYN(d->character, C_NRM), d->character);
      if (CAN_SEE(d->character, ch))
        send_to_char(buf1, d->character);
      else
        send_to_char(buf2, d->character);
      send_to_char(CCNRM(d->character, C_NRM), d->character);
    }
  }

  if (PRF_FLAGGED(ch, PRF_NOREPEAT))
    send_to_char(OK, ch);
}



ACMD(do_zreset)
{
  int i, j;

  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("You must specify a zone.\r\n", ch);
    return;
  }
  if (*arg == '*') {
    for (i = 0; i <= top_of_zone_table; i++)
      reset_zone(i);
    send_to_char("Reset world.\r\n", ch);
    sprintf(buf, "(GC) %s reset entire world.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
    return;
  } else if (*arg == '.')
    i = world[ch->in_room].zone;
  else {
    j = atoi(arg);
    for (i = 0; i <= top_of_zone_table; i++)
      if (zone_table[i].number == j)
        break;
  }
  if (i >= 0 && i <= top_of_zone_table) {
    reset_zone(i);
    sprintf(buf, "Reset zone %d (#%d): %s.\r\n", i, zone_table[i].number,
            zone_table[i].name);
    send_to_char(buf, ch);
    sprintf(buf, "(GC) %s reset zone %d (%s)", GET_NAME(ch), i, zone_table[i].name);
    mudlog(buf, NRM, MAX(LVL_GRGOD, GET_INVIS_LEV(ch)), TRUE);
  } else
    send_to_char("Invalid zone number.\r\n", ch);
}


/*
 *  General fn for wizcommands of the sort: cmd <player>
 */

ACMD(do_wizutil)
{
  struct char_data *vict;
  long result;

  one_argument(argument, arg);

  if (!*arg)
    send_to_char("Yes, but for whom?!?\r\n", ch);
  else if (!(vict = get_char_vis(ch, arg)))
    send_to_char("There is no such player.\r\n", ch);
  else if (IS_NPC(vict))
    send_to_char("You can't do that to a mob!\r\n", ch);
  else if (GET_LEVEL(vict) > GET_LEVEL(ch))
    send_to_char("Hmmm...you'd better not.\r\n", ch);
  else {
    switch (subcmd) {
    case SCMD_REROLL:
      send_to_char("Rerolled...\r\n", ch);
      roll_real_abils(vict);
      log("(GC) %s has rerolled %s.", GET_NAME(ch), GET_NAME(vict));
      sprintf(buf, "New stats: Str %d/%d, Int %d, Wis %d, Dex %d, Con %d, Cha %d\r\n",
              GET_STR(vict), GET_ADD(vict), GET_INT(vict), GET_WIS(vict),
              GET_DEX(vict), GET_CON(vict), GET_CHA(vict));
      send_to_char(buf, ch);
      break;
    case SCMD_PARDON:
      if (!PLR_FLAGGED(vict, PLR_THIEF | PLR_KILLER | PLR_DEAD)) {
	send_to_char("Your victim is not flagged.\r\n", ch);
	return;
      }
      REMOVE_BIT(PLR_FLAGS(vict), PLR_THIEF | PLR_KILLER | PLR_DEAD);
      send_to_char("Pardoned.\r\n", ch);
      send_to_char("You have been pardoned by the Gods!\r\n", vict);
      sprintf(buf, "(GC) %s pardoned by %s", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_NOTITLE:
      result = PLR_TOG_CHK(vict, PLR_NOTITLE);
      sprintf(buf, "(GC) Notitle %s for %s by %s.", ONOFF(result),
              GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      if (result)
        send_to_char("You have abused of the title feature. You can't change it anymore.\r\n", vict);
      else
        send_to_char("You can change your title again.\r\n", vict);
      sprintf(buf, "NOTITLE %sactivated for %s.\r\n", (result?"":"de"), GET_NAME(vict));
      send_to_char(buf, ch);
      break;
    case SCMD_SQUELCH:
      result = PLR_TOG_CHK(vict, PLR_NOSHOUT);
      sprintf(buf, "(GC) Squelch %s for %s by %s.", ONOFF(result),
              GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case SCMD_FREEZE:
      if (ch == vict) {
        send_to_char("Oh, yeah, THAT'S real smart...\r\n", ch);
        return;
      }
      if (PLR_FLAGGED(vict, PLR_FROZEN)) {
        send_to_char("Your victim is already pretty cold.\r\n", ch);
        return;
      }
      SET_BIT(PLR_FLAGS(vict), PLR_FROZEN);
      GET_FREEZE_LEV(vict) = GET_LEVEL(ch);
      send_to_char("A bitter wind suddenly rises and drains every erg of heat from your body!\r\nYou feel frozen!\r\n", vict);
      send_to_char("Frozen.\r\n", ch);
      act("A sudden cold wind conjured from nowhere freezes $n!", FALSE, vict, 0, 0, TO_ROOM);
      sprintf(buf, "(GC) %s frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      break;
    case SCMD_THAW:
      if (!PLR_FLAGGED(vict, PLR_FROZEN)) {
        send_to_char("Sorry, your victim is not morbidly encased in ice at the moment.\r\n", ch);
        return;
      }
      if (GET_FREEZE_LEV(vict) > GET_LEVEL(ch)) {
        sprintf(buf, "Sorry, a level %d God froze %s... you can't unfreeze %s.\r\n",
           GET_FREEZE_LEV(vict), GET_NAME(vict), HMHR(vict));
        send_to_char(buf, ch);
        return;
      }
      sprintf(buf, "(GC) %s un-frozen by %s.", GET_NAME(vict), GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
      REMOVE_BIT(PLR_FLAGS(vict), PLR_FROZEN);
      send_to_char("A fireball suddenly explodes in front of you, melting the ice!\r\nYou feel thawed.\r\n", vict);
      send_to_char("Thawed.\r\n", ch);
      act("A sudden fireball conjured from nowhere thaws $n!", FALSE, vict, 0, 0, TO_ROOM);
      break;
    case SCMD_UNAFFECT:
      if (vict->affected) {
        while (vict->affected)
          affect_remove(vict, vict->affected);
        send_to_char("There is a brief flash of light!\r\n"
                     "You feel slightly different.\r\n", vict);
        send_to_char("All spells removed.\r\n", ch);
      } else {
        send_to_char("Your victim does not have any affections!\r\n", ch);
        return;
      }
      break;
    default:
      log("SYSERR: Unknown subcmd %d passed to do_wizutil (%s)", subcmd, __FILE__);
      break;
    }
    save_char(vict, NOWHERE);
  }
}


/* single zone printing fn used by "show zone" so it's not repeated in the
   code 3 times ... -je, 4/6/93 */

void print_zone_to_buf(char *bufptr, int zone)
{
   sprintf(bufptr, "%s%3d %-30.30s Status: %8s ; Top: %5d\r\n",
          bufptr, zone_table[zone].number, zone_table[zone].name,
          (ZONE_FLAGGED(zone, ZONE_OPEN)?"DONE" : "NOT DONE"),
          zone_table[zone].top);
}

ACMD(do_find)
{
  int i, l;
  struct obj_data *obj;
  int count = 0;
  char field[MAX_INPUT_LENGTH];
  char value[MAX_INPUT_LENGTH];
  FILE *fl;
  char fname[MAX_INPUT_LENGTH];
  char find[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  int searching, achado;
  bool named;
  bool found = FALSE;
  struct rent_info rent;

  extern struct player_index_element *player_table;

  struct find_struct {
    const char *cmd;
    int level;
  } fields[] = {
/* 00 */ { "nothing",        0  },
/* 01 */ { "rent",           LVL_GRGOD },
/* 01 */ { "nolinkzone",     LVL_GRGOD },
/* 02 */ { "\n", 0 }
  };

  skip_spaces(&argument);

  if (!*argument) {
    sprintf(find, "As %s %s you can find:\r\n",
         strchr("aeiouyAEIOUY", *GET_GOD_NAME(ch))?"an":"a", GET_GOD_NAME(ch));
    send_to_char(find, ch);
    count=0;
    for (i=1; fields[i].cmd != "\n"; i++) {
      if (GET_LEVEL(ch) >= fields[i].level) {
        count=(count==4?1:count+1);
        sprintf(find, "[%3d] %-13s%s", fields[i].level,
                fields[i].cmd, (count==4?"\r\n":" "));
        send_to_char(find, ch);
      }
    }
    if (count != 4) send_to_char("\r\n", ch);
    return;
  }

  strcpy(arg, two_arguments(argument, field, value));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (is_abbrev(field, fields[l].cmd))
      break;

  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }
  buf[0] = '\0';
  switch (l) {
    case 1: /* rent */
      if (!isdigit(*value)) {
         send_to_char("Try to use real numbers...\r\n", ch);
         return;
      }
      if ((searching = atoi(value)) < 0) {
         send_to_char("A NEGATIVE number??\r\n", ch);
         return;
      }
      if ((achado = real_object(searching)) < 0) {
        send_to_char("Invalid object vnum.\r\n", ch);
        return;
      }
      obj = read_object(achado, REAL);
      sprintf(find, "Searching for the object '%s' (vnum #%d) in all rent files...\r\n",
                   obj->short_description, searching);
      send_to_char(find, ch);
      *find = '\0';
      extract_obj(obj);
      for (i=0, named = FALSE; i<=top_of_p_table; i++, named = FALSE) {
        if (!get_filename(player_table[i].name, fname, CRASH_FILE))
          return;
        if ((fl = fopen(fname, "rb"))) {
          if (!feof(fl))
            fread(&rent, sizeof(struct rent_info), 1, fl);
          while (!feof(fl)) {
            fread(&object, sizeof(struct obj_file_elem), 1, fl);
            if (ferror(fl)) {
              fclose(fl);
              return;
            }
            if (!feof(fl))
              if (real_object(object.item_number) > -1) {
                if (object.item_number == searching) {
                  if (!named) {
                    named = TRUE;
                    sprintf(find, "%s%s:\r\n", find, player_table[i].name);
                  }
                  found = TRUE;
                  obj = read_object(object.item_number, VIRTUAL);
                  sprintf(find, "%s [%5d] (%9dau) %s\r\n",
                          find, object.item_number, GET_OBJ_COST(obj),
                          obj->short_description);
                  extract_obj(obj);
                }
              }
          }
          fclose(fl);
        }
      }
      if (!found)
        send_to_char("No one found.\r\n", ch);
      else
        page_string(ch->desc, find, 1);
      break;
    case 2: /* link obj */
      if (!isdigit(*value)) {
         send_to_char("Try to use real numbers...\r\n", ch);
         return;
      }
      if ((searching = atoi(value)) < 0) {
         send_to_char("A NEGATIVE number??\r\n", ch);
         return;
      }
      if ((achado = real_zone(searching)) < 0) {
        send_to_char("Invalid zone vnum.\r\n", ch);
        return;
      }
      sprintf(find, "Searching for non linked object '%d' in all rent files...\r\n",
                   searching);
      send_to_char(find, ch);
      *find = '\0';
      for (i=0, named = FALSE; i<=top_of_p_table; i++, named = FALSE) {
        if (!get_filename(player_table[i].name, fname, CRASH_FILE))
          return;
        if ((fl = fopen(fname, "rb"))) {
          if (!feof(fl))
            fread(&rent, sizeof(struct rent_info), 1, fl);
          while (!feof(fl)) {
            fread(&object, sizeof(struct obj_file_elem), 1, fl);
            if (ferror(fl)) {
              fclose(fl);
              return;
            }
            if (!feof(fl))
              if (real_object(object.item_number) > -1) {
                if (div(object.item_number,100).quot == searching) {
                  if (!named) {
                    named = TRUE;
                    sprintf(find, "%s%s:\r\n", find, player_table[i].name);
                  }
                  found = TRUE;
                  obj = read_object(object.item_number, VIRTUAL);
                  sprintf(find, "%s [%5d] (%9dau) %s\r\n",
                          find, object.item_number, GET_OBJ_COST(obj),
                          obj->short_description);
                  extract_obj(obj);
                }
              }
          }
          fclose(fl);
        }
      }
      if (!found)
        send_to_char("No one found.\r\n", ch);
      else
        page_string(ch->desc, find, 1);
      break;
  }
}

#define EXITN(room, door)               (world[room].dir_option[door])

ACMD(do_liblist)
{
  extern struct room_data *world;
  extern struct index_data *mob_index;
  extern struct char_data *mob_proto;
  extern struct index_data *obj_index;
  extern struct obj_data *obj_proto;
  extern struct zone_data *zone_table;
  extern int top_of_objt;
  extern int top_of_mobt;
  extern int top_of_world;

  int first, last, nr, found = 0;
  int door, temsaida, tementrada,tnr;

  two_arguments(argument, buf, buf2);

  if (!*buf || !*buf2) {
    switch (subcmd) {
      case SCMD_RLIST:
        send_to_char("Usage: rlist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_OLIST:
        send_to_char("Usage: olist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_MLIST:
        send_to_char("Usage: mlist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_ZLIST:
        send_to_char("Usage: zlist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_ELIST:
        send_to_char("Usage: elist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_DLIST:
        send_to_char("Usage: dlist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_LLIST:
        send_to_char("Usage: llist <begining number> <ending number>\r\n", ch);
        break;
      case SCMD_VLIST:
        send_to_char("Usage: vlist <begining number> <ending number>\r\n", ch);
        break;
      default:
        sprintf(buf, "SYSERR:: invalid SCMD passed to ACMDdo_build_list!");
        mudlog(buf, BRF, LVL_SUPGOD, TRUE);
        break;
    }
    return;
  }

  first = atoi(buf);
  last = atoi(buf2);

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }

  if(last - first > 100){
    send_to_char("You can't pass the limit... (100 targets)\n\r", ch);
    return;
  }

  switch (subcmd) {
    case SCMD_ELIST:
      sprintf(buf, "Rooms Exits List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++)
       if (world[nr].number >= first)
         {
           for (door = 0; door < NUM_OF_DIRS; door++)
            if (EXITN(nr, door) && EXITN(nr, door)->to_room != NOWHERE )
             {
               if (world[EXITN(nr, door)->to_room].zone !=
                   world[nr].zone)
                  {
                   sprintf(buf, "%s%5d. [%5d] to [%5d] (%3d)\r\n", buf, ++found,
                      world[nr].number, GET_ROOM_VNUM(EXITN(nr, door)->to_room), door);
                  }
             }
          }
      break;

    case SCMD_DLIST:
      sprintf(buf, "Rooms List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++)
       if (world[nr].number >= first)
         {
           temsaida = 0;
           for (door = 0; door < NUM_OF_DIRS; door++)
            if (EXITN(nr, door) && EXITN(nr, door)->to_room != NOWHERE )
              {
                temsaida = 1;
              }
            if (temsaida == 0)
             sprintf(buf, "%s%5d. [%5d]\r\n", buf, ++found,
                      world[nr].number);
            temsaida = 0;
          }
      break;

    case SCMD_LLIST:
      sprintf(buf, "Rooms List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++)
       if (world[nr].number >= first)
         {
           tementrada = 0;
           for (tnr = 0; tnr <= top_of_world && (world[tnr].number <= last); tnr++)
            if (world[tnr].number >= first)
            {
             for (door = 0; door < NUM_OF_DIRS; door++)
              if (EXITN(tnr, door) && EXITN(tnr, door)->to_room != NOWHERE )
               {
                 if (world[EXITN(tnr, door)->to_room].number ==
                   world[nr].number)
                    if ( world[tnr].number != world[nr].number)
                     tementrada = 1;
               }
            }
            if (tementrada == 0)
             sprintf(buf, "%s%5d. [%5d]\r\n", buf, ++found,
                      world[nr].number);
          }
      break;

    case SCMD_VLIST:
      sprintf(buf, "Rooms List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++)
       if (world[nr].number >= first)
         {
           for (tnr = 0; tnr <= top_of_world; tnr++)
            {
             for (door = 0; door < NUM_OF_DIRS; door++)
              if (EXITN(tnr, door) && EXITN(tnr, door)->to_room != NOWHERE )
               {
                 if (world[EXITN(tnr, door)->to_room].number ==
                   world[nr].number)
                    if ( world[tnr].zone != world[nr].zone)
                     sprintf(buf, "%s%5d. [%5d] to [%5d] (%3d)\r\n", buf, ++found,
                      world[tnr].number, world[nr].number, door);
               }
            }

          }
      break;

    case SCMD_RLIST:
      sprintf(buf, "Room List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_world && (world[nr].number <= last); nr++) {
        if (world[nr].number >= first) {
          sprintf(buf, "%s%5d. [%5d] (%3d) %s\r\n", buf, ++found,
                  world[nr].number, world[nr].zone,
                  world[nr].name);
        }
      }
      break;
    case SCMD_OLIST:
      sprintf(buf, "Object List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_objt && (obj_index[nr].vnum <= last); nr++) {
        if (obj_index[nr].vnum >= first) {
          sprintf(buf, "%s%5d. [%5d] %s\r\n", buf, ++found,
                  obj_index[nr].vnum,
                  obj_proto[nr].short_description);
        }
      }
      break;
    case SCMD_MLIST:
      sprintf(buf, "Mob List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_mobt && (mob_index[nr].vnum <= last); nr++) {
        if (mob_index[nr].vnum >= first) {
          sprintf(buf, "%s%5d. [%5d] %s\r\n", buf, ++found,
                  mob_index[nr].vnum,
                  mob_proto[nr].player.short_descr);
        }
      }
      break;
    case SCMD_ZLIST:
      sprintf(buf, "Zone List From Vnum %d to %d\r\n", first, last);
      for (nr = 0; nr <= top_of_zone_table && (zone_table[nr].number <= last); nr++) {
        if (zone_table[nr].number >= first) {
          sprintf(buf, "%s%5d. [%5d] (%3d) %s\r\n", buf, ++found,
                  zone_table[nr].number, zone_table[nr].lifespan,
                  zone_table[nr].name);
        }
      }
      break;
    default:
      sprintf(buf, "SYSERR:: invalid SCMD passed to ACMD(do_liblist)!");
      mudlog(buf, BRF, LVL_OLC_FULL, TRUE);
      return;
  }

  if (!found) {
    switch (subcmd) {
      case SCMD_RLIST:
        send_to_char("No rooms found within those parameters.\r\n", ch);
        break;
      case SCMD_OLIST:
        send_to_char("No objects found within those parameters.\r\n", ch);
        break;
      case SCMD_MLIST:
        send_to_char("No mobiles found within those parameters.\r\n", ch);
        break;
      case SCMD_ZLIST:
        send_to_char("No zones found within those parameters.\r\n", ch);
        break;
      case SCMD_ELIST:
        send_to_char("No rooms exits found within those parameters.\r\n", ch);
        break;
      case SCMD_DLIST:
        send_to_char("No rooms found within those parameters.\r\n", ch);
        break;
      case SCMD_LLIST:
        send_to_char("No rooms found within those parameters.\r\n", ch);
        break;
      case SCMD_VLIST:
        send_to_char("No rooms found within those parameters.\r\n", ch);
        break;
      default:
        sprintf(buf, "SYSERR:: invalid SCMD passed to do_build_list!");
        mudlog(buf, BRF, LVL_GOD, TRUE);
        break;
    }
    return;
  }

  page_string(ch->desc, buf, TRUE);
}


ACMD(do_show)
{
  int i, j, k, l, con;
  char self = 0;
  struct char_data *vict = NULL;
  struct obj_data *obj;
  struct descriptor_data *d;
  int count = 0;
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH], birth[80];
  //bool found = FALSE;

  struct show_struct {
    const char *cmd;
    int level;
  } fields[] = {
/* 00 */ { "nothing",        0  },
/* 01 */ { "zones",          LVL_LORD },
/* 02 */ { "character",      LVL_DEMIGOD },
/* 03 */ { "rent",           LVL_GOD },
/* 04 */ { "stats",          LVL_GRGOD },
/* 05 */ { "errors",         LVL_SUPGOD },
/* 06 */ { "death",          LVL_GOD },
/* 07 */ { "godrooms",       LVL_GOD },
/* 08 */ { "shops",          LVL_LORD },
/* 09 */ { "houses",         LVL_SUPGOD },
/* 10 */ { "players",        LVL_MJGOD },
/* 11 */ { "rooms",          LVL_GOD },
/* 12 */ { "entrances",      LVL_DEMIGOD },
/* 13 */ { "snoop",	     LVL_GRGOD },			/* 10 */
/* 14 */ { "teleport",	     LVL_BUILDER },
/* 15 */ { "memory",	     LVL_SUPGOD },
/* 17 */ { "\n", 0 }
  };

  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "As %s %s you can view:\r\n",
         strchr("aeiouyAEIOUY", *GET_GOD_NAME(ch))?"an":"a", GET_GOD_NAME(ch));
    send_to_char(buf, ch);
    count=0;
    for (i=1; fields[i].cmd != "\n"; i++) {
      if (GET_LEVEL(ch) >= fields[i].level) {
        count=(count==4?1:count+1);
        sprintf(buf, "[%3d] %-13s%s", fields[i].level,
                fields[i].cmd, (count==4?"\r\n":" "));
        send_to_char(buf, ch);
      }
    }
    if (count != 4) send_to_char("\r\n", ch);
    return;
  }

  strcpy(arg, two_arguments(argument, field, value));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    //if (!strncmp(field, fields[l].cmd, strlen(field)))
    if (is_abbrev(field, fields[l].cmd))
      break;

  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }
  if (!strcmp(value, "."))
    self = 1;
  buf[0] = '\0';
  switch (l) {
  case 1: /* show zones */
    /* tightened up by JE 4/6/93 */
    if (self)
      print_zone_to_buf(buf, world[ch->in_room].zone);
    else if (*value && is_number(value)) {
      for (j = atoi(value), i = 0; zone_table[i].number != j && i <= top_of_zone_table; i++);
      if (i <= top_of_zone_table)
        print_zone_to_buf(buf, i);
      else {
        send_to_char("That is not a valid zone.\r\n", ch);
        return;
      }
    } else
      for (i = 0; i <= top_of_zone_table; i++)
        print_zone_to_buf(buf, i);
    page_string(ch->desc, buf, TRUE);
    break;
  case 2: /* show player */
    if (!*value) {
      send_to_char("A name would help.\r\n", ch);
      return;
    }

    CREATE(vict, struct char_data, 1);
    clear_char(vict);
    CREATE(vict->player_specials, struct player_special_data, 1);
    if (load_char(value, vict) < 0) {
      send_to_char("There is no such player.\r\n", ch);
      free_char(vict);
      return;
    }
    sprintf(buf, "Player: %-12s (%s) [%2d %s]\r\n", GET_NAME(vict),
      genders[(int) GET_SEX(vict)], GET_LEVEL(vict), class_abbrevs[(int)
	GET_CLASS(vict)]);
    sprintf(buf,
         "Au: %-8d  Bal: %-8d  Exp: %-8d  Align: %-5d  Lessons: %-3d\r\n",
	    GET_GOLD(vict), GET_BANK_GOLD(vict), GET_EXP(vict),
	    GET_ALIGNMENT(vict), GET_PRACTICES(vict));
    strcpy(birth, ctime(&vict->player.time.birth));
    sprintf(buf,
            "Started: %-20.16s  Last: %-20.16s  Played: %3dh %2dm\r\n",
	    birth, ctime(&vict->player.time.logon),
	    (int) (vict->player.time.played / 3600),
	    (int) (vict->player.time.played / 60 % 60));
    send_to_char(buf, ch);
    free_char(vict);
    break;
  case 3: /* show rent */
    Crash_listrent(ch, value);
    break;
  case 4: /* show stats */
    i = 0;
    j = 0;
    k = 0;
    con = 0;

    for (vict = character_list; vict; vict = vict->next) {
      if (IS_NPC(vict))
        j++;
      else if (CAN_SEE(ch, vict)) {
        i++;
        if (vict->desc)
          con++;
      }
    }
    for (obj = object_list; obj; obj = obj->next)
      k++;
    strcpy(buf, "Current stats:\r\n");
    sprintf(buf + strlen(buf), "  %5d players in game  %5d connected\r\n",
                i, con);
    sprintf(buf + strlen(buf), "  %5d registered\r\n",
                top_of_p_table + 1);
    sprintf(buf + strlen(buf), "  %5d mobiles          %5d prototypes\r\n",
                j, top_of_mobt + 1);
    sprintf(buf + strlen(buf), "  %5d objects          %5d prototypes\r\n",
                k, top_of_objt + 1);
    sprintf(buf + strlen(buf), "  %5d rooms            %5d zones\r\n",
                top_of_world + 1, top_of_zone_table + 1);
    sprintf(buf + strlen(buf), "  %5d large bufs\r\n",
                buf_largecount);
    sprintf(buf + strlen(buf), "  %5d buf switches     %5d overflows\r\n",
                buf_switches, buf_overflows);
    send_to_char(buf, ch);
    break;
  case 5: /* show errors */
    strcpy(buf, "Errant Rooms\r\n------------\r\n");
    for (i = 0, k = 0; i <= top_of_world; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
        if (world[i].dir_option[j] && world[i].dir_option[j]->to_room == 0)
          sprintf(buf + strlen(buf), "%2d: [%5d] %s\r\n", ++k, GET_ROOM_VNUM(i),
                  world[i].name);
    page_string(ch->desc, buf, TRUE);
    break;
  case 6: /* show death */
    strcpy(buf, "Death Traps\r\n-----------\r\n");
    for (i = 0, j = 0; i <= top_of_world; i++)
      if (ROOM_FLAGGED(i, ROOM_DEATH))
        sprintf(buf + strlen(buf), "%2d: [%5d] %s\r\n", ++j,
                GET_ROOM_VNUM(i), world[i].name);
    page_string(ch->desc, buf, TRUE);
    break;
  case 7: /* show godrooms */
    strcpy(buf, "Godrooms\r\n--------------------------\r\n");
    for (i = 0, j = 0; i < top_of_world; i++)
    if (ROOM_FLAGGED(i, ROOM_GODROOM))
      sprintf(buf + strlen(buf), "%2d: [%5d] %s\r\n",
                ++j, GET_ROOM_VNUM(i), world[i].name);
    page_string(ch->desc, buf, TRUE);
    break;
  case 8: /* show shops */
    show_shops(ch, value);
    break;
  case 9: /* show houses */
    hcontrol_list_houses(ch);
    break;
  case 10: /* show players */
    strcpy(buf, "\r\nDarkest WarDome MUD registered players:\r\n");
    for (j = 0; j <= top_of_p_table; j++){
	if(find_name((player_table + j)->name) >= 0)
          sprintf(buf + strlen(buf), "[%3d] %-19.19s%s", (player_table + j)->level, (player_table + j)->name, !(++count % 3) ? "\r\n" : "");
    }
    strcat(buf, (count % 3) ? "\r\n" : "");
    sprintf(buf + strlen(buf), "\r\nTotal active players: %d\r\n", count);
    page_string(ch->desc, buf, 1);
    break;
  case 11: /* show rooms <zone> */
    if (self) {
      for (i = 0; i <= top_of_world; i++)
        if ((int)(GET_ROOM_VNUM(i) / 100) == zone_table[world[ch->in_room].zone].number) {
          count++;
          if (count == 1 || !(count % 21 - 1)) sprintf(buf + strlen(buf), "      vnum   Room name\r\n");
          sprintf(buf + strlen(buf), "%3d. [%5d] %s\r\n", count, GET_ROOM_VNUM(i), world[i].name);
        }
    }
    else if (*value && is_number(value)) {
      for (j = atoi(value), i = 0; zone_table[i].number != j && i <= top_of_zone_table; i++);
        if (i <= top_of_zone_table) {
          for (i = 0; i <= top_of_world; i++)
            if ((int)(GET_ROOM_VNUM(i) / 100) == atoi(value)) {
              count++;
              if (count == 1 || !(count % 21 - 1)) sprintf(buf + strlen(buf), "      vnum   Room name\r\n");
              sprintf(buf + strlen(buf), "%3d. [%5d] %s\r\n", count, GET_ROOM_VNUM(i), world[i].name);
            }
        }
        else {
          send_to_char("Invalid zone number.\r\n", ch);
          return;
        }
    }
    else {
      send_to_char("Invalid zone number.\r\n", ch);
      return;
    }
    page_string(ch->desc, buf, TRUE);
    break;
  case 12: /* show entrances */
    if (self) {
      sprintf(buf, "Possible entrances to the room \"%s\" (%d):\r\n",
              world[ch->in_room].name, GET_ROOM_VNUM(ch->in_room));
      for (i = 0; i <= top_of_world; i++)
        for (j = 0; j < NUM_OF_DIRS; j++)
          if (world[i].dir_option[j] && GET_ROOM_VNUM(world[i].dir_option[j]->to_room) == GET_ROOM_VNUM(ch->in_room))
            sprintf(buf + strlen(buf), "%2d. [%5d] (%5s) %s\r\n", ++count, GET_ROOM_VNUM(i), dirs[j], world[i].name);
    }
    else {
      send_to_char("Sorry, only \"show entrances .\" is working.\r\n", ch);
      return;
      /*
      sprintf(buf, "Possible entrances to the room \"%s\" (%d):\r\n",
              world[ch->in_room].name, GET_ROOM_VNUM(ch->in_room));
      for (i = 0; i <= top_of_world; i++)
        for (j = 0; j < NUM_OF_DIRS; j++)
          if (world[i].dir_option[j] && GET_ROOM_VNUM(world[i].dir_option[j]->to_room) == GET_ROOM_VNUM(ch->in_room))
            sprintf(buf + strlen(buf), "[%5d] %s (%s)\r\n", GET_ROOM_VNUM(i), world[i].name, dirs[j]);
      */
    }
    page_string(ch->desc, buf, TRUE);
    break;
  case 13:
    *buf = '\0';
    send_to_char("People currently snooping:\r\n", ch);
    send_to_char("--------------------------\r\n", ch);
    for (d = descriptor_list; d; d = d->next) {
      if (d->snooping == NULL || d->character == NULL)
	continue;
      if (STATE(d) != CON_PLAYING || GET_LEVEL(ch) < GET_LEVEL(d->character))
	continue;
      if (!CAN_SEE(ch, d->character) || IN_ROOM(d->character) == NOWHERE)
	continue;
      sprintf(buf + strlen(buf), "%-10s - snooped by %s.\r\n",
               GET_NAME(d->snooping->character), GET_NAME(d->character));
    }
    send_to_char(*buf ? buf : "No one is currently snooping.\r\n", ch);
    break;
  case 14:      /* teleport */
    strcpy(buf, "Teleport Rooms\r\n--------------\r\n");
    for (i = 0, j = 0; i <= top_of_world; i++)
        if (world[i].tele != NULL)
          sprintf(buf, "%s%2d: [%5d] %-24.24s Targ: %5d\r\n", buf, ++j,
                  world[i].number, world[i].name, world[i].tele->targ);
    page_string(ch->desc, buf, 1);
    break;
  case 15: /* show memory */
    show_mreport(ch);
    break;

  default:
    send_to_char("Invalid SHOW option.\r\n", ch);
    break;
}
}

/***************** The do_set function ***********************************/

#define PC   1
#define NPC  2
#define BOTH 3

#define MISC    0
#define BINARY  1
#define NUMBER  2

#define SET_OR_REMOVE(flagset, flags) { \
        if (on) SET_BIT(flagset, flags); \
        else if (off) REMOVE_BIT(flagset, flags); }

#define RANGE(low, high) (value = MAX((low), MIN((high), (value))))


/* The set options available */
  struct set_struct {
    const char *cmd;
    int level;
    const char pcnpc;
    const char type;
  } set_fields[] = {
/* 00 */ { "brief",           LVL_GOD,        PC,     BINARY },
/* 01 */ { "invstart",        LVL_GOD,        PC,     BINARY },
/* 02 */ { "title",           LVL_GOD,        PC,     MISC   },
/* 03 */ { "nosummon",        LVL_GRGOD,      PC,     BINARY },
/* 04 */ { "maxhit",          LVL_GRGOD,      BOTH,   NUMBER },
/* 05 */ { "maxmana",         LVL_GRGOD,      BOTH,   NUMBER },
/* 06 */ { "maxmove",         LVL_GRGOD,      BOTH,   NUMBER },
/* 07 */ { "hit",             LVL_GOD,        BOTH,   NUMBER },
/* 08 */ { "mana",            LVL_GOD,        BOTH,   NUMBER },
/* 09 */ { "move",            LVL_GOD,        BOTH,   NUMBER },
/* 10 */ { "align",           LVL_GOD,        BOTH,   NUMBER },
/* 11 */ { "str",             LVL_GRGOD,      BOTH,   NUMBER },
/* 12 */ { "stradd",          LVL_GRGOD,      BOTH,   NUMBER },
/* 13 */ { "int",             LVL_GRGOD,      BOTH,   NUMBER },
/* 14 */ { "wis",             LVL_GRGOD,      BOTH,   NUMBER },
/* 15 */ { "dex",             LVL_GRGOD,      BOTH,   NUMBER },
/* 16 */ { "con",             LVL_GRGOD,      BOTH,   NUMBER },
/* 17 */ { "cha",             LVL_GRGOD,      BOTH,   NUMBER },
/* 18 */ { "ac",              LVL_GRGOD,      BOTH,   NUMBER },
/* 19 */ { "gold",            LVL_GRGOD,      BOTH,   NUMBER },
/* 20 */ { "bank",            LVL_GRGOD,      PC,     NUMBER },
/* 21 */ { "exp",             LVL_SUPGOD,     BOTH,   NUMBER },
/* 22 */ { "hitroll",         LVL_GRGOD,      BOTH,   NUMBER },
/* 23 */ { "damroll",         LVL_GRGOD,      BOTH,   NUMBER },
/* 24 */ { "invis",           LVL_IMPL,       PC,     NUMBER },
/* 25 */ { "nohassle",        LVL_GRGOD,      PC,     BINARY },
/* 26 */ { "frozen",          LVL_FREEZE,     PC,     BINARY },
/* 27 */ { "practices",       LVL_GRGOD,      PC,     NUMBER },
/* 28 */ { "lessons",         LVL_GRGOD,      PC,     NUMBER },
/* 29 */ { "drunk",           LVL_GRGOD,      BOTH,   MISC   },
/* 30 */ { "hunger",          LVL_GRGOD,      BOTH,   MISC   },
/* 31 */ { "thirst",          LVL_GRGOD,      BOTH,   MISC   },
/* 32 */ { "killer",          LVL_GOD,        PC,     BINARY },
/* 33 */ { "thief",           LVL_GOD,        PC,     BINARY },
/* 34 */ { "level",           LVL_MJGOD,     BOTH,   NUMBER },
/* 35 */ { "room",            LVL_SUPGOD,     BOTH,   NUMBER },
/* 36 */ { "siteok",          LVL_GRGOD,      PC,     BINARY },
/* 37 */ { "deleted",         LVL_SUPGOD,     PC,     BINARY },
/* 38 */ { "class",           LVL_GRGOD,      BOTH,   MISC   },
/* 39 */ { "nowizlist",       LVL_GOD,        PC,     BINARY },
/* 40 */ { "quest",           LVL_GOD,        PC,     BINARY },
/* 41 */ { "loadroom",        LVL_GRGOD,      PC,     MISC   },
/* 42 */ { "color",           LVL_GOD,        PC,     BINARY },
/* 43 */ { "idnum",           LVL_GOD,       PC,     NUMBER },
/* 44 */ { "passwd",          LVL_SUPGOD,     PC,     MISC   },
/* 45 */ { "nodelete",        LVL_GOD,        PC,     BINARY },
/* 46 */ { "sex",             LVL_GRGOD,      BOTH,   MISC   },
/* 47 */ { "age",             LVL_GRGOD,      BOTH,   NUMBER },
/* 48 */ { "olc",             LVL_SUPGOD,     PC,     NUMBER },
/* 49 */ { "crossdoors",      LVL_SUPGOD,     PC,     BINARY },
/* 50 */ { "name",            LVL_IMPL,       PC,     MISC   },
/* 51 */ { "points",          LVL_GRGOD,      PC,     NUMBER },
/* 52 */ { "email",           LVL_SUPGOD,     PC,     MISC   },
/* 53 */ { "race",            LVL_GRGOD,      PC,     MISC   },
/* 54 */ { "remort",          LVL_SUPGOD,     PC,     NUMBER },
/* 55 */ { "fbi",             LVL_SUPGOD,     PC,     NUMBER },
/* 56 */ { "nopk",	      LVL_SUPGOD,     PC,     BINARY },
/* 57 */ { "qnum",	      LVL_GOD,        PC,     NUMBER },
/* 58 */ { "maxmental",       LVL_SUPGOD,     BOTH,   NUMBER },
/* 59 */ { "qpoints",         LVL_GOD,        PC,     NUMBER },
/* 60 */ { "house",           LVL_GRGOD,      PC,     NUMBER },
/* 61 */ { "rpoints",	      LVL_GRGOD,      PC,     NUMBER },
    { "\n", 0, BOTH, MISC }
  };


int perform_set(struct char_data *ch, struct char_data *vict, int mode,
                char *val_arg)
{
  int i, on = 0, off = 0, value = 0;
  char output[MAX_STRING_LENGTH];
  char out_to_log2[MAX_STRING_LENGTH];
  char out_to_log1[MAX_STRING_LENGTH];
//  char out_to_log0[MAX_STRING_LENGTH];

  /* Check to make sure all the levels are correct */
  if (GET_LEVEL(ch) != LVL_IMPL) {
    if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict) && vict != ch) {
      send_to_char("Maybe that's not such a great idea...\r\n", ch);
      return 0;
    }
  }
  if (GET_LEVEL(ch) < set_fields[mode].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return 0;
  }

  /* Make sure the PC/NPC is correct */
  if (IS_NPC(vict) && !(set_fields[mode].pcnpc & NPC)) {
    send_to_char("You can't do that to a beast!\r\n", ch);
    return 0;
  }
  else if (!IS_NPC(vict) && !(set_fields[mode].pcnpc & PC)) {
    send_to_char("That can only be done to a beast!\r\n", ch);
    return 0;
  }

  /* Find the value of the argument */
  if (set_fields[mode].type == BINARY) {
    if (!strcmp(val_arg, "on") || !strcmp(val_arg, "yes"))
      on = 1;
    else if (!strcmp(val_arg, "off") || !strcmp(val_arg, "no"))
      off = 1;
    if (!(on || off)) {
      send_to_char("Value must be 'on' or 'off'.\r\n", ch);
      return 0;
    }
    sprintf(output, "(set) %s sets %s %s for %s.", GET_NAME(ch), set_fields[mode].cmd, ONOFF(on),
            GET_NAME(vict));
    mudlog(output, CMP, MAX(GET_INVIS_LEV(ch), LVL_SUBIMPL), TRUE);
  }
  else if (set_fields[mode].type == NUMBER) {
    value = atoi(val_arg);
    sprintf(output, "(set) %s sets %s's %s set to %d.", GET_NAME(ch), GET_NAME(vict),
            set_fields[mode].cmd, value);
    mudlog(output, CMP, MAX(GET_INVIS_LEV(ch), LVL_SUBIMPL), TRUE);
  }
  else {
    strcpy(output, "Okay.");  /* can't use OK macro here 'cause of \r\n */
  }

  switch (mode) {
  case 0: /* brief */
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_BRIEF);
    break;
  case 1: /* invstart */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_INVSTART);
    break;
  case 2: /* title */
    sprintf(out_to_log1, "%s sets %s's title from '%s' to '%s'",
            GET_NAME(ch), GET_NAME(vict), GET_TITLE(vict), val_arg);
    set_title(vict, val_arg);
    break;
  case 3: /* nosummon */
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_SUMMONABLE);
    break;
  case 4: /* maxhit */
    vict->points.max_hit = RANGE(1, 500000);
    affect_total(vict);
    break;
  case 5: /* maxmana */
    vict->points.max_mana = RANGE(1, 500000);
    affect_total(vict);
    break;
  case 6: /* maxmove */
    vict->points.max_move = RANGE(1, 500000);
    affect_total(vict);
    break;
  case 7: /* hit */
    vict->points.hit = RANGE(-9, vict->points.max_hit);
    affect_total(vict);
    break;
  case 8: /* mana */
    vict->points.mana = RANGE(0, vict->points.max_mana);
    affect_total(vict);
    break;
  case 9: /* move */
    vict->points.move = RANGE(0, vict->points.max_move);
    affect_total(vict);
    break;
  case 10: /* alignment */
    GET_ALIGNMENT(vict) = RANGE(-1000, 1000);
    affect_total(vict);
    break;
  case 11: /* str */
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.str = value;
    vict->real_abils.str_add = 0;
    affect_total(vict);
    break;
  case 12: /* stradd */
    vict->real_abils.str_add = RANGE(0, 100);
    if (value > 0)
      vict->real_abils.str = 18;
    affect_total(vict);
    break;
  case 13: /* int */
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.intel = value;
    affect_total(vict);
    break;
  case 14: /* wis */
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.wis = value;
    sprintf(out_to_log1, out_to_log2, vict->real_abils.wis);
    affect_total(vict);
    break;
  case 15: /* dex */
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.dex = value;
    affect_total(vict);
    break;
  case 16: /* con */
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.con = value;
    affect_total(vict);
    break;
  case 17: /* cha */
    if (IS_NPC(vict) || GET_LEVEL(vict) >= LVL_GRGOD)
      RANGE(3, 25);
    else
      RANGE(3, 18);
    vict->real_abils.cha = value;
    affect_total(vict);
    break;
  case 18: /* ac */
    vict->points.armor = RANGE(-300, 300);
    affect_total(vict);
    break;
  case 19: /* gold */
    GET_GOLD(vict) = RANGE(0, 100000000);
    break;
  case 20: /* bank */
    GET_BANK_GOLD(vict) = RANGE(0, 100000000);
    break;
  case 21: /* exp */
//    vict->points.exp = RANGE(0, 18000000000);
    GET_EXP(vict) = RANGE(0, 2005000000);
    break;
  case 22: /* hitroll */
    vict->points.hitroll = RANGE(-1200, 1200);
    affect_total(vict);
    break;
  case 23: /* damroll */
    vict->points.damroll = RANGE(-1200, 1200);
    affect_total(vict);
    break;
  case 24: /* invis */
    if (GET_LEVEL(ch) < LVL_IMPL && ch != vict) {
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return 0;
    }
    GET_INVIS_LEV(vict) = RANGE(0, GET_LEVEL(vict));
    break;
  case 25: /* nohassle */
    if (GET_LEVEL(ch) < LVL_IMPL && ch != vict) {
      send_to_char("You aren't godly enough for that!\r\n", ch);
      return 0;
    }
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_NOHASSLE);
    break;
  case 26: /* frozen */
    if (ch == vict) {
      send_to_char("Better not -- could be a long winter!\r\n", ch);
      return 0;
    }
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_FROZEN);
    break;
  case 27: /* practices */
  case 28: /* lessons */
    GET_PRACTICES(vict) = RANGE(0, 100);
    break;
  case 29: /* drunk */
    if (mode == 29) strcpy(out_to_log1, "DRUNK");
  case 30: /* hunger */
    if (mode == 30) strcpy(out_to_log1, "HUNGER");
  case 31: /* thirst */
    if (mode == 31) strcpy(out_to_log1, "THIRST");
    if (GET_COND(vict, (mode - 29)) > -1)
      sprintf(out_to_log1, out_to_log2, GET_COND(vict, (mode - 29)));
    if (!str_cmp(val_arg, "off")) {
      GET_COND(vict, (mode - 29)) = (char) -1; /* warning: magic number here */
      sprintf(out_to_log1, out_to_log2, "off");
    }
    else if (is_number(val_arg)) {
      value = atoi(val_arg);
      RANGE(0, 24);
      GET_COND(vict, (mode - 29)) = (char) value; /* and here too */
      sprintf(out_to_log1, out_to_log2, "%d");
      sprintf(out_to_log2, out_to_log1, GET_COND(vict, (mode - 29)));
      strcpy(out_to_log1, out_to_log2);
    }
    else {
      send_to_char("Must be 'off' or a value from 0 to 24.\r\n", ch);
      return 0;
    }
    break;
  case 32: /* killer */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_KILLER);
    break;
  case 33: /* thief */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_THIEF);
    break;
  case 34: /* level */
    if (value > GET_LEVEL(ch) || value > LVL_IMPL) {
      send_to_char("You can't do that.\r\n", ch);
      return 0;
    }
    RANGE(0, LVL_IMPL);
    vict->player.level = value;
    break;
  case 35: /* room */
    if ((i = real_room(value)) < 0) {
      send_to_char("No room exists with that number.\r\n", ch);
      return 0;
    }
    if (IN_ROOM(vict) != NOWHERE) {      /* Another Eric Green special. */
      char_from_room(vict);
    }
    char_to_room(vict, i);
    break;
  case 36: /* siteok */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_SITEOK);
    break;
  case 37: /* deleted */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_DELETED);
    break;
  case 38: /* class */
    if ((i = parse_class(*val_arg)) == CLASS_UNDEFINED) {
      send_to_char("That is not a class.\r\n", ch);
      return 0;
    }
    sprintf(out_to_log2, "%s changes %s's CLASS from '%s' to '%%s'.", GET_NAME(ch),
            GET_NAME(vict), pc_class_types[(int) GET_CLASS(vict)]);
    GET_CLASS(vict) = i;
    sprintf(out_to_log1, out_to_log2, pc_class_types[(int) GET_CLASS(vict)]);
    break;
  case 39: /* nowizlistable */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NOWIZLIST);
    break;
  case 40: /* quest */
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_QUEST);
    break;
  case 41: /* loadroom */
    if (!str_cmp(val_arg, "off")) {
      REMOVE_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
    } else if (is_number(val_arg)) {
      value = atoi(val_arg);
      if (real_room(value) != NOWHERE) {
        SET_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
        GET_LOADROOM(vict) = value;
        sprintf(output, "%s will enter at room #%d.", GET_NAME(vict),
                GET_LOADROOM(vict));
      } else {
        send_to_char("That room does not exist!\r\n", ch);
        return 0;
      }
    } else {
      send_to_char("Must be 'off' or a room's virtual number.\r\n", ch);
      return 0;
    }
    break;
  case 42: /* color */
    SET_OR_REMOVE(PRF_FLAGS(vict), (PRF_COLOR_1 | PRF_COLOR_2));
    break;
  case 43: /* idnum */
    GET_IDNUM(vict) = value;
    break;
  case 44: /* password */
    if (GET_LEVEL(vict) == LVL_IMPL && ch != vict) {
      send_to_char("You cannot change that.\r\n", ch);
      return 0;
    }
    strncpy(GET_PASSWD(vict), CRYPT(val_arg, GET_NAME(vict)), MAX_PWD_LENGTH);
    *(GET_PASSWD(vict) + MAX_PWD_LENGTH) = '\0';
    sprintf(output, "Password changed to '%s'.", val_arg);
    break;
  case 45: /* nodelete */
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NODELETE);
    break;
  case 46: /* sex */
    if (!str_cmp(val_arg, "male"))
      vict->player.sex = SEX_MALE;
    else if (!str_cmp(val_arg, "female"))
      vict->player.sex = SEX_FEMALE;
    else if (!str_cmp(val_arg, "neutral"))
      vict->player.sex = SEX_NEUTRAL;
    else {
      send_to_char("Must be 'male', 'female', or 'neutral'.\r\n", ch);
      return 0;
    }
    break;
  case 47: /* age */
    if (value < 2 || value > 200) {     /* Arbitrary limits. */
      send_to_char("Ages 2 to 200 accepted.\r\n", ch);
      return 0;
    }
    /*
     * NOTE: May not display the exact age specified due to the integer
     * division used elsewhere in the code.  Seems to only happen for
     * some values below the starting age (17) anyway. -gg 5/27/98
     */
    ch->player.time.birth = time(0) - ((value - 17) * SECS_PER_MUD_YEAR);
    break;
  case 48: /* olc */
    GET_OLC_ZONE(vict) = value;
    break;

  case 49: /* crossdoors */
    SET_OR_REMOVE(PRF_FLAGS(vict), PRF_CROSSDOORS);
    break;

  case 50: /* name */
    strncpy(GET_NAME(vict), CRYPT(val_arg, GET_NAME(vict)), MAX_NAME_LENGTH);
    *(GET_NAME(vict) + MAX_NAME_LENGTH) = '\0';
    sprintf(output, "Name changed to '%s'.", val_arg);
    break;

  case 51: /* points */
    GET_POINTS(vict) = value;
    break;

  case 52: /* email */
    strncpy(vict->player.email, val_arg, MAX_EMAIL_LENGTH);
    *(GET_EMAIL(vict) + MAX_EMAIL_LENGTH) = '\0';
    sprintf(buf, "%s's email is now: %s", GET_NAME(vict), GET_EMAIL(vict));
    break;

  case 53:
    if ((i = parse_race(*val_arg)) == RACE_UNDEFINED) {
      send_to_char("That is not a race.\r\n", ch);
      return 0;
    }
    GET_RACE(vict) = i;
    break;

  case 54:
    if ((value < 0) || (value > 99)) {
      send_to_char("Values between 0 and 99 are allowed.\r\n", ch);
      return 0;
    }
    GET_REMORT(vict) = value;
    break;

  case 55:
    if ((value < 0) || (value > 3)) {
      send_to_char("Values between 0 and 3 are allowed.\r\n", ch);
      return 0;
    }
    GET_FBI_POS(vict) = value;
    break;
  case 56:
    SET_OR_REMOVE(PLR_FLAGS(vict), PLR_NOPK);
    break;
  case 57:
    GET_QUEST(vict) = value;
    break;
  case 58: /* maxmental */
    vict->points.max_mental = RANGE(1, 500000);
    affect_total(vict);
    break;
  case 59: /* qpoints */
    GET_QP(vict) = value;
	break;
  case 60: /* House vnum */
    HOUSE(vict) = value;
	break;
  case 61:
    GET_RP(vict) = RANGE(0, 10000);
	break;
  default:
    send_to_char("Can't set that!\r\n", ch);
    return 0;
  }
  return 1;
}


ACMD(do_set)
{
  struct char_data *vict = NULL, *cbuf = NULL;
  char field[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH],
        val_arg[MAX_INPUT_LENGTH];
  int mode = -1, len = 0, player_i = 0, retval;
  char is_file = 0, is_mob = 0, is_player = 0;
  int i = 0;
  int conta = 0;

  half_chop(argument, name, buf);

  if (!strcmp(name, "file")) {
    is_file = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "player")) {
    is_player = 1;
    half_chop(buf, name, buf);
  } else if (!str_cmp(name, "mob")) {
    is_mob = 1;
    half_chop(buf, name, buf);
  }
  half_chop(buf, field, buf);
  strcpy(val_arg, buf);

  if (!*name || !*field) {
    send_to_char("Usage: set <victim> <field> <value>\r\n", ch);
    sprintf(buf, "As %s %s you can set the following fields:\r\n",
                 strchr("aeiouyAEIOUY", *GET_GOD_NAME(ch))?"an":"a",
                 GET_GOD_NAME(ch));
    send_to_char(buf, ch);
    conta=0;
    for (i=0; set_fields[i].cmd != "\n"; i++) {
      if (GET_LEVEL(ch) >= set_fields[i].level) {
        conta=(conta==4?1:conta+1);
        sprintf(buf, "[%3d] %-13s%s", set_fields[i].level,
                set_fields[i].cmd, (conta==4?"\r\n":" "));
        send_to_char(buf, ch);
      }
    }
    if (conta != 4) send_to_char("\r\n", ch);
    return;
  }

  /* find the target */
  if (!is_file) {
    if (is_player) {
      if (!(vict = get_player_vis(ch, name, 0))) {
        send_to_char("There is no such player.\r\n", ch);
        return;
      }
    } else {
      if (!(vict = get_char_vis(ch, name))) {
        send_to_char("There is no such creature.\r\n", ch);
        return;
      }
    }
  }
  else if (is_file) {
    if (mode == 35 || mode == 51) {
      send_to_char("You can't set this in the playerfile.\r\n", ch);
      return;
    }
    /* try to load the player off disk */
    CREATE(cbuf, struct char_data, 1);
    clear_char(cbuf);
    CREATE(cbuf->player_specials, struct player_special_data, 1);
    if ((player_i = load_char(name, cbuf)) > -1) {
      if (GET_LEVEL(cbuf) >= GET_LEVEL(ch)) {
        free_char(cbuf);
        send_to_char("Sorry, you can't do that.\r\n", ch);
        return;
      }
      vict = cbuf;
    }
    else {
      free_char(cbuf);
      send_to_char("There is no such player.\r\n", ch);
      return;
    }
  }

  /* find the command in the list */
  len = strlen(field);
  for (mode = 0; *(set_fields[mode].cmd) != '\n'; mode++)
    if (!strncmp(field, set_fields[mode].cmd, len))
      break;

  /* perform the set */
  retval = perform_set(ch, vict, mode, val_arg);

  /* save the character if a change was made */
  if (retval) {
    if (!is_file && !IS_NPC(vict))
      save_char(vict, NOWHERE);
    if (is_file) {
      GET_PFILEPOS(cbuf) = player_i;
      save_char(cbuf, GET_LOADROOM(cbuf));
      send_to_char("Saved in file.\r\n", ch);
    }
  }

  /* free the memory if we allocated it earlier */
  if (is_file)
    free_char(cbuf);
}


int find_skill_num(char *name);
extern struct spell_info_type spell_info[];

char *two_argumentss(char *argument, char *first_arg, char *second_arg)
{
  return one_word(one_word(argument, first_arg), second_arg); /* :-) */
}

int was_class(struct char_data *ch, int num)
{
  int x, c = -1;

     for(x = 1; x <= GET_REMORT(ch); x++)
        if(GET_CLASS_REMORT(ch, x) == num)
		c++;

  return (c);
}

int already_have(struct char_data *ch, int num)
{
  int w, x, r;

     r = (GET_REMORT(ch) > 0 ? GET_REMORT(ch) : 1);
     for(x = 0; x <= r; x++)
	  for(w = 0; w < MAX_RSKILLS; w++)
              if(GET_RSKILL(ch, x, w) == num)
	         return (num);

  return (0);
}

#define REMORT_TEXT \
"WarDome II - REMORT SYSTEM\r\n" \
"\r\n" \
"First of all, you can choose a maximum of 5 skills to keep after remorting:\r\n" \
"   remort skill <skill\\spell> -> the complete name\r\n" \
"\r\n" \
"After that, choose a class to remort with:\r\n" \
"   remort class <class letter>\r\n" \
"To see the letter of your future class, type: 'remort class'. It will show\r\n" \
"a list of classes and their letters.\r\n" \
"\r\n" \
"Every class you remort will be recorded. The same with your remort\r\n" \
"skills. Each skill you pick costs 1,000,000 and class 2,000,000. Choose\r\n" \
"wisely.\r\n" \
"\r\n" \
"&YCOST&n: A complete remort costs 7,000,000 coins.\r\n" \
"&RWARNING&n: Do not save in the remort process, you can lose gold.\r\n"

ACMD(do_remort)
{
  int x = 0, y = 0, i, w, c =  0, t = 0;
  int parse_class(char arg);
  char argum[MAX_INPUT_LENGTH], argum1[MAX_INPUT_LENGTH];
  ACMD(do_rskills);

  strcpy(argum1, one_argument(argument, argum));

  if (GET_LEVEL(ch) > LVL_GOREMORT) {
  	send_to_char("You are too experienced to remort.\r\n", ch);
        return;
  }

  if (GET_LEVEL(ch) < LVL_GOREMORT) {
	if(GET_REMORT(ch)) {
		do_rskills(ch, NULL, 0, 0);
		return;
	} else {
	  	send_to_char("You need more experience to remort.\r\n", ch);
        	return;
	}
  }

  if(!str_cmp(argum, "class")) {
    if(GET_GOLD(ch) < 2000000) {
       	send_to_char("You need 2,000,000 gold in cash to set a class.\r\n", ch);
       	return;
    }
    if(!*argum1) {
          send_to_char("&WPick a class to remort:&n\r\n\r\n", ch);
          for(i = 0; i < NUM_CLASSES; i++)
   	   if(allowed_classes(GET_RACE(ch), i)) {
   	   	sprintf(buf,"		%s %s%s\r\n", pc_clsl_types[i], (was_class(ch, i) != -1 ? "!Remorted! " : ""), (GET_CLASS(ch) == i ? "*Current Class*" : ""));
              	send_to_char(buf, ch);
   	   }
	  return;
    }

    y = GET_CLASS(ch);
    if (((x = parse_class(argum1[1])) == CLASS_UNDEFINED) ||
      !allowed_classes(GET_RACE(ch), x)){
      send_to_char("That is not a class.\r\n", ch);
      return;
    }

    if (GET_CLASS(ch) == x) {
      send_to_char("You can't remort with your current class.\r\n", ch);
      return;
    }

      for (w = 0; w < NUM_WEARS; w++){
        if (GET_EQ(ch, w))
            obj_to_char(unequip_char(ch, w), ch);
      }

        GET_INVIS_LEV(ch) = 0;
    	GET_CLASS(ch) = x;
	GET_REMORT(ch) += 1;
	GET_LEVEL(ch) = 1;
	GET_MAX_HIT(ch) = MAX(1, GET_MAX_HIT(ch) * 0.02);
	GET_MAX_MANA(ch) = MAX(1, GET_MAX_MANA(ch) * 0.02);
	GET_MAX_MOVE(ch) = MAX(1, GET_MAX_MOVE(ch) * 0.02);
	GET_MAX_MENTAL(ch) = 1;
	GET_HIT(ch) = GET_MAX_HIT(ch);
	GET_MOVE(ch) = GET_MAX_MOVE(ch);
	GET_MANA(ch) = GET_MAX_MANA(ch);
	GET_MENTAL(ch) = GET_MAX_MENTAL(ch);
	GET_EXP(ch) = 0;
	GET_POINTS(ch) = 7+GET_REMORT(ch);
        GET_STYLE(ch) = 2 ; // pode ser qq estilo que nao seja pro(3) ;
	GET_GOLD(ch) -= 2000000;
	GET_CLASS_REMORT(ch, (int)GET_REMORT(ch)) = y;

	if (PRF_FLAGGED(ch, PRF_NOHASSLE))
	  REMOVE_BIT(PRF_FLAGS(ch), PRF_NOHASSLE);
	if (PRF_FLAGGED(ch, PRF_HOLYLIGHT))
	  REMOVE_BIT(PRF_FLAGS(ch), PRF_HOLYLIGHT);
	if (PRF_FLAGGED(ch, PRF_LOG1))
	  REMOVE_BIT(PRF_FLAGS(ch), PRF_LOG1);
	if (PRF_FLAGGED(ch, PRF_LOG2))
	  REMOVE_BIT(PRF_FLAGS(ch), PRF_LOG2);
	if (PRF_FLAGGED(ch, PRF_CROSSDOORS))
	  REMOVE_BIT(PRF_FLAGS(ch), PRF_CROSSDOORS);
	if (!PLR_FLAGGED(ch, PLR_NODELETE))
          SET_BIT(PLR_FLAGS(ch), PLR_NODELETE);

	for (t = 1; t < MAX_SKILLS+1; t++)
		GET_SKILL_LS(ch, t) = 0;

        actualize_splskl(ch);
        Crash_crashsave(ch);
        save_char(ch, NOWHERE);
	check_autowiz(ch);

	if (ch->followers || ch->master)
	 die_follower(ch);

        sprintf(buf, "(REMORT) %s was %s, remorted with %s", GET_NAME(ch), pc_class_types[(int) y], pc_class_types[(int) x]);
        mudlog(buf, BRF, LVL_GRGOD, TRUE);

	send_to_char("\r\n"
		"You feel your blood bubbling in your heart.\r\n"
		"You can see the death angel waiting for you.\r\n"
		"The death angel takes your spirit and disappears...\r\n"
		"The death angel appears in front of you and recite some legendary words.\r\n"
		"You feel your spirit in a strange new body.\r\n"
		"You now begin a new life, with the power of the death angel!\r\n"
		"\r\n"
		"You are the next remort generation of WarDome II.\r\n", ch);
  } else if(!str_cmp(argum, "skill")) {
        if(GET_GOLD(ch) < 1000000) {
           send_to_char("You need 1,000,000 gold in cash to set a skill.\r\n", ch);
           return;
        }

	if(!*argum1) {
	  send_to_char("&WPick a skill to remort with.&n\r\n", ch);
	  return;
	}

	c = GET_CLASS(ch);
	if(((y = find_skill_num(argum1)) == -1) ||
	    spell_info[y].min_level[c] > GET_LEVEL(ch)) {
	  send_to_char("&WYou have not that skill.&n\r\n", ch);
	  return;
	}
/* trava msm skill...
	if(already_have(ch, y)) {
	  send_to_char("&WYou already have this remort skill.&n\r\n", ch);
	  return;
	} */
	for(w = 0; w < MAX_RSKILLS && !x; w++) {
            if(!GET_RSKILL(ch, ((int)GET_REMORT(ch)+1), w)) {
	       x++;
	       GET_RSKILL(ch, ((int)GET_REMORT(ch)+1), w) = y;
	       GET_GOLD(ch) -= 1000000;
	       sprintf(buf, "&R%d &Wability: &c%s&W.&n\r\n", (w+1), spells[GET_RSKILL(ch, (int)GET_REMORT(ch)+1, w)]);
	       send_to_char(buf, ch);
	    }
	}
	if(!x)
	   send_to_char("&WYou already have &R5&W remort &cskills&W.&n\r\n", ch);
  } else
     send_to_char(REMORT_TEXT, ch);
}

ACMD(do_chown)
{
  struct char_data *victim;
  struct obj_data *obj;
  char buf2[80];
  char buf3[80];
  int i, k = 0;

  two_arguments(argument, buf2, buf3);

  if (!*buf2)
    send_to_char("Syntax: chown <object> <character>.\r\n", ch);
  else if (!(victim = get_char_vis(ch, buf3)))
    send_to_char("No one by that name here.\r\n", ch);
  else if (victim == ch)
    send_to_char("Are you sure you're feeling ok?\r\n", ch);
  else if (GET_LEVEL(victim) >= GET_LEVEL(ch))
    send_to_char("That's really not such a good idea.\r\n", ch);
  else if (!*buf3)
    send_to_char("Syntax: chown <object> <character>.\r\n", ch);
  else {
    for (i = 0; i < NUM_WEARS; i++) {
      if (GET_EQ(victim, i) && CAN_SEE_OBJ(ch, GET_EQ(victim, i)) &&
         isname(buf2, GET_EQ(victim, i)->name)) {
        obj_to_char(unequip_char(victim, i), victim);
        k = 1;
      }
    }

  if (!(obj = get_obj_in_list_vis(victim, buf2, victim->carrying))) {
    if (!k && !(obj = get_obj_in_list_vis(victim, buf2, victim->carrying))) {
      sprintf(buf, "%s does not appear to have the %s.\r\n", GET_NAME(victim), buf2);
      send_to_char(buf, ch);
      return;
    }
  }

  act("$n makes a magical gesture and $p flies from $N to $m.",FALSE,ch,obj,
       victim,TO_NOTVICT);
  act("$n makes a magical gesture and $p flies away from you to $m.",FALSE,ch,
       obj,victim,TO_VICT);
  act("You make a magical gesture and $p flies away from $N to you.",FALSE,ch,
       obj, victim,TO_CHAR);

  obj_from_char(obj);
  obj_to_char(obj, ch);
  save_char(ch, NOWHERE);
  save_char(victim, NOWHERE);
  }

}

ACMD(do_xname)
{
   char tempname[MAX_INPUT_LENGTH];
   int i = 0;
   FILE *fp;
   *buf = '\0';

   one_argument(argument, buf);

   if(!*buf)
      send_to_char("Xname which name?\r\n", ch);
   if(!(fp = fopen(XNAME_FILE, "a"))) {
      perror("Problems opening xname file for do_xname");
      return;
   }
   strcpy(tempname, buf);
   for (i = 0; tempname[i]; i++)
      tempname[i] = LOWER(tempname[i]);
   fprintf(fp, "%s\n", tempname);
   fclose(fp);
   sprintf(buf1, "%s has been xnamed!\r\n", tempname);
   send_to_char(buf1, ch);
   Read_Invalid_List();
}

ACMD(do_seelog)
{
  FILE *req_file;
  int cur_line = 0,
      num_lines = 0,
      req_lines = 0,
      i;
  int l, count = 0;
  char field[MAX_INPUT_LENGTH],
       value[MAX_INPUT_LENGTH];

  struct file_struct {
    char *cmd;
    int level;
    char *file;
  } fields[] = {
    { "none",           LVL_IMPL,    "Does Nothing" },
    { "syslog",         LVL_IMPL,    "../syslog" },
    { "crash",          LVL_MJGOD,  "../syslog.CRASH" },
    { "levels",         LVL_GRGOD,   "../log/levels" },
    { "rip",            LVL_GRGOD,   "../log/rip" },
    { "new players",    LVL_GRGOD,   "../log/newplayers" },
    { "rentgone",       LVL_GRGOD,   "../log/rentgone" },
    { "godcmds",        LVL_SUBIMPL,    "../log/godcmds" },
    { "sets",           LVL_SUBIMPL,    "../log/sets" },
    { "remort",         LVL_GRGOD,   "../log/remort" },
    { "pkilling",       LVL_GRGOD,   "../log/pkilling" },
    { "errors",         LVL_MJGOD,  "../log/errors" },
    { "dts",            LVL_GRGOD,   "../log/dts" },
    { "restarts",       LVL_SUBIMPL,  "../log/restarts" },
    { "badpws",         LVL_GRGOD,  "../log/badpws" },
    { "delete",         LVL_SUPGOD,  "../log/delete" },
    { "olc",		LVL_OLC_FULL,  "../log/olc"},
    { "help",		LVL_SUPGOD,  "../log/help"},
    { "bug",	        LVL_MJGOD,   "../lib/misc/bugs"},
    { "typo",		LVL_SUPGOD,   "../lib/misc/typos"},
    { "ideas",		LVL_MJGOD,   "../lib/misc/ideas"},
    { "xnames",		LVL_SUPGOD,  "../lib/misc/xnames"},
    { "quests",		LVL_OLC_FULL,  "../log/quest"},
    { "revive",		LVL_MJGOD,  "../log/revive"},
    { "\n", 0, "\n" }
  };

  skip_spaces(&argument);

  if (!*argument) {
    sprintf(buf, "As %s %s you can access this logs:\r\n",
         strchr("aeiouyAEIOUY", *GET_GOD_NAME(ch))?"an":"a", GET_GOD_NAME(ch));
    send_to_char(buf, ch);
    count=0;
    for (i=1; fields[i].cmd != "\n"; i++) {
      if (GET_LEVEL(ch) >= fields[i].level) {
        count=(count==4?1:count+1);
        sprintf(buf, "[%3d] %-13s%s", fields[i].level,
                fields[i].cmd, (count==4?"\r\n":" "));
        send_to_char(buf, ch);
      }
    }
    if (count != 4) send_to_char("\r\n", ch);
    return;
  }

  strcpy(arg, two_arguments(argument, field, value));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if(*(fields[l].cmd) == '\n')
  {
    send_to_char("That is not a valid option!\r\n", ch);
    return;
  }

  if (GET_LEVEL(ch) < fields[l].level)
  {
    send_to_char("You are not godly enough to view that file!\r\n", ch);
    return;
  }

  if(!*value)
     req_lines = 20;
  else
     req_lines = atoi(value);

  if (!(req_file=fopen(fields[l].file,"r")))
  {
     sprintf(buf2, "SYSERR: Error opening file %s using 'seelog' command.",
             fields[l].file);
     mudlog(buf2, BRF, LVL_IMPL, TRUE);
     return;
  }

  get_line(req_file,buf);
  while (!feof(req_file))
  {
     num_lines++;
     get_line(req_file,buf);
  }
  fclose(req_file);


  if(req_lines > num_lines) req_lines = num_lines;
  if(req_lines > 15000) req_lines = 15000;


  if (!(req_file=fopen(fields[l].file,"r")))
  {
     sprintf(buf2, "SYSERR: Error opening file %s using 'seelog' command.",
             fields[l].file);
     mudlog(buf2, BRF, LVL_IMPL, TRUE);
     return;
  }

  buf2[0] = '\0';

  get_line(req_file,buf);
  while (!feof(req_file))
  {
     cur_line++;
     if(cur_line > (num_lines - req_lines))
     {
        sprintf(buf2,"%s%s\r\n",buf2, buf);
     }
     get_line(req_file,buf);
   }
   page_string(ch->desc, buf2, 1);


   fclose(req_file);
}

ACMD(do_tedit)
{
   int l, i;
   char field[MAX_INPUT_LENGTH];
   extern char *credits;
   extern char *news;
   extern char *motd;
   extern char *imotd;
   extern char *help;
   extern char *info;
   extern char *background;
   extern char *handbook;
   extern char *policies;

   struct editor_struct {
      char *cmd;
      int level;
      char *buffer;
      int  size;
      char *filename;
   } fields[] = {
      /* edit the lvls to your own needs */
	{ "credits",	LVL_IMPL,	credits,	2400,	CREDITS_FILE},
	{ "news",	LVL_MJGOD,	news,		8192,	NEWS_FILE},
	{ "motd",	LVL_GRGOD,	motd,		2400,	MOTD_FILE},
	{ "imotd",	LVL_GRGOD,	imotd,		2400,	IMOTD_FILE},
	{ "phelp",      LVL_SUPGOD,	help,		2400,	HELP_PAGE_FILE},
	{ "info",	LVL_SUBIMPL,	info,		8192,	INFO_FILE},
	{ "qotw",	LVL_GOD,	background,	8192,	BACKGROUND_FILE},
	{ "handbook",   LVL_IMPL,	handbook,	8192,   HANDBOOK_FILE},
	{ "policies",	LVL_MJGOD,	policies,	8192,	POLICIES_FILE},
	{ "\n",		0,		NULL,		0,	NULL }
   };

   if (ch->desc == NULL) {
      send_to_char("Get outta here you linkdead head!\r\n", ch);
      return;
   }

   half_chop(argument, field, buf);


   if (!*field) {
      sprintf(buf, "As %s %s you can edit:\r\n",
           strchr("aeiouyAEIOUY", *GET_GOD_NAME(ch))?"an":"a", GET_GOD_NAME(ch));
      i = 1;
      for (l = 0; *fields[l].cmd != '\n'; l++) {
	 if (GET_LEVEL(ch) >= fields[l].level) {
	    sprintf(buf, "%s[%3d] %-13.13s%s", buf, fields[l].level, fields[l].cmd, (i == 4 ? "\r\n" : " "));
	    i++;
	 }
      }
      if (--i % 4) strcat(buf, "\r\n");
      if (i == 0) strcat(buf, "None.\r\n");
      send_to_char(buf, ch);
      return;
   }

   for (l = 0; *(fields[l].cmd) != '\n'; l++)
     if (!strncmp(field, fields[l].cmd, strlen(field)))
     break;

   if (*fields[l].cmd == '\n') {
      send_to_char("Invalid text editor option.\r\n", ch);
      return;
   }

   if (GET_LEVEL(ch) < fields[l].level) {
      send_to_char("You are not godly enough for that!\r\n", ch);
      return;
   }

   switch (l) {
    case 0: ch->desc->str = &credits; break;
    case 1: ch->desc->str = &news; break;
    case 2: ch->desc->str = &motd; break;
    case 3: ch->desc->str = &imotd; break;
    case 4: ch->desc->str = &help; break;
    case 5: ch->desc->str = &info; break;
    case 6: ch->desc->str = &background; break;
    case 7: ch->desc->str = &handbook; break;
    case 8: ch->desc->str = &policies; break;
    default:
      send_to_char("Invalid text editor option.\r\n", ch);
      return;
   }

   /* set up editor stats */
   send_to_char("\x1B[J", ch);
   send_to_char("Now, edit the file: (/s saves /h for help)\r\n", ch);
   ch->desc->backstr = NULL;
   if (fields[l].buffer) {
      send_to_char(fields[l].buffer, ch);
      ch->desc->backstr = str_dup(fields[l].buffer);
   }
   ch->desc->max_str = fields[l].size;
   ch->desc->mail_to = 0;
   ch->desc->storage = str_dup(fields[l].filename);
   act("$n starts using OLC.", TRUE, ch, 0, 0, TO_ROOM);
   STATE(ch->desc) = CON_TEXTED;
   SET_BIT(PLR_FLAGS(ch), PLR_WRITING);

}

extern int top_of_objt;
extern int top_of_mobt;
extern int top_of_world;
extern int top_of_helpt;
extern int top_of_socialt;
extern int top_of_aquestt;
extern int top_shop;
extern int top_of_zone_table;
extern int top_of_p_file;

void show_mreport(struct char_data *ch)
{
  int i, x = 0, j = 0;
  struct char_data *vict;

  for (vict = character_list; vict; vict = vict->next)
    if (vict->desc)
      j++;

  for (i = 0; i <= top_of_zone_table; i++)
      x++;

  strcpy(buf, "Memory Report\r\n");
  strcat(buf, "-------------\r\n");
  sprintf(buf, "%s          %7s %4s %10s\r\n", buf, "Number", "Byte", "Total Used");
  sprintf(buf, "%sPlayers  :%7d %4d %10d\r\n", buf, j, sizeof(struct char_data) + sizeof(struct descriptor_data), (j) * (sizeof(struct char_data) + sizeof(struct descriptor_data)));
  sprintf(buf, "%sObjects  :%7d %4d %10d\r\n", buf, top_of_objt + 1, sizeof(struct obj_data), (top_of_objt + 1) * sizeof(struct obj_data));
  sprintf(buf, "%sMobProto :%7d %4d %10d\r\n", buf, top_of_mobt + 1, sizeof(struct char_data), (top_of_mobt + 1) * sizeof(struct char_data));
  sprintf(buf, "%sRooms    :%7d %4d %10d\r\n", buf, top_of_world + 1, sizeof(struct room_data), (top_of_world + 1) * sizeof(struct room_data));
  sprintf(buf, "%sHelp     :%7d %4d %10d\r\n", buf, top_of_helpt + 1, sizeof(struct help_index_element), (top_of_helpt + 1) * sizeof(struct help_index_element));
  sprintf(buf, "%sSocials  :%7d %4d %10d\r\n", buf, top_of_socialt + 1, sizeof(struct command_info), (top_of_socialt + 1) * sizeof(struct command_info));
  sprintf(buf, "%sQuests   :%7d \r\n", buf, top_of_aquestt + 1);
  sprintf(buf, "%sShops    :%7d \r\n", buf, top_shop + 1);
  sprintf(buf, "%sZones    :%7d %4d %10d\r\n", buf, top_of_zone_table + 1, sizeof(struct zone_data), (top_of_zone_table + 1) * sizeof(struct zone_data));
  send_to_char(buf, ch);
}

ACMD(do_playerlink)
{
  struct char_data *victim = NULL;
  char *action = arg, *vict = buf2;

  two_arguments(argument, action, vict);

  if (!*action || !*vict) {
    send_to_char("Usage: playerlink [ load | remove ] <player>\r\n", ch);
    return;
  }
  if (is_abbrev(action, "load")) {
    if (get_player_vis(ch, vict, 0)) {
      send_to_char("That player is already connected/loaded!\r\n", ch);
      return;
    }
    CREATE(victim, struct char_data, 1);
    clear_char(victim);
    CREATE(victim->player_specials, struct player_special_data, 1);
    if (load_char(vict, victim) > -1) {
      if (GET_LEVEL(victim) < GET_LEVEL(ch)) {
	Crash_load(victim);
	victim->next = character_list;
	character_list = victim;
	victim->desc = NULL;
	char_to_room(victim, ch->in_room);
	act("You gesture and a statue of $N forms from nothingness.",
	    FALSE, ch, 0, victim, TO_CHAR);
	act("$n gestures and a statue of $N appears from nowhere.", FALSE,
	    ch, 0, victim, TO_NOTVICT);
	/* read_aliases(victim); */
	sprintf(buf, "(GC) %s has loaded %s.", GET_NAME(ch),
		GET_NAME(victim));
	mudlog(buf, BRF, MAX(LVL_IMPL, GET_INVIS_LEV(ch)), TRUE);
      } else {
	send_to_char("Sorry, you aren't high enough level to load that char.\r\n", ch);
	free_char(victim);
      }
    } else {
      send_to_char("No such player.\r\n", ch);
      free(victim);
    }
  } else if (is_abbrev(action, "remove")) {
    if (!(victim = get_player_vis(ch, vict, 0))) {
      send_to_char("That player isn't in the game right now.\r\n", ch);
      return;
    } else if (victim->desc) {
      send_to_char("That player isn't linkdead.\r\n", ch);
      return;
    }
    act("You gesture and $N dissolves into nothingness.", FALSE, ch, 0,
	victim, TO_CHAR);
    act("$n gestures and $N dissolves into nothingness.", FALSE, ch, 0,
	victim, TO_NOTVICT);
    sprintf(buf, "(GC) %s has unloaded %s.", GET_NAME(ch), GET_NAME(victim));
   if (free_rent)
      Crash_rentsave(victim, 0);
      extract_char(victim);           /* Char is saved in extract char */
    mudlog(buf, BRF, MAX(LVL_IMPL, GET_INVIS_LEV(ch)), TRUE);
  } else {
  send_to_char("That isn't an option.\r\n", ch);
  return;
  }
}

extern int mother_desc, port;
void Crash_rentsave(struct char_data * ch, int cost);

#define EXE_FILE "bin/circle" /* maybe use argv[0] but it's not reliable */

/* (c) 1996-97 Erwin S. Andreasen <erwin@andreasen.org> */
ACMD(do_copyover)
{
	FILE *fp;
	struct descriptor_data *d, *d_next;
	char buf [100], buf2[100];

	fp = fopen (COPYOVER_FILE, "w");

	if (!fp)
	{
		send_to_char ("Copyover file not writeable, aborted.\n\r",ch);
		return;
	}

	/* Consider changing all saved areas here, if you use OLC */
	sprintf (buf, "\n\r*** WARDOME BOOT SYSTEM - Please remain seated! ***\n\r");

	/* For each playing descriptor, save its state */
	for (d = descriptor_list; d ; d = d_next)
	{
		struct char_data * och = d->character;
		d_next = d->next; /* We delete from the list , so need to save this */

		if (!d->character || d->connected > CON_PLAYING) /* drop those logging on */
		{
            write_to_descriptor (d->descriptor, "\n\rSorry, we are rebooting. Come back in a few minutes.\n\r");
			close_socket (d); /* throw'em out */
		}
		else
		{
			fprintf (fp, "%d %s %s\n", d->descriptor, GET_NAME(och), d->host);

        	    /* save och */
			write_aliases(och);
			save_char(och, och->in_room);
			Crash_crashsave(och);
			write_to_descriptor (d->descriptor, buf);
		}
	}

	fprintf (fp, "-1\n");
	fclose (fp);

	/* exec - descriptors are inherited */

	sprintf (buf, "%d", port);
    sprintf (buf2, "-C%d", mother_desc);

    /* Ugh, seems it is expected we are 1 step above lib - this may be dangerous! */
    chdir ("..");

	execl (EXE_FILE, "circle", buf2, buf, (char *) NULL);

	/* Failed - sucessful exec will not return */

	perror ("do_copyover: execl");
	send_to_char ("Copyover FAILED!\n\r",ch);

    exit (1); /* too much trouble to try to recover! */
}

ACMD(do_veq)
{
  char field[MAX_INPUT_LENGTH], value[MAX_INPUT_LENGTH];
  int i, j, l;

void vwear_object(int wearpos, struct char_data * ch)
{

  int nr, found = 0;

  *buf = '\0';
  for (nr = 0; nr <= top_of_objt; nr++) {
     if(GET_OBJ_TYPE(&obj_proto[nr]) == ITEM_KEY)
           continue;
     else if(wearpos == ITEM_WEAR_HOLD && (GET_OBJ_TYPE(&obj_proto[nr]) == ITEM_LIGHT ||
            GET_OBJ_TYPE(&obj_proto[nr]) == ITEM_WEAPON))
	   continue;
     else if(wearpos == ITEM_WEAR_TAKE && GET_OBJ_TYPE(&obj_proto[nr]) != ITEM_LIGHT)
	   continue;

     if (CAN_WEAR(&obj_proto[nr], wearpos))
        sprintf(buf+strlen(buf), "%3d. [%5d] %s\r\n", ++found,
          obj_index[nr].vnum, obj_proto[nr].short_description);

  }
  page_string(ch->desc, buf, 1);

}

struct listeq_struct {
    char *cmd;
    int level;
}
/* Change the LVL_GOD1 to your appropriate god levels */
  fields[] = {
    { "nothing", LVL_ELDER },
    { "finger", LVL_ELDER },
    { "neck", LVL_ELDER },
    { "body", LVL_ELDER },
    { "head", LVL_ELDER },
    { "legs", LVL_ELDER },
    { "feet", LVL_ELDER },
    { "hands", LVL_ELDER },
    { "shield", LVL_ELDER },
    { "arms", LVL_ELDER },
    { "about", LVL_ELDER },
    { "waist", LVL_ELDER },
    { "wrist", LVL_ELDER },
    { "wield", LVL_ELDER },
    { "hold", LVL_ELDER },
    { "ear", LVL_ELDER },
    { "face", LVL_ELDER },
    { "float", LVL_ELDER },
    { "light", LVL_ELDER },
/* Add any extra eq types here */
    { "\n", 0 }
  };

  skip_spaces(&argument);

  if (!*argument) {
    strcpy(buf, "List eq options:\r\n");
    for (j = 0, i = 1; fields[i].level; i++)
      if (fields[i].level <= GET_LEVEL(ch))
        sprintf(buf, "%s%-15s%s", buf, fields[i].cmd, (!(++j % 5) ? "\r\n" : ""));
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    return;
  }
  strcpy(arg, two_arguments(argument, field, value));

  for (l = 0; *(fields[l].cmd) != '\n'; l++)
    if (!strncmp(field, fields[l].cmd, strlen(field)))
      break;

  if (GET_LEVEL(ch) < fields[l].level) {
    send_to_char("You are not godly enough for that!\r\n", ch);
    return;
  }
  buf[0] = '\0';
  switch (l) {
/* The order is based on the above list.  Try and keep the same order */
/* otherwise you will get what you DON'T want */
    case 1:                     /* Finger eq */
      vwear_object(ITEM_WEAR_FINGER, ch);
      break;
    case 2:                     /* Neck eq */
      vwear_object(ITEM_WEAR_NECK, ch);
      break;
    case 3:                     /* Body eq */
      vwear_object(ITEM_WEAR_BODY, ch);
      break;
    case 4:                     /* Head eq */
      vwear_object(ITEM_WEAR_HEAD, ch);
      break;
    case 5:                     /* Leg eq */
      vwear_object(ITEM_WEAR_LEGS, ch);
      break;
    case 6:                     /* Foot eq */
      vwear_object(ITEM_WEAR_FEET, ch);
      break;
    case 7:                     /* Hand eq */
      vwear_object(ITEM_WEAR_HANDS, ch);
      break;
    case 8:                       /* Shield eq */
      vwear_object(ITEM_WEAR_SHIELD, ch);
      break;
    case 9:                       /* Arm eq */
      vwear_object(ITEM_WEAR_ARMS, ch);
      break;
    case 10:                       /* Worn about body eq */
      vwear_object(ITEM_WEAR_ABOUT, ch);
      break;
    case 11:                       /* Waist eq */
      vwear_object(ITEM_WEAR_WAIST, ch);
      break;
    case 12:                       /* Wrist eq */
      vwear_object(ITEM_WEAR_WRIST, ch);
      break;
    case 13:                       /* Wielded objects */
      vwear_object(ITEM_WEAR_WIELD, ch);
      break;
    case 14:                       /* Held eq */
      vwear_object(ITEM_WEAR_HOLD, ch);
      break;
    case 15:                       /* Ear eq */
      vwear_object(ITEM_WEAR_EAR, ch);
      break;
    case 16:                       /* Face eq */
      vwear_object(ITEM_WEAR_FACE, ch);
      break;
    case 17:                       /* Float eq */
      vwear_object(ITEM_WEAR_FLOAT, ch);
      break;
    case 18:                       /* Float eq */
      vwear_object(ITEM_WEAR_TAKE, ch);
      break;
/* You add any other eq types here */
    default:
      send_to_char("Come again?\r\n", ch);
      break;
  }
}

int zona_do_mob(int vnum)
{
	short int zona = 0;

	zona = (vnum - (vnum % 100)) / 100;

	return (zona);
}

ACMD(do_mobfix)
{
	int mob_num, zone, mobs = 0, remorts;
	char zona[20], remort[20];

	half_chop(argument, zona, remort);

	if(!*zona)
	{
		send_to_char("Formato: mobfix <zona> <remort>.\r\n", ch);
		return;
	}

	if(!*remort)
		remorts = 0;
	else
	{
		remorts = atoi(remort);
		if(remorts < 0)
		{
			send_to_char("Nao existe mob com remort negativo.\r\n", ch);
			return;
		}
	}
	zone = atoi(zona);

	for (mob_num = 0; mob_num <= top_of_mobt; mob_num++)
	{
		if(zona_do_mob(mob_index[mob_num].vnum) == zone)
		{
			GET_REMORT(mob_proto + mob_num) = remorts;
			mob_proto[mob_num].points.hit = 1;
			mob_proto[mob_num].points.mana = 1;
			if(GET_LEVEL(mob_proto + mob_num) < 70 && GET_REMORT(mob_proto + mob_num) == 0)
				mob_proto[mob_num].points.move = ((((7+(GET_REMORT(mob_proto + mob_num)*2))*GET_LEVEL(mob_proto + mob_num))/3)*12)*0.75;
			else
				mob_proto[mob_num].points.move = (((7+(GET_REMORT(mob_proto + mob_num)*2))*GET_LEVEL(mob_proto + mob_num))/3)*12;
			GET_EXP(mob_proto + mob_num) = (level_exp(GET_REMORT(mob_proto + mob_num), GET_LEVEL(mob_proto + mob_num))/17.5);
			GET_GOLD(mob_proto + mob_num) = (GET_LEVEL(mob_proto + mob_num)*15);
			mob_proto[mob_num].points.damroll = (GET_LEVEL(mob_proto + mob_num)/5)*2;
			mob_proto[mob_num].points.hitroll = (GET_LEVEL(mob_proto + mob_num)/4)*2;
			mob_proto[mob_num].mob_specials.damnodice = 10;
			mob_proto[mob_num].mob_specials.damsizedice = (GET_LEVEL(mob_proto + mob_num)/10 * ((100 + (GET_REMORT(mob_proto + mob_num) * 13))/100)) + 1;
			mob_proto[mob_num].points.armor = (100 + ((GET_LEVEL(mob_proto + mob_num)/2)*(-3)));
			mobs++;
		}

	}
	if(!mobs)
	{
		send_to_char("No mobs were changed.\r\n", ch);
		return;
	}
	else
	{
		sprintf(buf, "&WMobs changed: &R%dR%d&W.&n\r\n&WDo not &Rforget &Wto save zone info. &cType &COLC&c.&n\r\n", mobs, remorts);
		send_to_char(buf, ch);
		olc_add_to_save_list(zone, OLC_SAVE_MOB);
	}
}
::::::::::::::
aedit.c
::::::::::::::
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * File: aedit.c                                                   *
 * Comment: OLC for MUDs -- this one edits socials                 *
 * by Michael Scott <scottm@workcomm.net> -- 06/10/96              *
 * for use with OasisOLC                                           *
 * ftpable from ftp.circlemud.org:/pub/CircleMUD/contrib/code      *
 * Part of OLC+                                                    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "interpreter.h"
#include "handler.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "olc.h"
#include "screen.h"

extern int		       	 top_of_socialt;
extern struct social_messg	*soc_mess_list;
extern char			*position_types[];

/* WARNING: if you have added diagonal directions and have them at the
 * beginning of the command list.. change this value to 11 or 15 (depending) */
/* reserve these commands to come straight from the cmd list then start
 * sorting */
#define RESERVE_CMDS		7

/* external functs */
void sort_commands(void); /* aedit patch -- M. Scott */
void create_command_list(void);
void free_action(struct social_messg *action);


/* function protos */
void aedit_disp_menu(struct descriptor_data * d);
void aedit_parse(struct descriptor_data * d, char *arg);
void aedit_setup_new(struct descriptor_data *d);
void aedit_setup_existing(struct descriptor_data *d, int real_num);
void aedit_save_to_disk(struct descriptor_data *d);
void aedit_save_internally(struct descriptor_data *d);



/*
 * Utils and exported functions.
 */

void aedit_setup_new(struct descriptor_data *d) {
   CREATE(OLC_ACTION(d), struct social_messg, 1);
   OLC_ACTION(d)->command = str_dup(OLC_STORAGE(d));
   OLC_ACTION(d)->sort_as = str_dup(OLC_STORAGE(d));
   OLC_ACTION(d)->hide    = 0;
   OLC_ACTION(d)->min_victim_position = POS_STANDING;
   OLC_ACTION(d)->min_char_position   = POS_STANDING;
   OLC_ACTION(d)->min_level_char      = 0;
   OLC_ACTION(d)->char_no_arg = str_dup("This action is unfinished.");
   OLC_ACTION(d)->others_no_arg = str_dup("This action is unfinished.");
   OLC_ACTION(d)->char_found = NULL;
   OLC_ACTION(d)->others_found = NULL;
   OLC_ACTION(d)->vict_found = NULL;
   OLC_ACTION(d)->not_found = NULL;
   OLC_ACTION(d)->char_auto = NULL;
   OLC_ACTION(d)->others_auto = NULL;
   OLC_ACTION(d)->char_body_found = NULL;
   OLC_ACTION(d)->others_body_found = NULL;
   OLC_ACTION(d)->vict_body_found = NULL;
   OLC_ACTION(d)->char_obj_found = NULL;
   OLC_ACTION(d)->others_obj_found = NULL;
   aedit_disp_menu(d);
   OLC_VAL(d) = 0;
}

/*------------------------------------------------------------------------*/

void aedit_setup_existing(struct descriptor_data *d, int real_num) {
   CREATE(OLC_ACTION(d), struct social_messg, 1);
   OLC_ACTION(d)->command = str_dup(soc_mess_list[real_num].command);
   OLC_ACTION(d)->sort_as = str_dup(soc_mess_list[real_num].sort_as);
   OLC_ACTION(d)->hide    = soc_mess_list[real_num].hide;
   OLC_ACTION(d)->min_victim_position = soc_mess_list[real_num].min_victim_position;
   OLC_ACTION(d)->min_char_position   = soc_mess_list[real_num].min_char_position;
   OLC_ACTION(d)->min_level_char      = soc_mess_list[real_num].min_level_char;
   if (soc_mess_list[real_num].char_no_arg)
     OLC_ACTION(d)->char_no_arg = str_dup(soc_mess_list[real_num].char_no_arg);
   if (soc_mess_list[real_num].others_no_arg)
     OLC_ACTION(d)->others_no_arg = str_dup(soc_mess_list[real_num].others_no_arg);
   if (soc_mess_list[real_num].char_found)
     OLC_ACTION(d)->char_found = str_dup(soc_mess_list[real_num].char_found);
   if (soc_mess_list[real_num].others_found)
     OLC_ACTION(d)->others_found = str_dup(soc_mess_list[real_num].others_found);
   if (soc_mess_list[real_num].vict_found)
     OLC_ACTION(d)->vict_found = str_dup(soc_mess_list[real_num].vict_found);
   if (soc_mess_list[real_num].not_found)
     OLC_ACTION(d)->not_found = str_dup(soc_mess_list[real_num].not_found);
   if (soc_mess_list[real_num].char_auto)
     OLC_ACTION(d)->char_auto = str_dup(soc_mess_list[real_num].char_auto);
   if (soc_mess_list[real_num].others_auto)
     OLC_ACTION(d)->others_auto = str_dup(soc_mess_list[real_num].others_auto);
   if (soc_mess_list[real_num].char_body_found)
     OLC_ACTION(d)->char_body_found = str_dup(soc_mess_list[real_num].char_body_found);
   if (soc_mess_list[real_num].others_body_found)
     OLC_ACTION(d)->others_body_found = str_dup(soc_mess_list[real_num].others_body_found);
   if (soc_mess_list[real_num].vict_body_found)
     OLC_ACTION(d)->vict_body_found = str_dup(soc_mess_list[real_num].vict_body_found);
   if (soc_mess_list[real_num].char_obj_found)
     OLC_ACTION(d)->char_obj_found = str_dup(soc_mess_list[real_num].char_obj_found);
   if (soc_mess_list[real_num].others_obj_found)
     OLC_ACTION(d)->others_obj_found = str_dup(soc_mess_list[real_num].others_obj_found);
   OLC_VAL(d) = 0;
   aedit_disp_menu(d);
}


      
void aedit_save_internally(struct descriptor_data *d) {
   struct social_messg *new_soc_mess_list = NULL;
   int i;
   
   /* add a new social into the list */
   if (OLC_ZNUM(d) > top_of_socialt)  {
      CREATE(new_soc_mess_list, struct social_messg, top_of_socialt + 2);
      for (i = 0; i <= top_of_socialt; i++)
      	new_soc_mess_list[i] = soc_mess_list[i];
      new_soc_mess_list[++top_of_socialt] = *OLC_ACTION(d);
      free(soc_mess_list);
      soc_mess_list = new_soc_mess_list;
      create_command_list();
      sort_commands();
   }
   /* pass the editted action back to the list - no need to add */
   else {
      i = find_command(OLC_ACTION(d)->command);
      OLC_ACTION(d)->act_nr = soc_mess_list[OLC_ZNUM(d)].act_nr;
      /* why did i do this..? hrm */
      free_action(soc_mess_list + OLC_ZNUM(d));
      soc_mess_list[OLC_ZNUM(d)] = *OLC_ACTION(d);
      if (i > NOTHING) {
	 complete_cmd_info[i].command = soc_mess_list[OLC_ZNUM(d)].command;
	 complete_cmd_info[i].sort_as = soc_mess_list[OLC_ZNUM(d)].sort_as;
	 complete_cmd_info[i].minimum_position = soc_mess_list[OLC_ZNUM(d)].min_char_position;
	 complete_cmd_info[i].minimum_level	   = soc_mess_list[OLC_ZNUM(d)].min_level_char;
      }
   }
   olc_add_to_save_list(AEDIT_PERMISSION, OLC_SAVE_ACTION);
}


/*------------------------------------------------------------------------*/

void aedit_save_to_disk(struct descriptor_data *d) {
   FILE *fp;
   int i;

   if (!(fp = fopen(SOCMESS_FILE, "w+")))  {
      sprintf(buf, "Can't open socials file '%s'", SOCMESS_FILE);
      perror(buf);
      exit(1);
   }

   for (i = 0; i <= top_of_socialt; i++)  {
      sprintf(buf, "~%s %s %d %d %d %d\n",
	      soc_mess_list[i].command,
	      soc_mess_list[i].sort_as,
	      soc_mess_list[i].hide,
	      soc_mess_list[i].min_char_position,
	      soc_mess_list[i].min_victim_position,
	      soc_mess_list[i].min_level_char);
      fputs(buf, fp);
      sprintf(buf, "%s\n%s\n%s\n%s\n",
	      ((soc_mess_list[i].char_no_arg)?soc_mess_list[i].char_no_arg:"#"),
	      ((soc_mess_list[i].others_no_arg)?soc_mess_list[i].others_no_arg:"#"),
	      ((soc_mess_list[i].char_found)?soc_mess_list[i].char_found:"#"),
	      ((soc_mess_list[i].others_found)?soc_mess_list[i].others_found:"#"));
      fputs(buf, fp);
      sprintf(buf, "%s\n%s\n%s\n%s\n",
	      ((soc_mess_list[i].vict_found)?soc_mess_list[i].vict_found:"#"),
	      ((soc_mess_list[i].not_found)?soc_mess_list[i].not_found:"#"),
	      ((soc_mess_list[i].char_auto)?soc_mess_list[i].char_auto:"#"),
	      ((soc_mess_list[i].others_auto)?soc_mess_list[i].others_auto:"#"));
      fputs(buf, fp);
      sprintf(buf, "%s\n%s\n%s\n",
	      ((soc_mess_list[i].char_body_found)?soc_mess_list[i].char_body_found:"#"),
	      ((soc_mess_list[i].others_body_found)?soc_mess_list[i].others_body_found:"#"),
	      ((soc_mess_list[i].vict_body_found)?soc_mess_list[i].vict_body_found:"#"));
      fputs(buf, fp);
      sprintf(buf, "%s\n%s\n\n",
	      ((soc_mess_list[i].char_obj_found)?soc_mess_list[i].char_obj_found:"#"),
	      ((soc_mess_list[i].others_obj_found)?soc_mess_list[i].others_obj_found:"#"));
      fputs(buf, fp);
   }
   
   fprintf(fp, "$\n");
   fclose(fp);
   olc_remove_from_save_list(AEDIT_PERMISSION, OLC_SAVE_ACTION);
}

/*------------------------------------------------------------------------*/

/* Menu functions */

/* the main menu */
void aedit_disp_menu(struct descriptor_data * d) {
   struct social_messg *action = OLC_ACTION(d);
   struct char_data *ch        = d->character;

   get_char_cols(ch);
   
   sprintf(buf, "\x1B[H\x1B[J"
	   "%s-- Action editor\r\n\r\n"
	   "%sN%s) Command         : %s%-15.15s%s %s1%s) Sort as Command  : %s%-15.15s%s\r\n"
	   "%s2%s) Min Position[CH]: %s%-8.8s        %s3%s) Min Position [VT]: %s%-8.8s\r\n"
	   "%s4%s) Min Level   [CH]: %s%-3d             %s5%s) Show if Invisible: %s%s\r\n"
	   "%sA%s) Char    [NO ARG]: %s%s\r\n"
	   "%sB%s) Others  [NO ARG]: %s%s\r\n"
	   "%sC%s) Char [NOT FOUND]: %s%s\r\n"
	   "%sD%s) Char  [ARG SELF]: %s%s\r\n"
	   "%sE%s) Others[ARG SELF]: %s%s\r\n"
	   "%sF%s) Char      [VICT]: %s%s\r\n"
	   "%sG%s) Others    [VICT]: %s%s\r\n"
	   "%sH%s) Victim    [VICT]: %s%s\r\n"
	   "%sI%s) Char  [BODY PRT]: %s%s\r\n"
	   "%sJ%s) Others[BODY PRT]: %s%s\r\n"
	   "%sK%s) Victim[BODY PRT]: %s%s\r\n"
	   "%sL%s) Char       [OBJ]: %s%s\r\n"
	   "%sM%s) Others     [OBJ]: %s%s\r\n"
	   "%sQ%s) Quit\r\n",
	   nrm, grn, nrm,
	   yel, action->command, nrm,
	   grn, nrm,
	   yel, action->sort_as, nrm,
	   grn, nrm,
	   cyn, position_types[action->min_char_position],
	   grn, nrm,
	   cyn, position_types[action->min_victim_position],
	   grn, nrm,
	   cyn, action->min_level_char,
	   grn, nrm,
	   cyn, (action->hide?"HIDDEN":"NOT HIDDEN"),
	   grn, nrm, cyn,
	   action->char_no_arg ? action->char_no_arg : "<Null>",
	   grn, nrm, cyn,
	   action->others_no_arg ? action->others_no_arg : "<Null>",
	   grn, nrm, cyn,
	   action->not_found ? action->not_found : "<Null>",
	   grn, nrm, cyn,
	   action->char_auto ? action->char_auto : "<Null>",
	   grn, nrm, cyn,
	   action->others_auto ? action->others_auto : "<Null>",
	   grn, nrm, cyn,
	   action->char_found ? action->char_found : "<Null>",
	   grn, nrm, cyn,
	   action->others_found ? action->others_found : "<Null>",
	   grn, nrm, cyn,
	   action->vict_found ? action->vict_found : "<Null>",
	   grn, nrm, cyn,
	   action->char_body_found ? action->char_body_found : "<Null>",
	   grn, nrm, cyn,
	   action->others_body_found ? action->others_body_found : "<Null>",
	   grn, nrm, cyn,
	   action->vict_body_found ? action->vict_body_found : "<Null>",
	   grn, nrm, cyn,
	   action->char_obj_found ? action->char_obj_found : "<Null>",
	   grn, nrm, cyn,
	   action->others_obj_found ? action->others_obj_found : "<Null>",
	   grn, nrm);

   strcat(buf,"\r\n");
   strcat(buf, "Enter choice: ");

   send_to_char(buf, d->character);
   OLC_MODE(d) = AEDIT_MAIN_MENU;
}


/*
 * The main loop
 */

void aedit_parse(struct descriptor_data * d, char *arg) {
   int i;

   switch (OLC_MODE(d)) {
    case AEDIT_CONFIRM_SAVESTRING:
      switch (*arg) {
       case 'y': case 'Y':
	 aedit_save_internally(d);
	 sprintf(buf, "OLC: %s edits action %s", GET_NAME(d->character),
		 OLC_ACTION(d)->command);
	 mudlog(buf, CMP, LVL_IMPL, TRUE);
	 /* do not free the strings.. just the structure */
	 cleanup_olc(d, CLEANUP_STRUCTS);
	 send_to_char("Action saved to memory.\r\n", d->character);
	 break;
       case 'n': case 'N':
	 /* free everything up, including strings etc */
	 cleanup_olc(d, CLEANUP_ALL);
	 break;
       default:
	 send_to_char("Invalid choice!\r\nDo you wish to save this action internally? ", d->character);
	 break;
      }
      return; /* end of AEDIT_CONFIRM_SAVESTRING */

    case AEDIT_CONFIRM_EDIT:
      switch (*arg)  {
       case 'y': case 'Y':
	 aedit_setup_existing(d, OLC_ZNUM(d));
	 break;
       case 'q': case 'Q':
	 cleanup_olc(d, CLEANUP_ALL);
	 break;
       case 'n': case 'N':
	 OLC_ZNUM(d)++;
	 for (;(OLC_ZNUM(d) <= top_of_socialt); OLC_ZNUM(d)++)
	   if (is_abbrev(OLC_STORAGE(d), soc_mess_list[OLC_ZNUM(d)].command)) break;
	 if (OLC_ZNUM(d) > top_of_socialt) {
	    if (find_command(OLC_STORAGE(d)) > NOTHING)  {
	       cleanup_olc(d, CLEANUP_ALL);
	       break;
	    }
	    sprintf(buf, "Do you wish to add the '%s' action? ",
		    OLC_STORAGE(d));
	    send_to_char(buf, d->character);
	    OLC_MODE(d) = AEDIT_CONFIRM_ADD;
	 }
	 else  {
	    sprintf(buf, "Do you wish to edit the '%s' action? ", soc_mess_list[OLC_ZNUM(d)].command);
	    send_to_char(buf, d->character);
	    OLC_MODE(d) = AEDIT_CONFIRM_EDIT;
	 }
	 break;
       default:
	 sprintf(buf, "Invalid choice!\r\nDo you wish to edit the '%s' action? ", soc_mess_list[OLC_ZNUM(d)].command);
	 send_to_char(buf, d->character);
	 break;
      }
      return;

    case AEDIT_CONFIRM_ADD:
      switch (*arg)  {
       case 'y': case 'Y':
	 aedit_setup_new(d);
	 break;
       case 'n': case 'N': case 'q': case 'Q':
	 cleanup_olc(d, CLEANUP_ALL);
	 break;
       default:
	 sprintf(buf, "Invalid choice!\r\nDo you wish to add the '%s' action? ", OLC_STORAGE(d));
	 send_to_char(buf, d->character);
	 break;
      }
      return;

    case AEDIT_MAIN_MENU:
      switch (*arg) {
       case 'q': case 'Q':
	 if (OLC_VAL(d))  { /* Something was modified */
	    send_to_char("Do you wish to save this action internally? ", d->character);
	    OLC_MODE(d) = AEDIT_CONFIRM_SAVESTRING;
	 }
	 else cleanup_olc(d, CLEANUP_ALL);
	 break;
       case 'n':
	 send_to_char("Enter action name: ", d->character);
	 OLC_MODE(d) = AEDIT_ACTION_NAME;
	 return;
       case '1':
	 send_to_char("Enter sort info for this action (for the command listing): ", d->character);
	 OLC_MODE(d) = AEDIT_SORT_AS;
	 return;
       case '2':
	 send_to_char("Enter the minimum position the Character has to be in to activate social [0 - 8]: ", d->character);
	 OLC_MODE(d) = AEDIT_MIN_CHAR_POS;
	 return;
       case '3':
	 send_to_char("Enter the minimum position the Victim has to be in to activate social [0 - 8]: ", d->character);
	 OLC_MODE(d) = AEDIT_MIN_VICT_POS;
	 return;
       case '4':
	 send_to_char("Enter new minimum level for social: ", d->character);
	 OLC_MODE(d) = AEDIT_MIN_CHAR_LEVEL;
	 return;
       case '5':
	 OLC_ACTION(d)->hide = !OLC_ACTION(d)->hide;
	 aedit_disp_menu(d);
	 OLC_VAL(d) = 1;
	 break;
       case 'a': case 'A':
	 sprintf(buf, "Enter social shown to the Character when there is no argument supplied.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->char_no_arg)?OLC_ACTION(d)->char_no_arg:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_NOVICT_CHAR;
	 return;
       case 'b': case 'B':
	 sprintf(buf, "Enter social shown to Others when there is no argument supplied.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->others_no_arg)?OLC_ACTION(d)->others_no_arg:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_NOVICT_OTHERS;
	 return;
       case 'c': case 'C':
	 sprintf(buf, "Enter text shown to the Character when his victim isnt found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->not_found)?OLC_ACTION(d)->not_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_NOT_FOUND;
	 return;
       case 'd': case 'D':
	 sprintf(buf, "Enter social shown to the Character when it is its own victim.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->char_auto)?OLC_ACTION(d)->char_auto:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_SELF_CHAR;
	 return;
       case 'e': case 'E':
	 sprintf(buf, "Enter social shown to Others when the Char is its own victim.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->others_auto)?OLC_ACTION(d)->others_auto:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_SELF_OTHERS;
	 return;
       case 'f': case 'F':
	 sprintf(buf, "Enter normal social shown to the Character when the victim is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->char_found)?OLC_ACTION(d)->char_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_CHAR_FOUND;
	 return;
       case 'g': case 'G':
	 sprintf(buf, "Enter normal social shown to Others when the victim is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->others_found)?OLC_ACTION(d)->others_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_OTHERS_FOUND;
	 return;
       case 'h': case 'H':
	 sprintf(buf, "Enter normal social shown to the Victim when the victim is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->vict_found)?OLC_ACTION(d)->vict_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_VICT_FOUND;
	 return;
       case 'i': case 'I':
	 sprintf(buf, "Enter 'body part' social shown to the Character when the victim is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->char_body_found)?OLC_ACTION(d)->char_body_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_CHAR_BODY_FOUND;
	 return;
       case 'j': case 'J':
	 sprintf(buf, "Enter 'body part' social shown to Others when the victim is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->others_body_found)?OLC_ACTION(d)->others_body_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_OTHERS_BODY_FOUND;
	 return;
       case 'k': case 'K':
	 sprintf(buf, "Enter 'body part' social shown to the Victim when the victim is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->vict_body_found)?OLC_ACTION(d)->vict_body_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_VICT_VICT_BODY_FOUND;
	 return;
       case 'l': case 'L':
	 sprintf(buf, "Enter 'object' social shown to the Character when the object is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->char_obj_found)?OLC_ACTION(d)->char_obj_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_OBJ_CHAR_FOUND;
	 return;
       case 'm': case 'M':
	 sprintf(buf, "Enter 'object' social shown to the Room when the object is found.\r\n[OLD]: %s\r\n[NEW]: ",
		 ((OLC_ACTION(d)->others_obj_found)?OLC_ACTION(d)->others_obj_found:"NULL"));
	 send_to_char(buf, d->character);
	 OLC_MODE(d) = AEDIT_OBJ_OTHERS_FOUND;
	 return;
       default:
	 aedit_disp_menu(d);
	 break;
      }
      return;
	 
    case AEDIT_ACTION_NAME:
      if (*arg) {
	 if (strchr(arg,' ')) {
	    aedit_disp_menu(d);
	    return;
	 }
	 else  {
	    if (OLC_ACTION(d)->command)
	      free(OLC_ACTION(d)->command);
	    OLC_ACTION(d)->command = str_dup(arg);
	 }
      }
      else {
	 aedit_disp_menu(d);
	 return;
      }
      break;

    case AEDIT_SORT_AS:
      if (*arg) {
	 if (strchr(arg,' ')) {
	    aedit_disp_menu(d);
	    return;
	 }
	 else  {
	    if (OLC_ACTION(d)->sort_as)
	      free(OLC_ACTION(d)->sort_as);
	    OLC_ACTION(d)->sort_as = str_dup(arg);
	 }
      }
      else {
	 aedit_disp_menu(d);
	 return;
      }
      break;

    case AEDIT_MIN_CHAR_POS:
    case AEDIT_MIN_VICT_POS:
      if (*arg)  {
	 i = atoi(arg);
	 if ((i < 0) && (i > POS_STANDING))  {
	    aedit_disp_menu(d);
	    return;
	 }
	 else {
	    if (OLC_MODE(d) == AEDIT_MIN_CHAR_POS)
	      OLC_ACTION(d)->min_char_position = i;
	    else OLC_ACTION(d)->min_victim_position = i;
	 }
      }
      else  {
	 aedit_disp_menu(d);
	 return;
      }
      break;
      
    case AEDIT_MIN_CHAR_LEVEL:
      if (*arg)  {
	 i = atoi(arg);
	 if ((i < 0) && (i > LVL_IMPL))  {
	    aedit_disp_menu(d);
	    return;
	 }
	 else OLC_ACTION(d)->min_level_char = i;
      }
      else  {
	 aedit_disp_menu(d);
	 return;
      }
      break;

    case AEDIT_NOVICT_CHAR:
      if (OLC_ACTION(d)->char_no_arg)
      	free(OLC_ACTION(d)->char_no_arg);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->char_no_arg = str_dup(arg);
      }
      else OLC_ACTION(d)->char_no_arg = NULL;
      break;

    case AEDIT_NOVICT_OTHERS:
      if (OLC_ACTION(d)->others_no_arg)
      	free(OLC_ACTION(d)->others_no_arg);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->others_no_arg = str_dup(arg);
      }
      else OLC_ACTION(d)->others_no_arg = NULL;
      break;

    case AEDIT_VICT_CHAR_FOUND:
      if (OLC_ACTION(d)->char_found)
      	free(OLC_ACTION(d)->char_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->char_found = str_dup(arg);
      }
      else OLC_ACTION(d)->char_found = NULL;
      break;

    case AEDIT_VICT_OTHERS_FOUND:
      if (OLC_ACTION(d)->others_found)
      	free(OLC_ACTION(d)->others_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->others_found = str_dup(arg);
      }
      else OLC_ACTION(d)->others_found = NULL;
      break;

    case AEDIT_VICT_VICT_FOUND:
      if (OLC_ACTION(d)->vict_found)
      	free(OLC_ACTION(d)->vict_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->vict_found = str_dup(arg);
      }
      else OLC_ACTION(d)->vict_found = NULL;
      break;

    case AEDIT_VICT_NOT_FOUND:
      if (OLC_ACTION(d)->not_found)
      	free(OLC_ACTION(d)->not_found);
      if (*arg) {
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->not_found = str_dup(arg);
      }
      else OLC_ACTION(d)->not_found = NULL;
      break;

    case AEDIT_SELF_CHAR:
      if (OLC_ACTION(d)->char_auto)
      	free(OLC_ACTION(d)->char_auto);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->char_auto = str_dup(arg);
      }
      else OLC_ACTION(d)->char_auto = NULL;
      break;

    case AEDIT_SELF_OTHERS:
      if (OLC_ACTION(d)->others_auto)
      	free(OLC_ACTION(d)->others_auto);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->others_auto = str_dup(arg);
      }
      else OLC_ACTION(d)->others_auto = NULL;
      break;

    case AEDIT_VICT_CHAR_BODY_FOUND:
      if (OLC_ACTION(d)->char_body_found)
      	free(OLC_ACTION(d)->char_body_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->char_body_found = str_dup(arg);
      }
      else OLC_ACTION(d)->char_body_found = NULL;
      break;

    case AEDIT_VICT_OTHERS_BODY_FOUND:
      if (OLC_ACTION(d)->others_body_found)
      	free(OLC_ACTION(d)->others_body_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->others_body_found = str_dup(arg);
      }
      else OLC_ACTION(d)->others_body_found = NULL;
      break;

    case AEDIT_VICT_VICT_BODY_FOUND:
      if (OLC_ACTION(d)->vict_body_found)
      	free(OLC_ACTION(d)->vict_body_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->vict_body_found = str_dup(arg);
      }
      else OLC_ACTION(d)->vict_body_found = NULL;
      break;

    case AEDIT_OBJ_CHAR_FOUND:
      if (OLC_ACTION(d)->char_obj_found)
      	free(OLC_ACTION(d)->char_obj_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->char_obj_found = str_dup(arg);
      }
      else OLC_ACTION(d)->char_obj_found = NULL;
      break;

    case AEDIT_OBJ_OTHERS_FOUND:
      if (OLC_ACTION(d)->others_obj_found)
      	free(OLC_ACTION(d)->others_obj_found);
      if (*arg)	{
	 delete_doubledollar(arg);
	 OLC_ACTION(d)->others_obj_found = str_dup(arg);
      }
      else OLC_ACTION(d)->others_obj_found = NULL;
      break;

    default:
      /* we should never get here */
      break;
   }
   OLC_VAL(d) = 1;
   aedit_disp_menu(d);
}
::::::::::::::
alias.c
::::::::::::::
/***************************************************************************
*  File: alias.c                                 an addition to CircleMUD  *
*  Usage: saving player's aliases                                          *
*                                                                          *
*  a drop-in replacement for alias.c                                       *
*  written by Edward Almasy (almasy@axis.com)                              *
*                                                                          *
*  (original alias.c by Jeremy Hess and Chad Thompson)                     *
*                                                                          *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University  *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.                *
***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "db.h"
#include "buffer.h"

void write_aliases(struct char_data *ch)
{
  FILE         *ptFHndl;
  char          pcFileName[50];
  struct alias *pstAliasRec;
  char         *pcRepStart;
  
  get_filename(GET_NAME(ch), pcFileName, ALIAS_FILE);
  
  unlink(pcFileName);
  
  if (GET_ALIASES(ch) == NULL)
    return;
  
  ptFHndl = fopen(pcFileName,"wt");
  
  pstAliasRec = GET_ALIASES(ch);
  while (pstAliasRec != NULL) {
    fprintf(ptFHndl, "%d\n", strlen(pstAliasRec->alias)); 
    fprintf(ptFHndl, "%s\n", pstAliasRec->alias);
   
    pcRepStart = pstAliasRec->replacement; 
    while (*pcRepStart == ' ') pcRepStart++;
    
    fprintf(ptFHndl, "%d\n", strlen(pcRepStart)); 
    fprintf(ptFHndl, "%s\n", pcRepStart);
    fprintf(ptFHndl, "%d\n", pstAliasRec->type);
   
    pstAliasRec = pstAliasRec->next;
  }
  
  fclose(ptFHndl);
}


void read_aliases(struct char_data *ch)
{
    char          pcFileName[127];
    FILE         *ptFHndl;
    struct alias *pstAliasRec;
    int           iLen;
    
    get_filename(GET_NAME(ch), pcFileName, ALIAS_FILE);
    
    ptFHndl = fopen(pcFileName, "r");
    
    if (ptFHndl == NULL)
        return;
    
    CREATE(pstAliasRec, struct alias, 1);
    GET_ALIASES(ch) = pstAliasRec;

    while (!feof(ptFHndl))
    {
        fscanf(ptFHndl, "%d\n", &iLen);

        CREATE(pstAliasRec->alias, char, (iLen + 2));

        fgets(pstAliasRec->alias, (iLen+1), ptFHndl);

        fscanf(ptFHndl, "%d\n", &iLen);

        CREATE(pstAliasRec->replacement, char, (iLen + 3));
        *pstAliasRec->replacement = ' ';;

        fgets((pstAliasRec->replacement + 1), (iLen+1), ptFHndl);

        fscanf(ptFHndl, "%d\n", &pstAliasRec->type);

        if (!feof(ptFHndl))
        {
            CREATE(pstAliasRec->next, struct alias, 1);
            pstAliasRec = pstAliasRec->next;
            pstAliasRec->next = NULL;
        }
    }

    fclose(ptFHndl);
} 
::::::::::::::
arena.c
::::::::::::::
/**************************
 *
 * File: Arena.c
 *
 * Writen by:  Kevin Hoogheem aka Goon
 *             Modified by Billy H. Chan (STROM)
 *
 * Implementation of a event driven arena.. were players pay to kill.
 *
 * Using this code without consent by Goon will make your guts spill
 * out or worse.. Maybe I will hire Lauraina Bobbet to come visit you
 *
 */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "screen.h"
#include "spells.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "constants.h"
#include "buffer.h"

/*   external vars  */
extern FILE *player_fl;
extern struct room_data *world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern int restrict;
extern int top_of_world;
extern int top_of_mobt;
extern int top_of_objt;
extern int top_of_p_table;
extern sh_int r_mortal_start_room;
struct hall_of_fame_element *fame_list = NULL;
int in_arena = ARENA_OFF;
int start_time;
int game_length;
int lo_lim;
int hi_lim;
int lo_rem;
int hi_rem;
int cost_per_lev;
int time_to_start;
int time_left_in_game;
long arena_pot;
int bet_pot;


ACMD(do_arena)
{

 if (IS_NPC(ch)){
   send_to_char("Mobs can't enjoy the &RWar&n.\r\n",ch);
   return;
 }
 if (in_arena == ARENA_OFF)
 {
   send_to_char("The killing fields are closed right now.\r\n", ch);
 } else if (GET_LEVEL(ch) < lo_lim)
 {
   sprintf(buf, "Sorry but you must be at least level &M%d&n to enjoy the &RWar&n.\r\n",lo_lim);
   send_to_char(buf, ch);
 } else if (GET_REMORT(ch) < lo_rem)
 {
   sprintf(buf, "Sorry but you must be at least remort &M%d&n to enjoy the &RWar&n.\n\r", lo_rem);
    send_to_char(buf, ch);
 } else if (PLR_FLAGGED(ch, PLR_DEAD))
 {
    send_to_char("You are dead...\r\n", ch);
 } else if ((GET_LEVEL(ch) > hi_lim) || (GET_REMORT(ch) > hi_rem))
 {
    send_to_char("Sorry the killing fields are not open to you.\r\n",ch);
 } else if (GET_GOLD(ch) < (cost_per_lev * GET_LEVEL(ch)))
 {
    sprintf(buf, "Sorry but you need &Y%d&n coins to enjoy the &RWar&n.\r\n",
           (cost_per_lev * GET_LEVEL(ch)) );
    send_to_char(buf, ch);
 } else if (GET_LEVEL(ch) >= LVL_IMMORT)
 {
     send_to_char("Immortals can't join the &RWar&n.\r\n",ch);
 } else if (in_arena == ARENA_RUNNING)
 {
    send_to_char("It's too late to join the rumble now.  Wait for the next &RWar&n.\r\n", ch);
 } else if (AFF_FLAGGED(ch, AFF_GROUP))
 {
    send_to_char("When you are grouped you can't join the &RWar&n..\r\n", ch);
 } else if(ROOM_FLAGGED(IN_ROOM(ch), ROOM_ARENA))
 {
     send_to_char("You are in the &RWar&n already.\r\n",ch);
 } else
 {
   act("&C$n&n has been whisked away to the killing fields.\r\n", FALSE, ch, 0, 0, TO_ROOM);
   char_from_room(ch);
   char_to_room(ch, real_room(7500));
   act("&C$n&n is droped from the sky.", FALSE, ch, 0, 0, TO_ROOM);
   send_to_char("You have been taken to the killing fields.\r\n",ch);
   look_at_room(ch, 0);
   sprintf(buf, "&C%s&n has entered the &RWar&n.\r\n", GET_NAME(ch));
   sportschan(buf);
   GET_GOLD(ch) -= (cost_per_lev * GET_LEVEL(ch));
   arena_pot += (cost_per_lev * GET_LEVEL(ch));
   sprintf(buf, "You pay &Y%s&n coins to enjoy the &RWar&n.\r\n",
          add_points((cost_per_lev * GET_LEVEL(ch))));
   send_to_char(buf, ch);
  /* ok lets give them there free restore and take away all their */
  /* effects so they have to recast them spells onthemselfs       */
   ch->desc->hp = GET_HIT(ch);
   ch->desc->mana = GET_MANA(ch);
   ch->desc->move = GET_MOVE(ch);
   GET_HIT(ch) = GET_MAX_HIT(ch);
   GET_MANA(ch) = GET_MAX_MANA(ch);
   GET_MOVE(ch) = GET_MAX_MOVE(ch);
   GET_MENTAL(ch) = GET_MAX_MENTAL(ch);
   GET_OXI(ch) = GET_MAX_OXI(ch);
  if (ch->affected)
    while (ch->affected)
      affect_remove(ch, ch->affected);
  }
}


ACMD(do_chaos)
{
  char cost[MAX_INPUT_LENGTH], lolimit[MAX_INPUT_LENGTH];
  char hilimit[MAX_INPUT_LENGTH], start_delay[MAX_INPUT_LENGTH];
  char length[MAX_INPUT_LENGTH], lorem[MAX_INPUT_LENGTH];
  char hirem[MAX_INPUT_LENGTH];

/*Usage: chaos lo hi Rem Lo, Rem High start_delay cost/lev length*/

  if (in_arena != ARENA_OFF) {
	send_to_char("There is a &Rwar&n running already.\r\n", ch);
	return;
  }
half_chop(argument, lolimit, buf);
  lo_lim = atoi(lolimit);

  half_chop(buf, hilimit, buf);
  hi_lim = atoi(hilimit);

  half_chop(buf, start_delay, buf);
  start_time = atoi(start_delay);

  half_chop(buf, cost, buf);
  cost_per_lev = atoi(cost);

  half_chop(buf,length, buf);
  game_length = atoi(length);

  half_chop(buf, lorem, buf);
  lo_rem = atoi(lorem);

  half_chop(buf, hirem, buf);
  hi_rem = atoi(hirem);

  if (hi_lim > LVL_IMPL )
  {
    send_to_char("Please choose a <max level> under the Imps level.\r\n", ch);
    return;
  }

  if (lolimit < 0)
   silent_end();


  if(!*lolimit || !*hilimit || !*start_delay || !*cost || !*length || !*lorem || !*hirem)
  {
    send_to_char("Usage: chaos <low level> <max level> start_delay cost/lev length <min remort> <max remort>\r\n", ch);
    return;
  }
  if (!*lorem || !*hirem)
  {
  lo_rem = 0;
  hi_rem = 12;
  }

  if ((lo_lim > hi_lim) || (lo_rem > hi_rem))
  {
    send_to_char("Sorry, low limit must be lower than hi limit.\n\r", ch);
    return;
  }

  if ((hi_lim < 0) || (cost_per_lev < 0) || (game_length < 0) || (lo_rem < 0) || (hi_rem < 0))
  {
    send_to_char("I like positive numbers thank you.\n\r", ch);
    return;
  }

  if (start_time <= 0)
  {
    send_to_char("Lets at least give them a chance to enter!\r\n", ch);
    return;
  }

  if ((GET_LEVEL(ch) < LVL_SUBIMPL) && (cost_per_lev < MIN_ARENA_COST))
  {
    send_to_char("The implementors have put a minimum of 1000 entry fee.\r\n",ch);
    return;
  }

  in_arena = ARENA_START;
  time_to_start = start_time;
  time_left_in_game =0;
  arena_pot =0;
  start_arena();

}

void start_arena()
{

  if(time_to_start == 0){
    show_jack_pot();
    in_arena = ARENA_RUNNING;    /* start the blood shed */
    time_left_in_game = game_length;
    start_game();
  } else {
   if(time_to_start >1){
     sprintf(buf1, "The &RWAR&n will begin in %d hours open to levels: &M%d - &M%d&n and remorts: &M%d - &M%d&n.\r\n",
         time_to_start, lo_lim, hi_lim, lo_rem, hi_rem);
     sportschan(buf1);
     sprintf(buf1, "&Y%s&n coins per level to enter.\r\n",
         add_points(cost_per_lev));
     sportschan(buf1);
     sprintf(buf1, "Type &R'war'&n to enter.\r\n");
     sportschan(buf1);
   }else{
     sprintf(buf1, "The next &RWAR&n will begin in &G1&n hour open to levels: &M%d - &M%d&n and remorts: &M%d - &M%d&n.\r\n",
         lo_lim, hi_lim, lo_rem, hi_rem);
    sportschan(buf1);
    sprintf(buf1, "&Y%s&n coins per level to enter.\r\n",
	    add_points(cost_per_lev));
    sportschan(buf1);
    sprintf(buf1, "Type &R'war'&n to enter.\r\n");
    sportschan(buf1);
   }
   time_to_start--;
  }
}

void show_jack_pot()
{
  sprintf(buf1, "\007\007The &RWar&n begin NOW!!!!!!!!\r\n");
  sportschan(buf1);
  sprintf(buf1, "The &yjackpot&n for this &RWAR&n is &Y%s&n coins.\r\n", add_points(arena_pot));
  sportschan(buf1);

}

void start_game()
{
  struct char_data *i;
  struct descriptor_data *d;

  for (d = descriptor_list; d; d = d->next) {
   if (!d->connected && d->character) {
    i = d->character;
    if (i->in_room == real_room(7500)) {
       send_to_char("\r\nThe floor falls out from bellow, droping you in the middle of the &RWAR&n.\r\n", i);
         char_from_room(i);
         char_to_room(i, real_room(number(7501, 7517)));
         look_at_room(i, 0);
        }
   }
  }
  do_game();
}

void do_game()
{

  if(num_in_arena() == 1){
   in_arena = ARENA_OFF;
   find_game_winner();
  }else if(time_left_in_game == 0){
   in_arena = ARENA_OFF;
   do_end_game();
  }else if (num_in_arena() == 0){
   in_arena = ARENA_OFF;
   silent_end();
  } else if ((time_left_in_game % 5) || time_left_in_game <= 4) {
   sprintf(buf, "With &G%d&n hours left in the game there are &B%d&n players left.\r\n",
            time_left_in_game, num_in_arena());
   sportschan(buf);
  } else if(time_left_in_game == 1){
   sprintf(buf, "With &G1&n hour left in the game there are &B%d&n players left.\r\n",
            num_in_arena());
   sportschan(buf);
  }
  time_left_in_game--;
}

void find_game_winner()
{
  struct char_data *i;
  struct descriptor_data *d;
  struct hall_of_fame_element *fame_node;

  for (d = descriptor_list; d; d = d->next)
    if (!d->connected && d->character)
 {
   i = d->character;
        if (ROOM_FLAGGED(IN_ROOM(i), ROOM_ARENA) && (!IS_NPC(i)) && (i->in_room != NOWHERE) && GET_LEVEL(i) < LVL_ELDER)
  {
      GET_HIT(i) = i->desc->hp;
      GET_MANA(i) = i->desc->mana;
      GET_MOVE(i) = i->desc->move;
      GET_OXI(i) = GET_MAX_OXI(i);
      GET_MENTAL(i) = GET_MAX_MENTAL(i);

      if (i->affected)
          while (i->affected) affect_remove(i, i->affected);
      char_from_room(i);
      char_to_room(i, r_mortal_start_room);
      look_at_room(i, 0);
      act("$n falls from the sky.\r\n", FALSE, i, 0, 0, TO_ROOM);

      if(time_left_in_game == 1)
     {
         sprintf(buf, "After &G1&n hour of battle &C%s&n is declared the winner.\r\n",GET_NAME(i));
         sportschan(buf);

     }
     else
     {
        sprintf(buf, "After &G%d&n hours of battle &C%s&n is declared the winner.\r\n", game_length - time_left_in_game, GET_NAME(i));
        sportschan(buf);
     }

     GET_GOLD(i) += arena_pot;
     GET_TITLE(i) = "The Last Arena Winner";

     sprintf(buf, "You have been awarded &Y%s&n coins for being the best gladiator.\r\n", add_points(arena_pot));
     send_to_char(buf, i);

     sprintf(buf2, "%s has been awarded &Y%s&n coins for being the best gladiator.\r\n", GET_NAME(i), add_points(arena_pot));
     sportschan(buf2);
    if ((game_length - time_left_in_game) > 1)
        {
          CREATE(fame_node, struct hall_of_fame_element, 1);
          strncpy(fame_node->name, GET_NAME(i), MAX_NAME_LENGTH);
          fame_node->name[MAX_NAME_LENGTH] = '\0';
          fame_node->date = time(0);
          fame_node->award = (arena_pot/2);
          fame_node->next = fame_list;
          fame_list = fame_node;
          write_fame_list();
          find_bet_winners(i);
        }
  }
 }
}

void silent_end()
{
  struct descriptor_data *d;
  struct char_data *i;

     in_arena = ARENA_OFF;
     start_time = 0;
     game_length = 0;
     time_to_start = 0;
     time_left_in_game = 0;
     arena_pot = 0;

  sprintf(buf, "It looks like no one was brave enough to enter in the &RWar&n.\r\n\r\n");
  sportschan(buf);

        for (d = descriptor_list; d; d = d->next)
      {
           if (!d->connected && d->character)
          {
            i = d->character;
             if (i->in_room == real_room(7500))
            {

             send_to_char("\r\nThe floor falls out from bellow, droping you in The Wardome Preparation Room.\r\n", i);
             char_from_room(i);
             char_to_room(i, real_room(500));
             look_at_room(i, 0);
            }
          }
      }
}

void do_end_game()
{
  struct char_data *i;
  struct descriptor_data *d;

    for (d = descriptor_list; d; d = d->next)
      if (!d->connected && d->character)
   {
      i = d->character;
         if (ROOM_FLAGGED(IN_ROOM(i), ROOM_ARENA) && (i->in_room != NOWHERE) && (!IS_NPC(i)))
      {
           GET_HIT(i) = GET_MAX_HIT(i);
           GET_MANA(i) = GET_MAX_MANA(i);
           GET_MOVE(i) = GET_MAX_MOVE(i);
           GET_OXI(i) = GET_MAX_OXI(i);
           GET_MENTAL(i) = GET_MAX_MENTAL(i);

         if (i->affected)
           while (i->affected) affect_remove(i, i->affected);
        char_from_room(i);
        char_to_room(i, r_mortal_start_room);
        look_at_room(i, 0);
        act("$n falls from the sky.\r\n", FALSE, i, 0, 0, TO_ROOM);
      }
   }
      sprintf(buf, "After &G%d&n hours of battle the Match is a draw.\r\n",game_length);
      sportschan(buf);
      time_left_in_game = 0;
}

int num_in_arena()
{
  struct char_data *i;
  struct descriptor_data *d;
  int num = 0;

  for (d = descriptor_list; d; d = d->next){
     if (d->character)
   {
       i = d->character;
           if ((ROOM_FLAGGED(IN_ROOM(i), ROOM_ARENA)) && (i->in_room != NOWHERE))
        {
           if(GET_LEVEL(i) < LVL_ELDER)
             num++;
        }
   }
}
 return num;
}

ACMD(do_awho)
{
  struct descriptor_data *d;
  struct char_data *tch;
  double x = 100;
  int num =0, i = 0;
  *buf2 = '\0';

  if (in_arena == ARENA_OFF) {
    send_to_char("&WThere is no &RWAR&W going on right now&n.\r\n", ch);
	return;
  }

  sprintf(buf,"\r\n&CWarDome &RWAR&n\r\n");
  sprintf(buf + strlen(buf),"  &GLevels &W[&c%d&W] &Gto &W[&c%d&W]&n\r\n", lo_lim, hi_lim);
  sprintf(buf + strlen(buf),"     &GRemort &W[&c%d&W] &Gto &W[&c%d&W]&n\r\n", lo_rem, hi_rem);
  sprintf(buf + strlen(buf),"         Jackpot [&Y%s&n]\r\n\r\n", add_points(arena_pot));
  sprintf(buf + strlen(buf),"&WGladiators playing the &RWAR&W:\r\n");

  for (d = descriptor_list; d; d = d->next)
   if (!d->connected && d->character){
     tch = d->character;
 	 if (ROOM_FLAGGED(IN_ROOM(tch), ROOM_ARENA) &&
	     (tch->in_room != NOWHERE) && GET_LEVEL(tch)<LVL_ELDER){
		 if(!ROOM_FLAGGED(IN_ROOM(ch), ROOM_ARENA))
		 	x = ((GET_HIT(tch)*100)/GET_MAX_HIT(tch));
         sprintf(buf + strlen(buf), "&c[&R%3d&c] &C%-20.20s &R%3.2f%%&n%s ", GET_LEVEL(tch),
         GET_NAME(tch), x, (!(++num % 2) ? "\r\n" : ""));
	i++;
       }
   }
   if(i == 0)
       sprintf(buf, "&WNo one was brave to enjoy the &RWAR&W.&n");

  strcat(buf, "\r\n");
  send_to_char(buf, ch);
}
ACMD(do_bet)
{
  int newbet;
  struct char_data *bet_on;
//  struct char_data *winner;
//  struct char_data *i;


  two_arguments(argument, arg, buf1);

  if (IS_NPC(ch)) {
    send_to_char("Mobs cant bet on the war.\r\n",ch);
    return;
  }

  if(!*arg) {
    if(start_time) {
      send_to_char("Usage: bet <player> <amount>\r\n",ch);
      return;
    } else if(!start_time){
      send_to_char("&WSorry no &Rwar&W is in going on.&n\r\n", ch);
      return;
    } else if(in_arena == ARENA_RUNNING) {
      send_to_char("&WSorry &Rwar&W has already started, no more bets.&n\r\n", ch);
      return;
    }
  }

  if (!start_time)
    send_to_char("&WSorry the &Rwar &Wis not happening, wait until it opens up to bet.&n\r\n",ch);
  else if(num_in_arena() < 2)
    send_to_char("&WNeed more than one &ygladiator&W to bet.\r\n", ch);
  else if (in_arena == ARENA_RUNNING)
    send_to_char("&WSorry &Rwar&W is happening, no more bets.&n\r\n", ch);
  else if (!(bet_on = get_char_vis(ch, arg)))
    send_to_char(NOPERSON, ch);
  else if (bet_on == ch)
    send_to_char("&WThat doesn't make much sense, does it?&n\r\n", ch);
  else if (!(ROOM_FLAGGED(IN_ROOM(bet_on), ROOM_ARENA)))
    send_to_char("&WSorry that person is not fighting on the &Rwar.&n\r\n", ch);
  else if(GET_REMORT(ch) == 0 && GET_LEVEL(ch) < 2)
    send_to_char("&WYou don't have level to perform this movement.&n\r\n", ch);
  else {

    if(GET_BET_AMT(ch) > 0) {
      send_to_char("&WYou have already made a bet this time!&n\r\n", ch);
      return;
    }

    GET_BETTED_ON(ch) = bet_on;

    if (!is_number(buf1)) {
      send_to_char("That should be a number idiot!\r\n", ch);
      return;
    }

    newbet = atoi(buf1);

    if (newbet == 0 ) {
      send_to_char("Bet some gold why dont you!\r\n", ch);
      return;
    }

    if (newbet > GET_GOLD(ch) ) {
      send_to_char ("You don't have that much money!\n\r",ch);
      return;
    }

    if ( newbet > 25000 ) {
      send_to_char("Sorry the house will not accept that much.\r\n", ch);
      return;
    }

    GET_BET_AMT(ch) = newbet;

    GET_GOLD(ch) -= newbet; /* substract the gold - important :) */
    arena_pot += (newbet / 2);
    bet_pot += (newbet * 2);
    sprintf(buf, "&c[&R-&rWAR&R-&c] &b%s &nhas placed &y%s &ncoins on &b%s&G!&n\r\n", GET_NAME(ch),
	    add_points(newbet), GET_NAME(bet_on));
    sportschan(buf);
  }
}

ACMD(do_ahall)
{
  char site[MAX_INPUT_LENGTH], format[MAX_INPUT_LENGTH], *timestr;
  char format2[MAX_INPUT_LENGTH];
  struct hall_of_fame_element *fame_node;

  *buf = '\0';
  *buf2 = '\0';
  *buf3 = '\0';

    if (!fame_list) {
      send_to_char("&wThere are no &BGladiators &won &RHALL OF FAME&w.\n\r", ch);
      return;
    }

  sprintf(buf2,       "&y'''''''''''''''''''''''''''''''''''''''''\n\r");
  sprintf(buf2,     "%s&y'      &BW&bar&BD&bome &RArena &YHall &yof &YFame&y       '&n\n\r",buf2);
  sprintf(buf2,     "%s&y'''''''''''''''''''''''''''''''''''''''''\n\r\n\r",buf2);

  strcpy(format, "&G%-10.10s&n  &Y%-20.16s&n  &R%-40s&n\n\r");
    sprintf(buf, format,
	    "&gDate&n",
	    "&yAward Amt&n",
	    "&rName&n"
	  );
  strcat(buf2, buf);
  sprintf(buf, format,
	    "-=-=-=-=-=-=-=--=-=-=-=-=-=-=--=-",
	    "-=-=-=-=-=-=-=--=-=-=-=-=-=-=--=-",
	    "-=-=-=-=-=-=-=");
  strcat(buf2, buf);
  strcpy(format2, "&G%-10.10s&n  &Y%16.16s&n  &R%s&n\n\r");

  for (fame_node = fame_list; fame_node; fame_node = fame_node->next) {
    if (fame_node->date) {
	  timestr = asctime(localtime(&(fame_node->date)));
	*(timestr + 10) = 0;
	strcpy(site, timestr);
      }
      else
	strcpy(site, "Unknown");
      add_points((fame_node->award) * 2 );
      sprintf(buf, format2, site, buf3, fame_node->name);
      strcat(buf2, buf);
    }

  page_string(ch->desc, buf2, 1);
  return;
}



void load_hall_of_fame(void)
{
  FILE *fl;
  int date, award;
  char name[MAX_NAME_LENGTH + 1];
  struct hall_of_fame_element *next_node;

  fame_list = 0;

  if (!(fl = fopen(HALL_FAME_FILE, "r"))) {
    perror("Unable to open hall of fame file");
    return;
  }
  while (fscanf(fl, "%s %d %d", name, &date, &award) == 3) {
    CREATE(next_node, struct hall_of_fame_element, 1);
    strncpy(next_node->name, name, MAX_NAME_LENGTH);
    next_node->name[MAX_NAME_LENGTH] = '\0';
    next_node->date = date;
    next_node->award = award;
    next_node->next = fame_list;
    fame_list = next_node;
  }

  fclose(fl);
}


void write_fame_list(void)
{
  FILE *fl;

  if (!(fl = fopen(HALL_FAME_FILE, "w"))) {
    log("Error writing _hall_of_fame_list");
    return;
  }
  write_one_fame_node(fl, fame_list);/* recursively write from end to start */
  fclose(fl);

  return;
}

void write_one_fame_node(FILE * fp, struct hall_of_fame_element * node)
{
  if (node) {
    write_one_fame_node(fp, node->next);
    fprintf(fp, "%s %ld %ld\n", node->name,
	    (long) node->date, node->award);
  }
}
void find_bet_winners(struct char_data *winner)
{
  struct char_data *i;
  struct descriptor_data *d;

  *buf1 = '\0';

  for (d = descriptor_list; d; d = d->next)
    if (!d->connected) {
      i = d->character;
   if ((!IS_NPC(i)) && (i->in_room != NOWHERE) &&
       (GET_BETTED_ON(i) == winner) && GET_BET_AMT(i) > 0){
     sprintf(buf1, "\r\nYou have won &Y%d&n coins on your bet.\r\n",
	     GET_BET_AMT(i)*2);
     send_to_char(buf1, i);
     GET_GOLD(i) += GET_BET_AMT(i)*2;
     GET_BETTED_ON(i) = NULL;
     GET_BET_AMT(i) = 0;
   }
     GET_BETTED_ON(i) = NULL;
     GET_BET_AMT(i) = 0;
  }
}







::::::::::::::
auction.c
::::::::::::::
#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "screen.h"
#include "auction.h"

extern struct descriptor_data *descriptor_list;
extern struct room_data *world;

char *complete_char(char *string, int num);
int conta_cores(const char *texto);
char *item_condition(struct obj_data *obj);

void copia_auc(struct item_auction *donde, struct item_auction *pronde)
{
	pronde->obj = donde->obj;
	pronde->dono = donde->dono;
	pronde->comprador = donde->comprador;
	pronde->preco = donde->preco;
	pronde->tempo = donde->tempo;
}

void recriar_lista()
{
	struct item_auction *aucn;
	short int num, num2 = 0;

	CREATE(aucn, struct item_auction, 1);

	for(num = 0; num < num_aucs; num++)
		if(auc[num].tempo)
		{
			copia_auc(&auc[num], &aucn[num2++]);
			RECREATE(aucn, struct item_auction, num2 + 1);
		}

	free(auc);
	auc = aucn;
	num_aucs = num2;
}

void send_to_auction(const char *messg)
{
	struct descriptor_data *i;

	if (messg == NULL)
		return;

	for (i = descriptor_list; i; i = i->next)
		if (STATE(i) == CON_PLAYING)
			if (!PLR_FLAGGED(i->character, PLR_WRITING))
				if (!PRF_FLAGGED(i->character, PRF_NOAUCT))
					SEND_TO_Q(messg, i);
}

void adiciona_auction(struct char_data *ch, struct obj_data *tobj, int grana, short int tempu)
{
	if(!num_aucs)
		CREATE(auc, struct item_auction, num_aucs + 2);
	else
		RECREATE(auc, struct item_auction, num_aucs + 2);

	auc[num_aucs].obj = tobj;
	obj_from_char(auc[num_aucs].obj);

	auc[num_aucs].dono = ch;
	auc[num_aucs].comprador = NULL;
	auc[num_aucs].preco = grana;
	auc[num_aucs].ultimo_preco = grana;
	auc[num_aucs].tempo = tempu;
	num_aucs++;

	sprintf(buf, "&R[AUCTION] &c%s &Westa sendo leiloado.&n\r\n", tobj->short_description);
	send_to_auction(buf);
}

void passar_item(struct item_auction *auct)
{

	if(auct->dono)
	{
		sprintf(buf, "&WVoce vendeu %s&W.&n\r\n", auct->obj->short_description);
		send_to_char(buf, auct->dono);
		GET_GOLD(auct->dono) += auct->preco;
	}

	sprintf(buf, "&WVoce comprou %s&W.&n\r\n", auct->obj->short_description);
	send_to_char(buf, auct->comprador);
	GET_GOLD(auct->comprador) -= auct->preco;
	obj_to_char(auct->obj, auct->comprador);
	auct->tempo = 0;

	sprintf(buf, "&R[AUCTION] &c%s &Wfoi vendido por &Y%s &Wpara &C%s&W.&n\r\n",
				 auct->obj->short_description, add_points(auct->preco),
				 GET_NAME(auct->comprador));
	send_to_auction(buf);
}

void auction_update()
{
	short int num, atual = 0;

	if(!num_aucs)
		return;

	for(num = 0; num < num_aucs; num++)
	{
		if(auc[num].tempo > 1)
		{
			auc[num].tempo--;
			continue;
		}

		if(auc[num].comprador)
			passar_item(&auc[num]);
		else
		{
			if(auc[num].dono)
			{
				obj_to_char(auc[num].obj, auc[num].dono);
				send_to_char("&WVoce &Rnao &Wconseguiu vender o item.&n\r\n", auc[num].dono);
			}
			else
				free_obj(auc[num].obj);

			auc[num].tempo = 0;
		}
		atual = 1;
	}

	if(atual)
		recriar_lista();

	send_to_auction("&R[AUCTION] &WUm tick passou.\r\n");
}

void limpa_auctions(struct char_data *ch)
{
	short int num;

	for(num = 0; num < num_aucs; num++)
	{
		if(auc[num].dono == ch)
			auc[num].dono = NULL;
		if(auc[num].comprador == ch)
		{
			auc[num].comprador = NULL;
			auc[num].preco = auc[num].ultimo_preco;
		}
	}
}

ACMD(do_auction)
{
	char prim[MAX_INPUT_LENGTH], sec[MAX_INPUT_LENGTH], terc[MAX_INPUT_LENGTH];
	struct obj_data *obj;
	short int numauc, tempo;
	int gold;

	if (IS_NPC(ch) || (ch->master && AFF_FLAGGED(ch, AFF_CHARM)))
		return;
	else if (PRF_FLAGGED(ch, PRF_NOAUCT))
	{
		send_to_char("&WSem o canal de &Rauction &Wligado isso nao sera possivel&W.&n\r\n", ch);
		return;
	}
	else if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
	{
		send_to_char("Impossivel leiloar enquanto esta na &RWAR&n.\r\n", ch);
		return;
	}

	skip_spaces(&argument);
	half_chop(argument, prim, buf);
	half_chop(buf, sec, terc);

	if((!*prim || !*sec) && !*terc)
	{
		send_to_char("Formato: auction <tempo> <quantia> <obj>\r\n", ch);
		if(num_aucs)
		{
			send_to_char("         auction info <num>\r\n\r\n"
						 "&WNum. &cObjeto                          &CDono       &CComprador        &YPreco &WTempo\r\n", ch);
			for(numauc = 0; numauc < num_aucs; numauc++)
			{
				sprintf(buf, "&R%3d&W# &c%s &C%15s %15s &y%12d &W%5d&n\r\n", numauc + 1,
							complete_char(reprimir(auc[numauc].obj->short_description,
							20+(2*conta_cores(auc[numauc].obj->short_description))), 20),
							(auc[numauc].dono ? GET_NAME(auc[numauc].dono) : "Nao disponivel"),
							(auc[numauc].comprador ? GET_NAME(auc[numauc].comprador) : "Nenhum"),
							auc[numauc].preco, auc[numauc].tempo);
				send_to_char(buf, ch);
			}
		}
	}
	else if(!*terc && !strcmp(prim, "info") && is_number(sec))
	{
		numauc = atoi(sec) - 1;

		if(numauc < 0 || numauc > (num_aucs - 1))
		{
			send_to_char("Ver informacoes de qual objeto?\r\n", ch);
			return;
		}

		strcpy(buf, "&R[AUCTION] &WInfo&n\r\n");
		sprintf(buf + strlen(buf), "&WObjeto&n: %s&n\r\n", auc[numauc].obj->short_description);
		sprintf(buf + strlen(buf), "&cRemort&n/&CLevel&n: &c%d&n/&C%d&n\r\n",
					(GET_OBJ_LEVEL(auc[numauc].obj) - (GET_OBJ_LEVEL(auc[numauc].obj) %
					(LVL_IMMORT - 1))) / (LVL_IMMORT - 1), (GET_OBJ_LEVEL(auc[numauc].obj)
					% (LVL_IMMORT - 1)));
		sprintf(buf + strlen(buf), "&YPreco &Wno leilao&n: &y%14s      &YRende&n: %s%d&W%%&n\r\n",
					add_points(auc[numauc].preco), (GET_OBJ_COST(auc[numauc].obj) >
					auc[numauc].preco ? "&R" : "&Y"), ((auc[numauc].preco*100) /
					GET_OBJ_COST(auc[numauc].obj)) - 100);
		sprintf(buf + strlen(buf), "&WCondicao:%s&n\r\n",
					item_condition(auc[numauc].obj));
		send_to_char(buf, ch);
	}
	else
	{
		if(!is_number(prim) || !is_number(sec))
		{
			send_to_char("Tempo e/ou quantia tem de ser valor numerico.\r\n", ch);
			return;
		}

		if ((obj = get_obj_in_list_vis(ch, terc, ch->carrying)) == NULL)
		{
			send_to_char("Que objeto?\r\n", ch);
			return;
		}

		gold = atoi(sec);
		tempo = atoi(prim);

		if (IS_OBJ_STAT(obj, ITEM_NORENT))
		{
			send_to_char("Impossivel leiloar itens que nao sao salvos.\n\r", ch);
			return;
		}
		else if ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (GET_OBJ_VAL(obj, 3)))
		{
			send_to_char("Impossivel leiloar corpos.\n\r", ch);
			return;
		}
		else if (((GET_OBJ_TYPE(obj)) == ITEM_POTION) ||
			((GET_OBJ_TYPE(obj)) == ITEM_OTHER) || ((GET_OBJ_TYPE(obj)) == ITEM_TRASH) ||
			(((GET_OBJ_TYPE(obj)) == ITEM_NOTE) || ((GET_OBJ_TYPE(obj)) == ITEM_DRINKCON) ||
			((GET_OBJ_TYPE(obj)) == ITEM_KEY) || ((GET_OBJ_TYPE(obj)) == ITEM_FOOD) ||
			((GET_OBJ_TYPE(obj)) == ITEM_PEN) || ((GET_OBJ_TYPE(obj)) == ITEM_BOAT) ||
			((GET_OBJ_TYPE(obj)) == ITEM_SCROLL)))
		{
			send_to_char("Use o canal para verdadeiros leiloes somente.\n\r", ch);
			return;
		}
		else if ((GET_OBJ_TYPE(obj) == ITEM_CONTAINER) && (obj->contains))
		{
			send_to_char("You can auction only empty containers.\n\r", ch);
			return;
		}
		else if (gold < (GET_OBJ_COST(obj)*0.5))
		{
			send_to_char("Impossivel leiloar por menos de 50% do valor do item.\r\n", ch);
			return;
		}
		else if(gold > (GET_OBJ_COST(obj)*15))
		{
			send_to_char("Impossivel leiloar por mais que 15x o preco do objeto.\r\n", ch);
			return;
		}
		else if (tempo < 3 || tempo > 20)
		{
			send_to_char("Tempo fora dos limites. (3 <= tempo <= 20)\r\n", ch);
			return;
		}

		adiciona_auction(ch, obj, gold, tempo);
	}
}

ACMD(do_bid)
{
	char prim[MAX_INPUT_LENGTH], sec[MAX_INPUT_LENGTH];
	short int qual;
	int grana;

	skip_spaces(&argument);
	half_chop(argument, prim, sec);

	if (PRF_FLAGGED(ch, PRF_NOAUCT))
	{
		send_to_char("&WSem o canal de &Rauction &Wligado isso nao sera possivel&W.&n\r\n", ch);
		return;
	}
	else if(GET_REMORT(ch) == 0 && GET_LEVEL(ch) < 2)
	{
		send_to_char("Sem level pra dar um lance.\r\n", ch);
		return;
	}
	else if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
	{
		send_to_char("Impossivel dar um lance enquanto se esta na &RWAR&n.\r\n", ch);
		return;
	}

	if(!*prim || !*sec || !is_number(prim) || !is_number(sec))
	{
		send_to_char("Formato: bid <numero> <grana>\r\n", ch);
		return;
	}

	qual = atoi(prim) - 1;
	grana = atoi(sec);

	if(qual < 0 || qual > (num_aucs - 1))
	{
		send_to_char("Dar lance por qual produto?\r\n", ch);
		return;
	}
	else if(auc[qual].dono == ch)
	{
		send_to_char("Dar lance no proprio produto? Estranho.\r\n", ch);
		return;
	}
	else if(auc[qual].comprador == ch)
	{
		send_to_char("Cobrir o proprio lance? Estranho.\r\n", ch);
		return;
	}
	else if(grana < (auc[qual].preco == auc[qual].ultimo_preco ? auc[qual].preco : (auc[qual].preco*1.05)))
	{
		send_to_char("Ofereca no minimo 5% a mais que o preco atual.\r\n", ch);
		return;
	}
	else if(GET_GOLD(ch) < grana)
	{
		send_to_char("Voce nao tem gold para isso.\r\n", ch);
		return;
	}

	auc[qual].comprador = ch;
	auc[qual].preco = grana;

	sprintf(buf, "&R[AUCTION] &WNovo lance para &c%s&W.&n\r\n", auc[qual].obj->short_description);
	send_to_auction(buf);
}
::::::::::::::
ban.c
::::::::::::::
/* ************************************************************************
*   File: ban.c                                         Part of CircleMUD *
*  Usage: banning/unbanning/checking sites and player names               *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

struct ban_list_element *ban_list = NULL;
extern struct descriptor_data *descriptor_list;

/* local functions */
void load_banned(void);
int isbanned(char *hostname);
void _write_one_node(FILE * fp, struct ban_list_element * node);
void write_ban_list(void);
ACMD(do_ban);
ACMD(do_unban);
int Valid_Name(char *newname);
void Read_Invalid_List(void);

const char *ban_types[] = {
  "no",
  "new",
  "select",
  "all",
  "ERROR"
};


void load_banned(void)
{
  FILE *fl;
  int i, date;
  char site_name[BANNED_SITE_LENGTH + 1], ban_type[100];
  char name[MAX_NAME_LENGTH + 1];
  struct ban_list_element *next_node;

  ban_list = 0;

  if (!(fl = fopen(BAN_FILE, "r"))) {
    if (errno != ENOENT) {
      log("SYSERR: Unable to open banfile '%s'.", BAN_FILE);
      perror(BAN_FILE);
    } else
      log("Ban file '%s' doesn't exist.", BAN_FILE);
    return;
  }
  while (fscanf(fl, " %s %s %d %s ", ban_type, site_name, &date, name) == 4) {
    CREATE(next_node, struct ban_list_element, 1);
    strncpy(next_node->site, site_name, BANNED_SITE_LENGTH);
    next_node->site[BANNED_SITE_LENGTH] = '\0';
    strncpy(next_node->name, name, MAX_NAME_LENGTH);
    next_node->name[MAX_NAME_LENGTH] = '\0';
    next_node->date = date;

    for (i = BAN_NOT; i <= BAN_ALL; i++)
      if (!strcmp(ban_type, ban_types[i]))
        next_node->type = i;

    next_node->next = ban_list;
    ban_list = next_node;
  }

  fclose(fl);
}


int isbanned(char *hostname)
{
  int i;
  struct ban_list_element *banned_node;
  char *nextchar;

  if (!hostname || !*hostname)
    return (0);

  i = 0;
  for (nextchar = hostname; *nextchar; nextchar++)
    *nextchar = LOWER(*nextchar);

  for (banned_node = ban_list; banned_node; banned_node = banned_node->next)
    if (strstr(hostname, banned_node->site))    /* if hostname is a substring */
      i = MAX(i, banned_node->type);

  return i;
}


void _write_one_node(FILE * fp, struct ban_list_element * node)
{
  if (node) {
    _write_one_node(fp, node->next);
    fprintf(fp, "%s %s %ld %s\n", ban_types[node->type],
            node->site, (long) node->date, node->name);
  }
}



void write_ban_list(void)
{
  FILE *fl;

  if (!(fl = fopen(BAN_FILE, "w"))) {
    perror("SYSERR: write_ban_list");
    return;
  }
  _write_one_node(fl, ban_list);/* recursively write from end to start */
  fclose(fl);
  return;
}


ACMD(do_ban)
{
  char flag[MAX_INPUT_LENGTH], site[MAX_INPUT_LENGTH],
        format[MAX_INPUT_LENGTH], *nextchar, *timestr;
  int i;
  struct ban_list_element *ban_node;

  *buf = '\0';

  if (!*argument) {
    if (!ban_list) {
      send_to_char("No sites are banned.\r\n", ch);
      return;
    }
    strcpy(format, "%-25.25s  %-8.8s  %-10.10s  %-16.16s\r\n");
    sprintf(buf, format,
            "Banned Site Name",
            "Ban Type",
            "Banned On",
            "Banned By");
    send_to_char(buf, ch);
    sprintf(buf, format,
            "---------------------------------",
            "---------------------------------",
            "---------------------------------",
            "---------------------------------");
    send_to_char(buf, ch);

    for (ban_node = ban_list; ban_node; ban_node = ban_node->next) {
      if (ban_node->date) {
        timestr = asctime(localtime(&(ban_node->date)));
        *(timestr + 10) = 0;
        strcpy(site, timestr);
      } else
        strcpy(site, "Unknown");
      sprintf(buf, format, ban_node->site, ban_types[ban_node->type], site,
              ban_node->name);
      send_to_char(buf, ch);
    }
    return;
  }
  two_arguments(argument, flag, site);
  if (!*site || !*flag) {
    send_to_char("Usage: ban {all | select | new} site_name\r\n", ch);
    return;
  }
  if (!(!str_cmp(flag, "select") || !str_cmp(flag, "all") || !str_cmp(flag, "new"))) {
    send_to_char("Flag must be ALL, SELECT, or NEW.\r\n", ch);
    return;
  }
  for (ban_node = ban_list; ban_node; ban_node = ban_node->next) {
    if (!str_cmp(ban_node->site, site)) {
      send_to_char("That site has already been banned -- unban it to change the ban type.\r\n", ch);
      return;
    }
  }

  CREATE(ban_node, struct ban_list_element, 1);
  strncpy(ban_node->site, site, BANNED_SITE_LENGTH);
  for (nextchar = ban_node->site; *nextchar; nextchar++)
    *nextchar = LOWER(*nextchar);
  ban_node->site[BANNED_SITE_LENGTH] = '\0';
  strncpy(ban_node->name, GET_NAME(ch), MAX_NAME_LENGTH);
  ban_node->name[MAX_NAME_LENGTH] = '\0';
  ban_node->date = time(0);

  for (i = BAN_NEW; i <= BAN_ALL; i++)
    if (!str_cmp(flag, ban_types[i]))
      ban_node->type = i;

  ban_node->next = ban_list;
  ban_list = ban_node;

  sprintf(buf, "%s has banned %s for %s players.", GET_NAME(ch), site,
          ban_types[ban_node->type]);
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);
  send_to_char("Site banned.\r\n", ch);
  write_ban_list();
}


ACMD(do_unban)
{
  char site[MAX_INPUT_LENGTH];
  struct ban_list_element *ban_node, *temp;
  int found = 0;

  one_argument(argument, site);
  if (!*site) {
    send_to_char("A site to unban might help.\r\n", ch);
    return;
  }
  ban_node = ban_list;
  while (ban_node && !found) {
    if (!str_cmp(ban_node->site, site))
      found = 1;
    else
      ban_node = ban_node->next;
  }

  if (!found) {
    send_to_char("That site is not currently banned.\r\n", ch);
    return;
  }
  REMOVE_FROM_LIST(ban_node, ban_list, next);
  send_to_char("Site unbanned.\r\n", ch);
  sprintf(buf, "%s removed the %s-player ban on %s.",
          GET_NAME(ch), ban_types[ban_node->type], ban_node->site);
  mudlog(buf, NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE);

  free(ban_node);
  write_ban_list();
}


/**************************************************************************
 *  Code to check for invalid names (i.e., profanity, etc.)               *
 *  Written by Sharon P. Goza                                             *
 **************************************************************************/

#define MAX_INVALID_NAMES       500

char *invalid_list[MAX_INVALID_NAMES];
int num_invalid = 0;

int Valid_Name(char *newname)
{
  int i;
  struct descriptor_data *dt;
  char tempname[MAX_INPUT_LENGTH];

  /*
   * Make sure someone isn't trying to create this same name.  We want to
   * do a 'str_cmp' so people can't do 'Bob' and 'BoB'.  The creating login
   * will not have a character name yet and other people sitting at the
   * prompt won't have characters yet.
   */
  for (dt = descriptor_list; dt; dt = dt->next)
    if (dt->character && GET_NAME(dt->character) && !str_cmp(GET_NAME(dt->character), newname))
      return (STATE(dt) == CON_PLAYING);

  /* return valid if list doesn't exist */
  if (!invalid_list || num_invalid < 1)
    return 1;

  /* change to lowercase */
  strcpy(tempname, newname);
  for (i = 0; tempname[i]; i++)
    tempname[i] = LOWER(tempname[i]);

  /* Does the desired name contain a string in the invalid list? */
  for (i = 0; i < num_invalid; i++)
    if (strstr(tempname, invalid_list[i]))
      return 0;

  return 1;
}


void Read_Invalid_List(void)
{
  FILE *fp;
  char temp[256];

  if (!(fp = fopen(XNAME_FILE, "r"))) {
    perror("SYSERR: Unable to open invalid name file");
    return;
  }

  num_invalid = 0;
  while (get_line(fp, temp) && num_invalid < MAX_INVALID_NAMES)
    invalid_list[num_invalid++] = str_dup(temp);

  if (num_invalid >= MAX_INVALID_NAMES) {
    log("SYSERR: Too many invalid names; change MAX_INVALID_NAMES in ban.c");
    exit(1);
  }

  fclose(fp);
}
::::::::::::::
boards.c
::::::::::::::
/* ************************************************************************
*   File: boards.c                                      Part of CircleMUD *
*  Usage: handling of multiple bulletin boards                            *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


/* FEATURES & INSTALLATION INSTRUCTIONS ***********************************

This board code has many improvements over the infamously buggy standard
Diku board code.  Features include:

- Arbitrary number of boards handled by one set of generalized routines.
  Adding a new board is as easy as adding another entry to an array.
- Safe removal of messages while other messages are being written.
- Does not allow messages to be removed by someone of a level less than
  the poster's level.


TO ADD A NEW BOARD, simply follow our easy 4-step program:

1 - Create a new board object in the object files

2 - Increase the NUM_OF_BOARDS constant in board.h

3 - Add a new line to the board_info array below.  The fields, in order, are:

        Board's virtual number.
        Min level one must be to look at this board or read messages on it.
        Min level one must be to post a message to the board.
        Min level one must be to remove other people's messages from this
                board (but you can always remove your own message).
        Filename of this board, in quotes.
        Last field must always be 0.

4 - In spec_assign.c, find the section which assigns the special procedure
    gen_board to the other bulletin boards, and add your new one in a
    similar fashion.

*/


#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "boards.h"
#include "interpreter.h"
#include "handler.h"

/* Board appearance order. */
#define NEWEST_AT_TOP   TRUE

extern struct room_data *world;
extern struct descriptor_data *descriptor_list;
extern int top_of_world;

/*
format: vnum, read lvl, write lvl, remove lvl, filename, 0 at end
Be sure to also change NUM_OF_BOARDS in board.h
*/
struct board_info_type board_info[NUM_OF_BOARDS] = {
  {500, 0, 2, LVL_GOD, LIB_ETC"board.mort", 0},
  {509, 0, 2, LVL_GOD, LIB_ETC"board.path", 0},
  {512, 0, 2, LVL_GOD, LIB_ETC"board.quest", 0},
  {3098, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC"board.immort", 0},
  {98, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC"board.builder", 0},
  {97, LVL_IMMORT, LVL_IMMORT, LVL_GRGOD, LIB_ETC"board.coder", 0},
  {3097, 0, 0, LVL_GOD, LIB_ETC"board.freeze", 0}, /*purple dragons clan*/
  {3096, 0, 0, LVL_IMMORT, LIB_ETC"board.social", 0},
  {3077, 0, 0, LVL_GOD, LIB_ETC"board.bugs", 0},
  {31001, 0, 0, LVL_GOD, LIB_ETC"board.titans", 0},
  {30100, 0, 0, LVL_GOD, LIB_ETC"board.ultimates", 0},
  {1300, 0, LVL_GOD, LVL_GOD, LIB_ETC"board.questbook", 0},
 /* {3099, 0, 0, LVL_GOD, LIB_ETC"board.mort", 0},*/
  {9403, 0,0, LVL_GOD, LIB_ETC"board.helms", 0},
  {507, 0, 0, LVL_GOD, LIB_ETC"board.idea", 0},
  {30401, 0, 0, LVL_GOD, LIB_ETC"board.sith", 0}, /*sith clan*/
};

/* local functions */
SPECIAL(gen_board);
int find_slot(void);
int find_board(struct char_data * ch);
void init_boards(void);

char *msg_storage[INDEX_SIZE];
int msg_storage_taken[INDEX_SIZE];
int num_of_msgs[NUM_OF_BOARDS];
int ACMD_READ, ACMD_LOOK, ACMD_EXAMINE, ACMD_WRITE, ACMD_REMOVE;
struct board_msginfo msg_index[NUM_OF_BOARDS][MAX_BOARD_MESSAGES];


int find_slot(void)
{
  int i;

  for (i = 0; i < INDEX_SIZE; i++)
    if (!msg_storage_taken[i]) {
      msg_storage_taken[i] = 1;
      return i;
    }
  return -1;
}


/* search the room ch is standing in to find which board he's looking at */
int find_board(struct char_data * ch)
{
  struct obj_data *obj;
  int i;

  for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
    for (i = 0; i < NUM_OF_BOARDS; i++)
      if (BOARD_RNUM(i) == GET_OBJ_RNUM(obj))
        return i;

  return -1;
}


void init_boards(void)
{
  int i, j, fatal_error = 0;

  for (i = 0; i < INDEX_SIZE; i++) {
    msg_storage[i] = 0;
    msg_storage_taken[i] = 0;
  }

  for (i = 0; i < NUM_OF_BOARDS; i++) {
    if ((BOARD_RNUM(i) = real_object(BOARD_VNUM(i))) == -1) {
      log("SYSERR: Fatal board error: board vnum %d does not exist!",
              BOARD_VNUM(i));
      fatal_error = 1;
    }
    num_of_msgs[i] = 0;
    for (j = 0; j < MAX_BOARD_MESSAGES; j++) {
      memset((char *) &(msg_index[i][j]), 0, sizeof(struct board_msginfo));
      msg_index[i][j].slot_num = -1;
    }
    Board_load_board(i);
  }

  ACMD_READ = find_command("read");
  ACMD_WRITE = find_command("write");
  ACMD_REMOVE = find_command("remove");
  ACMD_LOOK = find_command("look");
  ACMD_EXAMINE = find_command("examine");

  if (fatal_error)
    exit(1);
}


SPECIAL(gen_board)
{
  int board_type;
  static int loaded = 0;
  struct obj_data *board = (struct obj_data *)me;

  if (!loaded) {
   // leak_logging = 0; 	
    init_boards();
   // leak_logging = 1;
    loaded = 1;
  }
  if (!ch->desc)
    return 0;

  if (cmd != ACMD_WRITE && cmd != ACMD_LOOK && cmd != ACMD_EXAMINE &&
      cmd != ACMD_READ && cmd != ACMD_REMOVE)
    return 0;

  if ((board_type = find_board(ch)) == -1) {
    log("SYSERR:  degenerate board!  (what the hell...)");
    return 0;
  }
  if (cmd == ACMD_WRITE)
    return (Board_write_message(board_type, ch, argument, board));
  else if (cmd == ACMD_LOOK || cmd == ACMD_EXAMINE)
    return (Board_show_board(board_type, ch, argument, board));
  else if (cmd == ACMD_READ)
    return (Board_display_msg(board_type, ch, argument, board));
  else if (cmd == ACMD_REMOVE)
    return (Board_remove_msg(board_type, ch, argument, board));
  else
    return 0;
}


int Board_write_message(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  char *tmstr;
  time_t ct;
  char buf[MAX_INPUT_LENGTH], buf2[MAX_INPUT_LENGTH];

  if (GET_LEVEL(ch) < WRITE_LVL(board_type)) {
    send_to_char("&cYou are not holy enough to write on this board.\r\n", ch);
    return 1;
  }
  if (num_of_msgs[board_type] >= MAX_BOARD_MESSAGES) {
    send_to_char("The board is full.\r\n", ch);
    return 1;
  }
  if ((NEW_MSG_INDEX(board_type).slot_num = find_slot()) == -1) {
    send_to_char("The board is malfunctioning - sorry.\r\n", ch);
    log("SYSERR: Board: failed to find empty slot on write.");
    return 1;
  }
  /* skip blanks */
  skip_spaces(&arg);
  delete_doubledollar(arg);

  /* JE 27 Oct 95 - Truncate headline at 80 chars if it's longer than that */
  arg[80] = '\0';

  if (!*arg) {
    send_to_char("We must have a headline!\r\n", ch);
    return 1;
  }
  ct = time(0);
  tmstr = (char *) asctime(localtime(&ct));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  sprintf(buf2, "(%s)", GET_NAME(ch));
  sprintf(buf, "%6.10s %-20s :: %s", tmstr, buf2, arg);
  NEW_MSG_INDEX(board_type).heading = str_dup(buf);
  NEW_MSG_INDEX(board_type).level = GET_LEVEL(ch);

  send_to_char("&cWrite your message.  (&r/s &Csaves &r/h &cfor &Chelp&c)\r\n\r\n", ch);
  act("&y-&c>$n starts to write a message.", TRUE, ch, 0, 0, TO_ROOM);

  if (!IS_NPC(ch))
    SET_BIT(PLR_FLAGS(ch), PLR_WRITING);

  ch->desc->str = &(msg_storage[NEW_MSG_INDEX(board_type).slot_num]);
  ch->desc->max_str = MAX_MESSAGE_LENGTH;
  ch->desc->mail_to = board_type + BOARD_MAGIC;

  num_of_msgs[board_type]++;
  return 1;
}


int Board_show_board(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  int i;
  char tmp[MAX_STRING_LENGTH], buf[MAX_STRING_LENGTH];

  if (!ch->desc)
    return 0;

  one_argument(arg, tmp);

  if (!*tmp || !isname(tmp, board->name))
    return 0;

  if (GET_LEVEL(ch) < READ_LVL(board_type)) {
    send_to_char("&cYou try but fail to understand the holy words.\r\n", ch);
    return 1;
  }
  act("$n studies the board.", TRUE, ch, 0, 0, TO_ROOM);

  strcpy(buf,
         "&cThis is a bulletin board.  &CUsage: &rREAD&c/&rREMOVE &c<&rmessg #&c>, &rWRITE &c<&rheader&c>.\r\n"
         "&cYou will need to look at the board to save your message.\r\n");
  if (!num_of_msgs[board_type])
    strcat(buf, "&WThe board is empty.\r\n");
  else {
    sprintf(buf + strlen(buf), "&cThere are [&r%d&c] messages on the board.&n\r\n",
            num_of_msgs[board_type]);
#if NEWEST_AT_TOP
    for (i = num_of_msgs[board_type] - 1; i >= 0; i--)
#else
    for (i = 0; i < num_of_msgs[board_type]; i++)
#endif
    {
      if (MSG_HEADING(board_type, i))
#if NEWEST_AT_TOP
        sprintf(buf + strlen(buf), "&n%-2d : %s&n\r\n",
                num_of_msgs[board_type] - i, reprimir(MSG_HEADING(board_type, i), 72));
#else
        sprintf(buf + strlen(buf), "&n%-2d : %s&n\r\n", i + 1, reprimir(MSG_HEADING(board_type, i), 72));
#endif
      else {
        log("SYSERR: The board is fubar'd.");
        send_to_char("Sorry, the board isn't working.\r\n", ch);
        return 1;
      }
    }
  }
  page_string(ch->desc, buf, 1);

  return 1;
}


int Board_display_msg(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  char number[MAX_STRING_LENGTH], buffer[MAX_STRING_LENGTH];
  int msg, ind;

  one_argument(arg, number);
  if (!*number)
    return 0;
  if (isname(number, board->name))      /* so "read board" works */
    return (Board_show_board(board_type, ch, arg, board));
  if (strchr(number, '.'))      /* read 2.mail, look 2.sword */
    return 0;
  if (!isdigit(*number) || (!(msg = atoi(number))))
    return 0;

  if (GET_LEVEL(ch) < READ_LVL(board_type)) {
    send_to_char("&cYou try but fail to understand the holy words.\r\n", ch);
    return 1;
  }
  if (!num_of_msgs[board_type]) {
    send_to_char("&WThe board is empty!\r\n", ch);
    return (1);
  }
  if (msg < 1 || msg > num_of_msgs[board_type]) {
    send_to_char("&cThat message exists only in your imagination.\r\n",
                 ch);
    return (1);
  }
#if NEWEST_AT_TOP
  ind = num_of_msgs[board_type] - msg;
#else
  ind = msg - 1;
#endif
  if (MSG_SLOTNUM(board_type, ind) < 0 ||
      MSG_SLOTNUM(board_type, ind) >= INDEX_SIZE) {
    send_to_char("Sorry, the board is not working.\r\n", ch);
    log("SYSERR: Board is screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
    return 1;
  }
  if (!(MSG_HEADING(board_type, ind))) {
    send_to_char("That message appears to be screwed up.\r\n", ch);
    return 1;
  }
  if (!(msg_storage[MSG_SLOTNUM(board_type, ind)])) {
    send_to_char("That message seems to be empty.\r\n", ch);
    return 1;
  }
  sprintf(buffer, "Message %d : %s\r\n\r\n%s\r\n", msg,
          MSG_HEADING(board_type, ind),
          msg_storage[MSG_SLOTNUM(board_type, ind)]);

  page_string(ch->desc, buffer, 1);

  return 1;
}


int Board_remove_msg(int board_type, struct char_data * ch, char *arg, struct obj_data *board)
{
  int ind, msg, slot_num;
  char number[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH];
  struct descriptor_data *d;

  one_argument(arg, number);

  if (!*number || !isdigit(*number))
    return 0;
  if (!(msg = atoi(number)))
    return (0);

  if (!num_of_msgs[board_type]) {
    send_to_char("&WThe board is empty!\r\n", ch);
    return 1;
  }
  if (msg < 1 || msg > num_of_msgs[board_type]) {
    send_to_char("&cThat message exists only in your imagination.\r\n", ch);
    return 1;
  }
#if NEWEST_AT_TOP
  ind = num_of_msgs[board_type] - msg;
#else
  ind = msg - 1;
#endif
  if (!MSG_HEADING(board_type, ind)) {
    send_to_char("That message appears to be screwed up.\r\n", ch);
    return 1;
  }
  sprintf(buf, "(%s)", GET_NAME(ch));
  if (GET_LEVEL(ch) < REMOVE_LVL(board_type) &&
      !(strstr(MSG_HEADING(board_type, ind), buf))) {
    send_to_char("&cYou are not holy enough to remove other people's messages.\r\n", ch);
    return 1;
  }
  if (GET_LEVEL(ch) < MSG_LEVEL(board_type, ind)) {
    send_to_char("&cYou can't remove a message holier than yourself.\r\n", ch);
    return 1;
  }
  slot_num = MSG_SLOTNUM(board_type, ind);
  if (slot_num < 0 || slot_num >= INDEX_SIZE) {
    send_to_char("That message is majorly screwed up.\r\n", ch);
    log("SYSERR: The board is seriously screwed up. (Room #%d)", GET_ROOM_VNUM(IN_ROOM(ch)));
    return 1;
  }
  for (d = descriptor_list; d; d = d->next)
    if (STATE(d) == CON_PLAYING && d->str == &(msg_storage[slot_num])) {
      send_to_char("At least wait until the author is finished before removing it!\r\n", ch);
      return 1;
    }
  if (msg_storage[slot_num])
    free(msg_storage[slot_num]);
  msg_storage[slot_num] = 0;
  msg_storage_taken[slot_num] = 0;
  if (MSG_HEADING(board_type, ind))
    free(MSG_HEADING(board_type, ind));

  for (; ind < num_of_msgs[board_type] - 1; ind++) {
    MSG_HEADING(board_type, ind) = MSG_HEADING(board_type, ind + 1);
    MSG_SLOTNUM(board_type, ind) = MSG_SLOTNUM(board_type, ind + 1);
    MSG_LEVEL(board_type, ind) = MSG_LEVEL(board_type, ind + 1);
  }
  num_of_msgs[board_type]--;
  send_to_char("Message removed.\r\n", ch);
  sprintf(buf, "$n just removed message %d.", msg);
  act(buf, FALSE, ch, 0, 0, TO_ROOM);
  Board_save_board(board_type);

  return 1;
}
 

void Board_save_board(int board_type)
{
  FILE *fl;
  int i;
  char *tmp1 = 0, *tmp2 = 0;

  if (!num_of_msgs[board_type]) {
    remove(FILENAME(board_type));
    return;
  }
  if (!(fl = fopen(FILENAME(board_type), "wb"))) {
    perror("Error writing board");
    return;
  }
  fwrite(&(num_of_msgs[board_type]), sizeof(int), 1, fl);

  for (i = 0; i < num_of_msgs[board_type]; i++) {
    if ((tmp1 = MSG_HEADING(board_type, i)))
      msg_index[board_type][i].heading_len = strlen(tmp1) + 1;
    else
      msg_index[board_type][i].heading_len = 0;

    if (MSG_SLOTNUM(board_type, i) < 0 ||
        MSG_SLOTNUM(board_type, i) >= INDEX_SIZE ||
        (!(tmp2 = msg_storage[MSG_SLOTNUM(board_type, i)])))
      msg_index[board_type][i].message_len = 0;
    else
      msg_index[board_type][i].message_len = strlen(tmp2) + 1;

    fwrite(&(msg_index[board_type][i]), sizeof(struct board_msginfo), 1, fl);
    if (tmp1)
      fwrite(tmp1, sizeof(char), msg_index[board_type][i].heading_len, fl);
    if (tmp2)
      fwrite(tmp2, sizeof(char), msg_index[board_type][i].message_len, fl);
  }

  fclose(fl);
}


void Board_load_board(int board_type)
{
  FILE *fl;
  int i, len1 = 0, len2 = 0;
  char *tmp1 = NULL, *tmp2 = NULL;


  if (!(fl = fopen(FILENAME(board_type), "rb"))) {
    if (errno != ENOENT)
      perror("Error reading board");
    return;
  }
  fread(&(num_of_msgs[board_type]), sizeof(int), 1, fl);
  if (num_of_msgs[board_type] < 1 || num_of_msgs[board_type] > MAX_BOARD_MESSAGES) {
    log("SYSERR: Board file %d corrupt.  Resetting.", board_type);
    Board_reset_board(board_type);
    return;
  }
  for (i = 0; i < num_of_msgs[board_type]; i++) {
    fread(&(msg_index[board_type][i]), sizeof(struct board_msginfo), 1, fl);
    if (!(len1 = msg_index[board_type][i].heading_len)) {
      log("SYSERR: Board file %d corrupt!  Resetting.", board_type);
      Board_reset_board(board_type);
      return;
    }
    CREATE(tmp1, char, len1);
    fread(tmp1, sizeof(char), len1, fl);
    MSG_HEADING(board_type, i) = tmp1;

    if ((MSG_SLOTNUM(board_type, i) = find_slot()) == -1) {
      log("SYSERR: Out of slots booting board %d!  Resetting...", board_type);
      Board_reset_board(board_type);
      return;
    }
    if ((len2 = msg_index[board_type][i].message_len)) {
      CREATE(tmp2, char, len2);
      fread(tmp2, sizeof(char), len2, fl);
      msg_storage[MSG_SLOTNUM(board_type, i)] = tmp2;
    } else
      msg_storage[MSG_SLOTNUM(board_type, i)] = NULL;
  }

  fclose(fl);
}


void Board_reset_board(int board_type)
{
  int i;

  for (i = 0; i < MAX_BOARD_MESSAGES; i++) {
    if (MSG_HEADING(board_type, i))
      free(MSG_HEADING(board_type, i));
    if (msg_storage[MSG_SLOTNUM(board_type, i)])
      free(msg_storage[MSG_SLOTNUM(board_type, i)]);
    msg_storage_taken[MSG_SLOTNUM(board_type, i)] = 0;
    memset((char *)&(msg_index[board_type][i]),0,sizeof(struct board_msginfo));
    msg_index[board_type][i].slot_num = -1;
  }
  num_of_msgs[board_type] = 0;
  remove(FILENAME(board_type));
}
::::::::::::::
breath.c
::::::::::::::
/***************************************************************************
* File: breath.c                                    a part of WarDomeMUD   *
*                                                                          *
* Description: This is a simple code to the breath system.		   *
*                                                                          *
* By Archangel(Paulo Mello) Implementor of WarDomeMUD                      *
****************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "buffer.h"

extern struct room_data *world;
extern struct char_data *character_list;
void raw_kill(struct char_data * ch, struct char_data * killer);
int has_boat(struct char_data *ch);
int breath_gain(struct char_data * ch);

void loss_breath(struct char_data * ch, int breath)
{
	if(GET_LEVEL(ch) < LVL_IMMORT && breath > 0)
	{
		if(GET_OXI(ch) >= 1)
		{
			GET_OXI(ch) -= breath;
			send_to_char("Your breath becomes deeper and slower...\r\n", ch);
		} else {
			if(GET_HIT(ch) > 0)
			{
            	GET_HIT(ch) -= (GET_MAX_HIT(ch)*0.2);
            	send_to_char("&RYou need some oxygen, your life is almost extinguished!&n\r\n", ch);
			} else {
	           	GET_HIT(ch) = 0;
	           	send_to_char("&RYour breath becomes so slow that you die because of it.&n\r\n", ch);
            	raw_kill(ch, NULL);
			}
		}
	}
}

int breath[][12] = {
//				 VA	DR DW EL OG OR TR GI GN LI SE GO
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
/*mountain*/	{2, 3, 4, 3, 4, 4, 5, 2, 3, 2, 5, 0},
/*water_swim*/	{1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 0, 1},
/*waternswim*/	{6, 6, 6, 6, 7, 6, 7, 6, 7, 6, 0, 6},
/*underwater*/	{3, 4, 2, 3, 5, 3, 4, 2, 4, 2, 0, 1},
/*flying*/		{0, 4, 3, 3, 2, 4, 3, 2, 4, 3, 5, 0}
};

void make_breath(struct char_data *ch)
{
	loss_breath(ch, breath[SECT(ch->in_room)][(GET_RACE(ch) > RACE_GORAK ? (GET_RACE(ch)-RACE_DUNEDAIN) : GET_RACE(ch))] );
}

void update_breath(void)
{
  struct char_data *i, *next_char;

  for (i = character_list; i; i = next_char)
  {
    next_char = i->next;

	if(!i) return;
	if(!IS_NPC(i))
	{
		if(!has_boat)
			make_breath(i);
	 	else {
	 		if (GET_POS(i) >= POS_STUNNED)
	 	    	GET_OXI(i) = MIN(GET_OXI(i) + breath_gain(i), GET_MAX_OXI(i));
		}
	}
  }
}
::::::::::::::
buffer.c
::::::::::::::
/************************************************************************
 * buffer.c - Advanced Buffer System				v1.8	*
 *									*
 * Designed for CircleMUD 3.0				May 30, 1998	*
 ************************************************************************/

#define __BUFFER_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "interpreter.h"

/* ------------------------------------------------------------------------ */

/*
 * ... BUF_NUKE ...
 * Set	: Use a memset() to clear each buffer after use.
 * Unset: Do a *buffer = '\0'
 * ... BUF_CHECK ...
 * Set	: Report how much of each buffer the functions used.
 * Unset: Don't report.
 * ... BUF_OVERBOOT ...
 * Set	: Reboot immediately on overflow. (recommended)
 * Unset: Try to keep running after an overflow.
 * ... BUF_DETAIL
 * Set  : Log details of what is going on.
 * Unset: Only report errors.
 * ... BUF_VERBOSE ...
 * Set	: Output extremely detailed information.
 * Unset: Log only error messages.
 */
#define BUF_NUKE	(1 << 0)
#define BUF_CHECK	(1 << 1)
#define BUF_OVERBOOT	(1 << 2)
#define BUF_DETAIL	(1 << 3)	/* VERBOSE overrides DETAIL. */
#define BUF_VERBOSE	(1 << 4)
/*
 * Example: ush_int buffer_opt = BUF_OVERBOOT | BUF_VERBOSE | BUF_CHECK;
 */
ush_int buffer_opt = BUF_OVERBOOT;
//ush_int buffer_opt = 0;

/*
 * 1 = Check every pointer in every buffer allocated on every new allocation.
 * 0 = Recommended, unless you are tracking memory corruption at the time.
 *
 * NOTE: This only works under Linux.  Do not try to use with anything else!
 */
#define BUFFER_EXTREME_PARANOIA	0

/*
 * 1 = Enable multithreaded support.  You _must_ have POSIX threads for this!
 * 0 = Use the standard heartbeat() method of freeing the buffers.
 */
#define BUFFER_THREADED	0

/*
 * MAGIC_NUMBER - Any arbitrary character unlikely to show up in a string.
 *	In this case, we use a control character. (0x6)
 * BUFFER_LIFE - How long can a buffer be unused before it is free()'d?
 * LEASE_LIFE - The amount of time a buffer can be used before it is
 *	considered forgotten and released automatically.
 */
#if !defined(MAGIC_NUMBER)
#define MAGIC_NUMBER	(0x6)	/* Also in bpl13. */
#endif
#define BUFFER_LIFE	(180 RL_SEC)	/* 5 minutes */
#define LEASE_LIFE	(60 RL_SEC)	/* 1 minute */

/*
 * MEMORY ARRAY OPTIONS
 *
 * If you change the maximum or minimum allocations, you'll probably also want
 * to change the hash number.  See the 'bufhash.c' program for determining a
 * decent one.  Think prime numbers.
 *
 * MAX_ALLOC - The largest buffer magnitude allowed without griping about it.
 * MIN_ALLOC - The lowest buffer magnitude ever handed out.  If 20 bytes are
 *	requested, we will allocate this size buffer anyway.
 * BUFFER_HASH - The direct size->array hash mapping number. This is _not_ an
	arbitrary number.
 * CACHE_SIZE - How many data->buffer mappings to maintain.
 */
#define MAX_ALLOC	(16)	/* 2**16 = 65536 bytes	*/
#define MIN_ALLOC	(6)	/* 2**6  = 64 bytes	*/
#define BUFFER_HASH	(11)	/* Not arbitrary! */
#define CACHE_SIZE	(3 + BUFFER_MEMORY * 22)	/* Cache is 10 in that case. */

/*
 * End of configurables section.
 * ----------------------------------------------------------------------------
 */

/*
 * Don't change these, they are derived from other settings above.
 *
 * B_FREELIFE - The buffer life in pulses.
 * B_GIVELIFE - The lease life in pulses.
 * BUFFER_MINSIZE - The smallest buffer actually allocated, in bytes.
 */
#define BUFFER_MINSIZE	(1 << MIN_ALLOC)	/* Minimum size, in bytes. */
#define BUFFER_MAXSIZE	(1 << MAX_ALLOC)	/* Maximum size, in bytes. */
#if BUFFER_THREADED
#define B_FREELIFE	(BUFFER_LIFE / PASSES_PER_SEC)
#define B_GIVELIFE	(BUFFER_LIFE / PASSES_PER_SEC)
#else
#define B_FREELIFE	(BUFFER_LIFE / PULSE_BUFFER)
#define B_GIVELIFE	(LEASE_LIFE / PULSE_BUFFER)	
#endif

#if BUFFER_THREADED
/*
 * Assorted lock types.
 */
#define LOCK_NONE               0
#define LOCK_ACQUIRE            1
#define LOCK_WILL_CLEAR         2
#define LOCK_WILL_FREE          4
#define LOCK_WILL_REMOVE        8
#endif

/*
 * NOTE: There are reasons for not making a 'mem_data' structure.  We would
 * have to modify all of the iterator functions to work with both structures,
 * possibly though void pointers, which is ugly.  Currently, the only change
 * required was to pick get_{memory,buffer}_head() based on what type of
 * variable is requested.  This does waste 4 bytes for every malloc() that we
 * could save with a separate mem_data, but the added complexity is not worth
 * it in my opinion.  Debugging isn't necessarily cheap. Beware of the union.
 */
struct buf_mem_data {
  struct buf_data **buf;
  struct buf_data **mem;
};

struct buf_data {
  byte magic;		/* Have we been trashed?		*/
#if BUFFER_THREADED
  byte locked;		/* Don't touch this item, we're locked.	*/
#endif
  byte type;		/* What type of buffer are we?		*/
  ush_int line;         /* What source code line is using this. */
  size_t req_size;	/* How much did the function request?	*/
  union {
    sh_long life;	/* An idle counter to free unused ones.	(B) */
    const char *var;	/* Name of variable allocated to.	(M) */
  } var_life;
  size_t size;          /* How large is this buffer?		*/
  const char *who;      /* Name of the function using this.     */
  char *data;           /* The buffer passed back to functions. */
  struct buf_data *next;	/* Next structure.		*/
};

/*
 * The union support.
 */
#define life	var_life.life
#define var	var_life.var

/* ------------------------------------------------------------------------ */

/*
 * Global variables.
 *  buffers - Head of the main buffer allocation linked list.
 *  buffer_cache - A list of the most recently acquired buffers.
 *  buffer_cache_stat - Holds how many buffer cache hits/misses we've had.
 *  buffer_array - The minimum and maximum array ranges for 'buffers'.
 *  buf_thread - Handle of the buffer thread.
 *  buflistmutex - Make sure the threads don't stomp on each other.
 */
static struct buf_mem_data buffers;
static struct buf_data *buffer_cache[CACHE_SIZE];
int buffer_cache_stat[2] = { 0, 0 };	/* Used in act.wizard.c also. */
static int buffer_array[2] = { 0, 0 };
#define BUF_MAX	0	/* buffer_array */
#define BUF_MIN	1

/* External functions and variables. */
extern void send_to_char(char *, struct char_data *);
extern void send_to_all(char *);
extern int circle_shutdown;
extern int circle_reboot;

/* Private functions. */
static struct buf_data *new_buffer(size_t size, int type);
static struct buf_data *malloc_buffer(size_t size, int type);
static struct buf_data *in_cache(const char *data);
static void free_buffer(struct buf_data *f);
static void clear_buffer(struct buf_data *clearme);
static void remove_buffer(struct buf_data *removeme);
static int remove_from_cache(struct buf_data *removeme);
static void add_to_cache(struct buf_data *addme);
static int get_used(struct buf_data *buf);
static int get_magnitude(ush_long number);
#if BUFFER_THREADED
static void *buffer_thread(void *);
static void bufferlist_lock(const char *func, ush_int line);
static void bufferlist_unlock(const char *func, ush_int line);
static void buffer_lock(struct buf_data *buf, int type, const char *func, ush_int line);
static void buffer_unlock(struct buf_data *buf, const char *func, ush_int line);
#endif


#if BUFFER_THREADED
/*
 * Wrapper macros.
 */
#include <pthread.h>
static pthread_mutex_t buflistmutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_t buf_thread = 0;
#define lock_buffers()		(bufferlist_lock(__FUNCTION__, __LINE__))
#define unlock_buffers()	(bufferlist_unlock(__FUNCTION__, __LINE__))
#define LOCK(buf, type)		(buffer_lock((buf), (type), __FUNCTION__, __LINE__))
#define UNLOCK(buf)		(buffer_unlock((buf), __FUNCTION__, __LINE__))
#define LOCKED(buf)		((buf)->locked)
#else
#define lock_buffers()		/* Not necessary. */
#define unlock_buffers()	/* Not necessary. */
#define LOCK(buf, type)		/* Not necessary. */
#define UNLOCK(buf)		/* Not necessary. */
#define LOCKED(buf)		(FALSE)
#endif

/*
 * Useful macros.
 */
#define buffer_hash(x)		((x) % BUFFER_HASH)
#define USED(x)			((x)->who)
#define get_buffer_head()	(buffers.buf)
#define set_buffer_head(x)	do { buffers.buf = (x); } while(0)
#define get_memory_head()	(buffers.mem)
#define set_memory_head(x)	do { buffers.mem = (x); } while(0)

/* ------------------------------------------------------------------------ */

/*
 * Private: count_bits(number to count)
 * Find out how many bits are in a number.  Used to see if it can be
 * rounded into a power of 2.
 */
static int count_bits(size_t y)
{
  int i, count = 0;

  for (i = 0; i < sizeof(size_t) * 8; i++)
    count += (y & (1 << i)) >> i;	/* Avoiding a jump to get 0 or 1. */
  return count;
}

/*
 * Private: round_to_pow2(number to round)
 * Converts a number to the next highest power of two.
 * 0000011000111010 (1594)
 *        to
 * 0000100000000000 (2048)
 */
#define bit(a,b)	((a) & (1 << (b)))
static void round_to_pow2(size_t *y)
{
  int i;

  if (count_bits(*y) <= 1)
    return;

  if (buffer_opt & BUF_VERBOSE)
    fprintf(stderr, "BUF: round_to_pow2: %d -> ", *y);

  i = sizeof(size_t) * 8 - 1;

  /* Check for MSB, otherwise scan for first set bit. */
  if (bit(*y, i) == 0) {
    do {
      if (bit(*y, i - 1) != 0)
        break;
    } while (--i > 0);

    /* No bits were set, exit. */
    if (i <= 0)
      return;

    /* Set the bit above the previous highest. */
    *y |= (1 << i);
  }

  /* Clear out the remaining bits. */
  while (i--)
    *y &= ~(1 << i);

  if (buffer_opt & BUF_VERBOSE) {
    fprintf(stderr, "%d\n", *y);
    fflush(stderr);
  }
} 

/*
 * Private: buffer_reboot(none)
 * Determine whether to reboot or continue after corruption.
 */
static void buffer_reboot(void)
{
   /* Recursing, just die now... */
  if (buffer_opt & BUF_OVERBOOT && circle_shutdown == 1 && circle_reboot == 1) {
    log("BUF: SYSERR: Clean shutdown not possible, dying...");
    exit(1);
  }
  
  init_buffers();
  
  if (buffer_opt & BUF_OVERBOOT) {
    send_to_all("Emergency reboot.. come back in a minute or two.\r\n");
    log("BUF: SYSERR: Emergency reboot, buffer corrupted!");
    circle_shutdown = circle_reboot = 1;
    return;
  }
  log("BUF: SYSERR: Buffer list cleared, crash imminent!");
}

#if BUFFER_EXTREME_PARANOIA == 0 || !defined(__linux__)	/* Doesn't support. */
#define valid_pointer(ptr)	(TRUE)

#else	/* only works on Linux due to pointer addresses. */
#define valid_pointer(ptr)	(((unsigned long)(ptr) & 0x48000000))

/*
 * Private: buffer_sanity_check(nothing)
 * Checks the entire buffer/memory list for overruns.
 */
static void buffer_sanity_check(struct buf_data **check)
{
  int magnitude, die = FALSE;

  if (check == NULL) {
    buffer_sanity_check(get_buffer_head());
    buffer_sanity_check(get_memory_head());
    return;
  }
  for (magnitude = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++) {
    struct buf_data *chk;
    if (check[magnitude] && !valid_pointer(check[magnitude]) && (die = TRUE))
      log("BUF: SYSERR: %s/%d head corrupted.", check == get_buffer_head() ? "buffer" : "memory", magnitude);
    for (chk = check[magnitude]; chk; chk = chk->next) {
      if (!valid_pointer(chk->data) && (die = TRUE))
	log("BUF: SYSERR: %p->%p (data) corrupted.", chk, chk->data);
      if (chk->next && !valid_pointer(chk->next) && (die = TRUE))
	log("BUF: SYSERR: %p->%p (next) corrupted.", chk, chk->next);
      if (chk->type != BT_MALLOC && valid_pointer(chk->life) && (die = TRUE))
	log("BUF: SYSERR: %p->%p [%ld] (life) is valid pointer on non-malloc memory.", chk, chk->var, chk->life);
      if (chk->type == BT_MALLOC && !valid_pointer(chk->var) && (die = TRUE))
	log("BUF: SYSERR: %p->%p [%ld] (var) not a valid pointer for malloc memory.", chk, chk->var, chk->life);
      if (chk->magic != MAGIC_NUMBER && (die = TRUE))
	log("BUF: SYSERR: %p->%d (magic) corrupted.", chk, chk->magic);
      if (chk->data[chk->req_size] != MAGIC_NUMBER && (die = TRUE))
	log("BUF: SYSERR: %p (%s:%d) overflowed requested size (%d).", chk, chk->who, chk->line, chk->req_size);
      if (chk->data[chk->size] != MAGIC_NUMBER && (die = TRUE))
	log("BUF: SYSERR: %p (%s:%d) overflowed real size (%d).", chk, chk->who, chk->line, chk->size);
    }
  }
  if (die)
    buffer_reboot();
}
#endif

/*
 * Private: magic_check(buffer to check)
 * Makes sure a buffer hasn't been overwritten by something else.
 */
static void magic_check(struct buf_data *buf)
{
  if (buf->magic != MAGIC_NUMBER) {
    char trashed[16];
    strncpy(trashed, (char *)buf, 15);
    trashed[15] = '\0';
    log("BUF: SYSERR: Buffer %p was trashed! (%s)", buf, trashed);
    buffer_reboot();
  }
}

/*
 * Private: get_magnitude(number)
 * Simple function to avoid math library, and enforce maximum allocations.
 * If it is not enforced here, we will overrun the bounds of the array.
 */
static int get_magnitude(ush_long y)
{
  ush_int number = buffer_hash(y);

  if (number > buffer_array[BUF_MAX]) {
    log("BUF: SYSERR: Hash result %d out of range 0-%d.", number, buffer_array[BUF_MAX]);
    number = buffer_array[BUF_MAX];
  }

  if (buffer_opt & BUF_VERBOSE)
    log("BUF: get_magnitude: %ld bytes -> %d", y, number);

  return number;
}

/*
 * Private: add_to_cache(structure to add)
 * Does what it says.
 */
static void add_to_cache(struct buf_data *addme)
{
  /*
   * Move everybody right.
   */
  memmove(buffer_cache + 1, buffer_cache, sizeof(struct buf_data *) * (CACHE_SIZE - 1));

  /*
   * Add the structure to the front.
   */
  buffer_cache[0] = addme;
}

/*
 * Private: remove_from_cache(structure to remove)
 * Does what it says.
 */
static int remove_from_cache(struct buf_data *removeme)
{
  int i, ret = FALSE;

  for (i = 0; i < CACHE_SIZE; i++)
    if (buffer_cache[i] == removeme) {
      buffer_cache[i] = NULL;
      ret = TRUE;
    }
  return ret;
}

/*
 * Private: in_cache(data to search for)
 * Used internally since the cache expanded complexity.
 */
static struct buf_data *in_cache(const char *data)
{
  int i;
  for (i = 0; i < CACHE_SIZE; i++)
    if (buffer_cache[i] && buffer_cache[i]->data == data) {
      buffer_cache_stat[BUFFER_CACHE_HITS]++;
      if (buffer_opt & BUF_VERBOSE)
	log("BUF: in_cache: Cache hit %p->%p from %p.", buffer_cache[i], buffer_cache[i]->data, data);
#if BUFFER_THREADED
      if (LOCKED(buffer_cache[i]))
	log("BUF: in_cache: Giving out locked buffer reference %p.", buffer_cache[i]);
#endif
      return buffer_cache[i];
    }
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: in_cache: Cache miss.");

  buffer_cache_stat[BUFFER_CACHE_MISSES]++;
  return NULL;
}

/*
 * Public: exit_buffers()
 * Called to clear out the buffer structures and log any BT_MALLOC's left.
 */
void exit_buffers(void)
{
  struct buf_data **head;
  ush_int magnitude;

  log("BUF: Shutting down.");
  
 /* buffer_opt = BUF_DETAIL;*/

#if BUFFER_THREADED
  pthread_join(buf_thread, NULL);
#endif

  log("BUF: Clearing buffer memory.");
  head = get_buffer_head();
  for (magnitude = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++) {
    struct buf_data *b, *bn;
    for (b = head[magnitude]; b; b = bn) {
      bn = b->next;
      LOCK(b, LOCK_WILL_CLEAR);
      clear_buffer(b);
      LOCK(b, LOCK_WILL_REMOVE);
      remove_buffer(b);
      LOCK(b, LOCK_WILL_FREE);
      free_buffer(b);
    }
  }
  log("BUF: Clearing malloc()'d memory.");
  head = get_memory_head();
  for (magnitude = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++)
    while (head[magnitude]) {
      LOCK(head[magnitude], LOCK_WILL_CLEAR);
      clear_buffer(head[magnitude]);
    }
  log("BUF: Done.");
}

/*
 * Private: find_hash(none)
 * Determine the size of the buffer array based on the hash size and the
 * allocation limits.
 */
static int find_hash(void)
{
  int maxhash = 0, result, i;
  
  if (buffer_opt & (BUF_DETAIL | BUF_VERBOSE))
    log("BUF: Calculating array size...");
    
  for (i = MIN_ALLOC; i <= MAX_ALLOC; i++) {
    result = buffer_hash(1 << i);
    if (result > maxhash)
      maxhash = result;
    if (buffer_opt & (BUF_DETAIL | BUF_VERBOSE))
      log("BUF: %7d -> %2d", 1 << i, result);
  }
  
  if (buffer_opt & (BUF_DETAIL | BUF_VERBOSE)) {
    log("BUF: ...done.");
    log("BUF: Array range is 0-%d.", maxhash);
  }
  
  buffer_array[BUF_MAX] = maxhash;
  return maxhash;
}

/*
 * Public: init_buffers(none)
 * This is called from main() to get everything started.
 */
void init_buffers(void)
{
#if BUFFER_THREADED
  int error = 0;
#endif
  static int yesyesiknow = FALSE;

  lock_buffers();
  
    /* Tag line. */
  if (!yesyesiknow) {
    log("BUF: Enhanced Buffer Allocation System v1.9");
    if (LEASE_LIFE * 2 < PULSE_BUFFER)
      log("BUF: SYSERR: Buffer lease life is too short.");
    if (BUFFER_LIFE * 2 < PULSE_BUFFER)
      log("BUF: SYSERR: Buffer unused life is too short.");
  }

  find_hash();

#if BUFFER_THREADED
  /*
   * If a buffer thread already exists, kill it.
   */
  if (buf_thread != 0)
    pthread_cancel(buf_thread);

  /*
   * Initialize pthread information and start the thread.
   */
  if ((error = pthread_create(&buf_thread, NULL, buffer_thread, NULL)) < 0) {
    perror("pthread_create");
    printf("%d\n", error);
    exit(1);
  }
#endif

  /*
   * Allocate room for the array of pointers.  We can't use the CREATE
   * macro here because that uses the array we're trying to make!
   */
  set_buffer_head(calloc(buffer_array[BUF_MAX] + 1, sizeof(struct buf_data *)));
  set_memory_head(calloc(buffer_array[BUF_MAX] + 1, sizeof(struct buf_data *)));

  if (!yesyesiknow) {
    log("BUF: Buffer cache: %d elements, %d bytes.", CACHE_SIZE, sizeof(struct buf_data *) * CACHE_SIZE);
    log("BUF: Allocations: %d-%d bytes (%d overhead)", 1 << MIN_ALLOC, 1 << MAX_ALLOC, sizeof(struct buf_data));
  }
  /*
   * Put any persistant buffers here.
   * Ex: new_buffer(8192, BT_PERSIST);
   */

  unlock_buffers();
  yesyesiknow = TRUE;
}

/*
 * Private: decrement_all_buffers(none)
 * Reduce the life on all buffers by 1.
 */
static void decrement_all_buffers(void)
{
  int magnitude;
  struct buf_data *clear, **head = get_buffer_head();

  for (magnitude = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++)
    for (clear = head[magnitude]; clear; clear = clear->next) {
      if (clear->type == BT_MALLOC) {
	log("BUF: SYSERR: Ack, memory (%p, %s:%d, '%s') in buffer list!", clear, clear->who, clear->line, clear->var);
	continue;
      }
      if (clear->life < 0)
	log("BUF: SYSERR: %p from %s:%d has %ld life.", clear, clear->who, clear->line, clear->life);
      else if (clear->life != 0)	/* We don't want to go negative. */
	clear->life--;
    }
}

/*
 * Private: release_old_buffers()
 * Check for any used buffers that have no remaining life.
 */
static void release_old_buffers(void)
{
  int magnitude;
  struct buf_data *relbuf, **head = get_buffer_head();

  for (magnitude = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++)
    for (relbuf = head[magnitude]; relbuf; relbuf = relbuf->next) {
      if (relbuf->type == BT_MALLOC) {
	log("BUF: SYSERR: Ack, memory (%p, %s:%d, '%s') in buffer list!", relbuf, relbuf->who, relbuf->line, relbuf->var);
	continue;
      }      
      if (!USED(relbuf))	/* Can't release, no one is using this. */
	continue;
      if (LOCKED(relbuf))	/* Someone has this locked already. */
	continue;
      if (relbuf->life > 0)	/* We only want expired buffers. */
	continue;
      LOCK(relbuf, LOCK_WILL_CLEAR);
      log("BUF: %s:%d forgot to release %d bytes in %p.", relbuf->who ? relbuf->who : "UNKNOWN", relbuf->line, relbuf->size, relbuf);
      clear_buffer(relbuf);
      UNLOCK(relbuf);
    }
}

/*
 * Private: free_old_buffers(void)
 * Get rid of any old unused buffers.
 */
static void free_old_buffers(void)
{
  int magnitude;
  struct buf_data *freebuf, *next_free, **head = get_buffer_head();

  lock_buffers();

  for (magnitude = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++)
    for (freebuf = head[magnitude]; freebuf; freebuf = next_free) {
      next_free = freebuf->next;
      if (freebuf->type != BT_STACK)	/* We don't free persistent ones. */
	continue;
      if (USED(freebuf))	/* Needs to be cleared first if used. */
	continue;      
      if (LOCKED(freebuf))	/* Already locked, skip it. */
	continue;
      if (freebuf->life > 0)	/* Hasn't expired yet. */
	continue;

      LOCK(freebuf, LOCK_WILL_REMOVE);
      remove_buffer(freebuf);
      LOCK(freebuf, LOCK_WILL_FREE);
      free_buffer(freebuf);
    }

  unlock_buffers();
}

/*
 * Public: release_all_buffers()
 * Forcibly release all buffers currently allocated.  This is useful to
 * reclaim any forgotten buffers.
 * See structs.h for PULSE_BUFFER to change the release rate.
 */
void release_all_buffers(void)
{
#if BUFFER_THREADED
  /* We don't do anything, there's already a thread doing this. */
#else
  decrement_all_buffers();
  release_old_buffers();
  free_old_buffers();
#endif
}

/*
 * Private: remove_buffer(buffer to remove)
 * Removes a buffer from the list without freeing it.
 */
static void remove_buffer(struct buf_data *removeme)
{
  struct buf_data **head, *traverse, *prev = NULL;
  int magnitude;

  if (!removeme) {
    log("BUF: SYSERR: NULL buf_data given to remove_buffer.");
    return;
  }

#if BUFFER_THREADED
  if (LOCKED(removeme) != LOCK_WILL_REMOVE)
    log("BUF: SYSERR: remove_buffer: Lock bit not properly set on %p!", removeme);
#endif

  head = (removeme->type == BT_MALLOC ? get_memory_head() : get_buffer_head());
  magnitude = get_magnitude(removeme->size);

  for (traverse = head[magnitude]; traverse; traverse = traverse->next) {
    if (traverse == removeme) {
      if (traverse == head[magnitude])
	head[magnitude] = traverse->next;
      else if (prev)
	prev->next = traverse->next;
      else
	log("BUF: SYSERR: remove_buffer: Don't know what to do with %p.", removeme);
#if BUFFER_THREADED
      if (LOCKED(removeme) != LOCK_WILL_REMOVE)
	log("BUF: SYSERR: remove_buffer: Lock bit removed from %p during operation!", removeme);
#endif
      return;
    }
    prev = traverse;
  }
  log("BUF: SYSERR: remove_buffer: Couldn't find the buffer %p from %s:%d.", removeme, removeme->who, removeme->line);
}

/*
 * Private: clear_buffer(buffer to clear)
 * This is used to declare an allocated buffer unused.
 */
static void clear_buffer(struct buf_data *clearme)
{
  if (clearme == NULL) {
    log("BUF: SYSERR: clear_buffer: NULL argument.");
    return;
  }

#if BUFFER_THREADED
  if (LOCKED(clearme) != LOCK_WILL_CLEAR)
    log("BUF: SYSERR: clear_buffer: Lock not properly set on %p!", clearme);
#endif

  magic_check(clearme);

  /*
   * If the magic number we set is not there then we have a suspected
   * buffer overflow.
   */
  if (clearme->data[clearme->req_size] != MAGIC_NUMBER) {
    log("BUF: SYSERR: Overflow in %p (%s) from %s:%d.",
		clearme, clearme->type == BT_MALLOC ? clearme->var : "a buffer", clearme->who ? clearme->who : "UNKNOWN", clearme->line);
    log("BUF: SYSERR: ... ticketed for doing %d in a %d (%d) zone.",
		strlen(clearme->data) + 1, clearme->req_size, clearme->size);
    if (clearme->data[clearme->size] == MAGIC_NUMBER) {
      log("BUF: SYSERR: ... overflow did not compromise memory.");
      clearme->data[clearme->req_size - 1] = '\0';
      clearme->data[clearme->req_size] = MAGIC_NUMBER;
    } else
      buffer_reboot();
  } else if (clearme->type == BT_MALLOC) {
    lock_buffers();
    LOCK(clearme, LOCK_WILL_REMOVE);
    remove_buffer(clearme);
    LOCK(clearme, LOCK_WILL_FREE);
    free_buffer(clearme);
    unlock_buffers();
  } else {
    if (buffer_opt & BUF_CHECK) {
      /*
       * If nothing in clearme->data return 0, else if paranoid_buffer, return
       * the result of get_used(), otherwise just strlen() the buffer.
       */
      log("BUF: %s:%d used %d/%d bytes in %p.",
		clearme->who, clearme->line, (clearme->data && *clearme->data ?
		((buffer_opt & BUF_NUKE) ? get_used(clearme) :
		strlen(clearme->data)) : 0), clearme->req_size, clearme);
    }
    if (buffer_opt & BUF_NUKE)
      memset(clearme->data, '\0', clearme->size);
    else
      *clearme->data = '\0';
    clearme->who = NULL;
    clearme->line = 0;
    clearme->req_size = clearme->size;	/* For exit_buffers() check. */
    clearme->life = B_FREELIFE;
#if BUFFER_THREADED
    if (LOCKED(clearme) != LOCK_WILL_CLEAR)
      log("BUF: SYSERR: clear_buffer: Someone cleared lock bit on %p.", clearme);
#endif
  }
}

/*
 * Private: find_this_buffer(buffer data pointer)
 * Used by detach_buffer() to locate the correct buffer.
 */
static struct buf_data *find_this_buffer(char *given, int type, int *searches)
{
  struct buf_data *clear, **b_head;
  int magnitude, scanned;
  
  if (searches)
    *searches = -1;

  /*
   * We cache the last allocated buffer to speed up cases where we
   * allocate a buffer and then free it shortly afterwards.
   */
  if ((clear = in_cache(given)) != NULL)    
    return clear;  

  b_head = (type == BT_MALLOC ? get_memory_head() : get_buffer_head());

  for (magnitude = 0, scanned = 0; magnitude <= buffer_array[BUF_MAX]; magnitude++)
    for (clear = b_head[magnitude]; clear; clear = clear->next, scanned++)
      if ((clear) && (clear->data)) 
        if (clear->data == given)
          goto got_it;	/* Cleaner than attempting two 'break;' commands. */

got_it:

  if (buffer_opt & BUF_VERBOSE)
    log("BUF: find_this_buffer: Scanning for %p, found %p->%p (%d scans).\n", given, clear, clear ? clear->data : NULL, scanned);

  if (searches)
    *searches = scanned;
  return clear;
}

/*
 * Public: as release_buffer(buffer data pointer)
 * Used throughout the code to finish their use of the buffer.
 */
struct buf_data *detach_buffer(char *data, byte type, const char *func, const int line_n)
{
  struct buf_data *clear;
  int scanned;

  if (data == NULL || func == NULL) {
    log("BUF: SYSERR: detach_buffer: Invalid information passed from %s:%d.", func, line_n);
    return FALSE;
  }

  clear = find_this_buffer(data, type, &scanned);

  if (clear == NULL) {
    log("BUF: SYSERR: detach_buffer: No buffer->data %p found for %s:%d.", data, func, line_n);
#if BUFFER_THREADED
  } else if (LOCKED(clear)) {
    if (LOCKED(clear) == LOCK_WILL_FREE)
      log("BUF: detach_buffer: Buffer %p, requested by %s:%d, already slated to be freed.", clear, func, line_n);
    else if (LOCKED(clear) == LOCK_WILL_CLEAR)
      log("BUF: detach_buffer: Buffer %p, requested by %s:%d, already being detached.", clear, func, line_n);
    else if (LOCKED(clear) == LOCK_WILL_REMOVE)
      log("BUF: detach_buffer: Buffer %p, requested by %s:%d, already being removed from list.", clear, func, line_n);
    else
      log("BUF: detach_buffer: Buffer %p, requested by %s:%d, already locked.", clear, func, line_n);
#endif
  } else if (clear->who == NULL)
    log("BUF: SYSERR: detach_buffer: Buffer %p, requested by %s:%d, already released. Locked: %d", clear, func, line_n, LOCKED(clear));
  else {
    LOCK(clear, LOCK_WILL_CLEAR);
    if (buffer_opt & (BUF_VERBOSE | BUF_DETAIL))
      log("BUF: %s:%d released %d bytes in '%s' (%p, %d scans) from %s:%d.", func, line_n,
		clear->size, clear->type == BT_MALLOC ? clear->var : "a buffer", clear, scanned, clear->who ? clear->who : "UNKNOWN", clear->line);
    clear_buffer(clear);
    UNLOCK(clear);
    return clear;
  }
  return NULL;
}
  
/*
 * Private: free_buffer(buffer)
 * Internal function for getting rid of buffers.
 */
static void free_buffer(struct buf_data *f)
{
  if (f == NULL) {
    log("BUF: SYSERR: free_buffer: NULL pointer.");
    return;
  } else if (f->type == BT_PERSIST)
    log("BUF: SYSERR: free_buffer: Freeing %d byte persistant buffer %p.", f->size, f);
  else if (f->type == BT_MALLOC) {
    if (buffer_opt & (BUF_VERBOSE | BUF_DETAIL))
      log("BUF: free_buffer: Freeing %d bytes in '%s' (%p) from %s:%d.", f->size, f->var, f, f->who, f->line);
  }/* else
    log("BUF: free_buffer: Freeing %d bytes in expired buffer %p.", f->size, f);*/

#if BUFFER_THREADED
  if (LOCKED(f) != LOCK_WILL_FREE)
    log("BUF: SYSERR: free_buffer: Lock not properly set on %p!", f);
#endif

  /*
   * Would be very bad to reuse this buffer after it is free()'d.
   */
  remove_from_cache(f);

  if (f->data)
    really_free(f->data);
  else
    log("BUF: SYSERR: free_buffer: Hey, no data in %p?", f);
  really_free(f);
}

/*
 * Private: new_buffer(size of buffer, type flag)
 * Finds where it should place the new buffer it's trying to malloc.
 */
static struct buf_data *new_buffer(size_t size, int type)
{
  struct buf_data **buflist, *potential;
  int magnitude;

  if (size == 0) {
    log("BUF: SYSERR: new_buffer: 0 byte buffer requested.");
    return NULL;
  }

  /*
   * This caused a severe bug when it was in malloc_buffer().  Basically the
   * buffer would be placed according to the non-rounded size and then later
   * rounded.  This would cause a lookup to fail later when the hash returns
   * a different value based on the new size.
   */
  if (type != BT_MALLOC)
    round_to_pow2(&size);

  /*
   * We separate the malloc and buffer lists for efficiency.
   */
  buflist = (type == BT_MALLOC ? get_memory_head() : get_buffer_head());
  magnitude = get_magnitude(size);

  /*
   * The new method of prepending and rounding is extremely fast and clean.
   */
   potential = NULL;
   potential = malloc_buffer(size, type);
   if (potential) {
    lock_buffers();
    potential->next = buflist[magnitude];
    buflist[magnitude] = potential;
    unlock_buffers();
   } 
   return potential;
    
}

/*
 * Private: malloc_buffer(size of buffer, type flag)
 * Creates a new buffer for use.
 */
static struct buf_data *malloc_buffer(size_t size, int type)
{
  struct buf_data *new_buf;

  if (!(new_buf = (struct buf_data *)malloc(sizeof(struct buf_data)))) {
    log("BUF: SYSERR: malloc_buffer: Failed %d byte 'buf_data' malloc().", sizeof(struct buf_data));
    /*perror("malloc_buffer()");*/
    return NULL;
  }

  memset(new_buf, 0, sizeof(struct buf_data));

  LOCK(new_buf, LOCK_ACQUIRE);

  if ((new_buf->data = (char *)malloc(size + 1)) == NULL){
    log("BUF: SYSERR: malloc_buffer: Failed %d byte 'data' malloc().", size);
    really_free(new_buf);
    /*perror("malloc_buffer()");*/
    return NULL;
  }
  
  new_buf->magic = MAGIC_NUMBER;
  new_buf->who = NULL;
  new_buf->line = 0;
  new_buf->type = type;
  new_buf->next = NULL;
  new_buf->size = size;
  new_buf->req_size = size;	/* do_buffer fools overflow code otherwise. */
  if (type != BT_MALLOC)
    new_buf->life = B_FREELIFE;
  else
    new_buf->var = NULL;

  if (buffer_opt & (BUF_VERBOSE | BUF_DETAIL))
    log("BUF: malloc_buffer: Allocated %d byte buffer %p, %d byte overhead.",
		new_buf->size, new_buf, sizeof(struct buf_data));

  /* We emulate calloc(), remember? */
  if (type == BT_MALLOC || buffer_opt & BUF_NUKE)
    memset(new_buf->data, '\0', new_buf->size);
  else
    *new_buf->data = '\0';

  /* Implant number here. */
  new_buf->data[new_buf->size] = MAGIC_NUMBER;

  return new_buf;
}

/*
 * We no longer search for buffers outside the specified power of 2 since
 * the next highest array index may actually be smaller.
 */
struct buf_data *find_free_buffer(size_t size)
{
  struct buf_data *search, **head = get_buffer_head();
  int magnitude = get_magnitude(size), scans = 0;

  lock_buffers();

  for (search = head[magnitude]; search; search = search->next) {
    scans++;
    if (search->type == BT_MALLOC) {
      log("BUF: SYSERR: Ack, memory (%p, %s:%d, '%s') in buffer list!", search, search->who, search->line, search->var);
      continue;
    }
    if (LOCKED(search))
      continue;
    if (USED(search))
      continue;
    if (search->size < size)
      continue;
    LOCK(search, LOCK_ACQUIRE);
    break;
  }
  if (buffer_opt & (BUF_VERBOSE | BUF_DETAIL))
    log("BUF: find_free_buffer: %d scans for %d bytes, found %p.", scans, size, search);
  unlock_buffers();
  return search;
}

/*
 * Public: as get_buffer(size of buffer)
 * Requests a buffer from the free pool.  If a buffer of the desired size
 * is not available, one is created.
 */
char *acquire_buffer(size_t size, int type, const char *varname, const char *who, ush_int line)
{
  struct buf_data *give;

#if BUFFER_EXTREME_PARANOIA
  buffer_sanity_check(NULL);
#endif

  /* Could happen... */
  if (buffer_array[BUF_MAX] == 0) {
    log("BUF: SYSERR: System has not been initialized before request from %s:%d.", who, line);
    log("BUF: SYSERR: ... You need to call init_buffers() first.");
    abort();		/* Could call it here, but why hide the bug? */
  }

  if (size > BUFFER_MAXSIZE)
    log("BUF: %s:%d requested %d bytes for '%s'.", who, line, size, varname);

  if (size == 0) {
    log("BUF: SYSERR: %s:%d requested 0 bytes.", who, line);
    return NULL;
  } else if (type == BT_MALLOC)
    give = new_buffer(size, type);
  else if ((give = find_free_buffer(size)) == NULL) {
    /*
     * Minimum buffer size, since small ones have high overhead.
     */
    ush_long allocate_size;
    if ((allocate_size = size) < BUFFER_MINSIZE && type != BT_MALLOC)
      allocate_size = BUFFER_MINSIZE;

    if (buffer_opt & (BUF_VERBOSE | BUF_DETAIL))
      log("BUF: acquire_buffer: Making a new %ld byte buffer for %s:%d.", allocate_size, who, line);

    /*
     * If we don't have a valid pointer by now, we're out of memory so just
     * return NULL and hope things don't crash too soon.
     */
    if ((give = new_buffer(allocate_size, type)) == NULL)
      return NULL;
  }
  
  if (give == NULL)
   return NULL;

  magic_check(give);

#if BUFFER_THREADED
  if (LOCKED(give) != LOCK_ACQUIRE) {
    log("BUF: SYSERR: acquire_buffer: Someone stole my buffer.");
    abort();
  }
#endif

  give->who = who;
  give->line = line;
  give->req_size = size;

  if (type != BT_MALLOC)
    give->life = B_GIVELIFE;
  else
    give->var = varname;

  if (buffer_opt & (BUF_VERBOSE | BUF_DETAIL))
    log("BUF: %s:%d requested %d bytes for '%s', received %d in %p.", who, line, size, varname ? varname : "a buffer", give->size, give);

  /*
   * Plant a magic number to see if someone overruns the buffer. If the first
   * character of the buffer is not NUL then somehow our memory was
   * overwritten...most likely by someone doing a release_buffer() and
   * keeping a secondary pointer to the buffer.
   */
  give->data[give->req_size] = MAGIC_NUMBER;
  if (*give->data != '\0') {
    log("BUF: SYSERR: acquire_buffer: Buffer %p is not empty as it ought to be!", give);
    *give->data = '\0';
  }

#if 0
  /* This will only work if the buf_data is allocated by valloc(). */
  if (type == BT_MALLOC)
    if (mprotect(give, sizeof(struct buf_data), PROT_READ) < 0)
      abort();
#endif

  UNLOCK(give);

  add_to_cache(give);	/* Cache this entry. */
  
  if (give->type == BT_STACK && give->life <= 1) {
    log("BUF: SYSERR: acquire_buffer: give->life <= 1 (Invalid lease life?!)");
    give->life = 10;
  }

  return give->data;
}

/*
 * Public: as 'show buffers'
 * This is really only useful to see who has lingering buffers around
 * or if you are curious.  It can't be called in the middle of a
 * command run by a player so it'll usually show the same thing.
 * You can call this with a NULL parameter to have it logged at any
 * time though.
 */
/*
 * XXX: This code works but is ugly and misleading.
 */
void show_buffers(struct char_data *ch, int buffer_type, int display_type)
{
  struct buf_data *disp, **head = NULL;
  char *buf;
  long i, size;
  char *buf_type[] = { "Stack", "Persist", "Malloc" };

  if (display_type == 1) {
    head = get_buffer_head();
    log("BUF: --- Buffer list --- (Inaccurate if not perfect hash.)");
  } else if (display_type == 2) {
    head = get_memory_head();
    log("BUF: --- Memory list --- (Byte categories are inaccurate.)");
  }
  if (display_type == 1 || display_type == 2) {
    for (size = MIN_ALLOC; size <= MAX_ALLOC; size++) {
      long bytes;
      int magnitude = get_magnitude(1 << size);
      for (i = 0, bytes = 0, disp = head[magnitude]; disp; disp = disp->next, i++)
	bytes += disp->size;
      log("%5d bytes (%2d): %5ld items, %6ld bytes, %5ld overhead.", (1 << size), magnitude, i, bytes, sizeof(struct buf_data) * i);
    }
    return;
  }

  buf = get_buffer(MAX_STRING_LENGTH);
  head = get_buffer_head();

  for (size = 0; size <= buffer_array[BUF_MAX]; size++)
    for (i = 0, disp = head[size]; disp; disp = disp->next) {
      if (buffer_type != -1 && buffer_type != disp->type) /* -1 == all */
	continue;
      sprintf(buf, "%1ld #%2ld %5d bytes, Life: %5ld, Type: %7s, Allocated: %s/%d.%s",
		size, ++i, disp->size, disp->life,
		buf_type[(int)disp->type], disp->who ? disp->who : "unused",
		disp->line ? disp->line : 0, ch ? "\r\n" : "");
      if (ch)
	send_to_char(buf, ch);
      else
	log(buf);
    }

  release_buffer(buf);
}

/*
 * Tests the overflow code.  Do not use. :)
 */
ACMD(do_overflow)
{
  /*
   * Write 256 bytes into the 130 byte buffer. Tweak to suit.
   */
  int write = 256, bufsize = 130;
  char *buf;

  buf = get_buffer(bufsize);
  while (--write)
    buf[write] = write;
  release_buffer(buf);

  if (ch)
    send_to_char("Ok!\r\n", ch);
}

char *BUFFER_FORMAT =
"buffer (add | delete) size (persistant | temporary)\r\n"
"buffer verbose - toggle verbose mode.\r\n"
"buffer detailed - toggle detailed mode.\r\n"
"buffer paranoid - toggle between memset() or *buf = NUL.\r\n"
"buffer check - toggle buffer usage checking.\r\n"
"buffer overflow - toggle immediate reboot on overflow.\r\n";

ACMD(do_buffer)
{
  char *arg1, *arg2, *arg3;
  long size;
  int persistant = FALSE;

  /* This looks nifty. */
  half_chop(argument, (arg1 = get_buffer(MAX_INPUT_LENGTH)), argument);
  half_chop(argument, (arg2 = get_buffer(MAX_INPUT_LENGTH)), argument);
  half_chop(argument, (arg3 = get_buffer(MAX_INPUT_LENGTH)), argument);

  if (!*arg1)
    size = -1;
  else if (!*arg2 || !*arg3)
    size = -2;
  else if ((size = atoi(arg2)) == 0)
    size = -1;
  else if (is_abbrev(arg3, "persistant"))
    persistant = TRUE;
  else if (is_abbrev(arg3, "temporary"))
    persistant = FALSE;
  else
    persistant = FALSE;

  /* Don't need these now. */
  release_buffer(arg2);
  release_buffer(arg3);

  if (size == -1)	/* Oops, error. */
    send_to_char(BUFFER_FORMAT, ch);
  else if (size == -2) {	/* -2 means a toggle command. */
    if (is_abbrev(arg1, "verbose")) {
      buffer_opt ^= BUF_VERBOSE;
      send_to_char((buffer_opt & BUF_VERBOSE) ? "Verbose On.\r\n" : "Verbose Off.\r\n", ch);
    } else if (is_abbrev(arg1, "detailed")) {
      buffer_opt ^= BUF_DETAIL;
      send_to_char((buffer_opt & BUF_DETAIL) ? "Detailed On.\r\n" : "Detailed Off.\r\n", ch);
    } else if (is_abbrev(arg1, "paranoid")) {
      buffer_opt ^= BUF_NUKE;
      send_to_char((buffer_opt & BUF_NUKE) ? "Now paranoid.\r\n" : "No longer paranoid.\r\n", ch);
    } else if (is_abbrev(arg1, "check")) {
      buffer_opt ^= BUF_CHECK;
      send_to_char((buffer_opt & BUF_CHECK) ? "Checking on.\r\n" : "Not checking.\r\n", ch);
    } else if (is_abbrev(arg1, "overflow")) {
      buffer_opt ^= BUF_OVERBOOT;
      send_to_char((buffer_opt & BUF_OVERBOOT) ? "Reboot on overflow.\r\n" : "Will try to keep going.\r\n", ch);
    } else
      send_to_char(BUFFER_FORMAT, ch);
  } else if (is_abbrev(arg1, "delete")) {
    struct buf_data *toy, **b_head = get_buffer_head();
    for (toy = b_head[get_magnitude(size)]; toy; toy = toy->next) {
      if (USED(toy))
	continue;
      if (toy->size != size)
	continue;
      if (persistant != toy->type)
	continue;
      if (LOCKED(toy))
	continue;
      LOCK(toy, LOCK_WILL_REMOVE);
      remove_buffer(toy);
      LOCK(toy, LOCK_WILL_FREE);
      free_buffer(toy);
      break;
    }
    if (!toy)
      send_to_char("Not found.\r\n", ch);
  } else if (is_abbrev(arg1, "add"))
    new_buffer(size, persistant); /* So easy. :) */
  else
    send_to_char(BUFFER_FORMAT, ch);

  release_buffer(arg1);
}

/*
 * Private: get_used(buffer to search)
 * Used mainly in when releasing a buffer and check size is set.
 * Does a backwards search for the first non-NUL character.
 * Useful for when a function uses a large buffer and then uses
 * it later for a smaller string, this will always return the
 * most used value.
 */
static int get_used(struct buf_data *buf)
{
  int cnt;
  for (cnt = buf->req_size - 1; cnt > 0 && buf->data[cnt] == '\0'; cnt--);
  return cnt;
}

/* ------------------------------------------------------------------------ */

#if BUFFER_MEMORY

char *debug_str_dup(const char *txt, const char *varname, const char *func, ush_int line)
{
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: debug_str_dup: %d bytes from %s:%d for '%s'.", strlen(txt) + 1, func, line, varname);
  return strcpy(acquire_buffer(strlen(txt) + 1, BT_MALLOC, varname, func, line), txt);
}

void *debug_calloc(size_t number, size_t size, const char *varname, const char *func, int line)
{
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: debug_calloc: %d*%d bytes from %s:%d for '%s'.", number, size, func, line, varname);
  return acquire_buffer(number * size, BT_MALLOC, varname, func, line);
}

void debug_free(void *ptr, const char *func, ush_int line)
{
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: debug_free: %p from %s:%d.", ptr, func, line);
  /* BT_MALLOC's are free()'d */
  detach_buffer(ptr, BT_MALLOC, func, line);
}

void *debug_realloc(void *ptr, size_t size, const char *varname, const char *func, int line)
{
  void *xtra;
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: debug_realloc: '%s' (%p) resized to %d bytes for %s:%d.", varname, ptr, size, func, line);
  xtra = acquire_buffer(size, BT_MALLOC, varname, func, line);
  memmove(xtra, ptr, size);
  detach_buffer(ptr, BT_MALLOC, func, line);
  return xtra;
}
#endif

/* ------------------------------------------------------------------------ */

#if BUFFER_THREADED

static void bufferlist_lock(const char *func, ush_int line)
{
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: List locked by %s:%d.", func, line);
  pthread_mutex_lock(&buflistmutex);
}

static void bufferlist_unlock(const char *func, ush_int line)
{
  if (buffer_opt & BUF_VERBOSE)
    log("BUF: List unlocked by %s:%d.", func, line);
  pthread_mutex_unlock(&buflistmutex);
}

static void buffer_lock(struct buf_data *buf, int type, const char *func, ush_int line)
{
  if (buf == NULL)
    log("BUF: SYSERR: buffer_lock: buf == NULL from %s:%d", func, line);
  else if (LOCKED(buf) != LOCK_NONE && LOCKED(buf) != LOCK_WILL_REMOVE && type != LOCK_WILL_FREE && LOCKED(buf) != LOCK_WILL_CLEAR && type != LOCK_WILL_REMOVE)
    log("BUF: SYSERR: buffer_lock: Trying to lock a buffer %p already locked, from %d to %d at %s:%d.", buf, LOCKED(buf), type, func, line);
  else
    buf->locked = type;
}

static void buffer_unlock(struct buf_data *buf, const char *func, ush_int line)
{
  if (buf == NULL)
    log("BUF: SYSERR: buffer_unlock: buf == NULL from %s:%d.", func, line);
  else if (LOCKED(buf) == LOCK_NONE)
    log("BUF: SYSERR: buffer_unlock: Buffer %p isn't locked, from %s:%d.", buf, func, line);
  else
    buf->locked = LOCK_NONE;
}

/*
 * Public: buffer_thread()
 * If we ever have a multithreaded base, this would be a very nice
 * application for it.  I plan to add a timer on how long someone
 * has used a buffer.
 *
 * Work in progress.
 */
void *buffer_thread(void *nothing)
{
  struct timeval tv;

  tv.tv_sec = 0;
  tv.tv_usec = OPT_USEC;
  log("BUF: Started buffer thread.");

  while (!circle_shutdown) {
    /* This is a generic function to reduce the life on all buffers by 1. */
    decrement_all_buffers();

    /* This checks for any buffers which were never released. */
    release_old_buffers();

    /* Here we free() any buffer which has not been used in a while. */
    free_old_buffers();

    /* Sleep the same amount of time the main loop does. */
    select(0, NULL, NULL, NULL, &tv);
  
    /* See if we should exit. */
    pthread_testcancel();
  }

  log("BUF: Buffer thread exited.");
  return NULL;
}
#endif

/* ------------------------------------------------------------------------ */

#if 0 /* BUFFER_SNPRINTF */
/*
 * Buffer using sprintf() with bounds checking via snprintf()
 */
int bprintf(buffer *str, const char *format, ...)
{
  va_list args;
  int chars, warned = FALSE;

  for (;;) {
    va_start(args, format);
    chars = vsnprintf(str->data, str->req_size, format, args);
    va_end(args);

    /* Wrote ok. */
    if (chars < str->req_size)
      break;

    if (!warned)
      log("BUF: SYSERR: bprintf: Overflow attempt in buffer %p from %s:%d with format '%s'.", str, str->who, str->line, format);

    /* Don't try again if it doesn't matter. */
    if (str->req_size == str->size)
      break;

    /* Don't double warn. */
    warned = TRUE;
    str->req_size = str->size;
  }
  return chars;
}

/*
 * Buffer wrapper.
 * b2b = from buffer to buffer.
 * s2b = from string to buffer.
 * b2s = from buffer to string.
 * s2s = doesn't exist, think about it.
 *
 * Another options would be to make b2b_cpy the default strcpy with #define.
 */
char *b2b_cpy(buffer *str1, const buffer *str2) { strcpy(str1->data, str2->data); }
char *s2b_cpy(buffer *str1, const char *str2) { strcpy(str1->data, str2); }
char *b2s_cpy(char *str1, const buffer *str2) { strcpy(str1, str2->data); )
char *b2s_cat(char *str1, const buffer *str2) { strcat(str1, str2->data); }
char *s2b_cat(buffer *str1, const char *str2) { strcat(str1->data, str2); }
char *b2b_cat(buffer *str1, const buffer *str2) { strcat(str1->data, str2->data); }
#endif

/* ------------------------------------------------------------------------ */

/*
 * At the bottom because we need to undefine the macro to get correct
 * results.
 */
/*#if BUFFER_MEMORY
#undef free*/
void really_free(void *ptr)
{
  if (!ptr)	/* Your OS may already do this, but it's insignificant. */
    return;
  free(ptr);
}
/*#endif*/
::::::::::::::
bufhash.c
::::::::::::::
/*
 * Copyright (C), 1997, 1998 George Greer
 * License: public domain
 * Warranty: none at all
 *
 * To use:
 *   gcc -o hash bufhash.c
 *   ./hash <hash_size> <MIN_ALLOC> <MAX_ALLOC>
 *
 * i.e.: hash 11 6 16
 */
#include <stdio.h>
#include <stdlib.h>

int pow2(int n)
{
  return (--n, n == -1 ? 1 : pow2(n) * 2);
}

int hash(int i, int w)
{
  return (i % w);
}

int main(int argc, char **argv)
{
  int i, hv, min, max;

  if (argc != 4) {
    printf("Usage: %s <hash> <min order> <max order>\n", argv[0]);
    return 1;
  }

  hv = atoi(argv[1]);
  min = atoi(argv[2]);
  max = atoi(argv[3]);

  for (i = min; i <= max; i++) {
    printf("%2d: %5d -> %2d\n", i, pow2(i), hash(pow2(i), hv));
  }
  return 0;
}
::::::::::::::
buftest.c
::::::::::::::
#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "utils.h"

void half_chop(char *string, char *arg1, char *arg2) {}
int is_abbrev(const char *arg1, const char *arg2) {}
void send_to_char(const char *x, struct char_data *y) {}
void send_to_all(const char *x) {}
int circle_shutdown, circle_reboot;
void skip_spaces(char **x) {}
#define logfile stderr
void basic_mud_log(const char *format, ...)
{va_list args;time_t ct = time(0);char *time_s = asctime(localtime(&ct));
time_s[strlen(time_s) - 1] = '\0';if (logfile == NULL)abort();
fprintf(logfile, "%-15.15s :: ", time_s + 4);va_start(args, format);
vfprintf(logfile, format, args);va_end(args);fprintf(logfile, "\n");
fflush(logfile);}
extern int buffer_opt;

int main(void)
{
  buffer *foo;
  buffer *bar;

  init_buffers();
  buffer_opt = 20;

  foo = get_buffer(32);
  bar = get_buffer(32);

  bprintf(foo, "This is a test of the emergency buffer system.");
  s2b_cat(foo, "This is only a test.");

  s2b_cpy(bar, "1234567890123456789012345678901234567890");
  s2b_cat(bar, "1234567890123456789012345678901234567890");
  printf("[%s|%s]\n", sz(foo), sz(bar));
  release_buffer(bar);
  release_buffer(foo);

  return 0;
}
::::::::::::::
castle.c
::::::::::::::
/* ************************************************************************
*   File: castle.c                                      Part of CircleMUD *
*  Usage: Special procedures for King's Castle area                       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Special procedures for Kings Castle by Pjotr (d90-pem@nada.kth.se)     *
*  Coded by Sapowox (d90-jkr@nada.kth.se)                                 *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "buffer.h"

/*   external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct time_info_data time_info;
extern int mini_mud;

/* IMPORTANT!
   The below defined number is the zone number of the Kings Castle.
   Change it to apply to your chosen zone number. The default zone
   number (On Alex and Alfa) is 80 (That is rooms and mobs have numbers
   in the 8000 series... */

#define Z_KINGS_C 150
/* local functions */
struct char_data *find_npc_by_name(struct char_data * chAtChar, const char *pszName, int iLen);
int block_way(struct char_data * ch, int cmd, char *arg, int iIn_room, int iProhibited_direction);
void assign_kings_castle(void);
int member_of_staff(struct char_data * chChar);
int member_of_royal_guard(struct char_data * chChar);
struct char_data *find_guard(struct char_data * chAtChar);
struct char_data *get_victim(struct char_data * chAtChar);
int banzaii(struct char_data * ch);
int do_npc_rescue(struct char_data * ch_hero, struct char_data * ch_victim);
int is_trash(struct obj_data * i);
void fry_victim(struct char_data * ch);


/**********************************************************************\
|* Special procedures for Kings Castle by Pjotr (d90-pem@nada.kth.se) *|
|* Coded by Sapowox (d90-jkr@nada.kth.se)                             *|
\**********************************************************************/

/*
 * 11/4/97 - This is kind of ugly but fixes a memory problem if a mob in
 *      the King's Castle does not exist. (Writing to mob_index[-1].func)
 */
#define C_MOB_SPEC(zone,mob)                                    \
        if ((check = real_mobile(((zone)*100)+(mob))) < 0) {    \
          if (!mini_mud) {                                      \
            sprintf(buf, "assign_kings_castle(): can't find mob #%d.", ((zone)*100)+(mob));     \
            log(buf);                                           \
          }                                                     \
        } else                                                  \
          mob_index[check].func

#define R_MOB(zone, mob) (real_mobile(((zone)*100)+(mob)))
#define R_OBJ(zone, obj) (real_object(((zone)*100)+(obj)))
#define R_ROOM(zone, num) (real_room(((zone)*100)+(num)))

#define CASTLE_ITEM(item) (Z_KINGS_C*100+(item))

SPECIAL(CastleGuard);
SPECIAL(James);
SPECIAL(cleaning);
SPECIAL(DicknDavid);
SPECIAL(tim);
SPECIAL(tom);
SPECIAL(king_welmar);
SPECIAL(training_master);
SPECIAL(peter);
SPECIAL(jerry);
ACMD(do_gen_door);
ACMD(do_follow);


/* Routine assign_kings_castle */
/* Used to assign function pointers to all mobiles in the Kings Castle */
/* Add a call to it from spec_assign.c! */

void assign_kings_castle(void)
{
  int check;

  C_MOB_SPEC(Z_KINGS_C, 0) = CastleGuard;   /* Gwydion */
  /* Added the previous line -- Furry */
  C_MOB_SPEC(Z_KINGS_C, 1) = king_welmar;   /* Our dear friend, the King */
  C_MOB_SPEC(Z_KINGS_C, 3) = CastleGuard;       /* Jim */
  C_MOB_SPEC(Z_KINGS_C, 4) = CastleGuard;       /* Brian */
  C_MOB_SPEC(Z_KINGS_C, 5) = CastleGuard;       /* Mick */
  C_MOB_SPEC(Z_KINGS_C, 6) = CastleGuard;       /* Matt */
  C_MOB_SPEC(Z_KINGS_C, 7) = CastleGuard;       /* Jochem */
  C_MOB_SPEC(Z_KINGS_C, 8) = CastleGuard;       /* Anne */
  C_MOB_SPEC(Z_KINGS_C, 9) = CastleGuard;       /* Andrew */
  C_MOB_SPEC(Z_KINGS_C, 10) = CastleGuard;      /* Bertram */
  C_MOB_SPEC(Z_KINGS_C, 11) = CastleGuard;      /* Jeanette */
  C_MOB_SPEC(Z_KINGS_C, 12) = peter;    /* Peter */
  C_MOB_SPEC(Z_KINGS_C, 13) = training_master;  /* The training master */
  C_MOB_SPEC(Z_KINGS_C, 16) = James;    /* James the Butler */
  C_MOB_SPEC(Z_KINGS_C, 17) = cleaning; /* Ze Cleaning Fomen */
  C_MOB_SPEC(Z_KINGS_C, 20) = tim;      /* Tim, Tom's twin */
  C_MOB_SPEC(Z_KINGS_C, 21) = tom;      /* Tom, Tim's twin */
  C_MOB_SPEC(Z_KINGS_C, 24) = DicknDavid;       /* Dick, guard of the
                                                 * Treasury */
  C_MOB_SPEC(Z_KINGS_C, 25) = DicknDavid;       /* David, Dicks brother */
  C_MOB_SPEC(Z_KINGS_C, 26) = jerry;    /* Jerry, the Gambler */
  C_MOB_SPEC(Z_KINGS_C, 27) = CastleGuard;      /* Michael */
  C_MOB_SPEC(Z_KINGS_C, 28) = CastleGuard;      /* Hans */
  C_MOB_SPEC(Z_KINGS_C, 29) = CastleGuard;      /* Boris */
}


/* Routine member_of_staff */
/* Used to see if a character is a member of the castle staff */
/* Used mainly by BANZAI:ng NPC:s */
int member_of_staff(struct char_data * chChar)
{
  int ch_num;

  if (!IS_NPC(chChar))
    return (FALSE);

  ch_num = GET_MOB_VNUM(chChar);
  return (ch_num == CASTLE_ITEM(1) ||
          (ch_num > CASTLE_ITEM(2) && ch_num < CASTLE_ITEM(15)) ||
          (ch_num > CASTLE_ITEM(15) && ch_num < CASTLE_ITEM(18)) ||
          (ch_num > CASTLE_ITEM(18) && ch_num < CASTLE_ITEM(30)));
}


/* Function member_of_royal_guard */
/* Returns TRUE if the character is a guard on duty, otherwise FALSE */
/* Used by Peter the captain of the royal guard */
int member_of_royal_guard(struct char_data * chChar)
{
  int ch_num;

  if (!chChar || !IS_NPC(chChar))
    return FALSE;

  ch_num = GET_MOB_VNUM(chChar);
  return (ch_num == CASTLE_ITEM(3) ||
          ch_num == CASTLE_ITEM(6) ||
          (ch_num > CASTLE_ITEM(7) && ch_num < CASTLE_ITEM(12)) ||
          (ch_num > CASTLE_ITEM(23) && ch_num < CASTLE_ITEM(26)));
}


/* Function find_npc_by_name */
/* Returns a pointer to an npc by the given name */
/* Used by Tim and Tom */
struct char_data *find_npc_by_name(struct char_data * chAtChar,
                const char *pszName, int iLen)
{
  struct char_data *ch;

  for (ch = world[chAtChar->in_room].people; ch; ch = ch->next_in_room)
    if (IS_NPC(ch))
      if (!strncmp(pszName, ch->player.short_descr, iLen))
        return (ch);

  return NULL;
}


/* Function find_guard */
/* Returns the pointer to a guard on duty. */
/* Used by Peter the Captain of the Royal Guard */
struct char_data *find_guard(struct char_data * chAtChar)
{

  struct char_data *ch;

  for (ch = world[chAtChar->in_room].people; ch; ch = ch->next_in_room)
    if (!FIGHTING(ch) && member_of_royal_guard(ch))
      return ch;

  return NULL;
}


/* Function get_victim */
/* Returns a pointer to a randomly chosen character in the same room, */
/* fighting someone in the castle staff... */
/* Used by BANZAII-ing characters and King Welmar... */
struct char_data *get_victim(struct char_data * chAtChar)
{

  struct char_data *ch;
  int iNum_bad_guys = 0, iVictim;

  for (ch = world[chAtChar->in_room].people; ch; ch = ch->next_in_room)
    if (FIGHTING(ch) &&
        member_of_staff(FIGHTING(ch)))
      iNum_bad_guys++;

  if (!iNum_bad_guys)
    return NULL;

  iVictim = number(0, iNum_bad_guys);   /* How nice, we give them a chance */
  if (!iVictim)
    return NULL;

  iNum_bad_guys = 0;

  for (ch = world[chAtChar->in_room].people; ch; ch = ch->next_in_room)
    if (FIGHTING(ch) &&
        member_of_staff(FIGHTING(ch)) &&
        ++iNum_bad_guys == iVictim)
      return ch;

  return NULL;
}


/* Function banzaii */
/* Makes a character banzaii on attackers of the castle staff */
/* Used by Guards, Tim, Tom, Dick, David, Peter, Master, King and Guards */
int banzaii(struct char_data * ch)
{

  struct char_data *chOpponent = NULL;

  if (!AWAKE(ch) || GET_POS(ch) == POS_FIGHTING)
    return FALSE;

  if ((chOpponent = get_victim(ch))) {
    act("$n roars: 'Protect the Kingdom of Great King Welmar!  BANZAIIII!!!'",
        FALSE, ch, 0, 0, TO_ROOM);
    hit(ch, chOpponent, TYPE_UNDEFINED);
    return TRUE;
  }
  return FALSE;
}


/* Function do_npc_rescue */
/* Makes ch_hero rescue ch_victim */
/* Used by Tim and Tom */
int do_npc_rescue(struct char_data * ch_hero, struct char_data * ch_victim)
{

  struct char_data *ch_bad_guy;

  for (ch_bad_guy = world[ch_hero->in_room].people;
       ch_bad_guy && (FIGHTING(ch_bad_guy) != ch_victim);
       ch_bad_guy = ch_bad_guy->next_in_room);
  if (ch_bad_guy) {
    if (ch_bad_guy == ch_hero)
      return FALSE;             /* NO WAY I'll rescue the one I'm fighting! */
    act("You bravely rescue $N.\r\n", FALSE, ch_hero, 0, ch_victim, TO_CHAR);
    act("You are rescued by $N, your loyal friend!\r\n",
        FALSE, ch_victim, 0, ch_hero, TO_CHAR);
    act("$n heroically rescues $N.", FALSE, ch_hero, 0, ch_victim, TO_NOTVICT);

    if (FIGHTING(ch_bad_guy))
      stop_fighting(ch_bad_guy);
    if (FIGHTING(ch_hero))
      stop_fighting(ch_hero);

    set_fighting(ch_hero, ch_bad_guy);
    set_fighting(ch_bad_guy, ch_hero);
    return TRUE;
  }
  return FALSE;
}


/* Procedure to block a person trying to enter a room. */
/* Used by Tim/Tom at Kings bedroom and Dick/David at treasury */
int block_way(struct char_data * ch, int cmd, char *arg, int iIn_room,
                  int iProhibited_direction)
{

  if (cmd != ++iProhibited_direction || (ch->player.short_descr &&
                       !strncmp(ch->player.short_descr, "King Welmar", 11)))
    return FALSE;

  if ((ch->in_room == real_room(iIn_room)) && (cmd == iProhibited_direction)) {
    if (!member_of_staff(ch))
      act("The guard roars at $n and pushes $m back.",
          FALSE, ch, 0, 0, TO_ROOM);
    send_to_char("The guard roars: 'Entrance is Prohibited!', and pushes you back.\r\n", ch);
    return (TRUE);
  }
  return FALSE;
}


/* Routine to check if an object is trash... */
/* Used by James the Butler and the Cleaning Lady */
int is_trash(struct obj_data * i)
{
  if (OBJWEAR_FLAGGED(i, ITEM_WEAR_TAKE) &&
      ((GET_OBJ_TYPE(i) == ITEM_DRINKCON) || (GET_OBJ_COST(i) <= 10)))
    return TRUE;
  else
    return FALSE;
}


/* Function fry_victim */
/* Finds a suitabe victim, and cast some _NASTY_ spell on him */
/* Used by King Welmar */
void fry_victim(struct char_data * ch)
{

  struct char_data *tch;

  if (ch->points.mana < 10)
    return;

  /* Find someone suitable to fry ! */

  if (!(tch = get_victim(ch)))
    return;

  switch (number(0, 8)) {
  case 1:
  case 2:
  case 3:
    act("You raise your hand in a dramatical gesture.", 1, ch, 0, 0, TO_CHAR);
    act("$n raises $s hand in a dramatical gesture.", 1, ch, 0, 0, TO_ROOM);
    cast_spell(ch, tch, 0, SPELL_COLOR_SPRAY);
    break;
  case 4:
  case 5:
    act("You concentrate and mumble to yourself.", 1, ch, 0, 0, TO_CHAR);
    act("$n concentrates, and mumbles to $mself.", 1, ch, 0, 0, TO_ROOM);
    cast_spell(ch, tch, 0, SPELL_HARM);
    break;
  case 6:
  case 7:
    act("You look deeply into the eyes of $N.", 1, ch, 0, tch, TO_CHAR);
    act("$n looks deeply into the eyes of $N.", 1, ch, 0, tch, TO_NOTVICT);
    act("You see an ill-boding flame in the eye of $n.", 1, ch, 0, tch, TO_VICT);
    cast_spell(ch, tch, 0, SPELL_FIREBALL);
    break;
  default:
    if (!number(0, 1))
      cast_spell(ch, ch, 0, SPELL_HEAL);
    break;
  }

  ch->points.mana -= 10;

  return;
}


/* Function king_welmar */
/* Control the actions and movements of the King. */
/* Used by King Welmar */
SPECIAL(king_welmar)
{
  const char *monolog[] = {
    "$n proclaims 'Primus in regnis Geticis coronam'.",
    "$n proclaims 'regiam gessi, subiique regis'.",
    "$n proclaims 'munus et mores colui sereno'.",
    "$n proclaims 'principe dignos'."
  };

  const char bedroom_path[] = "s33004o1c1S.";
  const char throne_path[] = "W3o3cG52211rg.";
  const char monolog_path[] = "ABCDPPPP.";

  static const char *path;
  static int index;
  static bool move = FALSE;

  if (!move) {
    if (time_info.hours == 8 && ch->in_room == R_ROOM(Z_KINGS_C, 51)) {
      move = TRUE;
      path = throne_path;
      index = 0;
    } else if (time_info.hours == 21 && ch->in_room == R_ROOM(Z_KINGS_C, 17)) {
      move = TRUE;
      path = bedroom_path;
      index = 0;
    } else if (time_info.hours == 12 && ch->in_room == R_ROOM(Z_KINGS_C, 17)) {
      move = TRUE;
      path = monolog_path;
      index = 0;
    }
  }
  if (cmd || (GET_POS(ch) < POS_SLEEPING) ||
      (GET_POS(ch) == POS_SLEEPING && !move))
    return FALSE;

  if (GET_POS(ch) == POS_FIGHTING) {
    fry_victim(ch);
    return FALSE;
  } else if (banzaii(ch))
    return FALSE;

  if (!move)
    return FALSE;

  switch (path[index]) {
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
    perform_move(ch, path[index] - 0, 1);
    break;
  case 'A':
  case 'B':
  case 'C':
  case 'D':
    act(monolog[path[index] - 'A'], FALSE, ch, 0, 0, TO_ROOM);
    break;
  case 'P':
    break;
  case 'W':
    GET_POS(ch) = POS_STANDING;
    act("$n awakens and stands up.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'S':
    GET_POS(ch) = POS_SLEEPING;
    act("$n lies down on $s beautiful bed and instantly falls asleep.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'r':
    GET_POS(ch) = POS_SITTING;
    act("$n sits down on his great throne.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 's':
    GET_POS(ch) = POS_STANDING;
    act("$n stands up.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'G':
    act("$n says 'Good morning, trusted friends.'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'g':
    act("$n says 'Good morning, dear subjects.'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'o':
    do_gen_door(ch, "door", 0, SCMD_UNLOCK);
    do_gen_door(ch, "door", 0, SCMD_OPEN);
    break;

  case 'c':
    do_gen_door(ch, "door", 0, SCMD_CLOSE);
    do_gen_door(ch, "door", 0, SCMD_LOCK);
    break;

  case '.':
    move = FALSE;
    break;
  }

  index++;
  return FALSE;
}


/* Function training_master */
/* Acts actions to the training room, if his students are present */
/* Also allowes warrior-class to practice */
/* Used by the Training Master */
SPECIAL(training_master)
{
  struct char_data *pupil1, *pupil2 = NULL, *tch;

  if (!AWAKE(ch) || (GET_POS(ch) == POS_FIGHTING))
    return FALSE;

  if (cmd)
    return FALSE;

  if (!banzaii(ch) && !number(0, 2)) {
    if ((pupil1 = find_npc_by_name(ch, "Brian", 5)) &&
        (pupil2 = find_npc_by_name(ch, "Mick", 4)) &&
        (!FIGHTING(pupil1) && !FIGHTING(pupil2))) {
      if (number(0, 1)) {
        tch = pupil1;
        pupil1 = pupil2;
        pupil2 = tch;
      }
      switch (number(0, 7)) {
      case 0:
        act("$n hits $N on $s head with a powerful blow.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("You hit $N on $s head with a powerful blow.",
            FALSE, pupil1, 0, pupil2, TO_CHAR);
        act("$n hits you on your head with a powerful blow.",
            FALSE, pupil1, 0, pupil2, TO_VICT);
        break;
      case 1:
        act("$n hits $N in $s chest with a thrust.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("You manage to thrust $N in the chest.",
            FALSE, pupil1, 0, pupil2, TO_CHAR);
        act("$n manages to thrust you in your chest.",
            FALSE, pupil1, 0, pupil2, TO_VICT);
        break;
      case 2:
        send_to_char("You command your pupils to bow\r\n.", ch);
        act("$n commands his pupils to bow.", FALSE, ch, 0, 0, TO_ROOM);
        act("$n bows before $N.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("$N bows before $n.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("You bow before $N, who returns your gesture.",
            FALSE, pupil1, 0, pupil2, TO_CHAR);
        act("You bow before $n, who returns your gesture.",
            FALSE, pupil1, 0, pupil2, TO_VICT);
        break;
      case 3:
        act("$N yells at $n, as he fumbles and drops his sword.",
            FALSE, pupil1, 0, ch, TO_NOTVICT);
        act("$n quickly picks up his weapon.", FALSE, pupil1, 0, 0, TO_ROOM);
        act("$N yells at you, as you fumble, losing your weapon.",
            FALSE, pupil1, 0, ch, TO_CHAR);
        send_to_char("You quickly pick up your weapon again.", pupil1);
        act("You yell at $n, as he fumbles, losing his weapon.",
            FALSE, pupil1, 0, ch, TO_VICT);
        break;
      case 4:
        act("$N tricks $n, and slashes him across the back.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("$N tricks you, and slashes you across your back.",
            FALSE, pupil1, 0, pupil2, TO_CHAR);
        act("You trick $n, and quickly slash him across his back.",
            FALSE, pupil1, 0, pupil2, TO_VICT);
        break;
      case 5:
        act("$n lunges a blow at $N but $N parries skillfully.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("You lunge a blow at $N but $E parries skillfully.",
            FALSE, pupil1, 0, pupil2, TO_CHAR);
        act("$n lunges a blow at you, but you skillfully parry it.",
            FALSE, pupil1, 0, pupil2, TO_VICT);
        break;
      case 6:
        act("$n clumsily tries to kick $N, but misses.",
            FALSE, pupil1, 0, pupil2, TO_NOTVICT);
        act("You clumsily miss $N with your poor excuse for a kick.",
            FALSE, pupil1, 0, pupil2, TO_CHAR);
        act("$n fails an unusually clumsy attempt at kicking you.",
            FALSE, pupil1, 0, pupil2, TO_VICT);
        break;
      default:
        send_to_char("You show your pupils an advanced technique.", ch);
        act("$n shows his pupils an advanced technique.",
            FALSE, ch, 0, 0, TO_ROOM);
        break;
      }
    }
  }
  return FALSE;
}


SPECIAL(tom)
{
  struct char_data *king, *tim;

  if (!AWAKE(ch))
    return FALSE;

  if ((!cmd) && (king = find_npc_by_name(ch, "King Welmar", 11))) {
    if (!ch->master)
      do_follow(ch, "King Welmar", 0, 0);
    if (FIGHTING(king))
      do_npc_rescue(ch, king);
  }
  if (!cmd)
    if ((tim = find_npc_by_name(ch, "Tim", 3)))
      if (FIGHTING(tim) && 2 * GET_HIT(tim) < GET_HIT(ch))
        do_npc_rescue(ch, tim);

  if (!cmd && GET_POS(ch) != POS_FIGHTING)
    banzaii(ch);

  return block_way(ch, cmd, arg, CASTLE_ITEM(49), 1);
}


SPECIAL(tim)
{
  struct char_data *king, *tom;

  if (!AWAKE(ch))
    return FALSE;

  if ((!cmd) && (king = find_npc_by_name(ch, "King Welmar", 11))) {
    if (!ch->master)
      do_follow(ch, "King Welmar", 0, 0);
    if (FIGHTING(king))
      do_npc_rescue(ch, king);
  }
  if (!cmd)
    if ((tom = find_npc_by_name(ch, "Tom", 3)))
      if (FIGHTING(tom) && 2 * GET_HIT(tom) < GET_HIT(ch))
        do_npc_rescue(ch, tom);

  if (!cmd && GET_POS(ch) != POS_FIGHTING)
    banzaii(ch);

  return block_way(ch, cmd, arg, CASTLE_ITEM(49), 1);
}


/* Routine for James the Butler */
/* Complains if he finds any trash... */
SPECIAL(James)
{

  struct obj_data *i;

  if (cmd || !AWAKE(ch) || (GET_POS(ch) == POS_FIGHTING))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = i->next_content)
    if (is_trash(i)) {
      act("$n says: 'My oh my!  I ought to fire that lazy cleaning woman!'",
          FALSE, ch, 0, 0, TO_ROOM);
      act("$n picks up a piece of trash.", FALSE, ch, 0, 0, TO_ROOM);
      obj_from_room(i);
      obj_to_char(i, ch);
      return TRUE;
    } else
      return FALSE;

  return FALSE;
}


/* Routine for the Cleaning Woman */
/* Picks up any trash she finds... */
SPECIAL(cleaning)
{
  struct obj_data *i, *next;

  if (cmd || !AWAKE(ch))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = next) {
    next = i->next_content;
    if (is_trash(i)) {
      act("$n picks up some trash.", FALSE, ch, 0, 0, TO_ROOM);
      obj_from_room(i);
      obj_to_char(i, ch);
      return TRUE;
    }
  }
  return FALSE;
}


/* Routine CastleGuard */
/* Standard routine for ordinary castle guards */
SPECIAL(CastleGuard)
{

  if (cmd || !AWAKE(ch) || (GET_POS(ch) == POS_FIGHTING))
    return FALSE;

  return (banzaii(ch));
}


/* Routine DicknDave */
/* Routine for the guards Dick and David */
SPECIAL(DicknDavid)
{

  if (!AWAKE(ch))
    return (FALSE);

  if (!cmd && GET_POS(ch) != POS_FIGHTING)
    banzaii(ch);

  return (block_way(ch, cmd, arg, CASTLE_ITEM(36), 1));
}


/* Routine peter */
/* Routine for Captain of the Guards. */
SPECIAL(peter)
{
  struct char_data *ch_guard = NULL;

  if (cmd || !AWAKE(ch) || GET_POS(ch) == POS_FIGHTING)
    return (FALSE);

  if (banzaii(ch))
    return FALSE;

  if (!(number(0, 3)) && (ch_guard = find_guard(ch)))
    switch (number(0, 5)) {
    case 0:
      act("$N comes sharply into attention as $n inspects $M.",
          FALSE, ch, 0, ch_guard, TO_NOTVICT);
      act("$N comes sharply into attention as you inspect $M.",
          FALSE, ch, 0, ch_guard, TO_CHAR);
      act("You go sharply into attention as $n inspects you.",
          FALSE, ch, 0, ch_guard, TO_VICT);
      break;
    case 1:
      act("$N looks very small, as $n roars at $M.",
          FALSE, ch, 0, ch_guard, TO_NOTVICT);
      act("$N looks very small as you roar at $M.",
          FALSE, ch, 0, ch_guard, TO_CHAR);
      act("You feel very small as $N roars at you.",
          FALSE, ch, 0, ch_guard, TO_VICT);
      break;
    case 2:
      act("$n gives $N some Royal directions.",
          FALSE, ch, 0, ch_guard, TO_NOTVICT);
      act("You give $N some Royal directions.",
          FALSE, ch, 0, ch_guard, TO_CHAR);
      act("$n gives you some Royal directions.",
          FALSE, ch, 0, ch_guard, TO_VICT);
      break;
    case 3:
      act("$n looks at you.", FALSE, ch, 0, ch_guard, TO_VICT);
      act("$n looks at $N.", FALSE, ch, 0, ch_guard, TO_NOTVICT);
      act("$n growls: 'Those boots need polishing!'",
          FALSE, ch, 0, ch_guard, TO_ROOM);
      act("You growl at $N.", FALSE, ch, 0, ch_guard, TO_CHAR);
      break;
    case 4:
      act("$n looks at you.", FALSE, ch, 0, ch_guard, TO_VICT);
      act("$n looks at $N.", FALSE, ch, 0, ch_guard, TO_NOTVICT);
      act("$n growls: 'Straighten that collar!'",
          FALSE, ch, 0, ch_guard, TO_ROOM);
      act("You growl at $N.", FALSE, ch, 0, ch_guard, TO_CHAR);
      break;
    default:
      act("$n looks at you.", FALSE, ch, 0, ch_guard, TO_VICT);
      act("$n looks at $N.", FALSE, ch, 0, ch_guard, TO_NOTVICT);
      act("$n growls: 'That chain mail looks rusty!  CLEAN IT !!!'",
          FALSE, ch, 0, ch_guard, TO_ROOM);
      act("You growl at $N.", FALSE, ch, 0, ch_guard, TO_CHAR);
      break;
    }

  return FALSE;
}


/* Procedure for Jerry and Michael in x08 of King's Castle.      */
/* Code by Sapowox modified by Pjotr.(Original code from Master) */

SPECIAL(jerry)
{
  struct char_data *gambler1, *gambler2 = NULL, *tch;

  if (!AWAKE(ch) || (GET_POS(ch) == POS_FIGHTING))
    return FALSE;

  if (cmd)
    return FALSE;

  if (!banzaii(ch) && !number(0, 2)) {
    if ((gambler1 = ch) &&
        (gambler2 = find_npc_by_name(ch, "Michael", 7)) &&
        (!FIGHTING(gambler1) && !FIGHTING(gambler2))) {
      if (number(0, 1)) {
        tch = gambler1;
        gambler1 = gambler2;
        gambler2 = tch;
      }
      switch (number(0, 5)) {
      case 0:
        act("$n rolls the dice and cheers loudly at the result.",
            FALSE, gambler1, 0, gambler2, TO_NOTVICT);
        act("You roll the dice and cheer. GREAT!",
            FALSE, gambler1, 0, gambler2, TO_CHAR);
        act("$n cheers loudly as $e rolls the dice.",
            FALSE, gambler1, 0, gambler2, TO_VICT);
        break;
      case 1:
        act("$n curses the Goddess of Luck roundly as he sees $N's roll.",
            FALSE, gambler1, 0, gambler2, TO_NOTVICT);
        act("You curse the Goddess of Luck as $N rolls.",
            FALSE, gambler1, 0, gambler2, TO_CHAR);
        act("$n swears angrily. You are in luck!",
            FALSE, gambler1, 0, gambler2, TO_VICT);
        break;
      case 2:
        act("$n sighs loudly and gives $N some gold.",
            FALSE, gambler1, 0, gambler2, TO_NOTVICT);
        act("You sigh loudly at the pain of having to give $N some gold.",
            FALSE, gambler1, 0, gambler2, TO_CHAR);
        act("$n sighs loudly as $e gives you your rightful win.",
            FALSE, gambler1, 0, gambler2, TO_VICT);
        break;
      case 3:
        act("$n smiles remorsefully as $N's roll tops his.",
            FALSE, gambler1, 0, gambler2, TO_NOTVICT);
        act("You smile sadly as you see that $N beats you. Again.",
            FALSE, gambler1, 0, gambler2, TO_CHAR);
        act("$n smiles remorsefully as your roll tops his.",
            FALSE, gambler1, 0, gambler2, TO_VICT);
        break;
      case 4:
        act("$n excitedly follows the dice with his eyes.",
            FALSE, gambler1, 0, gambler2, TO_NOTVICT);
        act("You excitedly follow the dice with your eyes.",
            FALSE, gambler1, 0, gambler2, TO_CHAR);
        act("$n excitedly follows the dice with his eyes.",
            FALSE, gambler1, 0, gambler2, TO_VICT);
        break;
      default:
        act("$n says 'Well, my luck has to change soon', as he shakes the dice.",
            FALSE, gambler1, 0, gambler2, TO_NOTVICT);
        act("You say 'Well, my luck has to change soon' and shake the dice.",
            FALSE, gambler1, 0, gambler2, TO_CHAR);
        act("$n says 'Well, my luck has to change soon', as he shakes the dice.",
            FALSE, gambler1, 0, gambler2, TO_VICT);
        break;
      }
    }
  }
  return FALSE;
}
::::::::::::::
challenge.c
::::::::::::::
/**************************
 * 
 * File: challenge.c
 *
 * Writen by:  Paulo Estima Mello a.k.a. Lothar
 *
 * Used to make a challenge of player x player.
 * Can fight only 1 x 1.
 *
 * Challenge System Version: 1.1.1
 **************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "screen.h"
#include "spells.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "constants.h"
#include "buffer.h"

extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern int top_of_world;
extern sh_int r_mortal_start_room;

void send_challenge_option(struct char_data * ch)
{

	send_to_char("You can use this options to the challenge system...\r\n"
		     "\r\n"
		     "For the challenger:		\r\n"
	             "	challenge 		<player>\r\n"      
	             "	challenge cancel		\r\n"
		     "\r\n"
		     "For who was challenged:		\r\n"
		     "	challenge accept		\r\n"
	             "	challenge decline		\r\n", ch);
		     
}
ACMD(do_challenge)
{
struct char_data *vict;

one_argument(argument, arg);

if(!*arg){
		send_challenge_option(ch);
		return;
	}

else if (!(vict = get_player_vis(ch, arg, FIND_CHAR_WORLD))){
	send_to_char("It is best to challenge someone who is actually here.\r\n", ch);
	return;
}
else if (ch == vict){
    send_to_char("You can not challenge one self.\r\n", ch);
  return;
}
else if (!vict){
	send_to_char("Whom do you wish to challenge?\r\n", ch);
	return;
}
else if (!IS_NPC(vict) && !vict->desc){        /* linkless */
    act("$E's linkless at the moment.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
	return;
}
else if (PLR_FLAGGED(vict, PLR_WRITING)){
	act("$E's writing a message right now; try again later.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
	return;
}
else if (GET_CHALLENGE(ch) == 1){
	sprintf(buf, "You are being challenged by %s. NACCEPT or NDECLINE first!\r\n", GET_NAME(GET_CHALLENGER(ch)));
	send_to_char(buf, ch);
	return;
}
else if (GET_CHALLENGE(ch) == 2){
	sprintf(buf, "You are already challenging &c%s, you must wait.\r\n", GET_NAME(GET_CHALLENGER(ch)));
	send_to_char(buf, ch);
	return;
}
else if (GET_CHALLENGE(ch) == 3){
	sprintf(buf, "You are already dualing %s, you must wait.\r\n", GET_NAME(GET_CHALLENGER(ch)));
	send_to_char(buf, ch);
	return;
}
else if (GET_CHALLENGE(vict) >= 1){
	send_to_char("You can not challenge some one who already is challenged.\r\n",ch);
	return;
}
else {

	GET_CHALLENGE(ch) = 2;
	GET_CHALLENGE(vict) = 1;
	GET_CHALLENGER(ch) = vict;
	GET_CHALLENGER(vict) = ch;

	sprintf(buf, "You challenge %s to a dual.\r\n", GET_NAME(vict));
	send_to_char(buf, ch);
	sprintf(buf, "%s challenges you to a dual, NACCEPT or NDECLINE?\r\n", GET_NAME(ch));
	send_to_char(buf, vict);
}
}
ACMD(do_accept){
	struct char_data *vict;
	room_vnum vto_room = 7505;
	room_rnum to_room;

	if(GET_CHALLENGE(ch) != 1){
		send_to_char("You are not challenged.", ch);
		return;
	}

	vict = GET_CHALLENGER(ch);

	GET_CHALLENGE(ch) = 3;
	GET_CHALLENGE(vict) = 3;

	sprintf(buf, "You accept %s's challenge and are magically transported into the arena.\r\n", GET_NAME(vict));
	send_to_char(buf, ch);

	vto_room = number(7503, 7504);
	to_room = real_room(vto_room);

	act("$n goes to fight THE DUAL.", TRUE, ch, 0, 0, TO_NOTVICT);
	char_from_room(ch);

	char_to_room(ch, to_room);
	look_at_room(ch, 0);

	sprintf(buf, "%s accepts your challenge and you are transported to the arena.\r\n", GET_NAME(ch));
	send_to_char(buf, vict);
	
	vto_room = number(7501, 7502);
	to_room = real_room(vto_room);

    act("$n goes to fight THE DUAL.", TRUE, vict, 0, 0, TO_NOTVICT);
	char_from_room(vict);

	char_to_room(vict, to_room);
	look_at_room(vict, 0);
}

ACMD(do_decline){
	struct char_data *vict;

	if(GET_CHALLENGE(ch) != 1){
		send_to_char("You are not challenged.", ch);
		return;
	}

	vict = GET_CHALLENGER(ch);

	GET_CHALLENGE(ch) = 0;
	GET_CHALLENGE(vict) = 0;

	sprintf(buf, "You decline %s's challenge and hand your title over.\r\n", GET_NAME(vict));
	send_to_char(buf, ch);

	sprintf(buf, "%s declines your challenge and hands over the title.\r\n", GET_NAME(ch));
	send_to_char(buf, vict);
}
::::::::::::::
clan.c
::::::::::::::
 //primeira fase do codigo de clan

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "clan.h"

extern struct descriptor_data *descriptor_list;
extern struct room_data *world;

short int numero_clans = 0;

struct comando_clan {
   char *comando;
   void (*procedimento_comando) (char *argumento, struct char_data *ch);
};

//nunca mude a ordem dos comandos,
//a ordem deles interfere no salvar_clan.
const struct comando_clan comandos[] = {
	{ "convocar", aceitar_membro },
	{ "numposicoes", posicoes_clan },
	{ "alteranomepos", alterar_nomes_pos },
	{ "mudaposcomando", muda_pos_comando },
	{ "promover", promover_membro },
	{ "rebaixar", rebaixar_membro },
	{ "expulsar", expulsar_membro },
	{ "falar", falar_clan },
	{ "membros", membros_clan },
	{ "depositar", depositar_clan },
	{ "sacar", sacar_clan },

};

char *complete_char(char *string, int num);

void carregar_clans()
{
	FILE *arquivo;
	char num_clan[15], cam_arq[30];
	short int numero = 0;

	if(!(arquivo = fopen("clans/index", "r+")))
	{
		log("Lista de clans nao pode ser aberta.");
		return;
	}

	while(get_line(arquivo, num_clan))
		numero_clans++;

	rewind(arquivo);

	CREATE(clans, struct estrutura_clan, numero_clans + 1);

	while(get_line(arquivo, num_clan))
	{
		sprintf(cam_arq, "clans/%s.clan", num_clan);
		//colocar previamente os numeros dos clans
		clans[numero].clan_num = atoi(num_clan);
		abrir_clan(cam_arq, numero);
		numero++;
	}
	fclose(arquivo);
	log("Clans abertos com sucesso.");
}

void abrir_clan(char *clan_arq, short int numero)
{
	FILE *clan;
	char linha[600];
	struct char_data *tch;
	short int membros = 0, posicao = 0, nivel = 0;

	if(!(clan = fopen(clan_arq, "r")))
	{
		log("Arquivo de clan faltando. Favor verificar.");
		exit(1);
	}

	while(get_line(clan, linha))
	{
		if(!str_cmp(linha, "Nome:"))
		{
			get_line(clan, linha);
			strcpy(clans[numero].nome_clan, linha);
		}
		else if(!str_cmp(linha, "Posicoes:"))
		{
			while(get_line(clan, linha))
			{
				if(linha[0] == '~')
					break;

				strcpy(clans[numero].pos_nome[posicao], linha);
				posicao++;
			}
			clans[numero].numero_posicoes = posicao;
		}
		else if(!str_cmp(linha, "Membros:"))
		{
			for(membros = 0; membros < MAX_MEMBROS; membros++)
				clans[numero].membros[membros] = 0;

			membros = 0;
			while(get_line(clan, linha))
			{
				if(linha[0] == '~')
					break;

				clans[numero].membros[membros] = atoi(linha);
				membros++;
			}
			clans[numero].numero_membros = membros;
		}
		else if(!str_cmp(linha, "PosComandos:"))
		{
			for(nivel = 0; nivel < NUM_COMANDOS; nivel++)
				clans[numero].pos_comando[nivel] = clans[numero].numero_posicoes;

			nivel = 0;
			while(get_line(clan, linha))
			{
				if(linha[0] == '~')
					break;

				clans[numero].pos_comando[nivel] = atoi(linha);
				nivel++;
			}
		}
		else if(!str_cmp(linha, "Grana:"))
		{
			get_line(clan, linha);
			clans[numero].grana = atoi(linha);
		}
/*		else if(!str_cmp(linha, "Poder:"))
		{
			get_line(clan, linha);
			clans[numero].poder = atoi(linha);
		}*/
	}

	//atualizar poder
	for(membros = 0; membros < MAX_MEMBROS; membros++)
	{
		if(clans[numero].membros[membros] != 0)
		{
			CREATE(tch, struct char_data, 1);
			clear_char(tch);
			CREATE(tch->player_specials, struct player_special_data, 1);
			if (load_char(get_name_by_id(clans[numero].membros[membros]), tch) > -1)
				clans[numero].poder += qto_poder(tch);
			free_char(tch);
		}
	}

	fclose(clan);
}

void atualizar_index()
{
	FILE *index;
	short int clan = 0;

	if(!(index = fopen("clans/index", "w")))
		log("Index de clan faltando. Favor verificar.");

	for(; clan < numero_clans; clan++)
		fprintf(index, "%d\n", clans[clan].clan_num);

	fclose(index);
}

int posicao_clan(short int num_clan)
{
	short int pos;

	for(pos = 0; pos < numero_clans; pos++)
		if(clans[pos].clan_num == num_clan)
			return (pos);
	return (-1);
}

void salvar_clan(short int num_clan)
{
	FILE *clan;
	char clan_arq[30];
	short int membros, pos, posicao, nivel;

	pos = posicao_clan(num_clan);

	sprintf(clan_arq, "clans/%d.clan", num_clan);

	if(!(clan = fopen(clan_arq, "w")))
		log("Arquivo de clan faltando. Criando novo.");

	fprintf(clan, "Nome:\n%s\n", clans[pos].nome_clan);

	fprintf(clan, "Posicoes:\n");
	for(posicao = 0; posicao < clans[pos].numero_posicoes; posicao++)
		fprintf(clan, "%s\n", clans[pos].pos_nome[posicao]);
	fprintf(clan, "~\n");

	fprintf(clan, "Membros:\n");
	for(membros = 0; membros < MAX_MEMBROS; membros++)
		if(clans[pos].membros[membros] != 0)
			fprintf(clan, "%ld\n", clans[pos].membros[membros]);
	fprintf(clan, "~\n");

	fprintf(clan, "PosComandos:\n");
	for(nivel = 0; nivel < NUM_COMANDOS; nivel++)
		fprintf(clan, "%d\n", clans[pos].pos_comando[nivel]);
	fprintf(clan, "~\n");

	fprintf(clan, "Grana:\n%d\n", clans[pos].grana);
	fprintf(clan, "Poder:\n%d\n", clans[pos].poder);

	fclose(clan);
}

short int tem_permissao(struct char_data *ch, short int comando)
{
	short int permissao = 0, clan;

	if(comando >= NUM_COMANDOS)
		return (permissao);

	if((clan = posicao_clan(GET_CLAN(ch))) == -1)
		return (permissao);

	if(clans[clan].pos_comando[comando] <= GET_CLAN_POS(ch))
		permissao = 1;

	return (permissao);
}

int qto_poder(struct char_data *ch)
{
	int poder = 0;

	poder = (GET_REMORT(ch)*(LVL_IMMORT-1))+GET_LEVEL(ch);

	return (poder);
}

short int membro_livre(short int clan)
{
	short int membro, klan;

	klan = posicao_clan(clan);
	for(membro = 0; membro < MAX_MEMBROS; membro++)
		if(clans[klan].membros[membro] == 0)
			return (membro);
	return (-1);
}

short int membro_pos(struct char_data *ch)
{
	short int membro, klan, id;

	klan = posicao_clan(GET_CLAN(ch));
	id = get_id_by_name(GET_NAME(ch));
	for(membro = 0; membro < MAX_MEMBROS; membro++)
		if(clans[klan].membros[membro] == id)
			return membro;
	return(-1);
}

short int remove_do_clan(struct char_data *ch)
{
	short int nclan = 0, pos;

	if((pos = membro_pos(ch)) == -1)
		return (0);

	nclan = posicao_clan(GET_CLAN(ch));

	clans[nclan].membros[pos] = 0;
	clans[nclan].numero_membros--;
	clans[nclan].poder -= qto_poder(ch);

	salvar_clan(GET_CLAN(ch));

	return (1);
}

void send_to_clan(struct char_data *ch, const char *messg)
{
  struct descriptor_data *i;

  if (messg == NULL)
    return;

  for (i = descriptor_list; i; i = i->next) {
    if (STATE(i) != CON_PLAYING)
      continue;
	if(PLR_FLAGGED(i->character, PLR_WRITING))
	  continue;
    if ((GET_CLAN(i->character) != GET_CLAN(ch)) || !GET_CLAN_POS(i->character))
      continue;

    SEND_TO_Q(messg, i);
  }
}

#define CLANMENSAGEM_INICIO \
"&WSeu clan foi criado com sucesso, porem, ainda faltam alguns ajustes.\r\n" \
"Use o comando &R'clan numposicoes' &We em seguida o comando &R'clan alteranomepos'&W\r\n" \
"para ajustar as posicoes do clan. Isso podera ser feito somente uma vez;\r\n" \
"portanto, nao erre. Os deuses nao tem culpa de sua incompetencia.&n\r\n"

//aqui comeca o sistema de clan
void cria_clan(char *nome, struct char_data *ch)
{
	struct char_data *lider;
	char nome_lider[50], clan_nome[500];
	short int num_mem, ult_num = 0, clan, nivel;

	if(!*nome)
	{
		send_to_char("Formato: clan criar <lider> <nome do clan>\r\n", ch);
		return;
	}

	half_chop(nome, nome_lider, clan_nome);

	if((lider = get_player_vis(ch, nome_lider, FIND_CHAR_ROOM)) == NULL)
	{
		send_to_char("O lider precisa estar no mesmo local que voce.\r\n", ch);
		return;
	}

	if(GET_CLAN(lider))
	{
		send_to_char("O lider ja possui clan.\r\n", ch);
		return;
	}

	if(!*clan_nome)
	{
		send_to_char("O clan precisa de um nome.\r\n", ch);
		return;
	}

	if(!numero_clans)
		CREATE(clans, struct estrutura_clan, 2);
	else
		RECREATE(clans, struct estrutura_clan, numero_clans + 2);

	strcpy(clans[numero_clans].nome_clan, clan_nome);

	for(clan = 0; clan < numero_clans; clan++)
		if(ult_num < clans[clan].clan_num)
			ult_num = clans[clan].clan_num;
	clans[numero_clans].clan_num = ult_num + 1;

	strcpy(clans[numero_clans].pos_nome[0], "Aprendiz");
	strcpy(clans[numero_clans].pos_nome[1], "Lider");
	clans[numero_clans].numero_posicoes = 2;

	clans[numero_clans].membros[0] = get_id_by_name(nome_lider);
	for(num_mem = 1; num_mem < MAX_MEMBROS; num_mem++)
		clans[numero_clans].membros[num_mem] = 0;
	clans[numero_clans].numero_membros = 1;

	for(nivel = 0; nivel < NUM_COMANDOS; nivel++)
		clans[numero_clans].pos_comando[nivel] = clans[numero_clans].numero_posicoes;

	clans[numero_clans].grana = 0;

	clans[numero_clans].poder = qto_poder(lider);

	//lider
	GET_CLAN(lider) = clans[numero_clans].clan_num;
	GET_CLAN_POS(lider) = clans[numero_clans].numero_posicoes;
	save_char(lider, lider->in_room);

	salvar_clan(clans[numero_clans++].clan_num);
	atualizar_index();

	sprintf(buf, "&WUma nova forca emerge, o clan %s &Wfoi fundado!&n\r\n", clan_nome);
	send_to_all(buf);

	send_to_char("Clan criado com sucesso!\r\n", ch);
	send_to_char(CLANMENSAGEM_INICIO, lider);
}

void lista_clans(char *clan, struct char_data *ch)
{
	struct char_data *tch;
	char buffer[MAX_INPUT_LENGTH], lider[1000], vice_lider[1000];
	short int nclan = 0, pos = 0, membros, temlider = 0, temvice = 0;


	if(!numero_clans)
	{
		send_to_char("&WNenhum clan domina &BW&bar&BD&bome &Wainda.&n\r\n", ch);
		return;
	}

	if(!*clan || !is_number(clan))
	{
		send_to_char("Formato: clan lista <numero>\r\n\r\n", ch);
		send_to_char("&WLista de &CClans&W:&n\r\n", ch);
		for(; nclan < numero_clans; nclan++)
		{
			sprintf(buffer, "      &W%2d. %s   &RPoder&W: &R%-8d&n\r\n", clans[nclan].clan_num,
				complete_char(clans[nclan].nome_clan, 30), clans[nclan].poder);
			send_to_char(buffer, ch);
		}
	}
	else
	{
		if((nclan = posicao_clan(atoi(clan))) == -1)
		{
			send_to_char("Numero de clan invalido.\r\n", ch);
			return;
		}

		sprintf(buffer, "&WListando clan %s&W.&n\r\n", clans[nclan].nome_clan);
		send_to_char(buffer, ch);

		sprintf(lider, "%s&W:&C", clans[nclan].pos_nome[clans[nclan].numero_posicoes - 1]);
		sprintf(vice_lider, "%s&W:&c", clans[nclan].pos_nome[clans[nclan].numero_posicoes - 2]);
		for(membros = 0; membros < MAX_MEMBROS; membros++)
		{
			if(clans[nclan].membros[membros] != 0)
			{
				CREATE(tch, struct char_data, 1);
				clear_char(tch);
				CREATE(tch->player_specials, struct player_special_data, 1);
				if (load_char(get_name_by_id(clans[nclan].membros[membros]), tch) > -1)
				{
					if(GET_CLAN_POS(tch) == clans[nclan].numero_posicoes)
					{
						temlider++;
						sprintf(lider + strlen(lider), " %s", GET_NAME(tch));
					}
					else if(GET_CLAN_POS(tch) == (clans[nclan].numero_posicoes - 1))
					{
						temvice++;
						sprintf(vice_lider + strlen(vice_lider), " %s", GET_NAME(tch));
					}
				}
				free_char(tch);
			}
		}

		if(!temlider)
			strcat(lider, " &RNenhum&n");

		if(!temvice)
			strcat(vice_lider, " &RNenhum&n");

		send_to_char("&CLideres &We &cvice-lideres&W:&n\r\n", ch);
		sprintf(buffer, " &C%2d&n %s\r\n", temlider, lider);
		send_to_char(buffer, ch);
		sprintf(buffer, " &c%2d&n %s\r\n", temvice, vice_lider);
		send_to_char(buffer, ch);

		sprintf(buffer, "&WDe poder &R%d&W.&n\r\n", clans[nclan].poder);
		sprintf(buffer + strlen(buffer), "&WCom &C%d &Wmembros.&n\r\n", clans[nclan].numero_membros);
		strcat(buffer, "&WPosicoes:&n ");
		send_to_char(buffer, ch);
		for(; pos < clans[nclan].numero_posicoes; pos++)
		{
			sprintf(buffer, "%s%s", clans[nclan].pos_nome[pos],
				(pos == (clans[nclan].numero_posicoes - 1) ? "&W.&n\r\n" : "&W,&n "));
			send_to_char(buffer, ch);
		}
		sprintf(buffer, "&yTesouro &Waproximado &Y%d&W.&n\r\n", clans[nclan].grana);
		send_to_char(buffer, ch);
	}
}

void alistar_clan(char *clan, struct char_data *ch)
{
	short int nclan = 0;

	if(!*clan || !is_number(clan))
	{
		send_to_char("Formato: clan alistar <numero>\r\n", ch);
		return;
	}
	if(GET_CLAN(ch))
	{
		send_to_char("Voce ja possui um clan, nao seja traidor.\r\n", ch);
		return;
	}
	nclan = atoi(clan);
	if(posicao_clan(nclan) == -1)
	{
		send_to_char("Numero de clan invalido.\r\n", ch);
		return;
	}

	GET_CLAN(ch) = nclan;
	save_char(ch, ch->in_room);
	sprintf(buf, "&RATENCAO&W: &c%s &Wacaba de alistar no seu clan.&n\r\n", GET_NAME(ch));
	send_to_clan(ch, buf);
	sprintf(buf, "&WVoce se alistou no clan %s&W.&n\r\n", clans[posicao_clan(nclan)].nome_clan);
	send_to_char(buf, ch);
}

void posicoes_clan(char *argumento, struct char_data *ch)
{
	short int pos = 0, clan, nivel;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, NUMPOSICOES))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento || !is_number(argumento))
	{
		send_to_char("Formato: clan numposicoes <numero>\r\n", ch);
		return;
	}

	clan = posicao_clan(GET_CLAN(ch));
	if(clans[clan].numero_posicoes > 2)
	{
		send_to_char("O numero de posicoes nao pode mais ser alterado.\r\n", ch);
		return;
	}

	pos = atoi(argumento);
	if(pos <= 2 || pos > MAX_POSICOES)
	{
		sprintf(buf, "Quantidade de posicoes invalida. (2 < posicao < %d)\r\n", MAX_POSICOES);
		send_to_char(buf, ch);
		return;
	}

	strcpy(clans[clan].pos_nome[pos-1], clans[clan].pos_nome[clans[clan].numero_posicoes-1]);

	clans[clan].numero_posicoes = pos;
	for(pos = 1; pos < (clans[clan].numero_posicoes - 1); pos++)
		strcpy(clans[clan].pos_nome[pos], "Membro");

	for(nivel = 0; nivel < NUM_COMANDOS; nivel++)
		clans[clan].pos_comando[nivel] = clans[clan].numero_posicoes;

	salvar_clan(GET_CLAN(ch));

	GET_CLAN_POS(ch) = clans[clan].numero_posicoes;
	save_char(ch, ch->in_room);
	sprintf(buf, "&WSeu clan possuira &R%d&W posicoes.&n\r\n"
				 "&WEsse numero agora e &Rfixo&W e &Rnao podera&W mais ser alterado.&n\r\n", clans[clan].numero_posicoes);
	send_to_char(buf, ch);
}

void alterar_nomes_pos(char *argumento, struct char_data *ch)
{
	char posicao[MAX_INPUT_LENGTH], nome[51];
	short int pos = 0, clan = 0;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, ALTERANOMEPOS))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	half_chop(argumento, posicao, nome);

	if(!*posicao || !*nome || !is_number(posicao))
	{
		send_to_char("Formato: clan alteranomepos <posicao> <nome>\r\n", ch);
		return;
	}

	clan = posicao_clan(GET_CLAN(ch));
	pos = atoi(posicao);
	if(pos < 1 || pos > clans[clan].numero_posicoes)
	{
		sprintf(buf, "Posicao invalida. (1 < posicao < %d)\r\n", clans[clan].numero_posicoes);
		send_to_char(buf, ch);
		return;
	}

	if(strlen(nome) > 49)
	{
		send_to_char("Nome muito extenso, se limite a 49 caracteres.\r\n", ch);
		return;
	}

	sprintf(buf, "&RATENCAO&W: A posicao &c'%s&c' &Wmudou de nome para &c'%s&c'&W.&n\r\n",
			clans[clan].pos_nome[pos - 1], nome);
	send_to_clan(ch, buf);

	strcpy(clans[clan].pos_nome[pos - 1], nome);
	salvar_clan(GET_CLAN(ch));

	sprintf(buf, "&WVoce alterou o nome da posicao &c%d &Wpara &c%s&W.&n\r\n", pos, nome);
	send_to_char(buf, ch);
}

void aceitar_membro(char *argumento, struct char_data *ch)
{
	struct char_data *jogador;
	short int clan = 0, livre;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, CONVOCAR))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento)
	{
		send_to_char("Formato: clan convocar <nome>\r\n", ch);
		return;
	}

	if((livre = membro_livre(GET_CLAN(ch))) == -1)
	{
		sprintf(buf, "Um clan pode ter no maximo %d membros.\r\n", MAX_MEMBROS);
		send_to_char(buf, ch);
		return;
	}

	if((jogador = get_player_vis(ch, argumento, FIND_CHAR_ROOM)) == NULL)
	{
		send_to_char("O jogador precisa estar no mesmo local que voce para ser convocado.\r\n", ch);
		return;
	}

	if(!GET_CLAN(jogador))
	{
		send_to_char("Este jogador nao tem interesse em nenhum clan no momento.\r\n", ch);
		return;
	}

	if(GET_CLAN(jogador) != GET_CLAN(ch))
	{
		send_to_char("Este jogador ja se alistou em outro clan.\r\n", ch);
		return;
	}

	if(GET_CLAN_POS(jogador) > 0)
	{
		send_to_char("Este jogador ja faz parte do seu clan.\r\n", ch);
		return;
	}
	clan = posicao_clan(GET_CLAN(ch));

	clans[clan].numero_membros++;
	clans[clan].membros[livre] = get_id_by_name(argumento);
	clans[clan].poder += qto_poder(jogador);

	sprintf(buf, "&RATENCAO&W: &c%s &Wfoi convocado para o clan.&n\r\n", GET_NAME(jogador));
	send_to_clan(ch, buf);
	salvar_clan(GET_CLAN(jogador));

	//jogador
	GET_CLAN_POS(jogador) = 1;
	save_char(jogador, jogador->in_room);
	sprintf(buf, "Voce foi convocado para o clan %s.\r\n", clans[clan].nome_clan);
	send_to_char(buf, jogador);
}

void abandonar_clan(struct char_data *ch)
{
	if(!GET_CLAN(ch))
	{
		send_to_char("Voce nao possui clan, nao tem o que abandonar.\r\n", ch);
		return;
	}

	if(GET_CLAN_POS(ch))
	{
		remove_do_clan(ch);

		sprintf(buf, "&RATENCAO&W: &c%s &Wacaba de abandonar seu clan.&n\r\n", GET_NAME(ch));
		send_to_clan(ch, buf);
	}

	GET_CLAN(ch) = 0;
	GET_CLAN_POS(ch) = 0;
	send_to_char("&WVoce abandonou seu clan, traidor.&n\r\n", ch);
}

void muda_pos_comando(char *argumento, struct char_data *ch)
{
	char comando[30], posicao[10];
	short int pos = 0, com, clan;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, MUDAPOSCOMANDO))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	half_chop(argumento, comando, posicao);

	if(!*comando || !*posicao || !is_number(posicao))
	{
		send_to_char("Formato: clan mudaposcomando <comando> <posicao>\r\n", ch);
		return;
	}

	pos = atoi(posicao);
	clan = posicao_clan(GET_CLAN(ch));
	if(pos < 1 || pos > clans[clan].numero_posicoes)
	{
		sprintf(buf, "Posicao invalida. (1 < posicao < %d)\r\n", clans[clan].numero_posicoes);
		send_to_char(buf, ch);
		return;
	}

	//comando
	for(com = 0; com < NUM_COMANDOS; com++)
	{
		if(!str_cmp(comando, comandos[com].comando))
		{
			sprintf(buf, "&RATENCAO&W: O comando de clan &c'%s&c' &Wmudou de posicao.&n\r\n"
							 "&RATENCAO&W: Passou de &c%s &Wpara &c%s&W.&n\r\n",
					comandos[com].comando, clans[clan].pos_nome[clans[clan].pos_comando[com]-1],
					clans[clan].pos_nome[pos-1]);
			send_to_clan(ch, buf);
			clans[clan].pos_comando[com] = pos;
			salvar_clan(GET_CLAN(ch));
			sprintf(buf, "&WVoce alterou a posicao do comando &c%s&W.&n\r\n", comandos[com].comando);
			send_to_char(buf, ch);
			return;
		}
	}
	send_to_char("Comando de clan nao encontrado.\r\n", ch);
}

void promover_membro(char *argumento, struct char_data *ch)
{
	struct char_data *jogador;
	short int clan;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, PROMOVER))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento)
	{
		send_to_char("Formato: clan promover <nome>\r\n", ch);
		return;
	}

	if((jogador = get_player_vis(ch, argumento, FIND_CHAR_ROOM)) == NULL)
	{
		send_to_char("O jogador precisa estar no mesmo local que voce para ser promovido.\r\n", ch);
		return;
	}

	if((GET_CLAN(ch) != GET_CLAN(jogador)) || !GET_CLAN_POS(jogador))
	{
		send_to_char("Ele nao faz parte do seu clan.\r\n", ch);
		return;
	}

	if(GET_CLAN_POS(jogador) >= GET_CLAN_POS(ch))
	{
		send_to_char("Somente um superior pode fazer isso.\r\n", ch);
		return;
	}

	GET_CLAN_POS(jogador)++;
	save_char(jogador, jogador->in_room);

	clan = posicao_clan(GET_CLAN(jogador));
	sprintf(buf, "&WVoce foi promovido a &c%s&W.&n\r\n", clans[clan].pos_nome[GET_CLAN_POS(jogador)-1]);
	send_to_char(buf, jogador);
	sprintf(buf, "&RATENCAO&W: &c%s &Wfoi promovido a &c%s&W.&n\r\n", GET_NAME(jogador), clans[clan].pos_nome[GET_CLAN_POS(jogador)-1]);
	send_to_clan(jogador, buf);
}

void rebaixar_membro(char *argumento, struct char_data *ch)
{
	struct char_data *jogador;
	short int clan;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, REBAIXAR))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento)
	{
		send_to_char("Formato: clan rebaixar <nome>\r\n", ch);
		return;
	}

	if((jogador = get_player_vis(ch, argumento, FIND_CHAR_ROOM)) == NULL)
	{
		send_to_char("O jogador precisa estar no mesmo local que voce para ser rebaixado.\r\n", ch);
		return;
	}

	if((GET_CLAN(ch) != GET_CLAN(jogador)) || !GET_CLAN_POS(jogador))
	{
		send_to_char("Ele nao faz parte do seu clan.\r\n", ch);
		return;
	}

	if(GET_CLAN_POS(jogador) >= GET_CLAN_POS(ch))
	{
		send_to_char("Somente um superior pode fazer isso.\r\n", ch);
		return;
	}

	if((GET_CLAN_POS(jogador)-1) < 1)
	{
		send_to_char("Ele ja esta no nivel mais inferior do clan.\r\n", ch);
		return;
	}

	GET_CLAN_POS(jogador)--;
	save_char(jogador, jogador->in_room);

	clan = posicao_clan(GET_CLAN(jogador));
	sprintf(buf, "&WVoce foi rebaixado a &c%s&W.&n\r\n", clans[clan].pos_nome[GET_CLAN_POS(jogador)-1]);
	send_to_char(buf, jogador);
	sprintf(buf, "&RATENCAO&W: &c%s &Wfoi rebaixado a &c%s&W.&n\r\n", GET_NAME(jogador), clans[clan].pos_nome[GET_CLAN_POS(jogador)-1]);
	send_to_clan(jogador, buf);
}

void expulsar_membro(char *argumento, struct char_data *ch)
{
	struct char_data *jogador;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, EXPULSAR))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento)
	{
		send_to_char("Formato: clan expulsar <nome>\r\n", ch);
		return;
	}

	if((jogador = get_player_vis(ch, argumento, FIND_CHAR_ROOM)) == NULL)
	{
		send_to_char("O jogador precisa estar no mesmo local que voce para ser rebaixado.\r\n", ch);
		return;
	}

	if((GET_CLAN(ch) != GET_CLAN(jogador)) || !GET_CLAN_POS(jogador))
	{
		send_to_char("Ele nao faz parte do seu clan.\r\n", ch);
		return;
	}

	if(GET_CLAN_POS(jogador) >= GET_CLAN_POS(ch))
	{
		send_to_char("Somente um superior pode fazer isso.\r\n", ch);
		return;
	}

	remove_do_clan(jogador);

	sprintf(buf, "&RATENCAO&W: &c%s &Wacaba de ser expulso do clan.&n\r\n", GET_NAME(jogador));
	send_to_clan(jogador, buf);

	GET_CLAN(jogador) = 0;
	GET_CLAN_POS(jogador) = 0;
	send_to_char("&WVoce foi expulso do clan.&n\r\n", jogador);
}

void send_to_membros_clan(struct char_data *ch, short int posicao, const char *messg)
{
  struct descriptor_data *i;

  if (messg == NULL)
    return;

  for (i = descriptor_list; i; i = i->next)
  {
    if (STATE(i) != CON_PLAYING)
      continue;
	if(ch == i->character)
	  continue;
	if(PLR_FLAGGED(i->character, PLR_WRITING) ||
		ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF))
	  continue;
	if (PRF2_FLAGGED(i->character, PRF2_CLAN_SEMFALAR))
	  continue;
    if ((GET_CLAN(i->character) != GET_CLAN(ch)) || !GET_CLAN_POS(i->character))
      continue;
	if(GET_CLAN_POS(i->character) < posicao)
	  continue;

    SEND_TO_Q(messg, i);
  }
}

void falar_clan(char *argumento, struct char_data *ch)
{
	char posicao[MAX_INPUT_LENGTH], fala[MAX_INPUT_LENGTH];
	short int pos = 0, clan = 0;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, FALAR))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	half_chop(argumento, posicao, fala);

	if(!*posicao && !*fala)
	{
		if (PRF2_FLAGGED(ch, PRF2_CLAN_SEMFALAR))
		{
			REMOVE_BIT(PRF2_FLAGS(ch), PRF2_CLAN_SEMFALAR);
			send_to_char("&WVoce &Cabriu &Wo canal de clan.\r\n", ch);
			return;
		}
		else
		{
			SET_BIT(PRF2_FLAGS(ch), PRF2_CLAN_SEMFALAR);
			send_to_char("&WVoce &Rfechou &Wo canal de clan.\r\n", ch);
			return;
		}
	}

	if(!*posicao || !*fala || !is_number(posicao))
	{
		send_to_char("Formato: clan falar <posicao> <texto>\r\n", ch);
		return;
	}

	clan = posicao_clan(GET_CLAN(ch));
	pos = atoi(posicao);
	if(pos < 0 || pos > clans[clan].numero_posicoes)
	{
		sprintf(buf, "Posicao invalida. (0 < posicao < %d)\r\n", clans[clan].numero_posicoes);
		send_to_char(buf, ch);
		return;
	}

	sprintf(buf2, " (%s%s&W)", (pos && pos < clans[clan].numero_posicoes ? "+" : ""),
			(pos ? clans[clan].pos_nome[pos - 1] : "todos"));

	sprintf(buf, "&C%s &Wfala para o clan%s, '%s&W'.\r\n", GET_NAME(ch), buf2, fala);
	send_to_membros_clan(ch, pos, buf);

	sprintf(buf, "&CVoce &Wfala para o clan%s, '%s&W'.\r\n", buf2, fala);
	send_to_char(buf, ch);
}

void nome_maiusculo(char *saida, char *entrada)
{
	strcpy(saida, entrada);
	saida[0] = UPPER(saida[0]);
}

void membros_clan(char *argumento, struct char_data *ch)
{
	char nome[30];
	short int membros, clan, num = 0;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, MEMBROS))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	clan = posicao_clan(GET_CLAN(ch));
	strcpy(buf, "\r\n&WLista de &Cmembros&W:\r\n&c");
	for(membros = 0; membros < MAX_MEMBROS; membros++)
		if(clans[clan].membros[membros] != 0)
		{
			num++;
			nome_maiusculo(nome, get_name_by_id(clans[clan].membros[membros]));
			sprintf(buf + strlen(buf), "%17s%s", nome, (!(num % 4) ? "\r\n" : " "));
		}
	if(num % 4)
		strcat(buf, "\r\n");

	send_to_char(buf, ch);
}

void clan_jogando(struct char_data *ch)
{
	struct descriptor_data *i;
	char buffer[MAX_INPUT_LENGTH];
	short int clan, contar = 0;

	clan = posicao_clan(GET_CLAN(ch));

	sprintf(buffer, "&WMembros do %s &cconectados&W:&n\r\n\r\n", clans[clan].nome_clan);
	send_to_char(buffer, ch);

	for (i = descriptor_list; i; i = i->next)
	{
		if (STATE(i) != CON_PLAYING)
			continue;
		if ((GET_CLAN(i->character) != GET_CLAN(ch)) || !GET_CLAN_POS(i->character))
			continue;
		if(!CAN_SEE(ch, i->character))
			continue;
		sprintf(buffer, "&y%20s&W : %s &W[&cLevel&W: &C%d &mRemort&W: &M%d&W]&n\r\n",
			GET_NAME(i->character),	clans[clan].pos_nome[GET_CLAN_POS(i->character) - 1],
			GET_LEVEL(i->character), GET_REMORT(i->character));
		send_to_char(buffer, ch);
		contar++;
	}
	sprintf(buffer, "\r\n&WVoce localizou &R%d &Wmembros do clan.&n\r\n", contar);
	send_to_char(buffer, ch);
}

void depositar_clan(char *argumento, struct char_data *ch)
{
	short int clan;
	int grana;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, DEPOSITAR))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento || !is_number(argumento))
	{
		send_to_char("Formato: clan depositar <grana>\r\n", ch);
		return;
	}

	grana = atoi(argumento);

	if(grana < 1)
	{
		send_to_char("Que numero hein? Nao procure bugs!\r\n", ch);
		return;
	}

	if(GET_GOLD(ch) < grana)
	{
		send_to_char("Voce nao tem essa quantia.\r\n", ch);
		return;
	}

	clan = posicao_clan(GET_CLAN(ch));

	GET_GOLD(ch) -= grana;
	save_char(ch, ch->in_room);
	sprintf(buf, "Voce depositou %s no clan.\r\n", add_points(grana));
	send_to_char(buf, ch);

	clans[clan].grana += grana;
	sprintf(buf, "&RATENCAO&W: &c%s &Wdepositou %s no clan.&n\r\n",
				 GET_NAME(ch), add_points(grana));
	send_to_clan(ch, buf);
	salvar_clan(GET_CLAN(ch));
}

void sacar_clan(char *argumento, struct char_data *ch)
{
	short int clan;
	int grana;

	if(!GET_CLAN(ch))
	{
		send_to_char("Comando nao disponivel.\r\n", ch);
		return;
	}

	if(!tem_permissao(ch, SACAR))
	{
		send_to_char("Voce nao tem posicao suficiente para usar esse comando.\r\n", ch);
		return;
	}

	if(!*argumento || !is_number(argumento))
	{
		send_to_char("Formato: clan sacar <grana>\r\n", ch);
		return;
	}

	grana = atoi(argumento);
	clan = posicao_clan(GET_CLAN(ch));

	if(grana < 1)
	{
		send_to_char("Que numero hein? Nao procure bugs!\r\n", ch);
		return;
	}

	if(clans[clan].grana < grana)
	{
		send_to_char("O clan nao tem essa quantia.\r\n", ch);
		return;
	}

	clans[clan].grana -= grana;
	salvar_clan(GET_CLAN(ch));
	sprintf(buf, "&RATENCAO&W: &c%s &Wsacou %s do clan.&n\r\n",
				 GET_NAME(ch), add_points(grana));
	send_to_clan(ch, buf);

	GET_GOLD(ch) += grana;
	save_char(ch, ch->in_room);
	sprintf(buf, "Voce sacou %s no clan.\r\n", add_points(grana));
	send_to_char(buf, ch);
}

short int ativa_comando(char *komando, char *buffer, struct char_data *ch)
{
	short int com;

	for(com = 0; com < NUM_COMANDOS; com++)
		if(!str_cmp(komando, comandos[com].comando))
		{
			(*comandos[com].procedimento_comando)(buffer, ch);
			return (1);
		}
	return (0);
}

#define COMANDOS_CLAN \
"&cConvencionais&W:&n\r\n" \
"&c lista                     alistar                   abandonar&n\r\n"
#define COMANDOS_SOH_CLAN \
"&c jogando                   &n\r\n\r\n"

#define COMANDOS_GOD \
"&cPara deuses&C: &Rcriar&n\r\n"

void lista_comandos(struct char_data *ch)
{
	char buffer[MAX_INPUT_LENGTH], texto[1000];
	short int komando, klanp = 0;

	strcpy(buffer, "&WLista de comandos de Clan:&n\r\n\r\n");
	strcat(buffer, COMANDOS_CLAN);
	send_to_char(buffer, ch);

	if(GET_CLAN(ch) && GET_CLAN_POS(ch))
	{
		send_to_char(COMANDOS_SOH_CLAN, ch);

		klanp = posicao_clan(GET_CLAN(ch));

		send_to_char("&CEspeciais&W:&n\r\n", ch);
		for(komando = 0; komando < NUM_COMANDOS; komando++)
		{
			sprintf(texto, "&C%s&W(%s&W)", comandos[komando].comando,
					clans[klanp].pos_nome[clans[klanp].pos_comando[komando] - 1]);
			sprintf(buffer, " %s%s", complete_char(texto, 25),
						((komando+1) % 3 ? "" : "\r\n"));
			send_to_char(buffer, ch);
		}
		if(komando % 3)
			send_to_char("\r\n", ch);
	}

	if(GET_LEVEL(ch) >= CLAN_GOD)
		send_to_char(COMANDOS_GOD, ch);
}

ACMD(do_clan)
{
	char buffer[MAX_INPUT_LENGTH], buffer2[MAX_INPUT_LENGTH];

	half_chop(argument, buffer, buffer2);

	if(!*buffer)
		lista_comandos(ch);
	else if(!str_cmp(buffer, "lista"))
		lista_clans(buffer2, ch);
	else if(!str_cmp(buffer, "alistar"))
		alistar_clan(buffer2, ch);
	else if(!str_cmp(buffer, "abandonar"))
		abandonar_clan(ch);
	else if(!str_cmp(buffer, "jogando") && GET_CLAN_POS(ch))
		clan_jogando(ch);
	else if(!str_cmp(buffer, "criar") && GET_LEVEL(ch) >= CLAN_GOD)
		cria_clan(buffer2, ch);
	else if(ativa_comando(buffer, buffer2, ch))
		return;
	else
		send_to_char("Comando nao encontrado.\r\n", ch);
}

::::::::::::::
class.c
::::::::::::::
/* ************************************************************************
*   File: class.c                                       Part of CircleMUD *
*  Usage: Source file for class-specific code                             *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/*
 * This file attempts to concentrate most of the code which must be changed
 * in order for new classes to be added.  If you're adding a new class,
 * you should go through this entire file from beginning to end and add
 * the appropriate new special cases for your new class.
 */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "handler.h"
#include "db.h"
#include "utils.h"
#include "spells.h"
#include "interpreter.h"
#include "olc.h"
#include "buffer.h"
#include "clan.h"

extern struct wis_app_type wis_app[];
extern struct con_app_type con_app[];
extern int siteok_everyone;
extern const char *god_wiznames;
extern struct obj_data *object_list;
extern const char *pc_clsl_types[];

int destransformar(struct char_data *ch, int trans);
void send_to_char(const char *messg, struct char_data *ch);
void obj_to_char(struct obj_data * object, struct char_data * ch);
int find_skill_num(char *name);
void actualize_splskl(struct char_data *ch);
void stop_fighting(struct char_data * ch);
extern int race_attrib[][6];

/* local functions */
int parse_class(char arg);
long find_class_bitvector(char arg);
int saving_throws(int class_num, int type, int level);
int thaco(int class_num, int level);
void roll_real_abils(struct char_data * ch);
void do_start(struct char_data * ch);
int backstab_mult(int level);
int invalid_class(struct char_data *ch, struct obj_data *obj);
int level_exp(int remort, int level);
const char *title_male(int chclass, int level);
const char *title_female(int chclass, int level);
void    write_to_output(const char *txt, struct descriptor_data *d);
int allowed_classes(int x, int i);
#define SEND_TO_Q(messg, desc)  write_to_output((messg), desc)

/* Names first */

const char *class_abbrevs[] = {
  "&CSo&n",
  "&BCl&n",
  "&GTh&n",
  "&rWa&n",
  "&WNc&n",
  "&yPa&n",
  "&cNj&n",
  "&YRg&n",
  "&gPs&n",
  "&mWr&n",
  "&RBr&n",
  "&bSh&n",
  "\n"
};


const char *pc_class_types[] = {
  "Sorcerer",
  "Cleric",
  "Thief",
  "Warrior",
  "Necromancer",
  "Paladin",
  "Ninja",
  "Ranger",
  "Psionicist",
  "Warlock",
  "Barbarian",
  "Shaman",
  "\n"
};

#define STR	0
#define DEX	1
#define CON	2
#define INW	3
#define WIS	4
#define CHA	5

#define MAX_ATTRIB	6

int class_attrib[][MAX_ATTRIB] = {
//  STR DEX CON INT WIS CHA
    {-1, 0, 0,  2,  0,  2},//SOR
    { 0,-1, 1,  0,  1,  2},//CLE
    { 0, 2, 0,  0, -1,  2},//THI
    { 1, 1, 1, -1,  0,  0},//WAR
    { 0, 0, 0,  2,  1, -2},//NEC
    { 1, 0, 1, -1,  0 , 2},//PAL
    { 1, 2, 0, -1,  0 , 0},//NIN
    { 1, 1, 0, -1,  1,  0},//RAN
    { 0, 0,-1,  3,  0,  0},//PSI
    { 0, 0, 1,  1,  1, -2},//WARL
    { 1, 0, 2, -1,  0,  0},//BAR
    { 0,-1, 0,  1,  2,  0} //SHA
};

char *return_attrib_sign(int z)
{
   char sign[3];

	if(z > 0)
	   sprintf(sign, "+%d", z);
	else if(z < 0)
	   sprintf(sign, "%d", z);
	else
	   sprintf(sign, " %d", z);

   return (str_dup(sign));
}

char *attrib_line(int race)
{
   char line[MAX_INPUT_LENGTH];

   int j;

	*line = '\0';
	for(j = 0; j < MAX_ATTRIB; j++)
		sprintf(line+strlen(line), "   %s ", return_attrib_sign(class_attrib[race][j]));

   return (str_dup(line));
}

void display_classes(struct descriptor_data *d)
{
  int x;
  char tes[65536];

	strcpy(tes, "\r\n  &C[&cOption&C]  &WCLASS&n 		  STR   DEX   CON   INT   WIS   CHA\r\n");
	for(x = 0; x < NUM_CLASSES; x++)
          if(allowed_classes(GET_RACE(d->character), x)) {
		sprintf(tes+strlen(tes), "     %s        %s\r\n", pc_clsl_types[x], attrib_line(x));
	  }
        strcat(tes, "\r\n     [-]    Reselect Race\n\r");
	SEND_TO_Q(tes, d);
}

void display_stat(struct descriptor_data *d)
{
  char tes[65536];

  strcpy(tes, "Your stats:\r\n");
  sprintf(tes+strlen(tes), "Str: [&c%d&n/&c%d&n]  Dex: [&c%d&n]  Con: [&c%d&n]  Int: [&c%d&n]  Wis: [&c%d&n]  Cha: [&c%d&n]\r\n",
          GET_STR(d->character), GET_ADD(d->character), GET_DEX(d->character), GET_CON(d->character),
           GET_INT(d->character), GET_WIS(d->character), GET_CHA(d->character));

  SEND_TO_Q(tes, d);
}

void disp_abils(struct descriptor_data *d, int class)
{
  int i, j, c = 1;
  extern char *spells[];
  extern struct spell_info_type spell_info[];
  char tes[65536];

  strcpy(tes, "&WYou will learn:&n\r\n");
  for (j = 1; j < LVL_IMMORT; j++) {
    for (i = 1; i < MAX_SKILLS+1; i++) {
      if (spell_info[i].min_level[class] == j)
	  sprintf(tes+strlen(tes), "  &chow to &C%-24s&n   %s", spells[i], (!(c++ % 2) ? "&n\r\n" : "  "));
    }
  }

  if(c % 2)
    strcat(tes, "\r\n");
  else
    strcat(tes, "\r\n\r\n");

  SEND_TO_Q(tes, d);
}

/* The menu for choosing a class in interpreter.c: */
/*const char *class_menu =
"\r\n"
"Now you can choose you class, a class define your style of fight...\r\n"
"\r\n"
"  [a] Magic User	""  [b] Cleric		""  [c] Warrior		""\r\n"
"  [d] Thief		""  [e] Necromancer	""  [f] Paladin		""\r\n"
"  [g] Ninja		""  [h] Ranger		""  [i] Augurer		""\r\n"
"  [j] Warlock		""  [l] Barbarian		""  [m] Sorcerer	""\r\n"
"\r\n";
*/

/*
 * The code to interpret a class letter -- used in interpreter.c when a
 * new character is selecting a class and by 'set class' in act.wizard.c.
 */

int parse_class(char arg)
{
  arg = LOWER(arg);

  switch (arg) {
  case 'a': return CLASS_MAGIC_USER;
  case 'b': return CLASS_CLERIC;
  case 'c': return CLASS_THIEF;
  case 'd': return CLASS_WARRIOR;
  case 'e': return CLASS_NECROMANCER;
  case 'f': return CLASS_PALADIN;
  case 'g': return CLASS_NINJA;
  case 'h': return CLASS_RANGER;
  case 'i': return CLASS_PSIONICIST;
  case 'j': return CLASS_WARLOCK;
  case 'l': return CLASS_BARBARIAN;
  case 'm': return CLASS_SORCERER;
  default:  return CLASS_UNDEFINED;
  }
}

/*
 * bitvectors (i.e., powers of two) for each class, mainly for use in
 * do_who and do_users.  Add new classes at the end so that all classes
 * use sequential powers of two (1 << 0, 1 << 1, 1 << 2, 1 << 3, 1 << 4,
 * 1 << 5, etc.
 */

long find_class_bitvector(char arg)
{
  arg = LOWER(arg);

  switch (arg) {
    case 'a': return (1 << CLASS_MAGIC_USER);
    case 'b': return (1 << CLASS_CLERIC);
    case 'c': return (1 << CLASS_THIEF);
    case 'd': return (1 << CLASS_WARRIOR);
    case 'e': return (1 << CLASS_NECROMANCER);
    case 'f': return (1 << CLASS_PALADIN);
    case 'g': return (1 << CLASS_NINJA);
    case 'h': return (1 << CLASS_RANGER);
    case 'i': return (1 << CLASS_PSIONICIST);
    case 'j': return (1 << CLASS_WARLOCK);
    case 'l': return (1 << CLASS_BARBARIAN);
    case 'm': return (1 << CLASS_SORCERER);
    default:  return CLASS_UNDEFINED;
  }
}

/*
 * Saving throws for:
 * MCTW
 *   PARA, ROD, PETRI, BREATH, SPELL
 *     Levels 0-40
 *
 * Do not forget to change extern declaration in magic.c if you add to this.
 */

int saving_throws(int class_num, int type, int level)
{
  return (MAX((200-(level)/2),1)) ;
}

/* terminar */
/* THAC0 for classes and levels.  (To Hit Armor Class 0) */
int thaco(int class_num, int level)
{
    int thac;

    switch (class_num)
    {
	case CLASS_MAGIC_USER:
	    thac = (20 - level / 12.6);
	    break;
	case CLASS_CLERIC:
	    thac = (20 - (level / 12.3));
	    break;
	case CLASS_THIEF:
	    thac = (20 - (level / 11.1));
	    break;
	case CLASS_WARRIOR:
	    thac = (20 - (level / 10.5));
	    break;
	case CLASS_NECROMANCER:
	    thac = (20 - (level / 11.7));
	    break;
	case CLASS_PALADIN:
	    thac = (20 - (level / 10.8));
	    break;
	case CLASS_NINJA:
	    thac = (20 - (level / 10.8));
	    break;
	case CLASS_RANGER:
	    thac = (20 - (level / 11.1));
	    break;
	case CLASS_PSIONICIST:
	    thac = (20 - (level / 12));
	    break;
	case CLASS_WARLOCK:
	    thac = (20 - (level / 13.5));
	    break;
	case CLASS_BARBARIAN:
	    thac = (20 - (level / 9.9));
	    break;
	case CLASS_SORCERER:
	    thac = (20 - (level / 12.9));
	    break;
	default:
	    thac = 20;
    }

    return thac;
}


/*
 * Roll the 6 stats for a character... each stat is made of the sum of
 * the best 3 out of 4 rolls of a 6-sided die.  Each class then decides
 * which priority will be given for the best to worst stats.
 */
void roll_real_abils(struct char_data * ch)
{
  int z;

  ch->real_abils.str_add = 0;
  ch->real_abils.luk = number(0, 15);
  GET_MAX_OXI(ch) = 100;

  z = GET_CLASS(ch);
  if(z >= 0) {
      ch->real_abils.str = class_attrib[z][0];
      ch->real_abils.dex = class_attrib[z][1];
      ch->real_abils.con = class_attrib[z][2];
      ch->real_abils.intel = class_attrib[z][3];
      ch->real_abils.wis = class_attrib[z][4];
      ch->real_abils.cha = class_attrib[z][5];
  }

  z = GET_RACE(ch);
  if(z >= 0) {
      ch->real_abils.str += race_attrib[z][0];
      ch->real_abils.dex += race_attrib[z][1];
      ch->real_abils.con += race_attrib[z][2];
      ch->real_abils.intel += race_attrib[z][3];
      ch->real_abils.wis += race_attrib[z][4];
      ch->real_abils.cha += race_attrib[z][5];
  }

  ch->aff_abils = ch->real_abils;
}


/* Some initializations for characters, including initial skills */
void do_start(struct char_data * ch)
{
  struct obj_data *obj;
  int ii;
  int give_obj[] = {508, 3076, 3081, 3086, 3043, 3021, 3042, 12008, 3010, 3010, 3002, -1 };

  if (siteok_everyone)
    SET_BIT(PLR_FLAGS(ch), PLR_SITEOK);

  SET_BIT(PRF_FLAGS(ch), PRF_AUTOEXIT);
  GET_OLC_ZONE(ch) = -1;
  GET_LEVEL(ch) = 1;
  GET_EXP(ch) = 1;
  GET_ALIGNMENT(ch) = 5 ; 

  GET_GOLD(ch) = 3500;

  set_title(ch, NULL);
  set_prename(ch, NULL);
  roll_real_abils(ch);

  ch->points.max_hit = number (10, 25);
  ch->points.max_mana = number (10, 25);
  ch->points.max_move = number (10, 25);

  SET_BIT(PRF_FLAGS(ch), PRF_DISPHP);
  SET_BIT(PRF_FLAGS(ch), PRF_DISPMOVE);
  SET_BIT(PRF2_FLAGS(ch), PRF2_DISPEXP);
  SET_BIT(PLR_FLAGS(ch), PLR_NOPK);

  for(ii = 0; give_obj[ii] != -1; ii++) {
   obj = read_object(give_obj[ii], VIRTUAL);
    if (obj == NULL)
     continue;
    obj_to_char(obj, ch);
  }

  switch (GET_CLASS(ch)) {
   case CLASS_MAGIC_USER:
   case CLASS_CLERIC:
   case CLASS_NECROMANCER:
   case CLASS_PSIONICIST:
   case CLASS_WARLOCK:
   case CLASS_SORCERER:
   case CLASS_PALADIN:
     SET_BIT(PRF_FLAGS(ch), PRF_DISPMANA);
     break;
   case CLASS_THIEF:
     break;
   case CLASS_WARRIOR:
     break;
   case CLASS_NINJA:
     break;
   case CLASS_BARBARIAN:
     break;
   case CLASS_RANGER:
     break;

  }

  advance_level(ch);

  GET_HIT(ch) = GET_MAX_HIT(ch);
  GET_MANA(ch) = GET_MAX_MANA(ch);
  GET_MOVE(ch) = GET_MAX_MOVE(ch);
  GET_MENTAL(ch) = GET_MAX_MENTAL(ch);
  GET_OXI(ch) = GET_MAX_OXI(ch);

  GET_COND(ch, THIRST) = 24;
  GET_COND(ch, FULL) = 24;
  GET_COND(ch, DRUNK) = 0;

  ch->player.time.played = 0;
  ch->player.time.logon = time(0);
}



/*
 * This function controls the change to maxmove, maxmana, and maxhp for
 * each class every time they gain a level.
 */
void advance_level(struct char_data * ch)
{
  //int add_hp = 0, add_mana = 0, add_move = 0;
  int add_mental = 0;
  int i, x;
  //add_hp = con_app[GET_CON(ch)].hitp;

  if(AFF2_FLAGGED(ch, AFF2_TRANSFORM)) // evita bugs qdo se
   destransformar(ch, GET_TRANS(ch));  // passa de level com transform

 switch (GET_CLASS(ch)) {
  case CLASS_MAGIC_USER:
    //add_hp += number(3, 8);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_mana = MIN(add_mana, 10);
    //add_move = number(0, 2);
    break;

  case CLASS_CLERIC:
    //add_hp += number(5, 10);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_mana = MIN(add_mana, 10);
    //add_move = number(0, 2);
    break;

  case CLASS_THIEF:
    //add_hp += number(9, 13);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(1, 3);
    break;

  case CLASS_WARRIOR:
    //add_hp += number(10, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(1, 3);
    break;

  case CLASS_NECROMANCER:
    //add_hp += number(7, 12);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_mana = MIN(add_mana, 10);
    //add_move = number(0, 2);
    break;

  case CLASS_PALADIN:
    //add_hp += number(8, 12);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_mana = MIN(add_mana, 10);
    //add_move = number(0, 2);
    break;

  case CLASS_NINJA:
    //add_hp += number(12, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(2, 5);
    break;

  case CLASS_RANGER:
    //add_hp += number(12, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(2, 5);
    break;

  case CLASS_PSIONICIST:
    //add_hp += number(12, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(2, 5);
    break;

  case CLASS_SORCERER:
    //add_hp += number(12, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(2, 5);
    break;

  case CLASS_WARLOCK:
    //add_hp += number(12, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(2, 5);
    break;

  case CLASS_BARBARIAN:
    //add_hp += number(12, 15);
    //add_mana = number(GET_LEVEL(ch), (int) (1.5 * GET_LEVEL(ch)));
    //add_move = number(2, 5);
    break;
 }

 switch (GET_RACE(ch)) {
  case RACE_VAMPIRE:
    add_mental = number(7, 11);
    break;

  case RACE_DROW:
    add_mental = number(5, 8);
    break;

  case RACE_DWARF:
    add_mental = number(4, 9);
    break;

  case RACE_ELF:
    add_mental = number(8, 10);
    break;

  case RACE_OGRE:
    add_mental = number(3, 6);
    break;

  case RACE_ORC:
    add_mental = number(6, 9);
    break;

  case RACE_TROLL:
    add_mental = number(2, 4);
    break;

  case RACE_GITH:
    add_mental = number(7, 12);
    break;

  case RACE_GNOME:
    add_mental = number(8, 12);
    break;

  case RACE_LIZARDMAN:
    add_mental = number(10, 16);
    break;

  case RACE_SEA_ELF:
    add_mental = number(4, 8);
    break;

  case RACE_GORAK:
    add_mental = number(10, 20);
    break;

  default:
    add_mental = number(5, 20);
   break;

 }
  //ch->points.max_hit += MAX(1, add_hp);
  //ch->points.max_move += MAX(1, add_move);
  if(GET_LEVEL(ch) < LVL_IMMORT)
   ch->points.max_mental += MAX(1, add_mental);

  GET_LVL_SUM(ch) += 1;

  GET_POINTS(ch) += (7+GET_REMORT(ch));
  GET_POINTS_S(ch) += (7+GET_REMORT(ch));

  GET_HIT(ch) = GET_MAX_HIT(ch);
  GET_MANA(ch) = GET_MAX_MANA(ch);
  GET_MOVE(ch) = GET_MAX_MOVE(ch);

  actualize_splskl(ch);

  if (IS_MAGIC_USER(ch) || IS_CLERIC(ch) || IS_NECROMANCER(ch) || IS_PALADIN(ch) || IS_WARLOCK(ch) || IS_PSIONICIST(ch) || IS_SORCERER(ch))
    GET_PRACTICES(ch) += MAX(2, wis_app[GET_WIS(ch)].bonus);
  else
    GET_PRACTICES(ch) += MIN(2, MAX(1, wis_app[GET_WIS(ch)].bonus));

  if (GET_LEVEL(ch) >= LVL_ELDER) {
    for (i = 0; i < 3; i++)
      GET_COND(ch, i) = (char) -1;
    SET_BIT(PRF_FLAGS(ch), PRF_HOLYLIGHT);
  }

  if (GET_LEVEL(ch) == 10) {
    stop_fighting(ch);
    if (ch->in_room != NOWHERE){
      char_from_room(ch);
      char_to_room(ch, real_room(500));
      look_at_room(ch, 0);
    }
    sprintf(buf, "\r\n&WNow, &C%s&W, you need choose.\r\nDo you want be a &RPlayer killer&W? &RType: &W'PK'&W. &RDo not forget, you can not choose again...&n\r\n", GET_NAME(ch));
    send_to_char(buf, ch);
  }

  if (GET_LEVEL(ch) == LVL_IMMORT) {
    SET_BIT(PRF_FLAGS(ch), PRF_NOHASSLE);
    sprintf(buf, "Welcome to the immortality, %s!!\r\n", GET_NAME(ch));
    send_to_char(buf, ch);
    if (ch->in_room != NOWHERE)
      char_from_room(ch);
      char_to_room(ch, real_room(500));
      look_at_room(ch, 0);
  }


	if(GET_CLAN(ch) && GET_CLAN_POS(ch))
		if((x = posicao_clan(GET_CLAN(ch))) != -1)
		{
			clans[x].poder++;
			salvar_clan(GET_CLAN(ch));
		}


   GET_EXP(ch) = 0;
//  sprintf(buf, "%s advanced to level %d", GET_NAME(ch), GET_LEVEL(ch));
//  mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
}

/*
 * This simply calculates the backstab multiplier based on a character's
 * level.  This used to be an array, but was changed to be a function so
 * that it would be easier to add more levels to your MUD.  This doesn't
 * really create a big performance hit because it's not used very often.
 */
int backstab_mult(int level)
{
  if (level <= 0)
    return 1;     /* level 0 */
  else if (level <= 20)
    return 2;     /* level 1 - 5 */
  else if (level <= 50)
    return 2.5;     /* level 6 - 15 */
  else if (level <= 100)
    return 3;     /* level 16 - 30 */
  else if (level <= 150)
    return 3.5;     /* level 31 - 50 */
  else if (level < LVL_IMMORT)
    return 4;     /* all remaining mortal levels */
  else
    return 10;    /* immortals */
}


/*
 * invalid_class is used by handler.c to determine if a piece of equipment is
 * usable by a particular class, based on the ITEM_ANTI_{class} bitvectors.
 */

int invalid_class(struct char_data *ch, struct obj_data *obj) {
  if (GET_LEVEL(ch) >= LVL_GOD ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_MAGIC_USER)  && IS_MAGIC_USER(ch) )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_CLERIC)      && IS_CLERIC(ch)     )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_NECROMANCER) && IS_NECROMANCER(ch))  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_PALADIN)     && IS_PALADIN(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_WARRIOR)     && IS_WARRIOR(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_THIEF)       && IS_THIEF(ch)      )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_NINJA)       && IS_NINJA(ch)      )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_RANGER)      && IS_RANGER(ch)     )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_PSIONICIST)  && IS_PSIONICIST(ch) )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_WARLOCK)     && IS_WARLOCK(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_SORCERER)    && IS_SORCERER(ch)   )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_BARBARIAN)   && IS_BARBARIAN(ch)) )

        return 1;
  else
        return 0;
}




/*
 * SPELLS AND SKILLS.  This area defines which spells are assigned to
 * which classes, and the minimum level the character must be to use
 * the spell or skill.
 */
void init_spell_levels(void)
{
  /* SORCERER */
  spell_level(SPELL_ARMOR,            CLASS_MAGIC_USER,  1);
  spell_level(SKILL_VITALIZE_MANA,    CLASS_MAGIC_USER,  4);
  spell_level(SPELL_INFRAVISION,      CLASS_MAGIC_USER,  8);
  spell_level(SPELL_ACIDARROW,        CLASS_MAGIC_USER,  11);
  spell_level(SPELL_MINOR_GLOBE,      CLASS_MAGIC_USER,  13);
  spell_level(SPELL_FLAMEARROW,       CLASS_MAGIC_USER,  18);
  spell_level(SPELL_REMOVE_CURSE,     CLASS_MAGIC_USER,  19);
  spell_level(SPELL_DETECT_INVIS,     CLASS_MAGIC_USER,  24);
  spell_level(SPELL_GREASE,           CLASS_MAGIC_USER,  26);
  spell_level(SPELL_DETECT_POISON,    CLASS_MAGIC_USER,  30);
  spell_level(SPELL_MAGIC_MISSILE,    CLASS_MAGIC_USER,  35);
  spell_level(SPELL_DETECT_MAGIC,     CLASS_MAGIC_USER,  37);
  spell_level(SPELL_REMOVE_POISON,    CLASS_MAGIC_USER,  43);
  spell_level(SPELL_CROMATIC_ORB,     CLASS_MAGIC_USER,  45);
  spell_level(SPELL_DETECT_ALIGN,     CLASS_MAGIC_USER,  50);
  spell_level(SPELL_STRENGTH,         CLASS_MAGIC_USER,  55);
  spell_level(SPELL_CHILL_TOUCH,      CLASS_MAGIC_USER,  56);
  spell_level(SPELL_IRON_SKIN,        CLASS_MAGIC_USER,  58);
  spell_level(SPELL_CURE_BLIND,       CLASS_MAGIC_USER,  67);
  spell_level(SPELL_AREA_LIGHTNING,   CLASS_MAGIC_USER,  68);
  spell_level(SPELL_INVISIBLE,        CLASS_MAGIC_USER,  70);
  spell_level(SPELL_LOCATE_OBJECT,    CLASS_MAGIC_USER,  77);
  spell_level(SPELL_SLEEP,            CLASS_MAGIC_USER,  78);
  spell_level(SPELL_BURNING_HANDS,    CLASS_MAGIC_USER,  81);
  spell_level(SPELL_MANA_SWORD,       CLASS_MAGIC_USER,  87);
  spell_level(SPELL_SHOCKING_GRASP,   CLASS_MAGIC_USER,  95);
  spell_level(SPELL_DUMBNESS,         CLASS_MAGIC_USER,  97);
  spell_level(SKILL_MEDITATE,         CLASS_MAGIC_USER,  100);
//spell_level(SPELL_GATE,             CLASS_MAGIC_USER,  102); /* Igual Wall of Force */
  spell_level(SKILL_SECOND_ATTACK,    CLASS_MAGIC_USER,  108);
  spell_level(SPELL_COLOR_SPRAY,      CLASS_MAGIC_USER,  110);
  spell_level(SPELL_PLATINUM_SKIN,    CLASS_MAGIC_USER,  113);
//spell_level(SPELL_BLAZE,            CLASS_MAGIC_USER,  117); /* As entradas da sala onde o Player se encontra fica sob chamas durante 5 segundos a partir do instante que ele entrou na sala. Resultado: outro player q entrar la nesse periodo sera atingido pelo fogo. */
  spell_level(SPELL_LIGHTNING_BOLT,   CLASS_MAGIC_USER,  126);
  spell_level(SPELL_BLINDNESS,        CLASS_MAGIC_USER,  127);
  spell_level(SPELL_FRIENDS,          CLASS_MAGIC_USER,  133);
  spell_level(SPELL_ENCHANT_WEAPON,   CLASS_MAGIC_USER,  138);
  spell_level(SPELL_MANA_SHIELD,      CLASS_MAGIC_USER,  140);
  spell_level(SPELL_ICEBOLT,          CLASS_MAGIC_USER,  142);
  spell_level(SPELL_ANTIMAGIC_SHELL,  CLASS_MAGIC_USER,  145);
  spell_level(SPELL_WALL_OF_FOG,      CLASS_MAGIC_USER,  147);
  spell_level(SPELL_CHARM,            CLASS_MAGIC_USER,  153);
  spell_level(SPELL_BLINK,            CLASS_MAGIC_USER,  155);
  spell_level(SPELL_FIREBOLT,         CLASS_MAGIC_USER,  158);
  spell_level(SPELL_DIAMOND_SKIN,     CLASS_MAGIC_USER,  164);
//spell_level(SPELL_SPIDER_WEB,       CLASS_MAGIC_USER,  169); /* Magia que nao causa dano nenhum ao oponente mas o impede de dar FLEE durante 1 tic. */
  spell_level(SPELL_PRISMATIC_SPHERE, CLASS_MAGIC_USER,  173);
  spell_level(SPELL_FLY,              CLASS_MAGIC_USER,  178);
//spell_level(SPELL_INVULNERABILITY   CLASS_MAGIC_USER,  181); /* Spell que impede outras criaturas de o atacarem durante 2 tics. */
  spell_level(SPELL_MAJOR_GLOBE,      CLASS_MAGIC_USER,  184);
  spell_level(SPELL_FIREBALL,         CLASS_MAGIC_USER,  187);
//spell_level(SPELL_WISH              CLASS_MAGIC_USER,  193); /* O player faz um desejo dentro de uma lista de dez que sera relacionado, como aumentar dam, hit, ac, dano da arma, str, etc. Ele podera usar 1 desejo de cada vez, ou seja, so podera usar outro depois q acabar o primeiro. */
//spell_level(SPELL_MAGIC_MIRROR,     CLASS_MAGIC_USER,  197); /* Essa magia deveria gastar muita MANA pois cria um espelho com uma imagem igual do player. Resultado: todas as SPELLS castadas pelo player serao duplicadas. Obs: So as magias serao duplicadas, os ataques armados nao serao pois e so um MIRROR. */

  /* NECROMANCERS */
  spell_level(SPELL_METEOR_SHOWER,     CLASS_NECROMANCER,   1);
  spell_level(SPELL_POISON,            CLASS_NECROMANCER,   4);
//  spell_level(SPELL_DETECT_GOOD,       CLASS_NECROMANCER,   6);
  spell_level(SPELL_CURSE,             CLASS_NECROMANCER,   8);
  spell_level(SPELL_PHANTOM_FLAME,     CLASS_NECROMANCER,  12);
  spell_level(SKILL_VITALIZE_MANA,     CLASS_NECROMANCER,  13);
  spell_level(SPELL_SIMULACRUM,        CLASS_NECROMANCER,  19);
  spell_level(SPELL_MINUTE_METEOR,     CLASS_NECROMANCER,  23);
  spell_level(SKILL_BLOOD_RITUAL,      CLASS_NECROMANCER,  26);
  spell_level(SPELL_BANSHEE_AURA,      CLASS_NECROMANCER,  30);
  spell_level(SPELL_SPECTRAL_WINGS,    CLASS_NECROMANCER,  34);
  spell_level(SPELL_DEATH_RIPPLE,      CLASS_NECROMANCER,  38);
  spell_level(SPELL_PHANTOM_ARMOR,     CLASS_NECROMANCER,  41);
  spell_level(SPELL_GOLEM,             CLASS_NECROMANCER,  49);
  spell_level(SPELL_CHILL_TOUCH,       CLASS_NECROMANCER,  55);
//spell_level(SPELL_REPULSION,         CLASS_NECROMANCER,  58); /* O player que usar essa magia cria uma repulsao na sala que faz com que criaturas de 10 ou mais levels para baixo do player nao consiga permanecer na sala por mais de 5 segundos. Resultado: a criatura e expelida para uma outra sala q nao seja DT. */
  spell_level(SPELL_ENERGY_DRAIN,      CLASS_NECROMANCER,  66);
//  spell_level(SPELL_PROT_FROM_GOOD,    CLASS_NECROMANCER,  68);
  spell_level(SPELL_SKULL_TRAP,        CLASS_NECROMANCER,  71);
//spell_level(SPELL_SPECTER,           CLASS_NECROMANCER,  79); /* Identico a spell GOLEM porem o SPECTER e um pouco mais forte. */
  spell_level(SPELL_GHASTLY_TOUCH,     CLASS_NECROMANCER,  86);
  spell_level(SPELL_TERROR,            CLASS_NECROMANCER,  91);
  spell_level(SPELL_DISPEL_GOOD,       CLASS_NECROMANCER,  99);
  spell_level(SPELL_ENGULFING_DARKNESS,CLASS_NECROMANCER,  100);
  spell_level(SKILL_SECOND_ATTACK,     CLASS_NECROMANCER,  104);
  spell_level(SPELL_DEATH_WAVE  ,      CLASS_NECROMANCER,  113);
//spell_level(SPELL_SKELETON,          CLASS_NECROMANCER,  118); /* Identico a spell GOLEM porem o SKELETON e mais forte. */
  spell_level(SPELL_DAMNED_CURSE,      CLASS_NECROMANCER,  119);
//spell_level(SKILL_DEVILISH_RITUAL,   CLASS_NECROMANCER,  123); /* Essa SKILL so poderia ser usada por players com align EVIL. E funcionaria assim: o player sacrificaria um corpo e receberia em troca uma pequena quantia de HitPoints. Seria um ritual que o necromante faria com o corpo para entrega-lo ao SATAN. */
  spell_level(SPELL_DEATH_FINGER,      CLASS_NECROMANCER,  125);
  spell_level(SPELL_DEATH_SCYTHE,      CLASS_NECROMANCER,  133);
  spell_level(SPELL_SATAN_PACT,        CLASS_NECROMANCER,  136);
  spell_level(SPELL_VAMPIRIC_TOUCH,    CLASS_NECROMANCER,  139);
//spell_level(SPELL_DEMON,             CLASS_NECROMANCER,  149); /* Identico a spell GOLEM porem o DEMON e bem mais forte. */
//spell_level(SPELL_HOLD_UNDEAD,       CLASS_NECROMANCER,  150); /* Para essa SPELL funcionar deveremos criar uma class para mobs UNDEAD que abrangeria todos os seres mortos do mundo. Essa spell funcionaria como MENTAL RAGE mas so funcionaria com mobs UNDEAD. */
  spell_level(SPELL_VULCAN,            CLASS_NECROMANCER,  155);
  spell_level(SPELL_DEATHDANCE,        CLASS_NECROMANCER,  163);
//spell_level(SPELL_CHAOS,             CLASS_NECROMANCER,  166); /* Essa spell funciona ao contrario da spell PEACE. Ao fazer uso dessa magia o player faz com que as outras criaturas da sala com 10 ou mais levels de diferenca comecem a lutar umas com as outras. */
  spell_level(SPELL_ARMAGEDDOM,        CLASS_NECROMANCER,  170);
//spell_level(SPELL_CHARM_UNDEAD,      CLASS_NECROMANCER,  175); /* Como a spell HOLD UNDEAD essa magia dependeria da flag UNDEAD dos mobs para funcionar como CHARM. */
  spell_level(SPELL_SIPHON_LIFE,       CLASS_NECROMANCER,  178);
  spell_level(SPELL_ANIMATE_DEAD,      CLASS_NECROMANCER,  182);
  spell_level(SPELL_PESTILENCE,        CLASS_NECROMANCER,  185);
  spell_level(SPELL_END_WORLD,         CLASS_NECROMANCER,  191);


  /* PALADINS */
//  spell_level(SPELL_DETECT_EVIL,      CLASS_PALADIN,  1);
  spell_level(SPELL_CURE_LIGHT,       CLASS_PALADIN,  3);
//spell_level(SPELL_CLEANSING,        CLASS_PALADIN,  6); /* Faz com que todos os objetos ou criaturas fiquem inertes a magias como POISON, CURSE, PESTILENCE, e outras durante 7 tics. */
  spell_level(SPELL_CREATE_WATER,     CLASS_PALADIN,  10);
  spell_level(SPELL_CREATE_FOOD,      CLASS_PALADIN,  15);
  spell_level(SPELL_BLESS,            CLASS_PALADIN,  21);
  spell_level(SKILL_STING,            CLASS_PALADIN,  28);
  spell_level(SPELL_PROT_FROM_EVIL,   CLASS_PALADIN,  36);
//spell_level(SKILL_PRAY,             CLASS_PALADIN,  45); /* SKILL semelhante a MEDITATE mas que so poderia ser usada por align GOOD. */
  spell_level(SPELL_SACRIFICE,        CLASS_PALADIN,  51);
  spell_level(SPELL_CURE_CRITIC,      CLASS_PALADIN,  55);
//spell_level(SPELL_SALVATION,        CLASS_PALADIN,  57);
  spell_level(SKILL_CRUSH,            CLASS_PALADIN,  64);
  spell_level(SKILL_RESCUE,           CLASS_PALADIN,  66);
//spell_level(SPELL_CONVERTION,       CLASS_PALADIN,  72); /* Spell que converteria inimigos com 10 ou mais levels de diferenca a se tornar aliados durante a batalha. */
  spell_level(SKILL_SECOND_ATTACK,    CLASS_PALADIN,  78);
  spell_level(SPELL_CONCENTRATION,    CLASS_PALADIN,  81);
  spell_level(SPELL_ARMOR,            CLASS_PALADIN,  91);
  spell_level(SPELL_REVITALIZE,       CLASS_PALADIN,  92);
  spell_level(SKILL_STROKE,           CLASS_PALADIN,  97);
  spell_level(SPELL_PEACE,            CLASS_PALADIN,  103);
  spell_level(SPELL_DISPEL_EVIL,      CLASS_PALADIN,  105);
  spell_level(SPELL_CONVICTION,       CLASS_PALADIN,  112);
//  spell_level(SKILL_REDEMPTION,       CLASS_PALADIN,  115); /* SKILL semelhante a skill DEVILISH RITUAL de necromante. A diferenca e que so poderia ser utilizada por players com align GOOD. O funcionamento e identico: sacrificar o corpo para seu DEUS em troca de um pouco de HitPoints. */
  spell_level(SKILL_SLASH,            CLASS_PALADIN,  120);
  spell_level(SKILL_THIRD_ATTACK,     CLASS_PALADIN,  125);
  spell_level(SPELL_CHAMPION_STRENGTH,CLASS_PALADIN,  126);
//spell_level(SPELL_ICESHIELD,        CLASS_PALADIN,  128); /* Spell que tiraria um ataque do oponente. Ou seja se este tivesse 4 ataques teria 3. So nao funcionaria se o oponente tivesse apenas 1 ataque. */
//spell_level(SPELL_HOLY_CLUB         CLASS_PALADIN   133); /* Spell identica a MANA SWORD. Ou seja, criaria um CLUB sagrado para poder usar e gastaria um pouco de sua MANA. */
  spell_level(SPELL_HOLY_MACE,        CLASS_PALADIN,  136);
  spell_level(SKILL_SHIELD_BLOCK,     CLASS_PALADIN,  139);
  spell_level(SKILL_THRASH,           CLASS_PALADIN,  141);
  spell_level(SPELL_HOLY_SHOUT,       CLASS_PALADIN,  145);
  spell_level(SPELL_GOD_PACT,         CLASS_PALADIN,  146);
  spell_level(SPELL_HOLY_SHIELD,      CLASS_PALADIN,  153);
  spell_level(SPELL_SANCTUARY,        CLASS_PALADIN,  159);
  spell_level(SKILL_COMBO,            CLASS_PALADIN,  160);
  spell_level(SPELL_LAY_ON_HANDS,     CLASS_PALADIN,  166);
  spell_level(SPELL_HOLY_WORD,        CLASS_PALADIN,  171);
//spell_level(SPELL_HOLY_FREEZE,      CLASS_PALADIN,  177); /* Essa spell so poderia ser usada por align GOOD e congelaria todos os outros integrantes da sala que nao fossem GOOD. Obs: congelar e diferente de petrificar, ou seja, se depois de congelar 5 oponentes ele atacasse 1 deles, esse se descongelaria com a primeira pancada e lutaria normalmente. A vantagem nessa spell esta para matar bichos HELPER numa sala cheia de criaturas, por exemplo. */
  spell_level(SPELL_HOLY_FURY,        CLASS_PALADIN,  184);
//  spell_level(SPELL_TURN_UNDEAD,      CLASS_PALADIN,  188);
  spell_level(SPELL_HOLY_BOLT,        CLASS_PALADIN,  190);

  /* CLERICS */
  spell_level(SPELL_CURE_LIGHT,       CLASS_CLERIC,   1);
  spell_level(SPELL_INFRAVISION,      CLASS_CLERIC,   2);
  spell_level(SPELL_DETECT_INVIS,     CLASS_CLERIC,   4);
  spell_level(SPELL_LIGHTNING_SPIT,   CLASS_CLERIC,   5);
  spell_level(SPELL_DETECT_POISON,    CLASS_CLERIC,   7);
  spell_level(SPELL_DETECT_MAGIC,     CLASS_CLERIC,  11);
  spell_level(SPELL_FROST_SPIT,       CLASS_CLERIC,  12);
  spell_level(SPELL_DETECT_ALIGN,     CLASS_CLERIC,  16);
  spell_level(SPELL_FIRE_SPIT,        CLASS_CLERIC,  19);
  spell_level(SPELL_CREATE_WATER,     CLASS_CLERIC,  22);
  spell_level(SPELL_GAS_SPIT,         CLASS_CLERIC,  26);
  spell_level(SPELL_CREATE_FOOD,      CLASS_CLERIC,  29);
  spell_level(SPELL_ARMOR,            CLASS_CLERIC,  30);
  spell_level(SPELL_ACID_SPIT,        CLASS_CLERIC,  33);
  spell_level(SPELL_BLESS,            CLASS_CLERIC,  36);
  spell_level(SPELL_SENSE_LIFE,       CLASS_CLERIC,  37);
  spell_level(SPELL_REMOVE_POISON,    CLASS_CLERIC,  40);
  spell_level(SPELL_CURE_CRITIC,      CLASS_CLERIC,  43);
  spell_level(SPELL_BLADEBARRIER,     CLASS_CLERIC,  44);
  spell_level(SPELL_REMOVE_CURSE,     CLASS_CLERIC,  47);
  spell_level(SPELL_IDENTIFY,         CLASS_CLERIC,  48);
  spell_level(SPELL_CALL_LIGHTNING,   CLASS_CLERIC,  55);
  spell_level(SPELL_WATERWALK,        CLASS_CLERIC,  58);
  spell_level(SPELL_WORD_OF_RECALL,   CLASS_CLERIC,  66);
  spell_level(SPELL_CURE_BLIND,       CLASS_CLERIC,  69);
//spell_level(SPELL_ICE_TONGUE,       CLASS_CLERIC,  72); /* Funciona como ENCHANT WEAPON mas tem duracao de 3 tics apenas e da 3 de HITROLL a arma. */
  spell_level(SPELL_EARTHQUAKE,       CLASS_CLERIC,  77);
  spell_level(SPELL_CONTROL_WEATHER,  CLASS_CLERIC,  81);
  spell_level(SPELL_CURE_SERIOUS,     CLASS_CLERIC,  85);
  spell_level(SPELL_BLINDNESS,        CLASS_CLERIC,  88);
//spell_level(SPELL_FIRE_TONGUE,      CLASS_CLERIC,  96); /* Funciona como ENCHANT WEAPON mas tem duracao de 3 tics apenas e da 3 de DAMROLL a arma. */
  spell_level(SKILL_SECOND_ATTACK,    CLASS_CLERIC,  90);
//spell_level(SPELL_REMOVE_FEAR,      CLASS_CLERIC,  102); /* Deixa a criatura sem sofrer consequencias das magias TERROR, AVERSION ou CONFUSION. Alem disso livra a criatura se ela ja tiver com algumas dessas affections. */
//spell_level(SPELL_FEAR,             CLASS_CLERIC,  107);
  spell_level(SPELL_DISPEL_EVIL,      CLASS_CLERIC,  110);
  spell_level(SPELL_DISPEL_GOOD,      CLASS_CLERIC,  114);
  spell_level(SPELL_DISPEL_NEUTRAL,   CLASS_CLERIC,  118);
  spell_level(SPELL_FLESH_ARMOR,      CLASS_CLERIC,  123);
  spell_level(SPELL_HEAL,             CLASS_CLERIC,  127);
  spell_level(SPELL_SHILLELAGH,       CLASS_CLERIC,  130);
  spell_level(SPELL_REFRESH,          CLASS_CLERIC,  135);
  spell_level(SPELL_GOD_PACT,         CLASS_CLERIC,  136);
  spell_level(SPELL_SANCTUARY,        CLASS_CLERIC,  140);
  spell_level(SKILL_THIRD_ATTACK,     CLASS_CLERIC, 145);
  spell_level(SPELL_MAGICAL_STONE,    CLASS_CLERIC,  146);
//spell_level(SPELL_INVERT_ALIGN,     CLASS_CLERIC,  147); /* Inverte o align do player */
//spell_level(SKILL_WATER_BREATHING,  CLASS_CLERIC,  151); /* Seria uma SKILL que funcionaria como SWIM, ja que o player poderia respirar dentro da agua. */
  spell_level(SPELL_ENTANGLE,         CLASS_CLERIC,  155);
  spell_level(SPELL_HASTE,            CLASS_CLERIC,  157);
  spell_level(SPELL_COMMAND,          CLASS_CLERIC,  162);
  spell_level(SPELL_SUMMON,           CLASS_CLERIC,  166);
  spell_level(SPELL_REGENERATION,     CLASS_CLERIC,  169);
//spell_level(SPELL_REJUVENATION,     CLASS_CLERIC,  177); /* Diminui em 20 a idade do player. */
  spell_level(SPELL_HARM,             CLASS_CLERIC,  184);
//spell_level(SPELL_GOOD_BERRIES,     CLASS_CLERIC,  194); /* Cria pequenas pocoes que gastam bastante MANA e recuperam pouco HitPoints. A vantagem e que pode ser carregada e nao pesa muito. */
  spell_level(SPELL_HOLD_PERSON,      CLASS_CLERIC,  198);

  /* THIEVES */
  spell_level(SKILL_SNEAK,            CLASS_THIEF,   1);
  spell_level(SKILL_PICK_LOCK,        CLASS_THIEF,   4);
//spell_level(SKILL_SENSE_DANGER,     CLASS_THIEF,   8); /* Arte de detectar se ha uma DT ao redor da sala onde ele se encontra. */
  spell_level(SKILL_SWIM,             CLASS_THIEF,  11);
  spell_level(SKILL_STEAL,            CLASS_THIEF,  13);
//spell_level(SKILL_FORAGE,           CLASS_THIEF,  17); /* Procurar comida. */
  spell_level(SKILL_HIDE,             CLASS_THIEF,  19);
  spell_level(SKILL_KNOCKOUT,         CLASS_THIEF,  24);
  spell_level(SKILL_BACKSTAB,         CLASS_THIEF,  26);
  spell_level(SKILL_TRACK,            CLASS_THIEF,  32);
  spell_level(SKILL_LISTEN,           CLASS_THIEF,  34);
  spell_level(SKILL_PIERCE,           CLASS_THIEF,  41);
//spell_level(SKILL_INCREASE_SPEED,   CLASS_THIEF,  43); /* Ao utilizar essa SKILL o player recupera mais rapido os MovePoints */
  spell_level(SKILL_ESCAPE,           CLASS_THIEF,  51);
//spell_level(SKILL_SLIT,             CLASS_THIEF,  55); /* Funcionaria como a skill KICK. Slit significa uma cutilada, ou seja, um BACKSTAB bem mais fraco. A vantagem e que enquanto o player nao tem CIRCLE AROUND ele pode usar o artificio SLIT no meio da luta. */
//spell_level(SKILL_POISON_JAVELIN,   CLASS_THIEF,  62); /* Infectaria um equipamento com uma pocao que duraria 10 tics e tiraria -5 dam -5 hit e + 30 AC. Para fazer uso disso o thief precisaria estar com align EVIL. */
  spell_level(SKILL_STING,            CLASS_THIEF,  68);
  spell_level(SKILL_SECOND_ATTACK,    CLASS_THIEF,  74);
  spell_level(SKILL_DISARM,           CLASS_THIEF,  82);
  spell_level(SKILL_SCAN,             CLASS_THIEF,  87);
//spell_level(SKILL_POLISH,           CLASS_THIEF,  97); /* Arte de polir algum equipamento com a finalidade de ele demorar mais tempo para se danificar. */
  spell_level(SKILL_STAB,             CLASS_THIEF,  101);
//spell_level(SKILL_STEALTH,          CLASS_THIEF,  104); /* Faz com que o player use SNEAK e HIDE ao mesmo tempo. Ou seja: permaneca HIDE mesmo quando ande. */
//spell_level(SKILL_KILLING_BLOW,     CLASS_THIEF,  111); /* Identico a CRITICAL ATTACK com uso automatico. */
  spell_level(SKILL_CIRCLE_ARROUND,   CLASS_THIEF,  116);
  spell_level(SKILL_THROW,            CLASS_THIEF,  124);
  spell_level(SKILL_FIRST_AID,        CLASS_THIEF,  132);
//spell_level(SKILL_IMP_PICK_LOCK,    CLASS_THIEF,  136); /* Pick Lock que funcionaria em bem maior numero de fechaduras. */
  spell_level(SKILL_THIRD_ATTACK,     CLASS_THIEF,  145);
  spell_level(SKILL_DROWN,            CLASS_THIEF,  147);
//spell_level(SKILL_TRICKERY,         CLASS_THIEF,  149); /* O thief usaria todas sua desonestidade e aumentaria em +3 sua DEX. Mas para conseguir trapacear dessa forma ele teria que estar com o align EVIL. */
  spell_level(SKILL_TUMBLE,           CLASS_THIEF,  155);
//spell_level(SKILL_FIND_TRAPS,       CLASS_THIEF,  158); /* Procurar ARMADILHAS feitas por outros players. Veja mais em ARM TRAPS. */
//spell_level(SKILL_DISARM_TRAPS,     CLASS_THIEF,  161); /* Desarmas ARMADILHAS feitas por ele mesmo ou por outros players. Veja mais em ARM TRAPS. */
//spell_level(SKILL_ARM_TRAPS,        CLASS_THIEF,  164); /* Armar ARMADILHAS. Funcionaria assim: cada player com essa skill teria direito a fazer uma unica armadilha, que ele deixaria em qualquer sala. Todas as criaturas que por la passassem sofreriam um dano se passassem por la rapido ou ficariam presos se ficassem mais de 5 segundos naquela sala. Como foi dito, cada player tem direito a uma unica armadilha, ou seja, se quiser colocar em outro lugar tera que desarmar aquela que fez anteriormente. Isso nao quer dizer que se desarmar de um outro player vai ter 2. Todos tem no maximo 1. */
//spell_level(SKILL_VENGEANCE,        CLASS_THIEF,  169); /* O thief para usar essa skill teria que estar com align EVIL. Para usar ele teria que digitar VENGEANCE (nome de alguma criatyra) no maximo 1 tic depois de lutar com essa criatura. Essa skill duraria 12 tics e se esse player voltasse a lutar contra aquele oponente novamente nesse periodo teria a forca de todos os seus golpes multiplicada por 1,5. */
  spell_level(SKILL_CHOP,             CLASS_THIEF,  173);
//spell_level(SKILL_PLAGUE_JAVELIN,   CLASS_THIEF,  177); /* Igual ao POISON JAVELIN. Ou seja, so podendo ser usado por align EVIL, so q o player infectaria um equipamente que duraria 24 tics e causaria -12 DAM, -12 HIT e + 60 AC em quem a usasse. */
  spell_level(SKILL_SECOND_STAB,      CLASS_THIEF,  186);
//spell_level(SKILL_FEND,             CLASS_THIEF,  195); /* Igual ao COMBO mas acertaria um golpe em cada outro oponente que estivesse na sala e bem mais fraco. */

  /* WARRIORS */
  spell_level(SKILL_SWIM,             CLASS_WARRIOR,   1);
  spell_level(SKILL_KICK,             CLASS_WARRIOR,   5);
//spell_level(SKILL_COMBAT_THEORY,    CLASS_WARRIOR,  11); /* Faria com que o player tivesse a skill TANK e nao deixasse os mobs HELPER que ajudassem o oponente atacar seus aliados. */
  spell_level(SKILL_HIT,              CLASS_WARRIOR,  14);
//spell_level(SKILL_MIGHT,            CLASS_WARRIOR,  18); /* Skill que sacrificaria 1 ponto de cada um dos atributos (WIS, CHA, CON, DEX e INT) que seriam convertidos em +5 em STR durante 2 tics. */
  spell_level(SKILL_TRACK,            CLASS_WARRIOR,  22);
  spell_level(SKILL_KNOCKOUT,         CLASS_WARRIOR,  30);
  spell_level(SKILL_RESCUE,           CLASS_WARRIOR,  31);
//spell_level(SKILL_BATTLECRY,        CLASS_WARRIOR,  39); /* Grito que tiraria certa quantidade de MovePoints e seria convertido em +2 de Hitroll ao player. */
  spell_level(SKILL_CRUSH,            CLASS_WARRIOR,  41);
//spell_level(SKILL_WARCRY,           CLASS_WARRIOR,  47); /* Grito que tiraria certa quantidade de MovePoints e seria convertido em +2 de Damroll ao player. */
//spell_level(SKILL_VIGOR,            CLASS_WARRIOR,  52); /* Skill que aumentaria o AC em +30 e aumentaria a CON em +2. */
  spell_level(SKILL_SECOND_ATTACK,    CLASS_WARRIOR,  45);
  spell_level(SKILL_WHIRLWIND,        CLASS_WARRIOR,  60);
  spell_level(SKILL_SLASH,            CLASS_WARRIOR,  65);
//spell_level(SKILL_SHOUT,            CLASS_WARRIOR,  79); /* Grito que tiraria certa quantidade de MovePoints e seria convertido em -30 de AC. */
//spell_level(SKILL_SMITE,            CLASS_WARRIOR,  80); /* Funcionaria igual KICK mas seria um pouco mais forte. SMITE significa uma pancada dada com o escudo, por isso e necessario q o player tenha. */
  spell_level(SKILL_PUNCH,            CLASS_WARRIOR,  94);
  spell_level(SKILL_THIRD_ATTACK,     CLASS_WARRIOR,  95);
  spell_level(SKILL_BASH,             CLASS_WARRIOR,  97);
  spell_level(SKILL_GUT,              CLASS_WARRIOR,  100);
  spell_level(SKILL_BLAST,            CLASS_WARRIOR,  110);
//spell_level(SKILL_IMPALE,           CLASS_WARRIOR,  117); /* Funciona quase igual ao DISARM, mas em vez de desarmar, o player desgasta a arma do oponente. */
//spell_level(SKILL_CONCENTRATE,      CLASS_WARRIOR,  127); /* Daria +5 ao Hitroll ao player. Poderia ter alguma outra skill que tirasse a concentracao de um player. */
  spell_level(SKILL_SCAN,             CLASS_WARRIOR,  133);
  spell_level(SKILL_THROW,            CLASS_WARRIOR,  140);
  spell_level(SKILL_POUND,            CLASS_WARRIOR,  143);
  spell_level(SKILL_PARRY,            CLASS_WARRIOR,  149);
  spell_level(SKILL_COMBO,            CLASS_WARRIOR,  150);
  spell_level(SKILL_DROWN,            CLASS_WARRIOR,  155);
  spell_level(SKILL_WHIP,             CLASS_WARRIOR,  161);
  spell_level(SKILL_DUAL_WIELD,       CLASS_WARRIOR,  155);
  spell_level(SKILL_CHOP,             CLASS_WARRIOR,  172);
//spell_level(SKILL_CHARGE,           CLASS_WARRIOR,  184); /* So poderia ser usado no inicio da luta. Teria um dano muito alto, como um ataque multiplicado por 4, ja q o player vem correndo para acertar o oponente. */


  /* NINJA */
  spell_level(SKILL_HAND_DAMAGE,      CLASS_NINJA,  1);
//spell_level(SKILL_DARKFIGHT,        CLASS_NINJA,  4); /* Lutar no escuro, como se estivesse claro. */
//spell_level(SKILL_BLINDFIGHT,       CLASS_NINJA,  9); /* Lutar cego, como se estivesse normal. */
  spell_level(SKILL_KICK,             CLASS_NINJA,  11);
  spell_level(SKILL_SNEAK,            CLASS_NINJA,  23);
  spell_level(SKILL_KNOCKOUT,         CLASS_NINJA,  28);
//spell_level(SKILL_SLACKEN,          CLASS_NINJA,  31); /* Meditacao ninja, que seria como MEDITATE mas recuperaria HitPoints em vez de ManaPoints mais rapidamente. */
  spell_level(SKILL_SLASH,            CLASS_NINJA,  40);
  spell_level(SKILL_KICKFLIP,         CLASS_NINJA,  45);
  spell_level(SKILL_SUICIDE,          CLASS_NINJA,  50);
  spell_level(SKILL_LISTEN,           CLASS_NINJA,  55);
  spell_level(SKILL_SECOND_ATTACK,    CLASS_NINJA,  61);
  spell_level(SKILL_STYLE_PRO,        CLASS_NINJA,  65);
//spell_level(SKILL_LICK,             CLASS_NINJA,  62); /* Lick e uma pancada ninja. Funcionaria como o KICK mas o dano seria um pouco mais forte. */
//spell_level(SKILL_INVISIBILITY,     CLASS_NINJA,  66); /* SKILL que funcionaria como a Spell INVISIBLE. */
  spell_level(SKILL_DISARM,           CLASS_NINJA,  73);
  spell_level(SKILL_TRACK,            CLASS_NINJA,  78);
//spell_level(SKILL_MENTAL_EXERC,     CLASS_NINJA,  79); /* Aumentaria seu INT +2 durante 2 tics. */
  spell_level(SKILL_HIT,              CLASS_NINJA,  86);
  spell_level(SKILL_PICK_LOCK,        CLASS_NINJA,  91);
//spell_level(SKILL_SPURT,            CLASS_NINJA,  96); /* Lick e um arremesso ninja. O ideal e q seja dificil de ser efetuado, mas quando consegue deixa o oponente SITTING durante 1 turno e o ataque e um pouco mais forte pois o oponente esta tonto devido a queda no arremesso. */
  spell_level(SKILL_WHITE_GAS,        CLASS_NINJA,  100);
//spell_level(SKILL_SHARPEN,          CLASS_NINJA,  105); /* Seria como o ENCHANT WEAPON mas daria +8 dam e +8 hit e duraria 1 tic so. SHARPEN significa afiar uma espada, portanto so funcionaria em armas SLASH. */
//spell_level(SKILL_CONCENTRATE,      CLASS_NINJA,  113); /* Daria +5 ao Hitroll ao player. Poderia ter alguma outra skill que tirasse a concentracao de um player. */
  spell_level(SKILL_DUAL_WIELD,       CLASS_NINJA,  115);
  spell_level(SKILL_THROW,            CLASS_NINJA,  130);
//spell_level(SKILL_SHURIKEN,         CLASS_NINJA,  131); /* Golpe mais forte dado pelo ninja. Funcionaria igual ao KICK mas teria o valor de 1,5 ataque normal. */
//spell_level(SKILL_IMPALE,           CLASS_NINJA,  136); /* Funciona quase igual ao DISARM, mas em vez de desarmar, o player desgasta a arma do oponente. */
  spell_level(SKILL_DROWN,            CLASS_NINJA,  147);
  spell_level(SKILL_ESCAPE,           CLASS_NINJA,  148);
//spell_level(SKILL_IMPROVED_SLASH,   CLASS_NINJA,  153); /* Maior poder ofensivo com armas SLASH. */
//spell_level(SKILL_IMMOBILIZATION,   CLASS_NINJA,  164); /* Imobilizacao ninja. Faria com que o player imobilizasse o oponente que fosse 10 ou mais levels abaixo do seu. Mas, para imobilizar seu oponente o player tb fica parado. Ou seja os 2 ficam sem se movimentar. A vantagem e que um outro player pode atacar esse oponente. Deveria ter duracao de alguns turnos somente e ser muito dificil de ser concretizado. */
  spell_level(SKILL_AGILITY,          CLASS_NINJA,  166);
  spell_level(SKILL_SABRE,            CLASS_NINJA,  181);
  spell_level(SKILL_THIRD_ATTACK,     CLASS_NINJA,  185);
//spell_level(SKILL_MORTAL_DASH,      CLASS_NINJA,  190); /* Golpe Mortal. Um golpe dado que mataria o player instantaneamente. Mas para ser utilizado o oponente deve estar com menos de 30% do seu HitPoint total e ser 10 ou mais levels abaixo. */
//spell_level(SKILL_NJ_MOTIONS,       CLASS_NINJA,  198); /* Ninjitsu Motions. O ninja usaria isso automaticamente e ficaria muito mais agil de acordo com o peso que carrega. Isso faria com que acertasse mais golpes e mais fortes, desviasse mais e mais dificil de tomar danos de magis. */

   /* RANGER */
  spell_level(SKILL_SWIM,             CLASS_RANGER,  1);
  spell_level(SPELL_INFRAVISION,      CLASS_RANGER,  4);
//spell_level(SKILL_FORAGE,           CLASS_RANGER,  8); /* Procurar comida. */
//spell_level(SKILL_ANIMAL_AFFINITY,  CLASS_RANGER, 11); /* Como a flag UNDEAD que citei na classe necromante, deveria existir uma flag pra mobs ANIMAL. Essa skill faria com que o Ranger nao fosse atacado por animais de nenhuma forma, ao menos que ele atacasse. */
  spell_level(SKILL_STING,            CLASS_RANGER, 13);
  spell_level(SKILL_KICK,             CLASS_RANGER, 15);
  spell_level(SKILL_TRACK,            CLASS_RANGER, 19);
  spell_level(SPELL_BARKSKIN,         CLASS_RANGER, 20);
//spell_level(SKILL_CAMP,             CLASS_RANGER, 23); /* Arte de acampar. Ao digitar CAMP o ranger faz com que a sala fique com regeneracao quase igual de temple e pode descansar ali. Porem, isso nao deixa a sala PEACE e ele pode ser atacado por outras criaturas. */
  spell_level(SPELL_DETECT_INVIS,     CLASS_RANGER, 26);
  spell_level(SPELL_ACIDARROW,        CLASS_RANGER, 31);
  spell_level(SPELL_ARMOR,            CLASS_RANGER, 34);
//spell_level(SKILL_BOWSHOT,          CLASS_RANGER, 35); /* Conseguir atingir uma criatura a uma sala ao lado. */
//spell_level(SKILL_DECOY,            CLASS_RANGER, 43); /* Provocar o oponente com a finalidade de ele lutar com toda a sua furia (mais forte) mas que o impede de dar FLEE. */
//spell_level(SKILL_NATURAL_RESIST,   CLASS_RANGER, 47); /* Fazer com que em salas com flag de FOREST, FIELD, e outras que nao sejam desconhecidas por um ranger, faca com que o player gaste menos MovePoints q o normal e se recupere mais rapidamente. */
//spell_level(SKILL_NATURE_FORCE,     CLASS_RANGER, 53); /* Comando que faz com que o ranger ganhe +2 em CON se ele estiver na FOREST. Dura 2 tics se ele sair desse ambiente. */
  spell_level(SKILL_HIDE,             CLASS_RANGER, 59);
  spell_level(SPELL_FLAMEARROW,       CLASS_RANGER, 62);
  spell_level(SKILL_BITE,             CLASS_RANGER, 64);
  spell_level(SKILL_DUAL_WIELD,       CLASS_RANGER, 68);
//spell_level(SPELL_HOLD_ANIMAL,      CLASS_RANGER, 71); /* Funcionaria como MENTAL RAGE, mas so os mobs com flag ANIMAL poderiam ser holded. */
  spell_level(SKILL_SECOND_ATTACK,    CLASS_RANGER, 76);
  spell_level(SKILL_WHIRLWIND,        CLASS_RANGER, 78);
//spell_level(SKILL_SHOUT,            CLASS_RANGER, 83); /* Grito que tiraria certa quantidade de MovePoints e seria convertido em -30 de AC. */
  spell_level(SPELL_INVISIBLE,        CLASS_RANGER, 89);
  spell_level(SPELL_VOLCANO,          CLASS_RANGER, 93);
//spell_level(SKILL_ICREASE_STAMINA,  CLASS_RANGER, 95); /* Faz com que o player recupere mais rapido HitPoints */
//spell_level(SKILL_BANDAGE           CLASS_RANGER, 100); /* Fazer bandagens, ou seja, curar ferimentos. Basta trocar move points por hit points. */
  spell_level(SKILL_MAUL,             CLASS_RANGER, 103);
//spell_level(SPELL_CHARM_ANIMAL,     CLASS_RANGER, 107); /* Funcionaria como CHARM PERSON, mas so os mobs com flag ANIMAL poderiam sofrer essa magia. */
  spell_level(SKILL_THROW,            CLASS_RANGER, 109);
//spell_level(SPELL_FLAME_BLADE,      CLASS_RANGER, 118); /* Uso identico a MANA SWORD mas o player criaria uma BLADE em chamas. */
//spell_level(SKILL_SCENT,            CLASS_RANGER, 119); /* Uso parecido com TRACK. A diferenca e que so funcionaria se a criatura estivesse na mesma ZONE e nesse caso funcionaria tb para mobs !TRACK. */
  spell_level(SPELL_CALL_BEAR,        CLASS_RANGER, 120);
  spell_level(SPELL_GEYSER,           CLASS_RANGER, 124);
  spell_level(SKILL_THIRD_ATTACK,     CLASS_RANGER, 125);
  spell_level(SKILL_FIRST_AID,        CLASS_RANGER, 131);
  spell_level(SKILL_POUND,            CLASS_RANGER, 134);
  spell_level(SKILL_DROWN,            CLASS_RANGER, 140);
  spell_level(SKILL_BLUDGEON,         CLASS_RANGER, 151);
  spell_level(SPELL_SHILLELAGH,       CLASS_RANGER, 155);
  spell_level(SPELL_FIRESHIELD,       CLASS_RANGER, 167);
  spell_level(SPELL_HASTE,            CLASS_RANGER, 169);
//spell_level(SKILL_FEND,             CLASS_RANGER, 171); /* Parecido ao COMBO mas acertaria um golpe em cada outro oponente que estivesse na sala e bem mais fraco. */
  spell_level(SPELL_ENTANGLE,         CLASS_RANGER, 179);
  spell_level(SKILL_SABRE,            CLASS_RANGER, 191);
//spell_level(SKILL_ZEAL,             CLASS_RANGER, 187); /* Identico ao COMBO, mas so funcionaria se o player estivesse com align GOOD. */
//spell_level(SKILL_METAMORPHOSIS,    CLASS_RANGER, 191); /* O player ganharia metamorfose e poderia se transformar em alguns animais como WOLF, TIGER ou BEAR, cada um com alguns beneficios. Ele so conseguiria fazer isso se estivesse GOOD e recebesse a graca divina para fazer isso. */

  /* BARBARIAN */
  spell_level(SKILL_HAND_DAMAGE,      CLASS_BARBARIAN, 1);
  spell_level(SKILL_VITALIZE_HEALTH,  CLASS_BARBARIAN, 4);
  spell_level(SKILL_HIT,              CLASS_BARBARIAN, 8);
  spell_level(SKILL_SWIM,             CLASS_BARBARIAN, 13);
  spell_level(SKILL_KICK,             CLASS_BARBARIAN, 15);
//spell_level(SKILL_INCREASE_SPEED,   CLASS_BARBARIAN, 19); /* Ao utilizar essa SKILL o player recupera mais rapido os MovePoints */
  spell_level(SKILL_THRASH,           CLASS_BARBARIAN, 26);
//spell_level(SKILL_HOWL,             CLASS_BARBARIAN, 34); /* Funcionando com uma criatura que seja 10 ou mais levels abaixo do player, ele da um rugido que assusta a criatura que foge. */
//spell_level(SKILL_SLANG,            CLASS_BARBARIAN, 35); /* Slang e um golpe baixo. Funciona igual ao KICK mas tira um pouco mais de dano. */
  spell_level(SKILL_SLASH,            CLASS_BARBARIAN, 43);
  spell_level(SKILL_SECOND_ATTACK,    CLASS_BARBARIAN, 53);
  spell_level(SKILL_WHIRLWIND,        CLASS_BARBARIAN, 55);
//spell_level(SKILL_WARORDER,         CLASS_BARBARIAN, 64); /* Funciona igual ao WARSHOUT mas da +5 de HIT ao grupo. */
//spell_level(SKILL_NAPEBASH,         CLASS_BARBARIAN, 75); /* Igual ao HEADBASH mas funcionaria de 4 em 4 turnos apenas e nao daria o ataque mais forte qdo o oponente estivesse caido. */
  spell_level(SKILL_BITE,             CLASS_BARBARIAN, 78);
//spell_level(SKILL_FURY_ATTACK,      CLASS_BARBARIAN, 84); /* Igual ao CRITICAL ATTACK. */
  spell_level(SKILL_WARSHOUT,         CLASS_BARBARIAN, 91);
//spell_level(SKILL_FRENZY,           CLASS_BARBARIAN, 95); /* Funcionaria igual ao KICK, mas seria uma porrada dada um pouco mais forte com a base da arma. Teria o valor 1,5 de uma pancada normal. */
  spell_level(SKILL_MAUL,             CLASS_BARBARIAN, 100);
  spell_level(SKILL_THIRD_ATTACK,     CLASS_BARBARIAN, 105);
  spell_level(SKILL_FIRST_AID,        CLASS_BARBARIAN, 108);
//spell_level(SKILL_DOUBLE_SWING,     CLASS_BARBARIAN, 115); /* Funcionaria igual ao KICK, mas o player daria 2 pancadas equivalente a 1 ataque normal. O primeiro acertaria o oponente com o qual esta lutando e o segundo um outro oponente que o esteja atacando tb. */
//spell_level(SKILL_TAUNT,            CLASS_BARBARIAN, 117); /* Desafiar o oponente a uma luta de vida ou morte sem que nenhum dos lutadores possa dar FLEE. */
  spell_level(SKILL_CLAW,             CLASS_BARBARIAN, 120);
//spell_level(SKILL_GRIM_WARD,        CLASS_BARBARIAN, 127); /* Grito dado em direcao a um corpo que causa panico nas outras criaturas da sala. */
  spell_level(SKILL_HEADBASH,         CLASS_BARBARIAN, 135);
//spell_level(SKILL_INCREASE_STAMINA, CLASS_BARBARIAN, 136); /* Faz com que o player recupere mais rapido HitPoints */
  spell_level(SKILL_BLUDGEON,         CLASS_BARBARIAN, 138);
//spell_level(SKILL_FORCE_LOCK,       CLASS_BARBARIAN, 144); /* Igual Pick Lock sem Improved. */
  spell_level(SKILL_DODGE,            CLASS_BARBARIAN, 150);
  spell_level(SKILL_BERZERK,          CLASS_BARBARIAN, 153);
  spell_level(SKILL_THROW,            CLASS_BARBARIAN, 155);
//spell_level(SKILL_RAGE,             CLASS_BARBARIAN, 163); /* Furia. Aumenta o Damroll em +20 e Hitroll em +20 e aumenta AC em +100. */
  spell_level(SKILL_FOURTH_ATTACK,    CLASS_BARBARIAN, 171);
  spell_level(SKILL_CHOP,             CLASS_BARBARIAN, 175);
//spell_level(SKILL_BATTLE_TATICS,    CLASS_BARBARIAN, 188); /* Uso de artimanhas durante a luta, como jogar areia nos olhos do adversario, confundir o oponente e outros. Daria pequenos danos e funcionaria automaticamente. */
//spell_level(SKILL_LEAP,             CLASS_BARBARIAN, 195); /* Significa se jogar sobre os oponentes. Resultado: tanto o player como todos os outros q estejam lutando contra ele fica SITTING 1 turno. A vantagem dessa skill e quando se luta em grupo. Nesse caso todos ficariam sentados e os aliados do player q executou LEAP ficariam em pe. */

  /* SHAMAN */
  spell_level(SPELL_METEOR_SHOWER,    CLASS_SORCERER,  1);
  spell_level(SPELL_ARMOR,            CLASS_SORCERER,  4);
  spell_level(SKILL_VITALIZE_MANA,    CLASS_SORCERER,  9);
//spell_level(SPELL_LIGHT,            CLASS_SORCERER,  11); /* Faz com que uma sala escura se torne luminosa por 12 horas. */
  spell_level(SPELL_BLESS,            CLASS_SORCERER,  15);
//spell_level(SPELL_REPULSION,        CLASS_SORCERER,  17); /* O player que usar essa magia cria uma repulsao na sala que faz com que criaturas de 10 ou mais levels para baixo do player nao consiga permanecer na sala por mais de 5 segundos. Resultado: a criatura e expelida para uma outra sala q nao seja DT. */
  spell_level(SPELL_GROUP_ARMOR,      CLASS_SORCERER,  20);
  spell_level(SPELL_MINUTE_METEOR,    CLASS_SORCERER,  22);
//  spell_level(SPELL_DETECT_EVIL,      CLASS_SORCERER,  26);
  spell_level(SPELL_SENSE_LIFE,       CLASS_SORCERER,  32);
  spell_level(SPELL_CURE_CRITIC,      CLASS_SORCERER,  33);
  spell_level(SPELL_GROUP_BLESS,      CLASS_SORCERER,  41);
  spell_level(SPELL_CORPOR_TREMBLING, CLASS_SORCERER,  43);
  spell_level(SPELL_ELEMENTAL,        CLASS_SORCERER,  50);
  spell_level(SPELL_INVISIBLE,        CLASS_SORCERER,  51);
  spell_level(SPELL_PROT_FROM_EVIL,   CLASS_SORCERER,  60);
  spell_level(SKILL_MEDITATE      ,   CLASS_SORCERER,  62);
  spell_level(SPELL_AREA_LIGHTNING,   CLASS_SORCERER,  64);
  spell_level(SPELL_FIREWALL,         CLASS_SORCERER,  71);
  spell_level(SPELL_PEACE,            CLASS_SORCERER,  79);
  spell_level(SKILL_LEVITATE,         CLASS_SORCERER,  83);
  spell_level(SPELL_VOLCANO,          CLASS_SORCERER,  85);
  spell_level(SPELL_CONFUSION,        CLASS_SORCERER,  87);
  spell_level(SPELL_BRAVERY,          CLASS_SORCERER,  96);
  spell_level(SKILL_SECOND_ATTACK,    CLASS_SORCERER,  101);
  spell_level(SPELL_DISPEL_EVIL,      CLASS_SORCERER,  110);
  spell_level(SPELL_GEYSER,           CLASS_SORCERER,  106);
//spell_level(SPELL_SPIRITUAL_HAMMER, CLASS_SORCERER,  111); /* Funciona igual MANA SWORD, mas o castador cria um martelo espiritual. */
  spell_level(SPELL_LOCATE_OBJECT,    CLASS_SORCERER,  116);
  spell_level(SPELL_ICEWALL,          CLASS_SORCERER,  123);
  spell_level(SPELL_ICE_HEART,        CLASS_SORCERER,  127);
//spell_level(SPELL_SHIVER_ARMOR,     CLASS_SORCERER,  132); /* Armadura que causa tremor ao adversario. Isso faz com que o oponente erre o primeiro ataque que tente dar, seja ele uma magia, uma skill qualquer, mental rage, etc. O detalhe e q depois q o adversario erra o golpe a armadura se desfaz, precisando ser castada novamente se desejar se defender novamente. Alem disso ela so pode ser utilizada antes do combate e nao durante ele. Ela so poderia ser usada qdo o castador estivesse GOOD. */
  spell_level(SPELL_FORCE_SHIELD,     CLASS_SORCERER,  135);
  spell_level(SPELL_GOD_PACT,         CLASS_SORCERER,  146);
  spell_level(SPELL_GLACIAL_CONE,     CLASS_SORCERER,  148);
  spell_level(SPELL_BLINK,            CLASS_SORCERER,  155);
  spell_level(SPELL_HEAL,             CLASS_SORCERER,  156);
  spell_level(SPELL_RIGID_THINKING,   CLASS_SORCERER,  161);
  spell_level(SPELL_FLY,              CLASS_SORCERER,  165);
  spell_level(SPELL_POLTEIRGEIST,     CLASS_SORCERER,  169);
  spell_level(SPELL_GROUP_HEAL,       CLASS_SORCERER,  173);
//spell_level(SPELL_GROUP_INVISIBLE,  CLASS_SORCERER,  177); /* O grupo inteiro fica com a spell INVISIBLE. */
  spell_level(SPELL_GROUP_FLY,        CLASS_SORCERER,  180);
  spell_level(SPELL_ADRENALINE,       CLASS_SORCERER,  186);
//spell_level(SPELL_SHOOTING_STARS,   CLASS_SORCERER,  190); /* O player q utilizar essa magia invoca meteoros automaticos durante 1 tic. A cada 2 turnos um meteoro de dano igual a um MAGIC MISSILE cai automaticamente causando dano a todos as criaturas, fora o castador, da sala. */
  spell_level(SPELL_PARADI_CHRYSALIS, CLASS_SORCERER,  195);
  spell_level(SPELL_MANA_SHIELD,      CLASS_SORCERER,  196);
  spell_level(SPELL_ABUTILON,         CLASS_SORCERER,  197);
  spell_level(SPELL_PETRIFY,          CLASS_SORCERER,  198);

  /* WARLOCK */
  spell_level(SPELL_METEOR_SHOWER,    CLASS_WARLOCK,  1);
  spell_level(SKILL_VITALIZE_MANA,    CLASS_WARLOCK,  3);
  spell_level(SPELL_ACIDARROW,        CLASS_WARLOCK,  6);
  spell_level(SPELL_DETECT_INVIS,     CLASS_WARLOCK,  9);
  spell_level(SPELL_BLADEBARRIER,     CLASS_WARLOCK, 11);
  spell_level(SPELL_DETECT_POISON,    CLASS_WARLOCK, 16);
  spell_level(SPELL_FLAMEARROW,       CLASS_WARLOCK, 17);
  spell_level(SPELL_GREASE,           CLASS_WARLOCK, 23);
  spell_level(SPELL_DETECT_MAGIC,     CLASS_WARLOCK, 24);
  spell_level(SPELL_MAGIC_MISSILE,    CLASS_WARLOCK, 30);
  spell_level(SPELL_ARMOR,            CLASS_WARLOCK, 33);
  spell_level(SPELL_CROMATIC_ORB,     CLASS_WARLOCK, 37);
  spell_level(SPELL_LOCATE_OBJECT,    CLASS_WARLOCK, 43);
  spell_level(SPELL_CHILL_TOUCH,      CLASS_WARLOCK, 45);
  spell_level(SPELL_AREA_LIGHTNING,   CLASS_WARLOCK, 53);
  spell_level(SKILL_MEDITATE,         CLASS_WARLOCK, 54);
  spell_level(SPELL_BURNING_HANDS,    CLASS_WARLOCK, 62);
  spell_level(SPELL_CONTROL_WEATHER,  CLASS_WARLOCK, 66);
  spell_level(SPELL_ELETRICSTORM,     CLASS_WARLOCK, 71);
  spell_level(SKILL_LEVITATE,         CLASS_WARLOCK, 79);
  spell_level(SPELL_SHOCKING_GRASP,   CLASS_WARLOCK, 81);
  spell_level(SPELL_ICESTORM,         CLASS_WARLOCK, 91);
  spell_level(SPELL_SLOW,             CLASS_WARLOCK, 93);
  spell_level(SPELL_COLOR_SPRAY,      CLASS_WARLOCK, 102);
  spell_level(SKILL_SECOND_ATTACK,    CLASS_WARLOCK, 108);
  spell_level(SPELL_FIRESTORM,        CLASS_WARLOCK, 113);
  spell_level(SPELL_LIGHTNING_BOLT,   CLASS_WARLOCK, 125);
//spell_level(SPELL_OPEN_LOCK,        CLASS_WARLOCK, 133); /* Igual Pick Lock sem improved. */
  spell_level(SPELL_METEORSTORM,      CLASS_WARLOCK, 137);
  spell_level(SPELL_ENHANCED_ARMOR,   CLASS_WARLOCK, 141);
  spell_level(SPELL_GLACIAL_CONE,     CLASS_WARLOCK, 148);
  spell_level(SPELL_STRENGTH,         CLASS_WARLOCK, 157);
  spell_level(SPELL_BLIZZARD,         CLASS_WARLOCK, 159);
  spell_level(SPELL_CLONE,            CLASS_WARLOCK, 166);
  spell_level(SPELL_PRISMATIC_SPHERE, CLASS_WARLOCK, 169);
  spell_level(SPELL_FIREBALL,         CLASS_WARLOCK, 179);
  spell_level(SPELL_TELEPORT,         CLASS_WARLOCK, 186);
  spell_level(SPELL_DELAYED_FIREBALL, CLASS_WARLOCK, 197);
//spell_level(SPELL_FURY,             CLASS_WARLOCK, 198); /* Spell que dobra o numero de ataques do castador. Deve-se perder um pouco de MANA a cada ataque acrescentado que o player efetuar. */

/* PSIONICIST */
  spell_level(SPELL_CREATE_LIGHT,     CLASS_PSIONICIST,   1);
  spell_level(SPELL_THOUGHT_SHIELD,   CLASS_PSIONICIST,   3);
  spell_level(SKILL_VITALIZE_MANA,    CLASS_PSIONICIST,   5);
  spell_level(SPELL_AURA_SIGHT,       CLASS_PSIONICIST,   6);
  spell_level(SPELL_CLAIRVOYANCE,     CLASS_PSIONICIST,  10);
//spell_level(SPELL_DANGER_SENSE,     CLASS_PSIONICIST,  11); /* Pressentir durante 8 tics se ha DTs ao redor da sala. */
//spell_level(SPELL_ECTOPLASMIC_FORM, CLASS_PSIONICIST,  14); /* Transformacao em uma forma Ectoplasmica. A unica vantagem e o fato de se regenerar mais rapidamente. */
//spell_level(SPELL_POISON_SENSE,     CLASS_PSIONICIST,  15); /* Igual DETECT POISON. */
  spell_level(SPELL_CREATE_FLAMES,    CLASS_PSIONICIST,  17);
//spell_level(SPELL_LIFE_DETECTION,   CLASS_PSIONICIST,  18); /* Quando utilizado em uma criatura, mostra qto de HitPoints a criatura possui. */
  spell_level(SPELL_CLAIRAUDIENCE,    CLASS_PSIONICIST,  21);
//spell_level(SPELL_DIMENSIONAL_DOOR, CLASS_PSIONICIST,  23); /* Cria uma porta bidimensional que leva ao templo. A porta dura 1 tic, e deve gastar 10x mais MANA que um WORD OF RECALL. */
//spell_level(SPELL_VISIONS,          CLASS_PSIONICIST,  25); /* Faz com que o player que sofra essa spell tenha visoes durante 1 tic de coisas como? XXX is standing here, XXX has arrived, XXX goes to north, etc., onde XXX e o player q utilizou a magia. */
  spell_level(SPELL_ILLUSION,         CLASS_PSIONICIST,  28);
//spell_level(SPELL_SUMMON_PLANAR,    CLASS_PSIONICIST,  29); /* Igual a spell ELEMENTAL, mas nesse caso ele invoca uma PLANAR CREATURE. */
  spell_level(SPELL_WINGED_KNIFE,     CLASS_PSIONICIST,  33);
  spell_level(SPELL_BIOFEEDBACK,      CLASS_PSIONICIST,  34);
  spell_level(SPELL_PAIN,             CLASS_PSIONICIST,  48);
  spell_level(SPELL_ENHANCED_STRENGTH,CLASS_PSIONICIST,  45);
  spell_level(SPELL_EGO_WHIP,         CLASS_PSIONICIST,  49);
  spell_level(SPELL_FARSIGHT,         CLASS_PSIONICIST,  51);
  spell_level(SPELL_EMPATHY,          CLASS_PSIONICIST,  53);
  spell_level(SPELL_DISPLACEMENT,     CLASS_PSIONICIST,  55);
  spell_level(SPELL_INTEL_FORTRESS,   CLASS_PSIONICIST,  63);
  spell_level(SPELL_LIFE_DRAINING,    CLASS_PSIONICIST,  65);
  spell_level(SKILL_LEVITATE,         CLASS_PSIONICIST,  66);
  spell_level(SPELL_BODY_WEAPONRY,    CLASS_PSIONICIST,  74);
  spell_level(SKILL_MEDITATE,         CLASS_PSIONICIST,  75);
  spell_level(SPELL_BODY_EQUILIBRIUM, CLASS_PSIONICIST,  78);
  spell_level(SPELL_PROJECT_FORCE,    CLASS_PSIONICIST,  81);
//  spell_level(SPELL_ADREN_CONTROL,    CLASS_PSIONICIST,  85);
//spell_level(SPELL_CHAMELEON_POWER,  CLASS_PSIONICIST,  91); /* Spell que funciona igual a skill HIDE. */
//spell_level(SPELL_SHADOW_FORM,      CLASS_PSIONICIST,  96); /* Spell de transformacao. Faz com que o player nao gaste MOVE enquanto se locomove. */
  spell_level(SPELL_WRENCH,           CLASS_PSIONICIST,  97);
  spell_level(SKILL_SECOND_ATTACK,    CLASS_PSIONICIST,  105);
//  spell_level(SPELL_MENTAL BARRIER,   CLASS_PSIONICIST,  108);
  spell_level(SPELL_LEND_HEALTH,      CLASS_PSIONICIST,  113);
//spell_level(SPELL_INNER_SIGHT,      CLASS_PSIONICIST,  117); /* Magia que impede durante 3 tics que uma criatura fique HIDE ou INVISIBLE. */
//spell_level(SPELL_ILLUSIVE_DAGGER,  CLASS_PSIONICIST,  120); /* Spell igual MANA SWORD, mas nesse caso o player cria uma dagger ilusiva. */
  spell_level(SPELL_FEEL_LIGHT,       CLASS_PSIONICIST,  121);
  spell_level(SPELL_BALISTIC_ATTACK,  CLASS_PSIONICIST,  129);
  spell_level(SPELL_COMBAT_MIND,      CLASS_PSIONICIST,  135);
//spell_level(SPELL_BODY_CONTROL,     CLASS_PSIONICIST,  136); /* Faz com que o player nao sinta fome, sede ou bebado. Vale por 1 WAYBREAD, 2 goles de agua e 4 horas de recuperacao de bebedeira. */
  spell_level(SPELL_PSIONIC_BLAST,    CLASS_PSIONICIST,  141);
  spell_level(SPELL_PSYCHIC_DRAIN,    CLASS_PSIONICIST,  145);
  spell_level(SPELL_WRAITHFORM,       CLASS_PSIONICIST,  149);
  spell_level(SPELL_INERTIAL_BARRIER, CLASS_PSIONICIST,  150);
//spell_level(SPELL_PROBAB_TRAVEL,    CLASS_PSIONICIST,  153); /* Spell que funciona como a Skill TRACK. */
  spell_level(SPELL_SUP_INVISIBLE,    CLASS_PSIONICIST,  159);
  spell_level(SPELL_DETONATE,         CLASS_PSIONICIST,  161);
  spell_level(SPELL_AVERSION,         CLASS_PSIONICIST,  166);
//spell_level(SPELL_DAYDREAM,         CLASS_PSIONICIST,  171); /* O player que usar essa spell dorme por 8 horas com boa recuperacao sem ficar com sede ou com fome. */
  spell_level(SPELL_MENTAL_RAGE,      CLASS_PSIONICIST,  175);
  spell_level(SPELL_PSYCHIC_RAY,      CLASS_PSIONICIST,  177);
  spell_level(SPELL_CELL_ADJUSTMENT,  CLASS_PSIONICIST,  181);
  spell_level(SPELL_MARTIAL_TRANCE,   CLASS_PSIONICIST,  188);
  spell_level(SPELL_POST_HYPNOT_SUGG, CLASS_PSIONICIST,  190);
  spell_level(SPELL_MOLEC_AGITATION,  CLASS_PSIONICIST,  193);
  spell_level(SPELL_ASTRAL_PROJECTION,CLASS_PSIONICIST,  195);
//spell_level(SPELL_MIND_BLANK,       CLASS_PSIONICIST,  198); /* Faz com que a criatura ou player atingido por essa spell esqueca 70% de todas as skills e spells q ele conhecer por 1 tic. */
}

/* Function to return the exp required for each class/level */
int level_exp_norm(int level)
{
    switch (level) {
      case   0: return (0);
      case   1: return (3443);
      case   2: return (6593);
      case   3: return (11711);
      case   4: return (19061);
      case   5: return (28904);
      case   6: return (41504);
      case   7: return (57122);
      case   8: return (76022);
      case   9: return (98465);
      case  10: return (124715);
      case  11: return (155033);
      case  12: return (189683);
      case  13: return (228926);
      case  14: return (273026);
      case  15: return (322244);
      case  16: return (376844);
      case  17: return (437087);
      case  18: return (503237);
      case  19: return (575555);
      case  20: return (654305);
      case  21: return (739748);
      case  22: return (832148);
      case  23: return (931766);
      case  24: return (1038866);
      case  25: return (1153709);
      case  26: return (1276559);
      case  27: return (1407677);
      case  28: return (1547327);
      case  29: return (1695770);
      case  30: return (1853270);
      case  31: return (2020088);
      case  32: return (2196488);
      case  33: return (2382731);
      case  34: return (2579081);
      case  35: return (2785799);
      case  36: return (3003149);
      case  37: return (3231392);
      case  38: return (3470792);
      case  39: return (3721610);
      case  40: return (3984110);
      case  41: return (4258553);
      case  42: return (4545203);
      case  43: return (4844321);
      case  44: return (5156171);
      case  45: return (5481014);
      case  46: return (5819114);
      case  47: return (6170732);
      case  48: return (6536132);
      case  49: return (6915575);
      case  50: return (7309325);
      case  51: return (7717643);
      case  52: return (8140793);
      case  53: return (8579036);
      case  54: return (9032636);
      case  55: return (9501854);
      case  56: return (9986954);
      case  57: return (10488197);
      case  58: return (11005847);
      case  59: return (11540165);
      case  60: return (12091415);
      case  61: return (12659858);
      case  62: return (13245758);
      case  63: return (13849376);
      case  64: return (14470976);
      case  65: return (15110819);
      case  66: return (15769169);
      case  67: return (16446287);
      case  68: return (17142437);
      case  69: return (17857880);
      case  70: return (18592880);
      case  71: return (19347698);
      case  72: return (20122598);
      case  73: return (20917841);
      case  74: return (21733691);
      case  75: return (22570409);
      case  76: return (23428259);
      case  77: return (24307502);
      case  78: return (25208402);
      case  79: return (26131220);
      case  80: return (27076220);
      case  81: return (28043663);
      case  82: return (29033813);
      case  83: return (30046931);
      case  84: return (31083281);
      case  85: return (32143124);
      case  86: return (33226724);
      case  87: return (34334342);
      case  88: return (35466242);
      case  89: return (36622685);
      case  90: return (37803935);
      case  91: return (39010253);
      case  92: return (40241903);
      case  93: return (41499146);
      case  94: return (42782246);
      case  95: return (44091464);
      case  96: return (45427064);
      case  97: return (46789307);
      case  98: return (48178457);
      case  99: return (49594775);
      case 100: return (51038525);
      case 101: return (52509968);
      case 102: return (54009368);
      case 103: return (55536986);
      case 104: return (57093086);
      case 105: return (58677929);
      case 106: return (60291779);
      case 107: return (61934897);
      case 108: return (63607547);
      case 109: return (65309990);
      case 110: return (67042490);
      case 111: return (68805308);
      case 112: return (70598708);
      case 113: return (72422951);
      case 114: return (74278301);
      case 115: return (76165019);
      case 116: return (78083369);
      case 117: return (80033612);
      case 118: return (82016012);
      case 119: return (84030830);
      case 120: return (86078330);
      case 121: return (88158773);
      case 122: return (90272423);
      case 123: return (92419541);
      case 124: return (94600391);
      case 125: return (96815234);
      case 126: return (99064334);
      case 127: return (101347952);
      case 128: return (103666352);
      case 129: return (106019795);
      case 130: return (108408545);
      case 131: return (110832863);
      case 132: return (113293013);
      case 133: return (115789256);
      case 134: return (118321856);
      case 135: return (120891074);
      case 136: return (123497174);
      case 137: return (126140417);
      case 138: return (128821067);
      case 139: return (131539385);
      case 140: return (134295635);
      case 141: return (137090078);
      case 142: return (139922978);
      case 143: return (142794596);
      case 144: return (145705196);
      case 145: return (148655039);
      case 146: return (151644389);
      case 147: return (154673507);
      case 148: return (157742657);
      case 149: return (160852100);
      case 150: return (164002100);
      case 151: return (167192918);
      case 152: return (170424818);
      case 153: return (173698061);
      case 154: return (177012911);
      case 155: return (180369629);
      case 156: return (183768479);
      case 157: return (187209722);
      case 158: return (190693622);
      case 159: return (194220440);
      case 160: return (197790440);
      case 161: return (201403883);
      case 162: return (205061033);
      case 163: return (208762151);
      case 164: return (212507501);
      case 165: return (216297344);
      case 166: return (220131944);
      case 167: return (224011562);
      case 168: return (227936462);
      case 169: return (231906905);
      case 170: return (235923155);
      case 171: return (239985473);
      case 172: return (244094123);
      case 173: return (248249366);
      case 174: return (252451466);
      case 175: return (256700684);
      case 176: return (260997284);
      case 177: return (265341527);
      case 178: return (269733677);
      case 179: return (274173995);
      case 180: return (278662745);
      case 181: return (283200188);
      case 182: return (287786588);
      case 183: return (292422206);
      case 184: return (297107306);
      case 185: return (301842149);
      case 186: return (306626999);
      case 187: return (311462117);
      case 188: return (316347767);
      case 189: return (321284210);
      case 190: return (326271710);
      case 191: return (331310528);
      case 192: return (336400928);
      case 193: return (341543171);
      case 194: return (346737521);
      case 195: return (351984239);
      case 196: return (357283589);
      case 197: return (362635832);
      case 198: return (368041232);
      case 199: return (373500050);
      case 200: return (379012550);
      case LVL_IMMORT: return (904526713);
    }

  log("SYSERR: XP tables not set up correctly in class.c!");
  return (0);
}

int level_exp(int remort, int level)
{
  int factor, exp;

  if (level > LVL_IMMORT || level < 0) {
    return (0);
  }

  factor = (15 - remort);

  if(remort == 0)
    exp = level_exp_norm(level);
  else
    exp = (level_exp_norm(level) + ((level_exp_norm(level)/factor)*3));

  return (exp);

}

/*
 * Default titles of male characters.
 */
const char *title_male(int chclass, int level)
{
  if (level <= 0 || level > LVL_IMPL)
    return "the Man";
  if (level == LVL_IMPL)
    return "the Owner Implementor";

  switch (chclass) {

    case CLASS_MAGIC_USER:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Sorcerer";
    }
    break;

    case CLASS_NECROMANCER:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Necromancer";
    }
    break;

    case CLASS_PALADIN:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Paladin";
    }
    break;

    case CLASS_NINJA:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Ninja";
    }
    break;

    case CLASS_CLERIC:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Cleric";
    }
    break;

    case CLASS_THIEF:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Thief";
    }
    break;

    case CLASS_WARRIOR:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Warrior";
    }
    break;

    case CLASS_RANGER:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Ranger";
    }
    break;

    case CLASS_PSIONICIST:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Psionicist";
    }
    break;

    case CLASS_WARLOCK:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Warlock";
    }
    break;

    case CLASS_BARBARIAN:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Barbarian";
    }
    break;

    case CLASS_SORCERER:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Shaman";
    }
    break;
  }

  /* Default title for classes which do not have titles defined */
  return "the Classless";
}


/*
 * Default titles of female characters.
 */
const char *title_female(int chclass, int level)
{
  if (level <= 0 || level > LVL_IMPL)
    return "the Woman";
  if (level == LVL_IMPL)
    return "the Owner Implementress";

  switch (chclass) {

    case CLASS_MAGIC_USER:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Sorceress";
    }
    break;

    case CLASS_CLERIC:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Cleric";
    }
    break;

    case CLASS_NECROMANCER:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Necromanceress";
    }
    break;

    case CLASS_PALADIN:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Paladin";
    }
    break;

    case CLASS_NINJA:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Ninja";
    }
    break;

    case CLASS_THIEF:
    switch (level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Thief";
    }
    break;

    case CLASS_WARRIOR:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Warrior";
    }
    break;

    case CLASS_RANGER:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Ranger";
    }
    break;

    case CLASS_PSIONICIST:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Psionicist";
    }
    break;

    case CLASS_WARLOCK:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Warlock";
    }
    break;

    case CLASS_BARBARIAN:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Barbarian";
    }
    break;

    case CLASS_SORCERER:
    switch(level) {
      case LVL_IMMORT: return "the Immortal";
      case LVL_ELDER:
      case LVL_LORD:
      case LVL_DEMIGOD:
      case LVL_GOD:
      case LVL_GRGOD:
      case LVL_SUPGOD:
      case LVL_MJGOD:
      case LVL_SUBIMPL:
        return "the member of the WarDome Staff";
      default: return "the Shaman";
    }
    break;
  }

  /* Default title for classes which do not have titles defined */
  return "the Classless";
}
::::::::::::::
comm.c
::::::::::::::
/*************************************************************************
*   File: comm.c                                        Part of CircleMUD *
*  Usage: Communication, socket handling, main(), central game loop       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __COMM_C__

#include "conf.h"
#include "sysdep.h"

#ifdef CIRCLE_MACINTOSH         /* Includes for the Macintosh */
# define SIGPIPE 13
# define SIGALRM 14
  /* GUSI headers */
# include <sys/ioctl.h>
  /* Codewarrior dependant */
# include <SIOUX.h>
# include <console.h>
#endif

#ifdef CIRCLE_WINDOWS           /* Includes for Win32 */
# ifdef __BORLANDC__
#  include <dir.h>
# else /* MSVC */
#  include <direct.h>
# endif
# include <mmsystem.h>
#endif /* CIRCLE_WINDOWS */

#ifdef CIRCLE_AMIGA             /* Includes for the Amiga */
# include <sys/ioctl.h>
# include <clib/socket_protos.h>
#endif /* CIRCLE_AMIGA */

#ifdef CIRCLE_ACORN             /* Includes for the Acorn (RiscOS) */
# include <socklib.h>
# include <inetlib.h>
# include <sys/ioctl.h>
#endif

/*
 * Note, most includes for all platforms are in sysdep.h.  The list of
 * files that is included is controlled by conf.h for that platform.
 */

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "house.h"
#include "olc.h"
#include "screen.h"
#include "dg_scripts.h"
#include "teleport.h"

#ifdef HAVE_ARPA_TELNET_H
#include <arpa/telnet.h>
#else
#include "telnet.h"
#endif

#ifndef INVALID_SOCKET
#define INVALID_SOCKET -1
#endif

/* externs */
extern struct ban_list_element *ban_list;
extern int num_invalid;
extern char *GREETINGS;
extern const char circlemud_version[];
extern int circle_restrict;
extern int mini_mud;
extern int no_rent_check;
extern ush_int DFLT_PORT;
extern char *DFLT_DIR;
extern char *DFLT_IP;
extern char *LOGNAME;
extern int MAX_PLAYERS;
extern int buffer_opt;
extern struct zone_data *zone_table;
extern const char *save_info_msg[];   /* In olc.c */
extern int top_of_zone_table;
extern struct room_data *world; /* In db.c */
extern int top_of_world;        /* In db.c */
extern struct time_info_data time_info;         /* In db.c */
extern char *help;
extern struct zone_data *zone_table;
extern char *npc_class_abbrevs[];
extern char *class_abbrevs[];

/* local globals */
struct descriptor_data *descriptor_list = NULL;         /* master desc list */
extern struct char_data *character_list;
struct txt_block *bufpool = 0;	/* pool of large output buffers */
int buf_largecount = 0;         /* # of large buffers which exist */
int buf_overflows = 0;          /* # of overflows of output */
int buf_switches = 0;           /* # of switches from small to large buf */
int circle_shutdown = 0;        /* clean shutdown */
int circle_reboot = 0;          /* reboot the game after a shutdown */
int no_specials = 0;            /* Suppress ass. of special routines */
int max_players = 0;            /* max descriptors available */
int tics = 0;                   /* for extern checkpointing */
int scheck = 0;                 /* for syntax checking mode */
int dg_act_check;               /* toggle for act_trigger */
unsigned long dg_global_pulse = 0; /* number of pulses since game start */
extern int nameserver_is_slow;  /* see config.c */
extern int auto_save;           /* see config.c */
extern int autosave_time;       /* see config.c */
struct timeval null_time;       /* zero-valued time structure */
FILE *logfile = NULL;           /* Where to send the log messages. */
extern int multi_player;	/* max players per host */
static bool fCopyOver;          /* Are we booting in copyover mode? */
int  mother_desc;        /* Now a global */
int     port;


/* functions in this file */
RETSIGTYPE reread_wizlists(int sig);
RETSIGTYPE unrestrict_game(int sig);
RETSIGTYPE reap(int sig);
RETSIGTYPE checkpointing(int sig);
RETSIGTYPE hupsig(int sig);
ssize_t perform_socket_read(socket_t desc, char *read_point,size_t space_left);
ssize_t perform_socket_write(socket_t desc, const char *txt,size_t length);
void echo_off(struct descriptor_data *d);
void echo_on(struct descriptor_data *d);
void sanity_check(void);
void circle_sleep(struct timeval *timeout);
int get_from_q(struct txt_q *queue, char *dest, int *aliased);
void init_game(int port);
void signal_setup(void);
void game_loop(int mother_desc);
socket_t init_socket(ush_int port);
int new_descriptor(socket_t s);
int get_max_players(void);
int process_output(struct descriptor_data *t);
int process_input(struct descriptor_data *t);
void timediff(struct timeval *diff, struct timeval *a, struct timeval *b);
void timeadd(struct timeval *sum, struct timeval *a, struct timeval *b);
void flush_queues(struct descriptor_data *d);
void nonblock(socket_t s);
int perform_subst(struct descriptor_data *t, char *orig, char *subst);
int perform_alias(struct descriptor_data *d, char *orig);
void record_usage(void);
char *make_prompt(struct descriptor_data *point);
void check_idle_passwords(void);
void heartbeat(int pulse);
void make_who2html(void);
struct in_addr *get_bind_addr(void);
int parse_ip(const char *addr, struct in_addr *inaddr);
int set_sendbuf(socket_t s);
#if defined(POSIX)
sigfunc *my_signal(int signo, sigfunc * func);
#endif
void    init_descriptor (struct descriptor_data *newd, int desc);

/* extern fcnts */
void reboot_wizlists(void);
void boot_world(void);
void affect_update(void);       /* In spells.c */
void mobile_activity(void);
void string_add(struct descriptor_data *d, char *str);
void perform_violence(void);
void show_string(struct descriptor_data *d, char *input);
int isbanned(char *hostname);
void weather_and_time(int mode);
void redit_save_to_disk(int zone_num);
void oedit_save_to_disk(int zone_num);
void medit_save_to_disk(int zone_num);
void sedit_save_to_disk(int zone_num);
void zedit_save_to_disk(int zone_num);
void qedit_save_to_disk(int zone_num);
int real_zone(int number);
char *make_bar(int val, int max, int len, int cores);
void mental_update(void);
void hmm_update(void);
void gods_update(void);
void update_breath(void);
void write_mud_date_to_file(void);
void dragon_upd(void); /* in winddrago.c */
int level_exp(int remort, int level);

#ifdef __CXREF__
#undef FD_ZERO
#undef FD_SET
#undef FD_ISSET
#undef FD_CLR
#define FD_ZERO(x)
#define FD_SET(x, y) 0
#define FD_ISSET(x, y) 0
#define FD_CLR(x, y)
#endif


/***********************************************************************
*  main game loop and related stuff                                    *
***********************************************************************/

#if defined(CIRCLE_WINDOWS) || defined(CIRCLE_MACINTOSH)

/* Windows doesn't have gettimeofday, so we'll simulate it. */
/* The Mac doesn't have gettimeofday either. */
void gettimeofday(struct timeval *t, struct timezone *dummy)
{
#if defined(CIRCLE_WINDOWS)
  DWORD millisec = GetTickCount();
#elif defined(CIRCLE_MACINTOSH)
  unsigned long int millisec;
  millisec = (int)((float)TickCount() * 1000.0 / 60.0);
#endif

  t->tv_sec = (int) (millisec / 1000);
  t->tv_usec = (millisec % 1000) * 1000;
}

#endif  /* CIRCLE_WINDOWS || CIRCLE_MACINTOSH */

int main(int argc, char **argv)
{
  int pos = 1;
  char *dir;

//  leak_logging = 0;

  /* Initialize these to check for overruns later. */
  buf[MAX_STRING_LENGTH - 1] = buf1[MAX_STRING_LENGTH - 1] = MAGIC_NUMBER;
  buf2[MAX_STRING_LENGTH - 1] = arg[MAX_STRING_LENGTH - 1] = MAGIC_NUMBER;

#ifdef CIRCLE_MACINTOSH
  /*
   * ccommand() calls the command line/io redirection dialog box from
   * Codewarriors's SIOUX library
   */
  argc = ccommand(&argv);
  /* Initialize the GUSI library calls.  */
  GUSIDefaultSetup();
#endif


  port = DFLT_PORT;
  dir = DFLT_DIR;

  /*
   * It would be nice to make this a command line option but the parser uses
   * the log() function, maybe later. -gg
   */
  if (LOGNAME == NULL || *LOGNAME == '\0')
    logfile = fdopen(STDERR_FILENO, "w");
  else
    logfile = freopen(LOGNAME, "w", stderr);

  if (logfile == NULL) {
      printf("error opening log file %s: %s\n",
                LOGNAME ? LOGNAME : "stderr", strerror(errno));
      exit(1);
  }

  /* Start up the better buffer system. */
 /* init_buffers(); */

  log(circlemud_version);

  while ((pos < argc) && (*(argv[pos]) == '-')) {
    switch (*(argv[pos] + 1)) {
    case 'C': /* -C<socket number> - recover from copyover, this is the control socket */
	fCopyOver = TRUE;
	mother_desc = atoi(argv[pos]+2);
	break;
    case 'v':
      if (*(argv[pos] + 2))
	buffer_opt = atoi(argv[pos] + 2);
      else if (++pos < argc)
	buffer_opt = atoi(argv[pos]);
      else {
	log("SYSERR: Number expected after option -v.");
	exit(1);
      }
      break;
    case 'd':
      if (*(argv[pos] + 2))
        dir = argv[pos] + 2;
      else if (++pos < argc)
        dir = argv[pos];
      else {
        log("SYSERR: Directory arg expected after option -d.");
        exit(1);
      }
      break;
    case 'm':
      mini_mud = 1;
      no_rent_check = 1;
      log("Running in minimized mode & with no rent check.");
      break;
    case 'c':
      scheck = 1;
      log("Syntax check mode enabled.");
      break;
    case 'q':
      no_rent_check = 1;
      log("Quick boot mode -- rent check supressed.");
      break;
    case 'r':
      circle_restrict = 1;
      log("Restricting game -- no new players allowed.");
      break;
    case 's':
      no_specials = 1;
      log("Suppressing assignment of special routines.");
      break;
    default:
      log("SYSERR: Unknown option -%c in argument string.", *(argv[pos] + 1));
      break;
    }
    pos++;
  }

  if (pos < argc) {
    if (!isdigit(*argv[pos])) {
      log("Usage: %s [-c] [-m] [-q] [-r] [-s] [-d pathname] [-v val] [port #]\n", argv[0]);
      exit(1);
    } else if ((port = atoi(argv[pos])) <= 1024) {
      log("SYSERR: Illegal port number %d.", port);
      exit(1);
    }
  }

  if (chdir(dir) < 0) {
    perror("SYSERR: Fatal error changing to data directory");
    exit(1);
  }
  log("Using %s as data directory.", dir);

  if (scheck) {
    boot_world();
    log("Done.");
  } else {
    log("Running game on port %d.", port);
    init_game(port);
  }
 /* exit_buffers();*/

  return 0;
}

int enter_player_game(struct descriptor_data *d);

/* Reload players after a copyover */
void copyover_recover()
{
	struct descriptor_data *d;
	FILE *fp;
	char host[1024];
	int desc, player_i;
   	bool fOld;
    	char name[MAX_INPUT_LENGTH];

	log ("Copyover recovery initiated");

	fp = fopen (COPYOVER_FILE, "r");

	if (!fp) /* there are some descriptors open which will hang forever then ? */
	{
		perror ("copyover_recover:fopen");
		log ("Copyover file not found. Exitting.\n\r");
		exit (1);
	}

	unlink (COPYOVER_FILE); /* In case something crashes - doesn't prevent reading	*/

	for (;;)
    {
        fOld = TRUE;
		fscanf (fp, "%d %s %s\n", &desc, name, host);
		if (desc == -1)
			break;

		/* Write something, and check if it goes error-free */
		if (write_to_descriptor (desc, "\n\rUpdate initiated...\n\r") < 0)
		{
			close (desc); /* nope */
			continue;
		}

        /* create a new descriptor */
        CREATE (d, struct descriptor_data, 1);
       /* memset ((char *) d, 0, sizeof (struct descriptor_data));*/
		init_descriptor (d,desc); /* set up various stuff */
        CREATE(d->history, char *, HISTORY_SIZE);
		strcpy(d->host, host);
		d->next = descriptor_list;
		descriptor_list = d;

        d->connected = CON_CLOSE;

		/* Now, find the pfile */

        CREATE(d->character, struct char_data, 1);
        clear_char(d->character);
        CREATE(d->character->player_specials, struct player_special_data, 1);
        d->character->desc = d;

        if ((player_i = load_char(name, d->character)) >= 0)
        {
            GET_PFILEPOS(d->character) = player_i;
            if (!PLR_FLAGGED(d->character, PLR_DELETED))
                REMOVE_BIT(PLR_FLAGS(d->character),PLR_WRITING | PLR_MAILING | PLR_CRYO);
            else
                fOld = FALSE;
        }
        else
            fOld = FALSE;

		if (!fOld) /* Player file not found?! */
		{
			write_to_descriptor (desc, "\n\rSomehow, your character was lost during the folding. Sorry.\n\r");
			close_socket (d);
		}
		else /* ok! */
		{
            write_to_descriptor (desc, "\n\rUpdate complete.\n\r");
            enter_player_game(d);
            d->connected = CON_PLAYING;
            look_at_room(d->character, 0);
		}

	}

	fclose (fp);
}

/* Init sockets, run game, and cleanup sockets */
void init_game(int port)
{
  /* We don't want to restart if we crash before we get up. */
  touch(KILLSCRIPT_FILE);

  circle_srandom(time(0));

  log("Finding player limit.");
  max_players = get_max_players();

  if (!fCopyOver) /* If copyover mother_desc is already set up */
  {
	log ("Opening mother connection.");
	mother_desc = init_socket (port);
  }

  boot_db();

#ifdef CIRCLE_UNIX
  log("Signal trapping.");
  signal_setup();
#endif

  if (fCopyOver) /* reload players */
	copyover_recover();

  /* If we made it this far, we will be able to restart without problem. */
  remove(KILLSCRIPT_FILE);

  log("Entering game loop.");

  game_loop(mother_desc);

  Crash_save_all();

  log("Closing all sockets.");
  while (descriptor_list)
    close_socket(descriptor_list);

  CLOSE_SOCKET(mother_desc);

  if (circle_reboot != 2 && olc_save_list) { /* Don't save zones. */
    struct olc_save_info *entry, *next_entry;
    int rznum;

    for (entry = olc_save_list; entry; entry = next_entry) {
      next_entry = entry->next;
      if (entry->type < 0 || entry->type > 5) {
        sprintf(buf, "OLC: Illegal save type %d!", entry->type);
        log(buf);
      } else if ((rznum = real_zone(entry->zone * 100)) == -1) {
        sprintf(buf, "OLC: Illegal save zone %d!", entry->zone);
        log(buf);
      } else if (rznum < 0 || rznum > top_of_zone_table) {
        sprintf(buf, "OLC: Invalid real zone number %d!", rznum);
        log(buf);
      } else {
        sprintf(buf, "OLC: Reboot saving %s for zone %d.",
                save_info_msg[(int)entry->type], zone_table[rznum].number);
        log(buf);
        switch (entry->type) {
        case OLC_SAVE_ROOM: redit_save_to_disk(rznum); break;
        case OLC_SAVE_OBJ:  oedit_save_to_disk(rznum); break;
        case OLC_SAVE_MOB:  medit_save_to_disk(rznum); break;
        case OLC_SAVE_ZONE: zedit_save_to_disk(rznum); break;
        case OLC_SAVE_SHOP: sedit_save_to_disk(rznum); break;
        case OLC_SAVE_QUEST:  qedit_save_to_disk(rznum); break;
        default:      log("Unexpected olc_save_list->type"); break;
        }
      }
    }
  }

  if (circle_reboot) {
    log("Rebooting.");
    exit(52);                   /* what's so great about HHGTTG, anyhow? */
  }
   log("Normal termination of game.");
}



/*
 * init_socket sets up the mother descriptor - creates the socket, sets
 * its options up, binds it, and listens.
 */
socket_t init_socket(ush_int port)
{
  socket_t s;
  struct sockaddr_in sa;
  int opt;

#ifdef CIRCLE_WINDOWS
  {
    WORD wVersionRequested;
    WSADATA wsaData;

    wVersionRequested = MAKEWORD(1, 1);

    if (WSAStartup(wVersionRequested, &wsaData) != 0) {
      log("SYSERR: WinSock not available!");
      exit(1);
    }
    if ((wsaData.iMaxSockets - 4) < max_players) {
      max_players = wsaData.iMaxSockets - 4;
    }
    log("Max players set to %d", max_players);

    if ((s = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) {
      log("SYSERR: Error opening network connection: Winsock error #%d",
          WSAGetLastError());
      exit(1);
    }
  }
#else
  /*
   * Should the first argument to socket() be AF_INET or PF_INET?  I don't
   * know, take your pick.  PF_INET seems to be more widely adopted, and
   * Comer (_Internetworking with TCP/IP_) even makes a point to say that
   * people erroneously use AF_INET with socket() when they should be using
   * PF_INET.  However, the man pages of some systems indicate that AF_INET
   * is correct; some such as ConvexOS even say that you can use either one.
   * All implementations I've seen define AF_INET and PF_INET to be the same
   * number anyway, so the point is (hopefully) moot.
   */

  if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
    perror("SYSERR: Error creating socket");
    exit(1);
  }
#endif                          /* CIRCLE_WINDOWS */

#if defined(SO_REUSEADDR) && !defined(CIRCLE_MACINTOSH)
  opt = 1;
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt)) < 0){
    perror("SYSERR: setsockopt REUSEADDR");
    exit(1);
  }
#endif

  set_sendbuf(s);

#if defined(SO_LINGER) && !defined(CIRCLE_MACINTOSH)
  {
    struct linger ld;

    ld.l_onoff = 0;
    ld.l_linger = 0;
    if (setsockopt(s, SOL_SOCKET, SO_LINGER, (char *) &ld, sizeof(ld)) < 0) {
      perror("SYSERR: setsockopt LINGER");
      exit(1);
    }
  }
#endif

  /* Clear the structure */
  memset((char *)&sa, 0, sizeof(sa));

  sa.sin_family = AF_INET;
  sa.sin_port = htons(port);
  sa.sin_addr = *(get_bind_addr());

  if (bind(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
    perror("SYSERR: bind");
    CLOSE_SOCKET(s);
    exit(1);
  }
  nonblock(s);
  listen(s, 5);
  return (s);
}


int get_max_players(void)
{
#ifndef CIRCLE_UNIX
  return (MAX_PLAYERS);
#else

  int max_descs = 0;
  const char *method;

/*
 * First, we'll try using getrlimit/setrlimit.  This will probably work
 * on most systems.  HAS_RLIMIT is defined in sysdep.h.
 */
#ifdef HAS_RLIMIT
  {
    struct rlimit limit;

    /* find the limit of file descs */
    method = "rlimit";
    if (getrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("SYSERR: calling getrlimit");
      exit(1);
    }

    /* set the current to the maximum */
    limit.rlim_cur = limit.rlim_max;
    if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
      perror("SYSERR: calling setrlimit");
      exit(1);
    }
#ifdef RLIM_INFINITY
    if (limit.rlim_max == RLIM_INFINITY)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else
      max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
#else
    max_descs = MIN(MAX_PLAYERS + NUM_RESERVED_DESCS, limit.rlim_max);
#endif
  }

#elif defined (OPEN_MAX) || defined(FOPEN_MAX)
#if !defined(OPEN_MAX)
#define OPEN_MAX FOPEN_MAX
#endif
  method = "OPEN_MAX";
  max_descs = OPEN_MAX;         /* Uh oh.. rlimit didn't work, but we have
                                 * OPEN_MAX */
#elif defined (_SC_OPEN_MAX)
  /*
   * Okay, you don't have getrlimit() and you don't have OPEN_MAX.  Time to
   * try the POSIX sysconf() function.  (See Stevens' _Advanced Programming
   * in the UNIX Environment_).
   */
  method = "POSIX sysconf";
  errno = 0;
  if ((max_descs = sysconf(_SC_OPEN_MAX)) < 0) {
    if (errno == 0)
      max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
    else {
      perror("SYSERR: Error calling sysconf");
      exit(1);
    }
  }
#else
  /* if everything has failed, we'll just take a guess */
  method = "random guess"
  max_descs = MAX_PLAYERS + NUM_RESERVED_DESCS;
#endif

  /* now calculate max _players_ based on max descs */
  max_descs = MIN(MAX_PLAYERS, max_descs - NUM_RESERVED_DESCS);

  if (max_descs <= 0) {
    log("SYSERR: Non-positive max player limit!  (Set at %d using %s).",
            max_descs, method);
    exit(1);
  }
  log("Setting player limit to %d using %s.", max_descs, method);
  return (max_descs);
#endif /* CIRCLE_UNIX */
}



/*
 * game_loop contains the main loop which drives the entire MUD.  It
 * cycles once every 0.10 seconds and is responsible for accepting new
 * new connections, polling existing connections for input, dequeueing
 * output and sending it out to players, and calling "heartbeat" functions
 * such as mobile_activity().
 */
void game_loop(socket_t mother_desc)
{
  fd_set input_set, output_set, exc_set, null_set;
  struct timeval last_time, before_sleep, opt_time, process_time, now, timeout, temp_time;
  char comm[MAX_INPUT_LENGTH];
  struct descriptor_data *d, *next_d;
  int pulse = 0, missed_pulses, maxdesc, aliased;

  /* initialize various time values */
  null_time.tv_sec = 0;
  null_time.tv_usec = 0;
  opt_time.tv_usec = OPT_USEC;
  opt_time.tv_sec = 0;
  FD_ZERO(&null_set);

  gettimeofday(&last_time, (struct timezone *) 0);

  /* The Main Loop.  The Big Cheese.  The Top Dog.  The Head Honcho.  The.. */
  while (!circle_shutdown) {

    /* Sleep if we don't have any connections */
    if (descriptor_list == NULL) {
      log("No connections.  Going to sleep.");
//      make_who2html();
      /*exit(2); - for bootup profiling*/
      FD_ZERO(&input_set);
      FD_SET(mother_desc, &input_set);
      if (select(mother_desc + 1, &input_set, (fd_set *) 0, (fd_set *) 0, NULL) < 0) {
        if (errno == EINTR)
          log("Waking up to process signal.");
        else
          perror("SYSERR: Select coma");
      } else
        log("New connection.  Waking up.");
      gettimeofday(&last_time, (struct timezone *) 0);
    }
    /* Set up the input, output, and exception sets for select(). */
    FD_ZERO(&input_set);
    FD_ZERO(&output_set);
    FD_ZERO(&exc_set);
    FD_SET(mother_desc, &input_set);

    maxdesc = mother_desc;
    for (d = descriptor_list; d; d = d->next) {
#ifndef CIRCLE_WINDOWS
      if (d->descriptor > maxdesc)
        maxdesc = d->descriptor;
#endif
      FD_SET(d->descriptor, &input_set);
      FD_SET(d->descriptor, &output_set);
      FD_SET(d->descriptor, &exc_set);
    }

    /*
     * At this point, we have completed all input, output and heartbeat
     * activity from the previous iteration, so we have to put ourselves
     * to sleep until the next 0.1 second tick.  The first step is to
     * calculate how long we took processing the previous iteration.
     */

    gettimeofday(&before_sleep, (struct timezone *) 0); /* current time */
    timediff(&process_time, &before_sleep, &last_time);

    /*
     * If we were asleep for more than one pass, count missed pulses and sleep
     * until we're resynchronized with the next upcoming pulse.
     */
    if (process_time.tv_sec == 0 && process_time.tv_usec < OPT_USEC) {
      missed_pulses = 0;
    } else {
      missed_pulses = process_time.tv_sec * PASSES_PER_SEC;
      missed_pulses += process_time.tv_usec / OPT_USEC;
      process_time.tv_sec = 0;
      process_time.tv_usec = process_time.tv_usec % OPT_USEC;
    }

    /* Calculate the time we should wake up */
    timediff(&temp_time, &opt_time, &process_time);
    timeadd(&last_time, &before_sleep, &temp_time);

    /* Now keep sleeping until that time has come */
    gettimeofday(&now, (struct timezone *) 0);
    timediff(&timeout, &last_time, &now);

    /* Go to sleep */
    do {
      circle_sleep(&timeout);
      gettimeofday(&now, (struct timezone *) 0);
      timediff(&timeout, &last_time, &now);
    } while (timeout.tv_usec || timeout.tv_sec);

    /* Poll (without blocking) for new input, output, and exceptions */
    if (select(maxdesc + 1, &input_set, &output_set, &exc_set, &null_time) < 0) {
      perror("SYSERR: Select poll");
      return;
    }
    /* If there are new connections waiting, accept them. */
    if (FD_ISSET(mother_desc, &input_set))
      new_descriptor(mother_desc);

    /* Kick out the freaky folks in the exception set and marked for close */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &exc_set)) {
        FD_CLR(d->descriptor, &input_set);
        FD_CLR(d->descriptor, &output_set);
        close_socket(d);
      }
    }

    /* Process descriptors with input pending */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (FD_ISSET(d->descriptor, &input_set))
        if (process_input(d) < 0)
          close_socket(d);
    }

    /* Process commands we just read from process_input */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;

      /* Not combined to retain --(d->wait) behavior. -gg 2/20/98 */
       if (d->character) {
        GET_WAIT_STATE(d) -= (GET_WAIT_STATE(d) > 0);

        if (GET_WAIT_STATE(d))
          continue;
      }

      if (!get_from_q(&d->input, comm, &aliased))
        continue;

      if (d->character) {
        /* Reset the idle timer & pull char back from void if necessary */
        d->character->char_specials.timer = 0;
        if (STATE(d) == CON_PLAYING && GET_WAS_IN(d->character) != NOWHERE) {
          if (d->character->in_room != NOWHERE)
            char_from_room(d->character);
          char_to_room(d->character, GET_WAS_IN(d->character));
          GET_WAS_IN(d->character) = NOWHERE;
          act("$n has returned.", TRUE, d->character, 0, 0, TO_ROOM);
        }
        GET_WAIT_STATE(d) = 1;
      }
      d->has_prompt = 0;

      if (d->str)		/* Writing boards, mail, etc. */
	string_add(d, comm);
      else if (d->showstr_count) /* Reading something w/ pager */
	show_string(d, comm);
      else if (STATE(d) != CON_PLAYING) /* In menus, etc. */
	nanny(d, comm);
      else {			/* else: we're playing normally. */
	if (aliased)		/* To prevent recursive aliases. */
	  d->has_prompt = 1;	/* To get newline before next cmd output. */
	else if (perform_alias(d, comm))    /* Run it through aliasing system */
	  get_from_q(&d->input, comm, &aliased);
	command_interpreter(d->character, comm); /* Send it to interpreter */
      }
    }

    /* Send queued output out to the operating system (ultimately to user) */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if ((d->output) && (d->descriptor))
      {
        if (*(d->output) && FD_ISSET(d->descriptor, &output_set)) {
          /* Output for this player is ready */
          if (process_output(d) < 0)
            close_socket(d);
          else
            d->has_prompt = 1;
        }
  	  }
      else{
         /*
          * if we were using a large buffer, put the large buffer on the buffer pool
          * and switch back to the small one
         */
         if (d->large_outbuf) {
           d->large_outbuf->next = bufpool;
           bufpool = d->large_outbuf;
           d->large_outbuf = NULL;
           d->output = d->small_outbuf;
         }
         /* reset total bufspace back to that of a small buffer */
         d->bufspace = SMALL_BUFSIZE - 1;
         d->bufptr = 0;
         *(d->output) = '\0';
      }
    }

    /* Print prompts for other descriptors who had no other output */
    for (d = descriptor_list; d; d = d->next) {
      if (!d->has_prompt) {
        write_to_descriptor(d->descriptor, make_prompt(d));
        d->has_prompt = 1;
      }
    }

    /* Kick out folks in the CON_CLOSE or CON_DISCONNECT state */
    for (d = descriptor_list; d; d = next_d) {
      next_d = d->next;
      if (STATE(d) == CON_CLOSE || STATE(d) == CON_DISCONNECT)
        close_socket(d);
    }

    /*
     * Now, we execute as many pulses as necessary--just one if we haven't
     * missed any pulses, or make up for lost time if we missed a few
     * pulses by sleeping for too long.
     */
    missed_pulses++;

    if (missed_pulses <= 0) {
      log("SYSERR: **BAD** MISSED_PULSES NONPOSITIVE (%d), TIME GOING BACKWARDS!!", missed_pulses);
      missed_pulses = 1;
    }

    /* If we missed more than 30 seconds worth of pulses, just do 30 secs */
    if (missed_pulses > (30 * PASSES_PER_SEC)) {
      log("SYSERR: Missed %d seconds worth of pulses.", missed_pulses / PASSES_PER_SEC);
      missed_pulses = 30 * PASSES_PER_SEC;
    }

    /* Now execute the heartbeat functions */
    while (missed_pulses--)
      heartbeat(++pulse);

    /* Roll pulse over after 10 hours */
    if (pulse >= (600 * 60 * PASSES_PER_SEC))
      pulse = 0;

#ifdef CIRCLE_UNIX
    /* Update tics for deadlock protection (UNIX only) */
    tics++;
    write_mud_date_to_file();
#endif
  }
}

void save_all_chars(void)
{
  struct char_data *i, *next_char;
  void write_aliases(struct char_data *ch);

  for (i = character_list; i; i = next_char)
  {
    next_char = i->next;
    if(!i)
    	return;
    if(IS_NPC(i))
    	return;
    if(LIBERDADE(i) > 0)
    	LIBERDADE(i)--;
    save_char(i, i->in_room);
    write_aliases(i);
  }
}

void heartbeat(int pulse)
{
  static int mins_since_crashsave = 0;
  void auction_update();
  void process_events(void);
  void process_program_output(void);

  process_program_output();

  /* Clear out all the global buffers now in case someone forgot. */
 /* if (!(pulse % PULSE_BUFFER))
    release_all_buffers();*/

  dg_global_pulse++;

  process_events();

  if (!(pulse % PULSE_DG_SCRIPT))
    script_trigger_check();

  if (teleport_on && !(pulse % PULSE_TELEPORT))
    TeleportPulseStuff();

  if (!(pulse % (30 * PASSES_PER_SEC)))
    sanity_check();

  if (!(pulse % PULSE_ZONE))
    zone_update();

  if (!(pulse % (15 * PASSES_PER_SEC)))         /* 15 seconds */
    check_idle_passwords();

  if (!(pulse % (60 * PASSES_PER_SEC)))
    auction_update();

  if (!(pulse % PULSE_MOBILE))
    mobile_activity();

  if (!(pulse % PULSE_VIOLENCE))
    perform_violence();

  if (!(pulse % (5 * PASSES_PER_SEC)))       /* 5 seconds */
    update_breath();

  if (!(pulse % (10 * PASSES_PER_SEC)))       /* 10 seconds */
    mental_update();

  if (!(pulse % (15 * PASSES_PER_SEC)))       /* 15 seconds */
    hmm_update();

  if (!(pulse % (60 * PASSES_PER_SEC)))       /* 60 seconds */
    gods_update();


/*  if (!(pulse % (20 * PASSES_PER_SEC)))
    make_who2html();
*/
  /* Do Arena related stuff */
  if (in_arena == ARENA_START)
    if(!(pulse % PULSE_ARENA))
        start_arena();
  if (in_arena == ARENA_RUNNING)
    if(!(pulse % PULSE_ARENA))
        do_game();

  if (!(pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC))) {
    weather_and_time(1);
    affect_update();
    point_update();
  }

  if (!(pulse % (8 * PASSES_PER_SEC)))
         dragon_upd();

  if (auto_save && !(pulse % (60 * PASSES_PER_SEC))) {  /* 1 minute */
    if (++mins_since_crashsave >= autosave_time) {
      mins_since_crashsave = 0;
      save_all_chars();
      Crash_save_all();
      House_save_all();
    }
  }
  if (!(pulse % (5 * 60 * PASSES_PER_SEC)))     /* 5 minutes */
    record_usage();


}


/* ******************************************************************
*  general utility stuff (for local use)                            *
****************************************************************** */

/*
 *  new code to calculate time differences, which works on systems
 *  for which tv_usec is unsigned (and thus comparisons for something
 *  being < 0 fail).  Based on code submitted by ss@sirocco.cup.hp.com.
 */

/*
 * code to return the time difference between a and b (a-b).
 * always returns a nonnegative value (floors at 0).
 */
void timediff(struct timeval *rslt, struct timeval *a, struct timeval *b)
{
  if (a->tv_sec < b->tv_sec)
    *rslt = null_time;
  else if (a->tv_sec == b->tv_sec) {
    if (a->tv_usec < b->tv_usec)
      *rslt = null_time;
    else {
      rslt->tv_sec = 0;
      rslt->tv_usec = a->tv_usec - b->tv_usec;
    }
  } else {			/* a->tv_sec > b->tv_sec */
    rslt->tv_sec = a->tv_sec - b->tv_sec;
    if (a->tv_usec < b->tv_usec) {
      rslt->tv_usec = a->tv_usec + 1000000 - b->tv_usec;
      rslt->tv_sec--;
    } else
      rslt->tv_usec = a->tv_usec - b->tv_usec;
  }
}

/*
 * Add 2 time values.
 *
 * Patch sent by "d. hall" <dhall@OOI.NET> to fix 'static' usage.
 */
void timeadd(struct timeval *rslt, struct timeval *a, struct timeval *b)
{
  rslt->tv_sec = a->tv_sec + b->tv_sec;
  rslt->tv_usec = a->tv_usec + b->tv_usec;

  while (rslt->tv_usec >= 1000000) {
    rslt->tv_usec -= 1000000;
    rslt->tv_sec++;
  }
}


void record_usage(void)
{
  int sockets_connected = 0, sockets_playing = 0;
  struct descriptor_data *d;

  for (d = descriptor_list; d; d = d->next) {
    sockets_connected++;
    if (STATE(d) == CON_PLAYING)
      sockets_playing++;
  }

  log("nusage: %-3d sockets connected, %-3d sockets playing",
          sockets_connected, sockets_playing);

#ifdef RUSAGE
  {
    struct rusage ru;

    getrusage(RUSAGE_SELF, &ru);
    log("rusage: user time: %ld sec, system time: %ld sec, max res size: %ld",
            ru.ru_utime.tv_sec, ru.ru_stime.tv_sec, ru.ru_maxrss);
  }
#endif

}



/*
 * Turn off echoing (specific to telnet client)
 */
void echo_off(struct descriptor_data *d)
{
  char off_string[] =
  {
    (char) IAC,
    (char) WILL,
    (char) TELOPT_ECHO,
    (char) 0,
  };

  SEND_TO_Q(off_string, d);
}


/*
 * Turn on echoing (specific to telnet client)
 */
void echo_on(struct descriptor_data *d)
{
  char on_string[] =
  {
    (char) IAC,
    (char) WONT,
    (char) TELOPT_ECHO,
    (char) TELOPT_NAOFFD,
    (char) TELOPT_NAOCRD,
    (char) 0,
  };

  SEND_TO_Q(on_string, d);
}

char *make_prompt(struct descriptor_data *d)
{
  static char prompt[MAX_PROMPT_LENGTH + 1];

  /* Note, prompt is truncated at MAX_PROMPT_LENGTH chars (structs.h )*/

  if (d->showstr_count)
    sprintf(prompt,
            "%s<<< Press ENTER (%d%s) or 'H' for help >>>%s ",
            KNRM, (100-((d->showstr_page*100)/d->showstr_count)),"%", KNRM);
  else if (d->str)
    strcpy(prompt, "] ");
  else if (STATE(d) == CON_PLAYING && !IS_NPC(d->character)) {
    *prompt = '\0';

   if(PRF_FLAGGED(d->character, PRF_INFO_START))
      sprintf(prompt, "%sDigite/Type [INFO]%s ", CCBYEL(d->character, C_NRM), KNRM);
   else if(PRF_FLAGGED(d->character, PRF_AFK))
      sprintf(prompt, "%s[AFK]%s ", CCBRED(d->character, C_NRM), KNRM);
   else if(PLR_FLAGGED(d->character, PLR_DEAD))
      sprintf(prompt, "%s[YOU ARE DEAD]%s ", CCBRED(d->character, C_NRM), KNRM);
   else {
    if (GET_INVIS_LEV(d->character))
      sprintf(prompt, "%si%d ",
        CCCYN(d->character, C_NRM), GET_INVIS_LEV(d->character));

    if (PRF2_FLAGGED(d->character, PRF2_DISPEXP))
      sprintf(prompt + strlen(prompt), "%s[%s%s%s] ", CCCYN(d->character, C_NRM),
        (GET_HIT(d->character) == GET_MAX_HIT(d->character) ? CCBWHT(d->character, C_NRM) :
          (GET_EXP(d->character) < level_exp(GET_REMORT(d->character), GET_LEVEL(d->character) + 1)*0.9 ? CCBWHT(d->character, C_NRM) : CCBCYN(d->character, C_NRM))),
        convert_num(level_exp(GET_REMORT(d->character), GET_LEVEL(d->character) + 1)-GET_EXP(d->character)), CCCYN(d->character, C_NRM));

    if (PRF_FLAGGED(d->character, PRF_DISPHP))
      sprintf(prompt + strlen(prompt), "%s[%s%s%s]%sHp", CCWHT(d->character, C_NRM),
        (GET_HIT(d->character) == GET_MAX_HIT(d->character) ? CCBWHT(d->character, C_NRM) :
          (GET_HIT(d->character) > GET_MAX_HIT(d->character) / 10 ? CCBWHT(d->character, C_NRM) : CCBRED(d->character, C_NRM))),
        add_points(GET_HIT(d->character)), CCWHT(d->character, C_NRM), CCBBLU(d->character, C_NRM));

    if (PRF_FLAGGED(d->character, PRF_DISPMANA))
      sprintf(prompt + strlen(prompt), "%s[%s%s%s]%sMn", CCWHT(d->character, C_NRM),
        (GET_MANA(d->character) == GET_MAX_MANA(d->character) ? CCBWHT(d->character, C_NRM) :
          (GET_MANA(d->character) > GET_MAX_MANA(d->character) / 10 ? CCBWHT(d->character, C_NRM) : CCBRED(d->character, C_NRM))),
        add_points(GET_MANA(d->character)), CCWHT(d->character, C_NRM), CCBBLU(d->character, C_NRM));

    if (PRF_FLAGGED(d->character, PRF_DISPMENT))
      sprintf(prompt + strlen(prompt), "%s[%s%s%s]%sMp", CCWHT(d->character, C_NRM),
        (GET_MENTAL(d->character) == GET_MAX_MENTAL(d->character) ? CCBWHT(d->character, C_NRM) :
          (GET_MENTAL(d->character) > GET_MAX_MENTAL(d->character) / 10 ? CCBWHT(d->character, C_NRM) : CCBRED(d->character, C_NRM))),
        add_points(GET_MENTAL(d->character)), CCWHT(d->character, C_NRM), CCBBLU(d->character, C_NRM));

    if (PRF_FLAGGED(d->character, PRF_DISPMOVE))
      sprintf(prompt + strlen(prompt), "%s[%s%s%s]%sMv", CCWHT(d->character, C_NRM),
        (GET_MOVE(d->character) == GET_MAX_MOVE(d->character) ? CCBWHT(d->character, C_NRM) :
          (GET_MOVE(d->character) > GET_MAX_MOVE(d->character) / 10 ? CCBWHT(d->character, C_NRM) : CCBRED(d->character, C_NRM))),
        add_points(GET_MOVE(d->character)), CCWHT(d->character, C_NRM), CCBBLU(d->character, C_NRM));
   }

   if(!PLR_FLAGGED(d->character, PLR_DEAD) && GET_OXI(d->character) < 100 && GET_LEVEL(d->character) < LVL_IMMORT && !PRF_FLAGGED(d->character, PRF_INFO_START))
      sprintf(prompt + strlen(prompt), "%s[%s%d%s]%s%sOx", CCWHT(d->character, C_NRM),
        (GET_OXI(d->character) == GET_MAX_OXI(d->character) ? CCBWHT(d->character, C_NRM) :
          (GET_OXI(d->character) > GET_MAX_OXI(d->character) / 10 ? CCBWHT(d->character, C_NRM) : CCBRED(d->character, C_NRM))),
        GET_OXI(d->character), CCWHT(d->character, C_NRM), "%", CCBBLU(d->character, C_NRM));

   if(!PLR_FLAGGED(d->character, PLR_DEAD) && FIGHTING(d->character))
	sprintf(prompt + strlen(prompt), " %s%s%s", CCBWHT(d->character, C_NRM), make_bar(GET_HIT(FIGHTING(d->character)), GET_MAX_HIT(FIGHTING(d->character)), 10, (clr(d->character, C_CMP) ? TRUE : FALSE)), KNRM);

    sprintf(prompt + strlen(prompt), "%s>%s ", CCBBLU(d->character, C_NRM), KNRM);
  } else if (STATE(d) == CON_PLAYING && IS_NPC(d->character))
    sprintf(prompt, "%s> ", GET_NAME(d->character));
  else
    *prompt = '\0';

 return (prompt);

}

void write_to_q(const char *txt, struct txt_q *queue, int aliased)
{
  struct txt_block *newt;

  CREATE(newt, struct txt_block, 1);
  newt->text = str_dup(txt);
  newt->aliased = aliased;

  /* queue empty? */
  if (!queue->head) {
    newt->next = NULL;
    queue->head = queue->tail = newt;
  } else {
    queue->tail->next = newt;
    queue->tail = newt;
    newt->next = NULL;
  }
}



int get_from_q(struct txt_q *queue, char *dest, int *aliased)
{
  struct txt_block *tmp;

  /* queue empty? */
  if (!queue->head)
    return (0);

  tmp = queue->head;
  strcpy(dest, queue->head->text);
  *aliased = queue->head->aliased;
  queue->head = queue->head->next;

  free(tmp->text);
  free(tmp);

  return (1);
}



/* Empty the queues before closing connection */
void flush_queues(struct descriptor_data *d)
{
  int dummy;

  if (d->large_outbuf) {
    d->large_outbuf->next = bufpool;
    bufpool = d->large_outbuf;
  }
  while (get_from_q(&d->input, buf2, &dummy));
}

#define MAX_CORES		15

#define LETRA				0
#define CODIGOCOR			1

char *letra_cor[] =
{
	"n",
	"r",
	"g",
	"y",
	"b",
	"m",
	"c",
	"w",
	"R",
	"G",
	"Y",
	"B",
	"M",
	"C",
	"W",
};

const char *codigo_cor[] =
{
	KNRM,
	KRED,
	KGRN,
	KYEL,
	KBLU,
	KMAG,
	KCYN,
	KWHT,
	KBRED,
	KBGRN,
	KBYEL,
	KBBLU,
	KBMAG,
	KBCYN,
	KBWHT,
};

int conta_cores(const char *texto)
{
	short int cores;
	int pos, numero = 0;

	for(pos = 0; texto[pos]; pos++)
		if(texto[pos] == '&')
		{
			for(cores = 0; cores < MAX_CORES; cores++)
				if(texto[pos+1] == *letra_cor[cores])
					numero++;
		}

	return (numero);
}

char *colorir_cor(char *onde, const char *oque)
{
	short int cores;

	for(cores = 0; oque[cores]; cores++)
		*(onde++) = oque[cores];
	return (onde);
}

short int que_cor(char letra)
{
	short kor;

	for(kor = 0; kor < MAX_CORES; kor++)
		if(letra == *letra_cor[kor])
			return (kor);
	return (-1);
}

char *cores(const char *txt, struct descriptor_data *t)
{
	char *com_cor, *corbkp;
	short int pos, cor;
	int qtd, num_cores;

	num_cores = conta_cores(txt);

	if(!num_cores)
	{
		com_cor = strdup(txt);
		return (com_cor);
	}

	qtd = strlen(txt) + (num_cores * 5) + 1;

	corbkp = com_cor = malloc(qtd);

	for(pos = 0; txt[pos] != '\0'; pos++)
	{
		if(txt[pos] == '&' && txt[pos+1])
		{
			if((cor = que_cor(txt[pos+1])) != -1)
			{
					if(clr(t->character, C_CMP))
						corbkp = colorir_cor(corbkp, codigo_cor[cor]);
					pos++;
					continue;
			}
		}
		*(corbkp++) = txt[pos];
	}
	*corbkp = '\0';

	return (com_cor);
}

void write_to_output(const char *txt, struct descriptor_data *t)
{
  int size;
  char *new_txt;

  /* if we're in the overflow state already, ignore this new output */
  if (t->bufptr < 0)
    return;

  new_txt = cores(txt, t);

  size = strlen(new_txt);

  /* if we have enough space, just write to buffer and that's it! */
  if (t->bufspace >= size) {
    strcpy(t->output + t->bufptr, new_txt);
    t->bufspace -= size;
    t->bufptr += size;
    free(new_txt);
    return;
  }
  /*
   * If we're already using the large buffer, or if even the large buffer
   * is too small to handle this new text, chuck the text and switch to the
   * overflow state.
   */
   if ((size + t->bufptr) > (LARGE_BUFSIZE - 1)) {
    t->bufptr = -1;
    buf_overflows++;
    free(new_txt);
    return;
  }
  buf_switches++;

  /* if the pool has a buffer in it, grab it */
  if (bufpool != NULL) {
    t->large_outbuf = bufpool;
    bufpool = bufpool->next;
  } else {
    /* else create a new one */
   // leak_logging = 0;
    CREATE(t->large_outbuf, struct txt_block, 1);
    CREATE(t->large_outbuf->text, char, LARGE_BUFSIZE);
   // leak_logging = 1;
    buf_largecount++;
  }

  strcpy(t->large_outbuf->text, t->output);	/* copy to big buffer */
  t->output = t->large_outbuf->text;	/* make big buffer primary */
  strcat(t->output, new_txt);	/* now add new text */

  /* set the pointer for the next write */
  t->bufptr = strlen(t->output);

  /* calculate how much space is left in the buffer */
  t->bufspace = LARGE_BUFSIZE - 1 - t->bufptr;

  free(new_txt);

}

/* ******************************************************************
*  socket handling                                                  *
****************************************************************** */


/*
 * get_bind_addr: Return a struct in_addr that should be used in our
 * call to bind().  If the user has specified a desired binding
 * address, we try to bind to it; otherwise, we bind to INADDR_ANY.
 * Note that inet_aton() is preferred over inet_addr() so we use it if
 * we can.  If neither is available, we always bind to INADDR_ANY.
 */
struct in_addr *get_bind_addr()
{
  static struct in_addr bind_addr;

  /* Clear the structure */
  memset((char *) &bind_addr, 0, sizeof(bind_addr));

  /* If DLFT_IP is unspecified, use INADDR_ANY */
  if (DFLT_IP == NULL) {
    bind_addr.s_addr = htonl(INADDR_ANY);
  } else {
    /* If the parsing fails, use INADDR_ANY */
    if (!parse_ip(DFLT_IP, &bind_addr)) {
      log("SYSERR: DFLT_IP of %s appears to be an invalid IP address",DFLT_IP);
      bind_addr.s_addr = htonl(INADDR_ANY);
    }
  }

  /* Put the address that we've finally decided on into the logs */
  if (bind_addr.s_addr == htonl(INADDR_ANY))
    log("Binding to all IP interfaces on this host.");
  else
    log("Binding only to IP address %s", inet_ntoa(bind_addr));

  return (&bind_addr);
}

#ifdef HAVE_INET_ATON

/*
 * inet_aton's interface is the same as parse_ip's: 0 on failure, non-0 if
 * successful
 */
int parse_ip(const char *addr, struct in_addr *inaddr)
{
  return (inet_aton(addr, inaddr));
}

#elif HAVE_INET_ADDR

/* inet_addr has a different interface, so we emulate inet_aton's */
int parse_ip(const char *addr, struct in_addr *inaddr)
{
  long ip;

  if ((ip = inet_addr(addr)) == -1) {
    return (0);
  } else {
    inaddr->s_addr = (unsigned long) ip;
    return (1);
  }
}

#else

/* If you have neither function - sorry, you can't do specific binding. */
int parse_ip(const char *addr, struct in_addr *inaddr)
{
  log("SYSERR: warning: you're trying to set DFLT_IP but your system has no\n"
      "functions to parse IP addresses (how bizarre!)");
  return (0);
}

#endif /* INET_ATON and INET_ADDR */



/* Sets the kernel's send buffer size for the descriptor */
int set_sendbuf(socket_t s)
{
#if defined(SO_SNDBUF) && !defined(CIRCLE_MACINTOSH)
  int opt = MAX_SOCK_BUF;

  if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &opt, sizeof(opt)) < 0) {
    perror("SYSERR: setsockopt SNDBUF");
    return (-1);
  }

#if 0
  if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *) &opt, sizeof(opt)) < 0) {
    perror("SYSERR: setsockopt RCVBUF");
    return (-1);
  }
#endif

#endif

  return (0);
}

/* Initialize a descriptor */
void init_descriptor (struct descriptor_data *newd, int desc)
{
    static int last_desc = 0;	/* last descriptor number */


	newd->descriptor = desc;
	newd->idle_tics = 0;
	newd->wait = 1;
	newd->output = newd->small_outbuf;
	newd->bufspace = SMALL_BUFSIZE - 1;
	newd->login_time = time(0);
	*newd->output = '\0';
	newd->bufptr = 0;
	newd->has_prompt = 1;
	STATE(newd) = CON_GET_NAME;

	if (++last_desc == 1000)
		last_desc = 1;
	newd->desc_num = last_desc;
}

int new_descriptor(int s) {
  socket_t desc;
  int sockets_connected = 0;
  int i/*, connections = 0*/;
  struct descriptor_data *newd/*, *k, *next_k*/;
  struct sockaddr_in peer;
  struct hostent *from;

  /* accept the new connection */
  i = sizeof(peer);
  if ((desc = accept(s, (struct sockaddr *) &peer, &i)) == INVALID_SOCKET) {
    perror("SYSERR: accept");
    return (-1);
  }
  /* keep it from blocking */
  nonblock(desc);

  /* set the send buffer size */
  if (set_sendbuf(desc) < 0) {
    CLOSE_SOCKET(desc);
    return (0);
  }

  /* make sure we have room for it */
  for (newd = descriptor_list; newd; newd = newd->next)
    sockets_connected++;

  if (sockets_connected >= max_players) {
    write_to_descriptor(desc, "Sorry, CircleMUD is full right now... please try again later!\r\n");
    CLOSE_SOCKET(desc);
    return (0);
  }

  /* create a new descriptor */
  CREATE(newd, struct descriptor_data, 1);
 /* memset((char *) newd, 0, sizeof(struct descriptor_data));*/

  /* find the sitename */
  if (nameserver_is_slow || !(from = gethostbyaddr((char *) &peer.sin_addr,
                                      sizeof(peer.sin_addr), AF_INET))) {

    /* resolution failed */
    if (!nameserver_is_slow)
      perror("SYSERR: gethostbyaddr");

    /* find the numeric site address */
    strncpy(newd->host, (char *)inet_ntoa(peer.sin_addr), HOST_LENGTH);
    *(newd->host + HOST_LENGTH) = '\0';
  } else {
    strncpy(newd->host, from->h_name, HOST_LENGTH);
    *(newd->host + HOST_LENGTH) = '\0';
  }

  /* determine if the site is banned */
  if (isbanned(newd->host) == BAN_ALL) {
    CLOSE_SOCKET(desc);
    sprintf(buf2, "Connection attempt denied from [%s]", newd->host);
    mudlog(buf2, CMP, LVL_GOD, TRUE);
    free(newd);
    return (0);
  }

#if 0
  /* Log new connections - probably unnecessary, but you may want it */
  sprintf(buf2, "New connection from [%s]", newd->host);
  mudlog(buf2, CMP, LVL_GOD, FALSE);
#endif
/*

  newd->descriptor = desc;
  newd->connected = CON_GET_NAME;
  newd->idle_tics = 0;
  newd->wait = 1;
  newd->output = newd->small_outbuf;
  newd->bufspace = SMALL_BUFSIZE - 1;
  newd->login_time = time(0);
  *newd->output = '\0';
  newd->bufptr = 0;
  newd->has_prompt = 1;
*/
  init_descriptor(newd, desc);

  /*
   * This isn't exactly optimal but allows us to make a design choice.
   * Do we embed the history in descriptor_data or keep it dynamically
   * allocated and allow a user defined history size?
   */
  CREATE(newd->history, char *, HISTORY_SIZE);

  /* prepend to list */
  newd->next = descriptor_list;
  descriptor_list = newd;

  write_to_descriptor(desc, GREETINGS);

  return (0);
}


/*
 * Send all of the output that we've accumulated for a player out to
 * the player's descriptor.
 * FIXME - This will be rewritten before 3.1, this code is dumb.
 */
int process_output(struct descriptor_data *t)
{
  int result;
  char i[MAX_SOCK_BUF];

  /* we may need this \r\n for later -- see below */
  strcpy(i, "\r\n");

  /* now, append the 'real' output */
  strcpy(i + 2, t->output);

  /* if we're in the overflow state, notify the user */
  if (t->bufptr < 0)
    strcat(i, "**OVERFLOW**\r\n");

  /* add the extra CRLF if the person isn't in compact mode */
  if (STATE(t) == CON_PLAYING && t->character && !IS_NPC(t->character) && !PRF_FLAGGED(t->character, PRF_COMPACT))
    strcat(i + 2, "\r\n");

  /* add a prompt */
  strncat(i + 2, make_prompt(t), MAX_PROMPT_LENGTH);

  strcat(i, "\0");

  /*
   * now, send the output.  If this is an 'interruption', use the prepended
   * CRLF, otherwise send the straight output sans CRLF.
   */
  if (t->has_prompt)            /* && !t->connected) */
    result = write_to_descriptor(t->descriptor, i);
  else
    result = write_to_descriptor(t->descriptor, (i + 2));

  /* handle snooping: prepend "% " and send to snooper */
  if (t->snoop_by) {
    SEND_TO_Q("% ", t->snoop_by);
    SEND_TO_Q(t->output, t->snoop_by);
    SEND_TO_Q("%%", t->snoop_by);
  }
  /*
   * if we were using a large buffer, put the large buffer on the buffer pool
   * and switch back to the small one
   */
  if (t->large_outbuf) {
     t->large_outbuf->next = bufpool;
     bufpool = t->large_outbuf;
     t->large_outbuf = NULL;
     t->output = t->small_outbuf;
  }
  /* reset total bufspace back to that of a small buffer */
  t->bufspace = SMALL_BUFSIZE - 1;
  t->bufptr = 0;
  *(t->output) = '\0';

  return (result);
}


/*
 * perform_socket_write: takes a descriptor, a pointer to text, and a
 * text length, and tries once to send that text to the OS.  This is
 * where we stuff all the platform-dependent stuff that used to be
 * ugly #ifdef's in write_to_descriptor().
 *
 * This function must return:
 *
 * -1  If a fatal error was encountered in writing to the descriptor.
 *  0  If a transient failure was encountered (e.g. socket buffer full).
 * >0  To indicate the number of bytes successfully written, possibly
 *     fewer than the number the caller requested be written.
 *
 * Right now there are two versions of this function: one for Windows,
 * and one for all other platforms.
 */

#if defined(CIRCLE_WINDOWS)

ssize_t perform_socket_write(socket_t desc, const char *txt, size_t length)
{
  ssize_t result;

  result = send(desc, txt, length, 0);

  if (result > 0) {
    /* Write was sucessful */
    return (result);
  }

  if (result == 0) {
    /* This should never happen! */
    log("SYSERR: Huh??  write() returned 0???  Please report this!");
    return (-1);
  }

  /* result < 0: An error was encountered. */

  /* Transient error? */
  if (WSAGetLastError() == WSAEWOULDBLOCK || WSAGetLastError() == WSAEINTR)
    return (0);

  /* Must be a fatal error. */
  return (-1);
}

#else

#if defined(CIRCLE_ACORN)
#define write   socketwrite
#endif

/* perform_socket_write for all Non-Windows platforms */
ssize_t perform_socket_write(socket_t desc, const char *txt, size_t length)
{
  ssize_t result;

  result = write(desc, txt, length);

  if (result > 0) {
    /* Write was successful. */
    return (result);
  }

  if (result == 0) {
    /* This should never happen! */
    log("SYSERR: Huh??  write() returned 0???  Please report this!");
    return (-1);
  }

  /*
   * result < 0, so an error was encountered - is it transient?
   * Unfortunately, different systems use different constants to
   * indicate this.
   */

#ifdef EAGAIN           /* POSIX */
  if (errno == EAGAIN)
    return (0);
#endif

#ifdef EWOULDBLOCK      /* BSD */
  if (errno == EWOULDBLOCK)
    return (0);
#endif

#ifdef EDEADLK          /* Macintosh */
  if (errno == EDEADLK)
    return (0);
#endif

  /* Looks like the error was fatal.  Too bad. */
  return (-1);
}

#endif /* CIRCLE_WINDOWS */


/*
 * write_to_descriptor takes a descriptor, and text to write to the
 * descriptor.  It keeps calling the system-level write() until all
 * the text has been delivered to the OS, or until an error is
 * encountered.
 *
 * Returns:
 *  0  If all is well and good,
 * -1  If an error was encountered, so that the player should be cut off
 */
int write_to_descriptor(socket_t desc, const char *txt)
{
  size_t total;
  ssize_t bytes_written;

  total = strlen(txt);

  if (total > MAX_SOCK_BUF)
   total = MAX_SOCK_BUF;

  while (total > 0) {
    bytes_written = perform_socket_write(desc, txt, total);

    if (bytes_written < 0) {
      /* Fatal error.  Disconnect the player. */
      perror("SYSERR: Write to socket");
      return (-1);
    } else if (bytes_written == 0) {
      /*
       * Temporary failure -- socket buffer full.  For now we'll just
       * cut off the player, but eventually we'll stuff the unsent
       * text into a buffer and retry the write later.  JE 30 June 98.
       */
      log("WARNING: write_to_descriptor: socket write would block, about to close");
      return (-1);
    } else {
      txt += bytes_written;
      total -= bytes_written;
    }
  }

  return (0);
}


/*
 * Same information about perform_socket_write applies here. I like
 * standards, there are so many of them. -gg 6/30/98
 */
ssize_t perform_socket_read(socket_t desc, char *read_point, size_t space_left)
{
  ssize_t ret;

#if defined(CIRCLE_ACORN)
  ret = recv(desc, read_point, space_left, MSG_DONTWAIT);
#elif defined(CIRCLE_WINDOWS)
  ret = recv(desc, read_point, space_left, 0);
#else
  ret = read(desc, read_point, space_left);
#endif

  /* Read was successful. */
  if (ret > 0)
    return (ret);

  /* read() returned 0, meaning we got an EOF. */
  if (ret == 0) {
    log("WARNING: EOF on socket read (connection broken by peer)");
    return (-1);
  }

  /*
   * read returned a value < 0: there was an error
   */

#if defined(CIRCLE_WINDOWS)     /* Windows */
  if (WSAGetLastError() == WSAEWOULDBLOCK || WSAGetLastError() == WSAEINTR)
    return (0);
#else

#ifdef EINTR            /* Interrupted system call - various platforms */
  if (errno == EINTR)
    return (0);
#endif

#ifdef EAGAIN           /* POSIX */
  if (errno == EAGAIN)
    return (0);
#endif

#ifdef EWOULDBLOCK      /* BSD */
  if (errno == EWOULDBLOCK)
    return (0);
#endif /* EWOULDBLOCK */

#ifdef EDEADLK          /* Macintosh */
  if (errno == EDEADLK)
    return (0);
#endif

#ifdef ECONNRESET
  if (errno == ECONNRESET)
    return (-1);
#endif

#endif /* CIRCLE_WINDOWS */

  /* We don't know what happened, cut them off. */
  perror("SYSERR: perform_socket_read: about to lose connection");
  return (-1);
}

int process_input(struct descriptor_data *t)
{
  int buf_length, failed_subst;
  ssize_t bytes_read;
  size_t space_left;
  char *ptr, *read_point, *write_point, *nl_pos = NULL;
  char tmp[MAX_INPUT_LENGTH];

  /* first, find the point where we left off reading data */
  buf_length = strlen(t->inbuf);
  read_point = t->inbuf + buf_length;
  space_left = MAX_RAW_INPUT_LENGTH - buf_length - 1;

  do {
    if (space_left <= 0) {
      log("WARNING: process_input: about to close connection: input overflow");
      return (-1);
    }

    bytes_read = perform_socket_read(t->descriptor, read_point, space_left);

    if (bytes_read < 0) /* Error, disconnect them. */
      return (-1);
    else if (bytes_read == 0)   /* Just blocking, no problems. */
      return (0);

    /* at this point, we know we got some data from the read */

    *(read_point + bytes_read) = '\0';  /* terminate the string */

    /* search for a newline in the data we just read */
    for (ptr = read_point; *ptr && !nl_pos; ptr++)
      if (ISNEWL(*ptr))
        nl_pos = ptr;

    read_point += bytes_read;
    space_left -= bytes_read;

/*
 * on some systems such as AIX, POSIX-standard nonblocking I/O is broken,
 * causing the MUD to hang when it encounters input not terminated by a
 * newline.  This was causing hangs at the Password: prompt, for example.
 * I attempt to compensate by always returning after the _first_ read, instead
 * of looping forever until a read returns -1.  This simulates non-blocking
 * I/O because the result is we never call read unless we know from select()
 * that data is ready (process_input is only called if select indicates that
 * this descriptor is in the read set).  JE 2/23/95.
 */
#if !defined(POSIX_NONBLOCK_BROKEN)
  } while (nl_pos == NULL);
#else
  } while (0);

  if (nl_pos == NULL)
    return (0);
#endif /* POSIX_NONBLOCK_BROKEN */

  /*
   * okay, at this point we have at least one newline in the string; now we
   * can copy the formatted data to a new array for further processing.
   */

  read_point = t->inbuf;

  while (nl_pos != NULL) {
    write_point = tmp;
    space_left = MAX_INPUT_LENGTH - 1;

    for (ptr = read_point; (space_left > 1) && (ptr < nl_pos); ptr++) {
      if (*ptr == '\b' || *ptr == 127) { /* handle backspacing or delete key */
        if (write_point > tmp) {
          if (*(--write_point) == '$') {
            write_point--;
            space_left += 2;
          } else
            space_left++;
        }
      } else if (isascii(*ptr) && isprint(*ptr)) {
        if ((*(write_point++) = *ptr) == '$') {         /* copy one character */
          *(write_point++) = '$';       /* if it's a $, double it */
          space_left -= 2;
        } else
          space_left--;
      }
    }

    *write_point = '\0';

    if ((space_left <= 0) && (ptr < nl_pos)) {
      char buffer[MAX_INPUT_LENGTH + 64];

      sprintf(buffer, "Line too long.  Truncated to:\r\n%s\r\n", tmp);
      if (write_to_descriptor(t->descriptor, buffer) < 0)
        return (-1);
    }
    if (t->snoop_by) {
      SEND_TO_Q("% ", t->snoop_by);
      SEND_TO_Q(tmp, t->snoop_by);
      SEND_TO_Q("\r\n", t->snoop_by);
    }
    failed_subst = 0;

    if (*tmp == '!' && !(*(tmp + 1)))   /* Redo last command. */
      strcpy(tmp, t->last_input);
    else if (*tmp == '!' && *(tmp + 1)) {
      char *commandln = (tmp + 1);
      int starting_pos = t->history_pos,
          cnt = (t->history_pos == 0 ? HISTORY_SIZE - 1 : t->history_pos - 1);

      skip_spaces(&commandln);
      for (; cnt != starting_pos; cnt--) {
        if (t->history[cnt] && is_abbrev(commandln, t->history[cnt])) {
          strcpy(tmp, t->history[cnt]);
          strcpy(t->last_input, tmp);
          SEND_TO_Q(tmp, t); SEND_TO_Q("\r\n", t);
          break;
        }
        if (cnt == 0)   /* At top, loop to bottom. */
          cnt = HISTORY_SIZE;
      }
    } else if (*tmp == '^') {
      if (!(failed_subst = perform_subst(t, t->last_input, tmp)))
        strcpy(t->last_input, tmp);
    } else {
      strcpy(t->last_input, tmp);
      if (t->history[t->history_pos])
        /*free(t->history[t->history_pos]);*/       /* Clear the old line. */
      t->history[t->history_pos] = str_dup(tmp);        /* Save the new. */
      if (++t->history_pos >= HISTORY_SIZE)     /* Wrap to top. */
        t->history_pos = 0;
    }

    if (!failed_subst)
      write_to_q(tmp, &t->input, 0);

    /* find the end of this line */
    while (ISNEWL(*nl_pos))
      nl_pos++;

    /* see if there's another newline in the input buffer */
    read_point = ptr = nl_pos;
    for (nl_pos = NULL; *ptr && !nl_pos; ptr++)
      if (ISNEWL(*ptr))
        nl_pos = ptr;
  }

  /* now move the rest of the buffer up to the beginning for the next pass */
  write_point = t->inbuf;
  while (*read_point)
    *(write_point++) = *(read_point++);
  *write_point = '\0';

  return (1);
}


/* perform substitution for the '^..^' csh-esque syntax orig is the
 * orig string, i.e. the one being modified.  subst contains the
 * substition string, i.e. "^telm^tell"
 */
int perform_subst(struct descriptor_data *t, char *orig, char *subst)
{
  char newsub[MAX_INPUT_LENGTH + 5];

  char *first, *second, *strpos;

  /*
   * first is the position of the beginning of the first string (the one
   * to be replaced
   */
  first = subst + 1;

  /* now find the second '^' */
  if (!(second = strchr(first, '^'))) {
    SEND_TO_Q("Invalid substitution.\r\n", t);
    return (1);
  }
  /* terminate "first" at the position of the '^' and make 'second' point
   * to the beginning of the second string */
  *(second++) = '\0';

  /* now, see if the contents of the first string appear in the original */
  if (!(strpos = strstr(orig, first))) {
    SEND_TO_Q("Invalid substitution.\r\n", t);
    return (1);
  }
  /* now, we construct the new string for output. */

  /* first, everything in the original, up to the string to be replaced */
  strncpy(newsub, orig, (strpos - orig));
  newsub[(strpos - orig)] = '\0';

  /* now, the replacement string */
  strncat(newsub, second, (MAX_INPUT_LENGTH - strlen(newsub) - 1));

  /* now, if there's anything left in the original after the string to
   * replaced, copy that too. */
  if (((strpos - orig) + strlen(first)) < strlen(orig))
    strncat(newsub, strpos + strlen(first), (MAX_INPUT_LENGTH - strlen(newsub) - 1));

  /* terminate the string in case of an overflow from strncat */
  newsub[MAX_INPUT_LENGTH - 1] = '\0';
  strcpy(subst, newsub);

  return (0);
}



void close_socket(struct descriptor_data *d)
{
  char buf[128];
  struct descriptor_data *temp;

  REMOVE_FROM_LIST(d, descriptor_list, next);
  CLOSE_SOCKET(d->descriptor);
  flush_queues(d);

  /* Forget snooping */
  if (d->snooping)
    d->snooping->snoop_by = NULL;

  if (d->snoop_by) {
    SEND_TO_Q("Your victim is no longer among us.\r\n", d->snoop_by);
    d->snoop_by->snooping = NULL;
  }

  /*. Kill any OLC stuff .*/
  switch (d->connected) {
    case CON_OEDIT:
    case CON_REDIT:
    case CON_ZEDIT:
    case CON_MEDIT:
    case CON_SEDIT:
    case CON_HEDIT:
    case CON_AEDIT:
    case CON_TRIGEDIT:
      cleanup_olc(d, CLEANUP_ALL);
    default:
      break;
  }

  if (d->character) {
    /* If we're switched, this resets the mobile taken. */
     d->character->desc = NULL;

    /*
     * Plug memory leak, from Eric Green.
     */
    if (!IS_NPC(d->character) && PLR_FLAGGED(d->character, PLR_MAILING) && d->str) {
      if (*(d->str))
        free(*(d->str));
      free(d->str);
    }
    if (STATE(d) == CON_PLAYING || STATE(d) == CON_DISCONNECT) {
      struct char_data *link_challenged = d->original ? d->original : d->character;

      act("$n has lost $s link.", TRUE, link_challenged, 0, 0, TO_ROOM);
      if (!IS_NPC(link_challenged)) {
	save_char(link_challenged, NOWHERE);
	sprintf(buf, "Closing link to: %s.", GET_NAME(link_challenged));
	mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(link_challenged)), TRUE);
      }
    } else {
      sprintf(buf, "Losing player: %s.",
              GET_NAME(d->character) ? GET_NAME(d->character) : "<null>");
      mudlog(buf, CMP, LVL_IMMORT, TRUE);
      free_char(d->character);
    }
  } else
    mudlog("Losing descriptor without char.", CMP, LVL_IMMORT, TRUE);

  /* JE 2/22/95 -- part of my unending quest to make switch stable */
  if (d->original && d->original->desc)
    d->original->desc = NULL;

  /* Clear the command history. */
  if (d->history) {
    int cnt;
    for (cnt = 0; cnt < HISTORY_SIZE; cnt++)
      if (d->history[cnt])
        free(d->history[cnt]);
    free(d->history);
  }

  if (d->showstr_head)
    free(d->showstr_head);
  if (d->showstr_count)
    free(d->showstr_vector);
  if (d->storage)
    free(d->storage);

  free(d);

}



void check_idle_passwords(void)
{
  struct descriptor_data *d, *next_d;

  for (d = descriptor_list; d; d = next_d) {
    next_d = d->next;
    if (STATE(d) != CON_PASSWORD && STATE(d) != CON_GET_NAME)
      continue;
    if (!d->idle_tics) {
      d->idle_tics++;
      continue;
    } else {
      echo_on(d);
      SEND_TO_Q("\r\nTimed out... The WarDome close your connection.\r\n", d);
      STATE(d) = CON_CLOSE;
    }
  }
}



/*
 * I tried to universally convert Circle over to POSIX compliance, but
 * alas, some systems are still straggling behind and don't have all the
 * appropriate defines.  In particular, NeXT 2.x defines O_NDELAY but not
 * O_NONBLOCK.  Krusty old NeXT machines!  (Thanks to Michael Jones for
 * this and various other NeXT fixes.)
 */

#if defined(CIRCLE_WINDOWS)

void nonblock(socket_t s)
{
  unsigned long val = 1;
  ioctlsocket(s, FIONBIO, &val);
}

#elif defined(CIRCLE_AMIGA)

void nonblock(socket_t s)
{
  long val = 1;
  IoctlSocket(s, FIONBIO, &val);
}

#elif defined(CIRCLE_ACORN)

void nonblock(socket_t s)
{
  int val = 1;
  socket_ioctl(s, FIONBIO, &val);
}

#elif defined(CIRCLE_UNIX) || defined(CIRCLE_OS2) || defined(CIRCLE_MACINTOSH)

#ifndef O_NONBLOCK
#define O_NONBLOCK O_NDELAY
#endif

void nonblock(socket_t s)
{
  int flags;

  flags = fcntl(s, F_GETFL, 0);
  flags |= O_NONBLOCK;
  if (fcntl(s, F_SETFL, flags) < 0) {
    perror("SYSERR: Fatal error executing nonblock (comm.c)");
    exit(1);
  }
}

#endif  /* CIRCLE_UNIX || CIRCLE_OS2 || CIRCLE_MACINTOSH */


/* ******************************************************************
*  signal-handling functions (formerly signals.c).  UNIX only.      *
****************************************************************** */

#if defined(CIRCLE_UNIX) || defined(CIRCLE_MACINTOSH)

RETSIGTYPE reread_wizlists(int sig)
{
  mudlog("Signal received - rereading wizlists.", CMP, LVL_SUPGOD, TRUE);
  reboot_wizlists();
}


RETSIGTYPE unrestrict_game(int sig)
{
  mudlog("Received SIGUSR2 - completely unrestricting game (emergent)",
         BRF, LVL_IMMORT, TRUE);
  ban_list = NULL;
  circle_restrict = 0;
  num_invalid = 0;
}

#ifdef CIRCLE_UNIX

/* clean up our zombie kids to avoid defunct processes */
RETSIGTYPE reap(int sig)
{
  while (waitpid(-1, NULL, WNOHANG) > 0);

  my_signal(SIGCHLD, reap);
}

RETSIGTYPE checkpointing(int sig)
{
  if (!tics) {
    log("SYSERR: CHECKPOINT shutdown: tics not updated. (Infinite loop suspected)");
    abort();
  } else
    tics = 0;
}

RETSIGTYPE hupsig(int sig)
{
  log("SYSERR: Received SIGHUP, SIGINT, or SIGTERM.  Shutting down...");
  exit(1);
}

#endif	/* CIRCLE_UNIX */


/*
 * This is an implementation of signal() using sigaction() for portability.
 * (sigaction() is POSIX; signal() is not.)  Taken from Stevens' _Advanced
 * Programming in the UNIX Environment_.  We are specifying that all system
 * calls _not_ be automatically restarted for uniformity, because BSD systems
 * do not restart select(), even if SA_RESTART is used.
 *
 * Note that NeXT 2.x is not POSIX and does not have sigaction; therefore,
 * I just define it to be the old signal.  If your system doesn't have
 * sigaction either, you can use the same fix.
 *
 * SunOS Release 4.0.2 (sun386) needs this too, according to Tim Aldric.
 */

#ifndef POSIX
#define my_signal(signo, func) signal(signo, func)
#else
sigfunc *my_signal(int signo, sigfunc * func)
{
  struct sigaction act, oact;

  act.sa_handler = func;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
#ifdef SA_INTERRUPT
  act.sa_flags |= SA_INTERRUPT; /* SunOS */
#endif

  if (sigaction(signo, &act, &oact) < 0)
    return (SIG_ERR);

  return (oact.sa_handler);
}
#endif                          /* POSIX */


void signal_setup(void)
{
#ifndef CIRCLE_MACINTOSH
  struct itimerval itime;
  struct timeval interval;

  /* user signal 1: reread wizlists.  Used by autowiz system. */
  my_signal(SIGUSR1, reread_wizlists);

  /*
   * user signal 2: unrestrict game.  Used for emergencies if you lock
   * yourself out of the MUD somehow.  (Duh...)
   */
  my_signal(SIGUSR2, unrestrict_game);

  /*
   * set up the deadlock-protection so that the MUD aborts itself if it gets
   * caught in an infinite loop for more than 3 minutes.
   */
  interval.tv_sec = 180;
  interval.tv_usec = 0;
  itime.it_interval = interval;
  itime.it_value = interval;
  setitimer(ITIMER_VIRTUAL, &itime, NULL);
  my_signal(SIGVTALRM, checkpointing);

  /* just to be on the safe side: */
  my_signal(SIGHUP, hupsig);
  my_signal(SIGCHLD, reap);
#endif /* CIRCLE_MACINTOSH */
  my_signal(SIGINT, hupsig);
  my_signal(SIGTERM, hupsig);
  my_signal(SIGPIPE, SIG_IGN);
  my_signal(SIGALRM, SIG_IGN);
}

#endif	/* CIRCLE_UNIX || CIRCLE_MACINTOSH */

/* ****************************************************************
*       Public routines for system-to-player-communication        *
**************************************************************** */

void send_to_char(const char *messg, struct char_data *ch)
{
  if (ch->desc && messg && *messg)
	    SEND_TO_Q(messg, ch->desc);
}


void send_to_all(const char *messg)
{
  struct descriptor_data *i;

  if (messg == NULL)
    return;

  for (i = descriptor_list; i; i = i->next)
    if (STATE(i) == CON_PLAYING)
      SEND_TO_Q(messg, i);
}


void send_to_outdoor(const char *messg)
{
  struct descriptor_data *i;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next) {
    if (STATE(i) != CON_PLAYING || i->character == NULL)
      continue;
    if (!AWAKE(i->character) || !OUTSIDE(i->character))
      continue;
	if(PLR_FLAGGED(i->character, PLR_WRITING))
	  continue;
    SEND_TO_Q(messg, i);
  }
}



void send_to_room(const char *messg, int room)
{
  struct char_data *i;

  if (messg == NULL)
    return;

  for (i = world[room].people; i; i = i->next_in_room)
    if (i->desc)
      SEND_TO_Q(messg, i->desc);
}



const char *ACTNULL = "<NULL>";

#define CHECK_NULL(pointer, expression) \
  if ((pointer) == NULL) i = ACTNULL; else i = (expression);


/* higher-level communication: the act() function */
void perform_act(const char *orig, struct char_data *ch, struct obj_data *obj,
                const void *vict_obj, const struct char_data *to)
{
  const char *i = NULL;
  char lbuf[MAX_STRING_LENGTH], *buf, *j;
  const struct char_data *dg_victim = NULL;
  const struct obj_data *dg_target = NULL;
  const char *dg_arg = NULL;
  bool uppercasenext = FALSE;

  buf = lbuf;

  for (;;) {
    if (*orig == '$') {
      switch (*(++orig)) {
      case 'n':
        i = PERS(ch, to);
        break;
      case 'N':
        CHECK_NULL(vict_obj, PERS((const struct char_data *) vict_obj, to));
        dg_victim = (const struct char_data *) vict_obj;
        break;
      case 'm':
        i = HMHR(ch);
        break;
      case 'M':
        CHECK_NULL(vict_obj, HMHR((const struct char_data *) vict_obj));
        dg_victim = (const struct char_data *) vict_obj;
        break;
      case 's':
        i = HSHR(ch);
        break;
      case 'S':
        CHECK_NULL(vict_obj, HSHR((const struct char_data *) vict_obj));
        dg_victim = (const struct char_data *) vict_obj;
        break;
      case 'e':
        i = HSSH(ch);
        break;
      case 'E':
        CHECK_NULL(vict_obj, HSSH((const struct char_data *) vict_obj));
        dg_victim = (const struct char_data *) vict_obj;
        break;
      case 'o':
        CHECK_NULL(obj, OBJN(obj, to));
        break;
      case 'O':
        CHECK_NULL(vict_obj, OBJN((const struct obj_data *) vict_obj, to));
        dg_target = (const struct obj_data *) vict_obj;
        break;
      case 'p':
        CHECK_NULL(obj, OBJS(obj, to));
        break;
      case 'P':
        CHECK_NULL(vict_obj, OBJS((const struct obj_data *) vict_obj, to));
        dg_target = (const struct obj_data *) vict_obj;
        break;
      case 'a':
        CHECK_NULL(obj, SANA(obj));
        break;
      case 'A':
        CHECK_NULL(vict_obj, SANA((const struct obj_data *) vict_obj));
        dg_target = (const struct obj_data *) vict_obj;
        break;
      case 'T':
        CHECK_NULL(vict_obj, (const char *) vict_obj);
        break;
        dg_arg = (const char *) vict_obj;
      case 't':
	CHECK_NULL(obj, (char *) obj);
	break;
      case 'F':
        CHECK_NULL(vict_obj, fname((char *) vict_obj));
        break;
      /* uppercase previous word */
      case 'u':
        for (j=buf; j > lbuf && !isspace((int) *(j-1)); j--);
        if (j != buf)
          *j = UPPER(*j);
        i = "";
        break;
      /* uppercase next word */
      case 'U':
        uppercasenext = TRUE;
        i = "";
        break;
      case '$':
        i = "$";
        break;
      default:
        log("SYSERR: Illegal $-code to act(): %c", *orig);
        log("SYSERR: %s", orig);
        break;
      }
/*      while ((*buf = *(i++)))
        buf++;
      orig++;
    } else if (!(*(buf++) = *(orig++)))
      break;*/
      while ((*buf = *(i++)))
        {
        if (uppercasenext && !isspace((int) *buf))
          {
          *buf = UPPER(*buf);
          uppercasenext = FALSE;
          }
	buf++;
        }
      orig++;
    } else if (!(*(buf++) = *(orig++))) {
      break;
    } else if (uppercasenext && !isspace((int) *(buf-1))) {
      *(buf-1) = UPPER(*(buf-1));
      uppercasenext = FALSE;
    }
  }

  *(--buf) = '\r';
  *(++buf) = '\n';
  *(++buf) = '\0';

  if (to->desc)
    SEND_TO_Q(CAP(lbuf), to->desc);

  if ((IS_NPC(to) && dg_act_check) && (to != ch))
    act_mtrigger((struct char_data *)to, lbuf, ch, (struct char_data *)dg_victim, obj, (struct obj_data *)dg_target, (char *)dg_arg);

}

#ifndef SENDOK
#define SENDOK(ch)	((ch)->desc && (to_sleeping || AWAKE(ch)) && \
			(IS_NPC(ch) || !PLR_FLAGGED((ch), PLR_WRITING)))
#endif

void act(const char *str, int hide_invisible, struct char_data *ch,
         struct obj_data *obj, const void *vict_obj, int type)
{
  const struct char_data *to = NULL;
  int to_sleeping;
  struct descriptor_data *i;

  if (!str || !*str)
    return;

  if (!(dg_act_check = !(type & DG_NO_TRIG)))
    type &= ~DG_NO_TRIG;

  /*
   * Warning: the following TO_SLEEP code is a hack.
   *
   * I wanted to be able to tell act to deliver a message regardless of sleep
   * without adding an additional argument.  TO_SLEEP is 128 (a single bit
   * high up).  It's ONLY legal to combine TO_SLEEP with one other TO_x
   * command.  It's not legal to combine TO_x's with each other otherwise.
   * TO_SLEEP only works because its value "happens to be" a single bit;
   * do not change it to something else.  In short, it is a hack.
   */

  /* check if TO_SLEEP is there, and remove it if it is. */
  if ((to_sleeping = (type & TO_SLEEP)))
    type &= ~TO_SLEEP;

  if (type == TO_CHAR) {
    if(ch)
      if(SENDOK(ch))
        perform_act(str, ch, obj, vict_obj, ch);
    return;
  }

  if (type == TO_VICT) {
    if ((to = (const struct char_data *) vict_obj) != NULL && SENDOK(to))
      perform_act(str, ch, obj, vict_obj, to);
    return;
  }
  /* ASSUMPTION: at this point we know type must be TO_NOTVICT or TO_ROOM */

  if (type == TO_GMOTE) {
    for (i = descriptor_list; i; i = i->next) {
      if (!i->connected && i->character &&
	!IS_NPC(i->character) &&
	!PRF_FLAGGED(i->character, PRF_NOGOSS) &&
	!PLR_FLAGGED(i->character, PLR_WRITING) &&
	!ROOM_FLAGGED(i->character->in_room, ROOM_SOUNDPROOF)) {
        perform_act(str, ch, obj, vict_obj, i->character);
      }
    }
    return;
  }


  if (ch) {
    if (ch->in_room != NOWHERE)
      to = world[ch->in_room].people;
  } else if (obj) {
    if (obj->in_room != NOWHERE)
      to = world[obj->in_room].people;
  } else {
    log("SYSERR: no valid target to act()!");
    return;
  }

/* snip, taerin 4/12/99
   sometimes things die too rapidly
   sticking in separated pointer checks above
   this might fix the null pointer crashes

  if (ch && ch->in_room != NOWHERE)
    to = world[ch->in_room].people;
  else if (obj && obj->in_room != NOWHERE)
    to = world[obj->in_room].people;
  else {
    log("SYSERR: no valid target to act()!");
    return;
  } */

  for (; to; to = to->next_in_room) {
    if (!SENDOK(to) || (to == ch))
      continue;
    if (hide_invisible && ch && !CAN_SEE(to, ch))
      continue;
    if (type != TO_ROOM && to == vict_obj)
      continue;
    perform_act(str, ch, obj, vict_obj, to);
  }
}

void write_mud_date_to_file(void)
{
   FILE *f;
   struct time_write date;

   f = fopen("date_record", "w");
   date.year = time_info.year;
   date.month = time_info.month;
   date.day   = time_info.day;
   fwrite(&date,sizeof(struct time_write),1,f);
   fclose(f);
}

/*
 * This function is called every 30 seconds from heartbeat().  It checks
 * the four global buffers in CircleMUD to ensure that no one has written
 * past their bounds.  If our check digit is not there (and the position
 * doesn't have a NUL which may result from snprintf) then we gripe that
 * someone has overwritten our buffer.  This could cause a false positive
 * if someone uses the buffer as a non-terminated character array but that
 * is not likely. -gg
 */
#define offset  (MAX_STRING_LENGTH - 1)
void sanity_check(void)
{
  int ok = TRUE;

  /*
   * If any line is false, 'ok' will become false also.
   */
  ok &= (buf[offset] == MAGIC_NUMBER || buf[offset] == '\0');
  ok &= (buf1[offset] == MAGIC_NUMBER || buf1[offset] == '\0');
  ok &= (buf2[offset] == MAGIC_NUMBER || buf2[offset] == '\0');
  ok &= (buf3[offset] == MAGIC_NUMBER || buf3[offset] == '\0');
  ok &= (arg[offset] == MAGIC_NUMBER || arg[offset] == '\0');

  /*
   * This isn't exactly the safest thing to do (referencing known bad memory)
   * but we're doomed to crash eventually, might as well try to get something
   * useful before we go down. -gg
   */
  if (!ok)
    log("SYSERR: *** Buffer overflow! ***\n"
        "buf: %s\nbuf1: %s\nbuf2: %s\nbuf3: %s\narg: %s", buf, buf1, buf2, buf3, arg);
    /* Initialize these to check for overruns later. */
    buf[MAX_STRING_LENGTH - 1] = buf1[MAX_STRING_LENGTH - 1] = MAGIC_NUMBER;
    buf2[MAX_STRING_LENGTH - 1] = arg[MAX_STRING_LENGTH - 1] = MAGIC_NUMBER;
    buf3[MAX_STRING_LENGTH - 1] = MAGIC_NUMBER;
#if 0
  log("Statistics: buf=%d buf1=%d buf2=%d arg=%d",
        strlen(buf), strlen(buf1), strlen(buf2), strlen(arg));
#endif
}

/*
 * This may not be pretty but it keeps game_loop() neater than if it was inline.
 */
#if defined(CIRCLE_WINDOWS)

void circle_sleep(struct timeval *timeout)
{
  Sleep(timeout->tv_sec * 1000 + timeout->tv_usec / 1000);
}

#else

void circle_sleep(struct timeval *timeout)
{
  if (select(0, (fd_set *) 0, (fd_set *) 0, (fd_set *) 0, timeout) < 0) {
    if (errno != EINTR) {
      perror("SYSERR: Select sleep");
      exit(1);
    }
  }
}

#endif /* CIRCLE_WINDOWS */

const char *sgod_wiznames[] =
{
  "Imm",
  "EId",
  "Lrd",
  "Dem",
  "God",
  "GrG",
  "SuG",
  "MjG",
  "Imp",
  "Own",
  "\n"
};

void make_who2html(void)
{
   extern struct descriptor_data *descriptor_list;
   FILE *opf;
   struct descriptor_data *d;
   struct char_data *ch;
   int y = 1;

   if (!(opf = fopen("who.file", "w"))) {
       touch("who.file");
       if (!(opf = fopen("who.file", "w")))
          return; /* or log it ? *shrug* */
   }

   fprintf(opf, "<html><head><title>Untitled Document</title>\n");
   fprintf(opf, "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"></head>\n");
   fprintf(opf, "<body bgcolor=\"#FFFFFF\" background=\"imagens/back.jpg\">\n");
   fprintf(opf, "<div align=\"center\">\n");
   fprintf(opf, "<p><b><i><font size=\"5\" color=\"#000000\"> <font size=\"7\">Wardome Online Players</font></font></i></b></p>\n");

   for(d = descriptor_list; d; d = d->next)
     if(!d->connected)
       {
         if(d->original)
            ch = d->original;
         else if (!(ch = d->character))
            continue;
         if(GET_LEVEL(ch) < LVL_IMMORT || (GET_LEVEL(ch)>=LVL_IMMORT &&
                                         !GET_INVIS_LEV(ch)))
           {
	     if(GET_LEVEL(ch) >= LVL_IMMORT) {
	        sprintf(buf, "[%3s] %40s%s", sgod_wiznames[(GET_LEVEL(ch)) - LVL_IMMORT],
        	             GET_NAME(ch), (!(y++ % 4) ? "\n <BR>" : " "));
             	fprintf(opf, buf);
	     } else {
	        sprintf(buf, "[%3d] %40s%s", GET_LEVEL(ch),
        	             GET_NAME(ch), (!(y++ % 4) ? "\n <BR>" : " "));
             	fprintf(opf, buf);
	     }
           }
        }

   fprintf(opf, "</div></body></html>\n");
   fclose(opf);
   system("mv /home/wardome/wdII/lib/who.file /home/wardome/public_html/who.html");
}
::::::::::::::
condition.c
::::::::::::::
/* ************************************************************************
*   File: condition.c                                   Part of CircleMUD *
*  Usage: Communication, socket handling, main(), central game loop       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "handler.h"
#include "comm.h"
#include "db.h"

extern struct room_data *world;

int apply_ac(struct char_data * ch, int eq_pos);

char *item_condition(struct obj_data *obj)
{
  int value;
  static char buf[MAX_STRING_LENGTH];

  /* default conditon is 100, and reflects average quality. This can be
     raised, through _special_ and _expensive_ smiths, tailors, etc to a max
     of 125, reflecting exceptional quality and manufacture. Code only
     cares about 1-12, so lets chop the name down a bit...
   */

  value = GET_OBJ_COND(obj);

  if (value == 101)
    sprintf(buf, " &W[indestructible]&n ");
  else if (value >= 90)
    sprintf(buf, " &B[new]&n ");
  else if (value >= 80)
    sprintf(buf, " &b[almost new]&n ");
  else if (value >= 70)
    sprintf(buf, " &G[very good]&n ");
  else if (value >= 60)
    sprintf(buf, " &g[good]&n ");
  else if (value >= 50)
    sprintf(buf, " &C[used]&n ");
  else if (value >= 40)
    sprintf(buf, " &c[fair]&n ");
  else if (value >= 30)
    sprintf(buf, " &M[well worn]&n ");
  else if (value >= 20)
    sprintf(buf, " &m[worn]&n ");
  else if (value >= 10)
    sprintf(buf, " &r[partially worn]&n ");
  else if (value >= 0)
    sprintf(buf, " &R[ruined]&n ");
  else
    sprintf(buf, " ");
    
  return buf;
}

int DamageItem(struct char_data *ch, struct obj_data *o)
{
  int temp,i;

  if (!o)
    return 0;

  if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA | ROOM_PEACEFUL))
    return 0;
      	
  temp = number(1, 2);
  if(GET_OBJ_COND(o) == 101){
	return FALSE;
  } else{
     for (i = 0; i < NUM_WEARS; i++) {
      if (GET_EQ(ch, i))
       GET_AC(ch) += apply_ac(ch, i);
     } 	
     
     GET_OBJ_COND(o) -= temp;
     
     for (i = 0; i < NUM_WEARS; i++) {
      if (GET_EQ(ch, i))
       GET_AC(ch) -= apply_ac(ch, i);
     }
    }  
  save_char(ch, NOWHERE);
  
  sprintf(buf, "&G%s&g was &Gdamaged&g in the combat!&n\r\n", (CAN_SEE_OBJ(ch, o) ? CAP(o->short_description) : "Something"));
  send_to_char(buf, ch);
  
  if (GET_OBJ_COND(o) < 0) {
    GET_OBJ_COND(o) = 0;
    return TRUE;
  }
  return FALSE;
}

int DamageOneItem(struct char_data *ch, struct obj_data *obj)
{

  if (!obj)
    return 0;

  if (DamageItem(ch, obj)) {
    return TRUE;
  }

  return FALSE;
}

void MakeScrap(struct char_data *ch, struct obj_data *obj)
{
  char buf[256];
  struct obj_data *t, *x;
  int pos;


  if (!ch || !obj || (ch->in_room == NOWHERE))
    return;

  act("$p falls to the ground in scraps.", TRUE, ch, obj, 0, TO_CHAR);
  act("$p falls to the ground in scraps.", TRUE, ch, obj, 0, TO_ROOM);

  t = read_object(9, VIRTUAL);
  if (!t)
    return;

  sprintf(buf, "Scraps from %s&n lie in a pile",
	  obj->short_description);
  t->description = str_dup(buf);
  t->short_description = str_dup("a pile of scraps");

  if (obj->carried_by) {
    obj_from_char(obj);
  } else if (obj->worn_by) {
    for (pos = 0; pos < NUM_WEARS; pos++)
      if (ch->equipment[pos] == obj)
	break;
    if (pos >= NUM_WEARS) {
      log("SYSERR: MakeScrap(), can't find worn object in equip");
      exit(1);
    }
    obj = unequip_char(ch, pos);
  }
  obj_to_room(t, ch->in_room);
  while (obj->contains) {
    x = obj->contains;
    obj_from_obj(x);
    obj_to_room(x, ch->in_room);
  }
  extract_obj(obj);
}

void DamageAllStuff(struct char_data *ch, int dam_type, int dam)
{
  int j;
  struct obj_data *obj, *next;

  /* this procedure takes all of the items in equipment and inventory
     and damages the ones that should be damaged */

  /* equipment */

  for (j = 0; j < NUM_WEARS; j++) {
    if (ch->equipment[j]) {
      obj = ch->equipment[j];
      if (DamageOneItem(ch, obj)) {	/* TRUE == destroyed */
	if ((obj = unequip_char(ch, j)) != NULL) {
	  MakeScrap(ch, obj);
	} else {
	  log("SYSERR: DamageAllStuff(): hmm, really wierd!");
	}
      }
    }
  }

  /* inventory */

  for (obj = ch->carrying; obj; obj = next) {
    next = obj->next_content;
    if (DamageOneItem(ch, obj))
      MakeScrap(ch, obj);
  }
}
/*
void DamageStuff(struct char_data *ch)
{
  int j;
  struct obj_data *obj;

  for (j = 0; j < NUM_WEARS; j++) {
    if (ch->equipment[j]) {
      obj = ch->equipment[j];
      if ((number(0, 90) > number(70, 200)) && DamageOneItem(ch, obj)) {
	if ((obj = unequip_char(ch, j)) != NULL) {
	  MakeScrap(ch, obj);
	  save_char(ch, ch->in_room);
	} else {
	  log("SYSERR: DamageStuff(): hmm, really wierd!");
	}
      }
    }
  }
}
*/

void DamageStuff(struct char_data *ch)
{
  int j;
  struct obj_data *obj;

   j = number(0, (NUM_WEARS - 1));
    if (GET_EQ(ch, j)) {
      obj = GET_EQ(ch, j)/*ch->equipment[j]*/;
      if ((number(0, 60) > number(30, 90)) && DamageOneItem(ch, obj)) {
	if ((obj = unequip_char(ch, j)) != NULL) {
	  MakeScrap(ch, obj);
	  save_char(ch, ch->in_room);
	} else {
	  log("SYSERR: DamageStuff(): hmm, really wierd!");
	}
      }
    }
}
::::::::::::::
config.c
::::::::::::::
/* ************************************************************************
*   File: config.c                                      Part of CircleMUD *
*  Usage: Configuration of various aspects of CircleMUD operation         *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __CONFIG_C__

#include "conf.h"
#include "sysdep.h"

#include "screen.h"
#include "structs.h"
#include "buffer.h"

#define TRUE    1
#define YES     1
#define FALSE   0
#define NO      0

/*
 * Below are several constants which you can change to alter certain aspects
 * of the way CircleMUD acts.  Since this is a .c file, all you have to do
 * to change one of the constants (assuming you keep your object files around)
 * is change the constant in this file and type 'make'.  Make will recompile
 * this file and relink; you don't have to wait for the whole thing to
 * recompile as you do if you change a header file.
 *
 * I realize that it would be slightly more efficient to have lots of
 * #defines strewn about, so that, for example, the autowiz code isn't
 * compiled at all if you don't want to use autowiz.  However, the actual
 * code for the various options is quite small, as is the computational time
 * in checking the option you've selected at run-time, so I've decided the
 * convenience of having all your options in this one file outweighs the
 * efficency of doing it the other way.
 *
 */

/****************************************************************************/
/****************************************************************************/


/* GAME PLAY OPTIONS */

/*
 * pk_allowed sets the tone of the entire game.  If pk_allowed is set to
   * NO, then players will not be allowed to kill, summon, charm, or sleep
 * other players, as well as a variety of other "asshole player" protections.
 * However, if you decide you want to have an all-out knock-down drag-out
 * PK Mud, just set pk_allowedo YES - and anything goes.
 */
int pk_allowed = YES;

/* is playerthieving allowed? */
int pt_allowed = YES;

/* minimum level a player must be to shout/holler/gossip/auction */
int level_can_shout = 1;

/* number of movement points it costs to holler */
int holler_move_cost = 20;

/* exp change limits */
int max_exp_gain = 25000000;      /* max gainable per kill */
int max_exp_loss = 25000000;      /* max losable per death */

/* number of tics (usually 75 seconds) before PC/NPC corpses decompose */
int max_npc_corpse_time = 5;
int max_pc_corpse_time = 10;

/* How many ticks before a player is sent to the void or idle-rented. */
int idle_void = 8;
int idle_rent_time = 20;

/* This level and up is immune to idling, LVL_IMPL+1 will disable it. */
int idle_max_level   = LVL_GOD;

/* should items in death traps automatically be junked? */
int dts_are_dumps = NO;

/*
 * Whether you want items that immortals load to appear on the ground or not.
 * It is most likely best to set this to 'YES' so that something else don't
 * grab the item before the immortal does, but that also means people will be
 * able to carry around things like boards.  That's not necessarily a bad
 * thing, but this will be left at a default of 'NO' for historic reasons.
 */
int load_into_inventory = NO;

/* "okay" etc. */
const char *OK = "Okay.\r\n";
const char *NOPERSON = "No-one by that name here.\r\n";
const char *NOEFFECT = "Nothing seems to happen.\r\n";

/****************************************************************************/
/****************************************************************************/

/* number of connections per host */
int multi_player = 1;

/* RENT/CRASHSAVE OPTIONS */

/*
 * Should the MUD allow you to 'rent' for free?  (i.e. if you just quit,
 * your objects are saved at no cost, as in Merc-type MUDs.)
 */
int free_rent = YES;

/* maximum number of items players are allowed to rent */
int max_obj_save = 60;

/* receptionist's surcharge on top of item costs */
int min_rent_cost = 100;

/*
 * Should the game automatically save people?  (i.e., save player data
 * every 4 kills (on average), and Crash-save as defined below.  This
 * option has an added meaning past bpl13.  If auto_save is YES, then
 * the 'save' command will be disabled to prevent item duplication via
 * game crashes.
 */
int auto_save = YES;

/*
 * if auto_save (above) is yes, how often (in minutes) should the MUD
 * Crash-save people's objects?   Also, this number indicates how often
 * the MUD will Crash-save players' houses.
 */
int autosave_time = 1;

/* Lifetime of crashfiles and forced-rent (idlesave) files in days */
int crash_file_timeout = 10;

/* Lifetime of normal rent files in days */
int rent_file_timeout = 30;

/* Do you want to automatically wipe players who've been gone too long? */
int auto_pwipe = TRUE;

/* Autowipe deletion criteria
   This struct holds information used to determine which players to wipe
   then the mud boots.  The levels must be in ascending order, with a
   descending level marking the end of the array.  A level -1 entry in the
   beginning is the case for players with the PLR_DELETED flag.  The
   values below match the stock purgeplay.c criteria.

   Detailed explanation by array element:
   * Element 0, level -1, days 0: Players with PLR_DELETED flag are always
	wiped.
   * Element 1, level 0, days 0: Players at level 0 have created a
	character, but have never actually entered the game, so always
	wipe them.
   * Element 2, level 1, days 4: Players at level 1 are wiped if they
	haven't logged on in the past 4 days.
   * Element 3, level 4, days 7: Players level 2 through 4 are wiped if
	they haven't logged on in the past 7 days.
   * Element 4, level 10, days 30: Players level 5-10 get 30 days.
   * Element 5, level LVL_IMMORT - 1, days 60: All other mortals get
	60 days.
   * Element 6, level LVL_IMPL, days 90: Immortals get 90 days.
   * Element 7: Because -2 is less than LVL_IMPL, this is assumed to
	be the end of the criteria.  The days entry is not used in this
	case.
*/
struct pclean_criteria_data pclean_criteria[] = {
/*	LEVEL		DAYS	*/
  {	-1		,0	}, /* players with PLR_DELETE flag */
  {	0		,0	}, /* level 0 */
  {	1		,14	},
  {	20		,160	},
  {	100		,320	},
  {	LVL_IMMORT - 1	,440	}, /* highest mortal */
  {	LVL_IMPL	,999	}, /* all immortals */
  {	-2		,0	}  /* no more level checks */
};

/* Do you want players who self-delete to be wiped immediately with no
   backup?
*/
int selfdelete_fastwipe = YES;

/****************************************************************************/
/****************************************************************************/


/* ROOM NUMBERS */

/* virtual number of room that mortals should enter at */
sh_int mortal_start_room = 500;

/* virtual number of room that immorts should enter at by default */
sh_int immort_start_room = 1204;

/* virtual number of room that frozen players should enter at */
sh_int frozen_start_room = 1202;

/* virtual number of room that dead players should enter at */
sh_int deadly_start_room = 10;

/*
 * virtual numbers of donation rooms.  note: you must change code in
 * do_drop of act.item.c if you change the number of non-NOWHERE
 * donation rooms.
 */
sh_int donation_room_1 = 502;
sh_int donation_room_2 = NOWHERE;       /* unused - room for expansion */
sh_int donation_room_3 = NOWHERE;       /* unused - room for expansion */


/****************************************************************************/
/****************************************************************************/


/* GAME OPERATION OPTIONS */

/*
 * This is the default port on which the game should run if no port is
 * given on the command-line.  NOTE WELL: If you're using the
 * 'autorun' script, the port number there will override this setting.
 * Change the PORT= line in autorun instead of (or in addition to)
 * changing this.
 */
ush_int DFLT_PORT = 2022;

/*
 * IP address to which the MUD should bind.  This is only useful if
 * you're running Circle on a host that host more than one IP interface,
 * and you only want to bind to *one* of them instead of all of them.
 * Setting this to NULL (the default) causes Circle to bind to all
 * interfaces on the host.  Otherwise, specify a numeric IP address in
 * dotted quad format, and Circle will only bind to that IP address.  (Of
 * course, that IP address must be one of your host's interfaces, or it
 * won't work.)
 */
const char *DFLT_IP = NULL; /* bind to all interfaces */
/* const char *DFLT_IP = "192.168.1.1";  -- bind only to one interface */

/* default directory to use as data directory */
const char *DFLT_DIR = "lib";

/*
 * What file to log messages to (ex: "log/syslog").  Setting this to NULL
 * means you want to log to stderr, which was the default in earlier
 * versions of Circle.  If you specify a file, you don't get messages to
 * the screen. (Hint: Try 'tail -f' if you have a UNIX machine.)
 */
const char *LOGNAME = NULL;
/* const char *LOGNAME = "log/syslog";  -- useful for Windows users */

/* maximum number of players allowed before game starts to turn people away */
int MAX_PLAYERS = 300;

/* maximum size of bug, typo and idea files in bytes (to prevent bombing) */
int max_filesize = 50000;

/* maximum number of password attempts before disconnection */
int max_bad_pws = 3;

/*
 * Rationale for enabling this, as explained by naved@bird.taponline.com.
 *
 * Usually, when you select ban a site, it is because one or two people are
 * causing troubles while there are still many people from that site who you
 * want to still log on.  Right now if I want to add a new select ban, I need
 * to first add the ban, then SITEOK all the players from that site except for
 * the one or two who I don't want logging on.  Wouldn't it be more convenient
 * to just have to remove the SITEOK flags from those people I want to ban
 * rather than what is currently done?
 */
int siteok_everyone = FALSE;

/*
 * Some nameservers are very slow and cause the game to lag terribly every 
 * time someone logs in.  The lag is caused by the gethostbyaddr() function
 * which is responsible for resolving numeric IP addresses to alphabetic names.
 * Sometimes, nameservers can be so slow that the incredible lag caused by
 * gethostbyaddr() isn't worth the luxury of having names instead of numbers
 * for players' sitenames.
 *
 * If your nameserver is fast, set the variable below to NO.  If your
 * nameserver is slow, of it you would simply prefer to have numbers
 * instead of names for some other reason, set the variable to YES.
 *
 * You can experiment with the setting of nameserver_is_slow on-line using
 * the SLOWNS command from within the MUD.
 */

int nameserver_is_slow = YES;


const char *MENU =
"\r\n"
"&cYou are welcome to the &CWarDome&c.\r\n"
"&cHere you can fight, talk or only have a good time.\r\n"
"&n\r\n"
"&b	    ____________________________________________________ \r\n"
"&b	   | &BWarDome&b MUD menu... 				|\r\n"
"&b	   |							|\r\n"
"&b	   |	&C(&c0&C) &BLeave of the WarDome&b			|\r\n"
"&b	   |							|\r\n"
"&b	   |	&C(&c1&C) &BJoin the game&b				|\r\n"
"&b	   |	&C(&c2&C) &BGive a glance in the rules&b			|\r\n"
"&b	   |	&C(&c3&C) &BRead the Quest of the Week&b			|\r\n"
"&b	   |	&C(&c4&C) &BChange your password&b			|\r\n"
"&b	   |	&C(&c5&C) &BEnter your description&b			|\r\n"
"&b	   |	&C(&c6&C) &BEnter your message for the players&b		|\r\n"
"&b	   |	&C(&c7&C) &BCheck your summary&b				|\r\n"
"&b	   |	&C(&c8&C) &BDelete this player&b				|\r\n"
"&b	   |____________________________________________________|\r\n"
"&n\r\n"
"\r\n"
"&C	Choose your option:&n ";

// with colors
/*
const char *GREETINGS =
"\x1B[1;31m     __        __  ______   ______   \x1B[1;34m_____   ______                _____\r\n"
"\x1B[1;31m     \\ \\      / / |  __  | |  __  \\ \x1B[1;34m|  _  \\ |  __  |    /\\  /\\    |  ___|\r\n"
"\x1B[1;31m      \\ \\    / /  | |__| | | |__| | \x1B[1;34m| | | | | |  | |   /  \\/  \\   | |___ \r\n"
"\x1B[1;31m       \\ \\  / /   |      | |  __  | \x1B[1;34m| | | | | |  | |   / /  \\ \\   |  ___|\r\n"
"\x1B[1;31m       \\  /\\  /   | |  | | | |  \\ \\ \x1B[1;34m| |_| | | |__| |  / /    \\ \\  | |___ \r\n"
"\x1B[1;31m        \\/  \\/    | |  | | | |   \\  \x1B[1;34m|_____/ |______| /_/      \\_\\ |_____|\r\n"
"\x1B[0;33m\r\n"
"\x1B[1;31m                                                               MUD\r\n"
"\x1B[0;33m\r\n"
"\x1B[1;31m                                                       Beta Version\r\n"
"\x1B[1;31m                                                             1.1\r\n"
"\x1B[0;33m\r\n"
"\x1B[0;33m\r\n"
"\x1B[0;37m              Based on CircleMUD 3.0, created by Jeremy Elson.\r\n"
"\x1B[0;37m    A derivative of DikuMUD (GAMMA 0.0), created by Hans-Henrik Staerfeldt,\r\n"
"\x1B[0;37m        Katja Nyboe, Tom Madsen, Michael Seifert, and Sebastian Hammer\r\n"
"\x1B[0;33m\r\n"
"\x1B[0;37mHey, what's your name?\x1B[0;0m ";
*/

const char *GREETINGS =
" W E L C O M E  T O\r\n"     
"				  ____________\r\n"
"		                 |_   ____   _|\r\n" 
"   _      _    ______   ______    _|_|_   |_|___                 _____\r\n"                          
"  / /    \\ \\  |  __  | |  __  \\  |  _  \\  |  __  |    /\\  /\\    |  ___|\r\n" 
"  \\ \\    / /  | |__| | | |__| |  | | | |  | |  | |   /  \\/  \\   | |___\r\n" 
"   \\ \\  / /   |      | |  __  |  | | | |  | |  | |   / /  \\ \\   |  ___|\r\n" 
"   \\  /\\  /   | |  | | | |  \\ \\  | |_| |  | |__| |  / /    \\ \\  | |___ \r\n" 
"    \\/  \\/    | |  | | | |   \\ \\ |_____/  |______|  \\_\\    /_/  |_____|\r\n"                      
"                                  _| |____| |_\r\n"               
"                                 |_____MUD____|\r\n"                               
"\r\n" 
"                                             		Beta Version 2.0\r\n" 
"\r\n"
"\r\n"
"              Based on CircleMUD 3.0, created by Jeremy Elson.\r\n"
"    A derivative of DikuMUD (GAMMA 0.0), created by Hans-Henrik Staerfeldt,\r\n"
"        Katja Nyboe, Tom Madsen, Michael Seifert, and Sebastian Hammer\r\n"
"                  VERY SPECIAL THANKS TO ZAAROTH THANKS FOR ALL!!!\r\n" 
"\r\n"
"Hey, what's your name? "; 

const char *WELC_MESSG =
"\r\n"
"&cWelcome to the &CW&car&CD&come.&n\r\n"
"\r\n\r\n";

const char *START_MESSG =
"&c\r\n"
"Welcome.  This is your new character!  You can now earn gold,\r\n"
"gain experience, find weapons and equipment, and much more -- while\r\n"
"meeting people from around the world!\r\n"
"\r\n"
"Type &CHELP&c to see the most common commands.&n\r\n\r\n";

/****************************************************************************/
/****************************************************************************/


/* AUTOWIZ OPTIONS */

/*
 * Should the game automatically create a new wizlist/immlist every time
 * someone immorts, or is promoted to a higher (or lower) god level?
 * NOTE: this only works under UNIX systems.
 */
int use_autowiz = NO;

/* If yes, what is the lowest level which should be on the wizlist?  (All
   immort levels below the level you specify will go on the immlist instead.) */
int min_wizlist_lev = LVL_GOD;

/* is teleport rooms working yet? */
int teleport_on = YES;
::::::::::::::
constants.c
::::::::::::::
/* ************************************************************************
*   File: constants.c                                   Part of CircleMUD *
*  Usage: Numeric and string contants used by the MUD                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"

cpp_extern const char circlemud_version[] = {
        "WarDomeMUD II, version 0.21 "
};

/* strings corresponding to ordinals/bitvectors in structs.h ***********/

/* (Note: strings for class definitions in class.c instead of here) */

/* god names */
const char *god_names[] =
{
  "Immortal",
  "Elder",
  "Lord",
  "Helper",
  "Builder",
  "Coder",
  "Major Builder",
  "Supreme Coder",
  "Implementor",
  "Owner Implementor",
  "\n"
};

/*
const char *god_wiznames[] =
{
  "Im",
  "EI",
  "Lr",
  "DG",
  "Dv",
  "GG",
  "SG",
  "MG",
  "Ip",
  "OI",
  "\n"
};
*/
const char *god_wiznames[] =
{

  "  Imm  ",
  " Elder ",
  "ImmLord",
  "Helper ",
  "Builder",
  " Coder ",
  " Major ",
  "Supreme",
  " Imple ",
  " Owner ",
  "\n"
};

const char *remort_names[] =
{
  " Hunter",
  " Raider",
  " Knight",
  "Avenger",
  " Master",
  " Noble ",
  "  Hero ",
  "Veteran",
  "General",
  " Prince",
  "  King ",
  " Legend",
  "\n"
};

/* cardinal directions */
const char *dirs[] =
{
  "north",
  "east",
  "south",
  "west",
  "up",
  "down",
  "\n"
};

const char *zone_bits[] = {
  "OPEN",
  "CLOSED",
  "!RECALL",
  "!SUMMON",
  "REMORTS"
 };

/* inverse cardinal directions */
const char *from_dir[] =  {
    "the south",
    "the west",
    "the north",
    "the east",
    "below",
    "above",
    "\n"
};

/* ROOM_x */
const char *room_bits[] = {
  "DARK",
  "DEATH",
  "!MOB",
  "INDOORS",
  "PEACEFUL",
  "SOUNDPROOF",
  "!TRACK",
  "!MAGIC",
  "TUNNEL",
  "PRIVATE",
  "GODROOM",
  "HOUSE",
  "HCRSH",
  "ATRIUM",
  "OLC",
  "*",                          /* BFS MARK */
  "ARENA",
  "CHALLENGE",
  "LEARN",
  "TELEPORT",
  "GOOD_REGEN",
  "NO_REGEN_MANA",
  "NO_REGEN_HIT",
  "DONATION",
  "\n"
};

char *teleport_bits[] = {
  "ForceLook",
  "EntryResetsTime",
  "SetsRandomTime",
  "Spin(NOT AVAIL)",
  "HasOBJinInv",
  "NoOBJinInv",
  "NoMesgDisplay",
  "SkipMobs",
  "SkipGroundObjects",
  "\n"
};

/* EX_x */
const char *exit_bits[] = {
  "DOOR",
  "CLOSED",
  "LOCKED",
  "PICKPROOF",
  "\n"
};


/* SECT_ */
const char *sector_types[] = {
  "Inside",
  "City",
  "Field",
  "Forest",
  "Hills",
  "Mountains",
  "Water (Swim)",
  "Water (No Swim)",
  "Underwater",
  "In Flight",
  "\n"
};


/*
 * SEX_x
 * Not used in sprinttype() so no \n.
 */
const char *genders[] =
{
  "Neutral",
  "Male",
  "Female"
};


/* POS_x */
const char *position_types[] = {
  "Dead",
  "Mortally wounded",
  "Incapacitated",
  "Stunned",
  "Sleeping",
  "Resting",
  "Sitting",
  "Fighting",
  "Standing",
  "\n"
};

/* PERM_x */
const char *perm_flags[] =
{
  "BLIND",
  "INVIS",
  "DET-ALIGN",
  "DET-INVIS",
  "DET-MAGIC",
  "SENSE-LIFE",
  "WATWALK",
  "SANCT",
  "GROUP",
  "CURSE",
  "INFRA",
  "POISON",
  "PROT-EVIL",
  "PROT-GOOD",
  "SLEEP",
  "!TRACK",
  "MANA-SHIELD",
  "DAMNED-CURSE",
  "SNEAK",
  "HIDE",
  "HASTE",
  "CHARM",
  "HELD",
  "SATAN_PACT",
  "GOD_PACT",
  "MENTAL",
  "FLY",
  "WGAS",
  "VULCAN",
  "\n"
};

/* PLR_x */
const char *player_bits[] = {
  "KILLER",
  "THIEF",
  "FROZEN",
  "DONTSET",
  "WRITING",
  "MAILING",
  "CSH",
  "SITEOK",
  "NOSHOUT",
  "NOTITLE",
  "DELETED",
  "LOADRM",
  "!WIZL",
  "!DEL",
  "INVST",
  "CRYO",
  "DEAD",
  "!PK",
  "MEDITATE",
  "MESSAGING",
  "\n"
};


/* MOB_x */
const char *action_bits[] = {
  "SPEC",
  "SENTINEL",
  "SCAVENGER",
  "ISNPC",
  "AWARE",
  "AGGR",
  "STAY-ZONE",
  "WIMPY",
  "AGGR_EVIL",
  "AGGR_GOOD",
  "AGGR_NEUTRAL",
  "MEMORY",
  "HELPER",
  "!CHARM",
  "!SUMMN",
  "!SLEEP",
  "!BASH",
  "!BLIND",
  "!TANGLE",
  "CLAN_MOB",
  "!STEAL",
  "!DISARM",
  "\n"
};


/* PRF_x */
const char *preference_bits[] = {
  "BRIEF",
  "COMPACT",
  "DEAF",
  "!TELL",
  "D_HP",
  "D_MANA",
  "D_MOVE",
  "AUTOEXITS",
  "!HASSLE",
  "QUEST",
  "SUMMONABLE",
  "!REPEAT",
  "LIGHT",
  "C1",
  "C2",
  "!WIZNET",
  "L1",
  "L2",
  "!AUCTION",
  "!GOSSIP",
  "!GRATS",
  "D_MAX",
  "CROSSD",
  "AUTOLOOT",
  "AUTOGOLD",
  "AUTOSPLIT",
  "AFK",
  "AUTOASSIST",
  "INFOSTART",
  "D_MENTAL",
  "!CHAT",
  "\n"
};

/* PRF2_x */
const char *preference2_bits[] = {
  "D_EXP",
  "WDPROT",
  "MAP",
  "!REPLY",
  "HOUSERECALL",
  "!CFALAR",
  "!NEWBIE",
  "\n"
};

/* AFF_x */
const char *affected_bits[] =
{
  "BLIND",
  "INVIS",
  "DET-ALIGN",
  "DET-INVIS",
  "DET-MAGIC",
  "SENSE-LIFE",
  "WATWALK",
  "SANCT",
  "GROUP",
  "CURSE",
  "INFRA",
  "POISON",
  "PROT-EVIL",
  "PROT-GOOD",
  "SLEEP",
  "!TRACK",
  "MANA-SHIELD",
  "DAMNED-CURSE",
  "SNEAK",
  "HIDE",
  "HASTE",
  "CHARM",
  "MENTAL",
  "SATAN_PACT",
  "GOD_PACT",
  "REGEN",
  "FLY",
  "WGAS",
  "TANGLED",
  "FIRESHIELD",
  "BERZERK",
  "\n"
};

/* AFF2_x */
const char *affected2_bits[] =
{
  "TRANSFORM",
  "WARSHOUT",
  "TERROR",
  "BANSHEE-AURA",
  "BLINK",
  "DEATHDANCE",
  "PROT_FIRE",
  "PASSDOOR",
  "MORALE",
  "SLOW",
  "MUIR1",
  "MUIR2",
  "MUIR3",
  "ILMA1",
  "ILMA2",
  "ILMA3",
  "SELUNE",
  "\n"
};

/* AFF3_x */
const char *affected3_bits[] =
{
  "SEM-USO",
  "\n"
};

/* CON_x */
const char *connected_types[] = {
  "Playing",
  "Disconnecting",
  "Get name",
  "Confirm name",
  "Get password",
  "Get new PW",
  "Confirm new PW",
  "Select sex",
  "Select class",
  "Reading MOTD",
  "Main Menu",
  "Get descript.",
  "Changing PW 1",
  "Changing PW 2",
  "Changing PW 3",
  "Self-Delete 1",
  "Self-Delete 2",
  "Disconnecting",
  "Object edit",
  "Room edit",
  "Zone edit",
  "Mobile edit",
  "Shop edit",
  "Help edit",
  "Select race",
  "Entering pdesc",
  "Check Terminal",
  "Text edit",
  "Action edit",
  "See summary",
  "Trigger edit",
  "Quest edit",
  "Choose PK",
  "Confirm race",
  "Confirm character",
  "\n"
};


/*
 * WEAR_x - for eq list
 * Not use in sprinttype() so no \n.
 */
const char *where[] = {
  "&C<&cused as light&C>&n      ",
  "&C<&cworn on finger&C>&n     ",
  "&C<&cworn on finger&C>&n     ",
  "&C<&cworn around neck&C>&n   ",
  "&C<&cworn around neck&C>&n   ",
  "&C<&cworn on body&C>&n       ",
  "&C<&cworn on head&C>&n       ",
  "&C<&cworn on legs&C>&n       ",
  "&C<&cworn on feet&C>&n       ",
  "&C<&cworn on hands&C>&n      ",
  "&C<&cworn on arms&C>&n       ",
  "&C<&cworn as shield&C>&n     ",
  "&C<&cworn about body&C>&n    ",
  "&C<&cworn about waist&C>&n   ",
  "&C<&cworn around wrist&C>&n  ",
  "&C<&cworn around wrist&C>&n  ",
  "&C<&cwielded&C>&n            ",
  "&C<&cheld&C>&n               ",
  "&C<&cdual wielded&C>&n       ",
  "&C<&cworn on ear&C>&n        ",
  "&C<&cworn on ear&C>&n        ",
  "&C<&cworn on face&C>&n       ",
  "&C<&cfloating in air&C>&n    "
};


/* WEAR_x - for stat */
const char *equipment_types[] = {
  "Used as light",
  "Worn on right finger",
  "Worn on left finger",
  "First worn around Neck",
  "Second worn around Neck",
  "Worn on body",
  "Worn on head",
  "Worn on legs",
  "Worn on feet",
  "Worn on hands",
  "Worn on arms",
  "Worn as shield",
  "Worn about body",
  "Worn around waist",
  "Worn around right wrist",
  "Worn around left wrist",
  "Wielded",
  "Held",
  "Dual Wielded",
  "Hook on right ear",
  "Hook on left ear",
  "Worn on face",
  "Floating in air",
  "\n"
};

const int wear_order_index[NUM_WEARS] = {
  WEAR_FLOAT,
  WEAR_HEAD,
  WEAR_FACE,
  WEAR_EAR_R,
  WEAR_EAR_L,
  WEAR_NECK_1,
  WEAR_NECK_2,
  WEAR_ABOUT,
  WEAR_BODY,
  WEAR_WAIST,
  WEAR_ARMS,
  WEAR_WRIST_R,
  WEAR_WRIST_L,
  WEAR_HANDS,
  WEAR_FINGER_R,
  WEAR_FINGER_L,
  WEAR_WIELD,
  WEAR_DWIELD,
  WEAR_HOLD,
  WEAR_LIGHT,
  WEAR_SHIELD,
  WEAR_LEGS,
  WEAR_FEET
};

/* ITEM_x (ordinal object types) */
const char *item_types[] = {
  "UNDEFINED",
  "LIGHT",
  "SCROLL",
  "WAND",
  "STAFF",
  "WEAPON",
  "FIRE WEAPON",
  "MISSILE",
  "TREASURE",
  "ARMOR",
  "POTION",
  "WORN",
  "OTHER",
  "TRASH",
  "TRAP",
  "CONTAINER",
  "NOTE",
  "LIQ CONTAINER",
  "KEY",
  "FOOD",
  "MONEY",
  "PEN",
  "BOAT",
  "FOUNTAIN",
  "\n"
};


/* ITEM_WEAR_ (wear bitvector) */
const char *wear_bits[] = {
  "TAKE",
  "FINGER",
  "NECK",
  "BODY",
  "HEAD",
  "LEGS",
  "FEET",
  "HANDS",
  "ARMS",
  "SHIELD",
  "ABOUT",
  "WAIST",
  "WRIST",
  "WIELD",
  "HOLD",
  "EAR",
  "FACE",
  "FLOAT",
  "\n"
};


/* ITEM_x (extra bits) */
const char *extra_bits[] = {
  "GLOW",
  "HUM",
  "!RENT",
  "!DONATE",
  "!INVIS",
  "INVISIBLE",
  "MAGIC",
  "!DROP",
  "BLESS",
  "!GOOD",
  "!EVIL",
  "!NEUTRAL",
  "!SORCERER",
  "!CLERIC",
  "!THIEF",
  "!WARRIOR",
  "!SELL",
  "!NECROMANCER",
  "!PALADIN",
  "!NINJA",
  "!RANGER",
  "!PSIONICIST",
  "!WARLOCK",
  "!SHAMAN",
  "!BARBARIAN",
  "!VAMPIRE",
  "!DROW",
  "!DWARF!",
  "!ELF",
  "!OGRE",
  "!ORC",
  "!TROLL",
  "!GITH",
  "!GNOME",
  "!LIZARDMAN",
  "!SEAELF",
  "!GORAK",
  "\n"
};


/* APPLY_x */
const char *apply_types[] = {
  "NONE",
  "STR",
  "DEX",
  "INT",
  "WIS",
  "CON",
  "CHA",
  "CLASS",
  "LEVEL",
  "AGE",
  "CHAR_WEIGHT",
  "CHAR_HEIGHT",
  "MAXMANA",
  "MAXHIT",
  "MAXMOVE",
  "GOLD",
  "EXP",
  "ARMOR",
  "HITROLL",
  "DAMROLL",
  "SAVING_PARA",
  "SAVING_ROD",
  "SAVING_PETRI",
  "SAVING_BREATH",
  "SAVING_SPELL",
  "\n"
};


/* CONT_x */
const char *container_bits[] = {
  "CLOSEABLE",
  "PICKPROOF",
  "CLOSED",
  "LOCKED",
  "\n",
};


/* LIQ_x */
const char *drinks[] =
{
  "water",
  "beer",
  "wine",
  "ale",
  "dark ale",
  "whisky",
  "lemonade",
  "firebreather",
  "local speciality",
  "slime mold juice",
  "milk",
  "tea",
  "coffee",
  "blood",
  "salt water",
  "clear water",
  "\n"
};


/* other constants for liquids ******************************************/


/* one-word alias for each drink */
const char *drinknames[] =
{
  "water",
  "beer",
  "wine",
  "ale",
  "ale",
  "whisky",
  "lemonade",
  "firebreather",
  "local",
  "juice",
  "milk",
  "tea",
  "coffee",
  "blood",
  "salt",
  "water",
  "\n"
};


/* effect of drinks on hunger, thirst, and drunkenness -- see values.doc */
int drink_aff[][3] = {
  {0, 1, 10},
  {3, 2, 5},
  {5, 2, 5},
  {2, 2, 5},
  {1, 2, 5},
  {6, 1, 4},
  {0, 1, 8},
  {10, 0, 0},
  {3, 3, 3},
  {0, 4, -8},
  {0, 3, 6},
  {0, 1, 6},
  {0, 1, 6},
  {0, 2, -1},
  {0, 1, -2},
  {0, 0, 13}
};


/* color of the various drinks */
const char *color_liquid[] =
{
  "clear",
  "brown",
  "clear",
  "brown",
  "dark",
  "golden",
  "red",
  "green",
  "clear",
  "light green",
  "white",
  "brown",
  "black",
  "red",
  "clear",
  "crystal clear",
  "\n"
};


/*
 * level of fullness for drink containers
 * Not used in sprinttype() so no \n.
 */
const char *fullness[] =
{
  "less than half ",
  "about half ",
  "more than half ",
  ""
};


/* str, int, wis, dex, con applies **************************************/


/* [ch] strength apply (all) */
cpp_extern const struct str_app_type str_app[] = {
  {-5, -4, 0, 0},       /* str = 0 */
  {-5, -4, 10, 1},       /* str = 1 */
  {-3, -2, 25, 2},
  {-3, -1, 50, 3},
  {-2, -1, 100, 4},
  {-2, -1, 120, 5},      /* str = 5 */
  {-1, 0,140, 6},
  {-1, 0,160, 7},
  {0, 0, 180, 8},
  {0, 0, 200, 9},
  {0, 0, 250, 10},      /* str = 10 */
  {0, 0, 300, 11},
  {0, 0, 350, 12},
  {0, 0, 400, 13},
  {0, 0, 450, 14},
  {0, 0, 500, 15},      /* str = 15 */
  {0, 1, 550, 16},
  {1, 1, 600, 18},
  {1, 2, 650, 20},      /* str = 18 */
  {3, 7, 960, 40},
  {3, 8, 970, 40},      /* str = 20 */
  {4, 9, 980, 40},
  {4, 10, 1000, 40},
  {5, 11, 1100, 40},
  {6, 12, 1200, 40},
  {7, 14, 1500, 40},    /* str = 25 */
  {1, 3, 680, 21},      /* str = 18/10*/
  {2, 3, 710, 22},      /* str = 18/20*/
  {2, 4, 740, 23},      /* str = 18/30*/
  {3, 4, 770, 24},      /* str = 18/40*/
  {3, 5, 800, 25},      /* str = 18/50*/
  {3, 6, 830, 26},      /* str = 18/60*/
  {4, 6, 860, 27},      /* str = 18/70*/
  {4, 7, 890, 28},      /* str = 18/80*/
  {5, 7, 920, 29},      /* str = 18/90*/
  {5, 8, 950, 30}       /* str = 18/100*/
};



/* [dex] skill apply (thieves only) */
cpp_extern const struct dex_skill_type dex_app_skill[] = {
  {-99, -99, -90, -99, -60},    /* dex = 0 */
  {-90, -90, -60, -90, -50},    /* dex = 1 */
  {-80, -80, -40, -80, -45},
  {-70, -70, -30, -70, -40},
  {-60, -60, -30, -60, -35},
  {-50, -50, -20, -50, -30},    /* dex = 5 */
  {-40, -40, -20, -40, -25},
  {-30, -30, -15, -30, -20},
  {-20, -20, -15, -20, -15},
  {-15, -10, -10, -20, -10},
  {-10, -5, -10, -15, -5},      /* dex = 10 */
  {-5, 0, -5, -10, 0},
  {0, 0, 0, -5, 0},
  {0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0},              /* dex = 15 */
  {0, 5, 0, 0, 0},
  {5, 10, 0, 5, 5},
  {10, 15, 5, 10, 10},          /* dex = 18 */
  {15, 20, 10, 15, 15},
  {15, 20, 10, 15, 15},         /* dex = 20 */
  {20, 25, 10, 15, 20},
  {20, 25, 15, 20, 20},
  {25, 25, 15, 20, 20},
  {25, 30, 15, 25, 25},
  {25, 30, 15, 25, 25}          /* dex = 25 */
};



/* [dex] apply (all) */
cpp_extern const struct dex_app_type dex_app[] = {
  {-7, -7, 6},          /* dex = 0 */
  {-6, -6, 5},          /* dex = 1 */
  {-4, -4, 5},
  {-3, -3, 4},
  {-2, -2, 3},
  {-1, -1, 2},          /* dex = 5 */
  {0, 0, 1},
  {0, 0, 0},
  {0, 0, 0},
  {0, 0, 0},
  {0, 0, 0},            /* dex = 10 */
  {0, 0, 0},
  {0, 0, 0},
  {0, 0, 0},
  {0, 0, 0},
  {0, 0, -1},           /* dex = 15 */
  {1, 1, -2},
  {2, 2, -3},
  {2, 2, -4},           /* dex = 18 */
  {3, 3, -4},
  {3, 3, -4},           /* dex = 20 */
  {4, 4, -5},
  {4, 4, -5},
  {4, 4, -5},
  {5, 5, -6},
  {5, 5, -6}            /* dex = 25 */
};



/* [con] apply (all) */
cpp_extern const struct con_app_type con_app[] = {
  {-4, 20},             /* con = 0 */
  {-3, 25},             /* con = 1 */
  {-2, 30},
  {-2, 35},
  {-1, 40},
  {-1, 45},             /* con = 5 */
  {-1, 50},
  {0, 55},
  {0, 60},
  {0, 65},
  {0, 70},              /* con = 10 */
  {0, 75},
  {0, 80},
  {0, 85},
  {0, 88},
  {1, 90},              /* con = 15 */
  {2, 95},
  {2, 97},
  {3, 99},              /* con = 18 */
  {3, 99},
  {4, 99},              /* con = 20 */
  {5, 99},
  {5, 99},
  {5, 99},
  {6, 99},
  {6, 99}               /* con = 25 */
};



/* [int] apply (all) */
cpp_extern const struct int_app_type int_app[] = {
  {3},          /* int = 0 */
  {5},          /* int = 1 */
  {7},
  {8},
  {9},
  {10},         /* int = 5 */
  {11},
  {12},
  {13},
  {15},
  {17},         /* int = 10 */
  {19},
  {22},
  {25},
  {30},
  {35},         /* int = 15 */
  {40},
  {45},
  {50},         /* int = 18 */
  {53},
  {55},         /* int = 20 */
  {56},
  {57},
  {58},
  {59},
  {60}          /* int = 25 */
};


/* [wis] apply (all) */
cpp_extern const struct wis_app_type wis_app[] = {
  {0},  /* wis = 0 */
  {0},  /* wis = 1 */
  {0},
  {0},
  {0},
  {0},  /* wis = 5 */
  {0},
  {0},
  {0},
  {0},
  {0},  /* wis = 10 */
  {0},
  {2},
  {2},
  {3},
  {3},  /* wis = 15 */
  {3},
  {4},
  {5},  /* wis = 18 */
  {6},
  {6},  /* wis = 20 */
  {6},
  {6},
  {7},
  {7},
  {7}  /* wis = 25 */
};



const char *spell_wear_off_msg[] = {
  "RESERVED DB.C",              /* 0 */
  "You feel less protected.",   /* 1 */
  "!Teleport!",
  "You feel less righteous.",
  "You feel a cloak of blindness disolve.",
  "!Burning Hands!",            /* 5 */
  "!Call Lightning",
  "You feel more self-confident.",
  "You feel your strength return.",
  "!Clone!",
  "!Color Spray!",              /* 10 */
  "!Control Weather!",
  "!Create Food!",
  "!Create Water!",
  "!Cure Blind!",
  "!Cure Critic!",              /* 15 */
  "!Cure Light!",
  "You feel more optimistic.",
  "You feel less aware.",
  "Your eyes stop tingling.",
  "The detect magic wears off.",/* 20 */
  "The detect poison wears off.",
  "!Dispel Evil!",
  "!Earthquake!",
  "!Enchant Weapon!",
  "!Energy Drain!",             /* 25 */
  "!Fireball!",
  "!Harm!",
  "!Heal!",
  "You feel yourself exposed.",
  "!Lightning Bolt!",           /* 30 */
  "!Locate object!",
  "!Magic Missile!",
  "You feel less sick.",
  "You feel less protected.",
  "!Remove Curse!",             /* 35 */
  "The white aura around your body fades.",
  "!Shocking Grasp!",
  "You feel less tired.",
  "You feel weaker.",
  "!Summon!",                   /* 40 */
  "!Ventriloquate!",
  "!Word of Recall!",
  "!Remove Poison!",
  "You feel less aware of your suroundings.",
  "!Animate Dead!",             /* 45 */
  "!Dispel Good!",
  "!Group Armor!",
  "!Group Heal!",
  "!Group Recall!",
  "Your night vision seems to fade.",   /* 50 */
  "Your feet seem less boyant.",
  "Your mana shield slowly fades out of existence.",
  "You feel really better!",
  "!Refresh!",
  "You feel slower.", /* 55 */
  "!REGENERATION!",
  "!MENTAL RAGE!",
  "The yellow aura around your body fades.",
  "The red aura around your body fades.",
  "!ENDWORLD!", /* 60 */
  "You starts to move slower...",
  "!SATANICCURE!",
  "Your feets slowly touch the floor.",
  "You feel you are not thirsty of blood now.",
  "You are finally free of the vines that bind.", /* 65 */
  "Your magic shield fades away happily.",
  "Your feel yourself normal again.",
  "!ICESTORM!",
  "!METEORSTORM!",
  "!FIRESTORM!", /* 70 */
  "Your force shield fades away happily.",
  "You feel your protection fading.",
  "!REVITALIZE!",
  "!GOLEM!",
  "!ILLUSION!", /* 75 */
  "The fog seams to clear out.",
  "The fire wall disappear in the air.",
  "The ice wall melts by your eyes.",
  "!MANASWORD!",
  "!POISONWEAPON!", /* 80 */
  "!FIREBOLT!",
  "!ICEBOLT!",
  "!FARSIGHT!",
  "!ELEMENTAL!",
  "!GREASE",   /* 85 */
  "!CROMATIC_ORB",
  "!FLAMEARROW",
  "You feel yourself fast.",
  "!ELETRICSTORM",
  "You feel your skin normal.",  /* 90 */
  "You feel your skin normal.",
  "You feel your skin normal.",
  "!ACIDARROW",
  "!MINUTE_METEOR",
  "!CONE_OF_COLD",  /* 95 */
  "!AREA_LIGHTNING",
  "!FIRE_SPIT",
  "!GAS_SPIT",
  "!FROST_SPIT",
  "!ACID_SPIT",    /* 100 */
  "!LIGHTNING_SPIT",
  "!BLADEBARRIER",
  "!PRIZMATIC_SPHERE",
  "!ARMAGEDDOM",
  "!DELAYED_FIREBALL",     /* 105*/
  "You feel you arent charismatic anymore.",
  "You feel smarter.",
  "The phantoms leave you.",
  "Your spectral wings vanish and you fall to the ground.",
  "You feel your fighting ability decrease.", /* 110 */
  "You no longer feel like you can take on an army.",
  "!HOLY_MACE",
  "!Death scythe!",
  "!Simulacrum!",
  "Your fear is gone.",/* 115 */
  "!Death finger!",
  "Darkness leaves your body.",
  "The banshee aura no longer exists.",
  "!SIPHON_LIFE!",
  "You feel more in tune with your surroundings.",/* 120 */
  "!Meteor Shower!",
  "!Holy Word!",
  "!Holy Shout!",
  "You feel your life force return to you!",
  "!Death Ripple!",/* 125 */
  "!Death Wave!",
  "!Peace!",
  "You feel less insulated.",
  "!Group Fly!",
  "You feel yourself becoming solid again.", //130
  "Your fear fades.",
  "The minor globe no longer protects you.",
  "The major globe no longer protects you.",
  "!Phanton flame!",
  "You no longer needs to sacrifice yourself.",     //135
  "!Skull trap!",
  "Your strength returns.",
  "Your strength returns.",
  "The pestilence leaves your body.",
  "The antimagic shell no longer protects you.", //140
  "!Holy Bolt!",
  "!Dispel Neutral!",
  "!Shilelaugh!",
  "!Magic Stone!",
  "!Command!",     //145
  "You are no longer held.",
  "!Volcano!",
  "!Geyser!",
  "The group bless no longer works.",
  "!Corpor Trembling!",           // 150
  "!Ice Heart!",
  "!Poltersgeist!",
  "!Blizzard!",
  "!Create Light!",
  "Your eyes return to normal.",    // 155
  "!Create Flames!",
  "Your ears return to normal.",
  "!Winged Knife!",
  "Your strength returns to its original form.",
  "!Ego Whip!",    // 160
  "!Project force!",
  "!Wrench!",
  "The lights leave your eyes.",
  "!Balistic Attack!",
  "Your invisibility no longer exists.", // 165
  "!Detonate!",
  "The aversion leaves your body, you can fight now.",
  "!Psychic Ray!",
  "!Molec Agitation!",
  "Your empathy no longer exists.",       //170
  "The thought shield no longer protects you.",
  "The biofeedback no longer protects you.",
  "The barrier of mental forcer no longer protects you.",
  "The inertial barrier no longer protects you.",
  "The cell adjustment is over.",  //175
  "You are no longer concentrated.",
  "You lost your conviction.",
  "You lost your holy shield.",
  "!Lay on hands!",
  "!Cure Serious!",           // 180
  "!Remove Fear!",
  "The flesh armor leaves your body.",
  "You are no longer confused.",
  "You lost your bravery.",
  "!Rigid Thinking!",      //185
  "The power of Paradi Chrysalis leaves your soul.",
  "The power of Abutilion leaves your soul.",
  "The helper aura vanishes.",
  "You no longer fells pain.",
  "Your body is not displaced anymore.",  //190
  "Your wisdom return to normal.",
  "!Life Drainning!",
  "Your body is no longer a weapon.",
  "You lost the equilibrium of your body.",
  "Your dexterity returns to normal.",  //195
  "!Lend Health!",
  "Your mind is no longer in combat mode.",
  "!Psyonic blast!",
  "!Psyonic drain!",
  "You are no longer in martial trance.",  //200
  "!Post Hypno!",
  "!Astral Projection!",
  "!ULTIMA!",
  "!Summon Bahamut!",
  "You feel your skin back to normal.",//205
  "!CALL_BEAR!",
  "The power of Muir fades!",
  "The power of Ilmanateur fades",
  "The power of Selune fades",
  "!SPELL_HELM!",
  "!SPELL_TALOS!",
  "!SPELL_OGHMA!",
  "\n"
};


const char *npc_class_types[] = {
  "Normal",
  "Undead",
  "Dragon",
  "Demon",
  "Spirit",
  "Animal",
  "Human",
  "Giant",
  "\n"
};

const char *npc_class_abbrevs[] = {
  "Nm",
  "Un",
  "Dr",
  "De",
  "Sp",
  "An",
  "Hu",
  "Gi",
  "\n"
};



int rev_dir[] =
{
  2,
  3,
  0,
  1,
  5,
  4
};


int movement_loss[] =
{
  1,    /* Inside     */
  1,    /* City       */
  2,    /* Field      */
  3,    /* Forest     */
  4,    /* Hills      */
  6,    /* Mountains  */
  4,    /* Swimming   */
  1,    /* Unswimable */
  1,    /* Flying     */
  5     /* Underwater */
};

#if defined(OASIS_MPROG)
/*
 * Definitions necessary for MobProg support in OasisOLC
 */
const char *mobprog_types[] = {
  "INFILE",
  "ACT",
  "SPEECH",
  "RAND",
  "FIGHT",
  "DEATH",
  "HITPRCNT",
  "ENTRY",
  "GREET",
  "ALL_GREET",
  "GIVE",
  "BRIBE",
  "\n"
};
#endif

/* Not used in sprinttype(). */
const char *weekdays[] = {
  "the Day of the Moon",
  "the Day of the Bull",
  "the Day of the Deception",
  "the Day of Thunder",
  "the Day of Freedom",
  "the day of the Great Gods",
  "the Day of the Sun"
};


/* Not used in sprinttype(). */
const char *month_name[] = {
  "Month of Winter",            /* 0 */
  "Month of the Winter Wolf",
  "Month of the Frost Giant",
  "Month of the Old Forces",
  "Month of the Grand Struggle",
  "Month of the Spring",
  "Month of Nature",
  "Month of Futility",
  "Month of the Dragon",
  "Month of the Sun",
  "Month of the Heat",
  "Month of the Battle",
  "Month of the Dark Shades",
  "Month of the Shadows",
  "Month of the Long Shadows",
  "Month of the Ancient Darkness",
  "Month of the Great Evil"
};

const char *pc_clsl_types[] = {
  "[A]    &CSorcerer&n	",
  "[B]    &BCleric&n	",
  "[C]    &GThief&n 	",
  "[D]    &rWarrior&n	",
  "[E]    &WNecromancer&n	",
  "[F]    &yPaladin&n	",
  "[G]    &cNinja&n 	",
  "[H]    &YRanger&n	",
  "[I]    &gPsionicist&n	",
  "[J]    &mWarlock&n	",
  "[L]    &RBarbarian&n	",
  "[M]    &bShaman&n	",
  "\n"
};

const char *room_affections[] = {
	"FOG",
	"FIREWALL",
	"ICEWALL",
	"\n"
};

const char *class_types[] = {
  "Undefined",
  "Sorcerer",
  "Cleric",
  "Thief",
  "Warrior",
  "Necromancer",
  "Paladin",
  "Ninja",
  "Ranger",
  "Psionicist",
  "Warlock",
  "Barbarian",
  "Shaman",
  "\n"
};

const char *race_types[] = {
  "Undefined",
  "Vampire",
  "Drow",
  "Dwarf",
  "Elf",
  "Ogre",
  "Orc",
  "Troll",
  "Gith",
  "Gnome",
  "Lizardman",
  "Seaelf",
  "Gorak",
  "Dunedain",
  "AncientDrow",
  "Naugrim",
  "HighElf",
  "HillOgre",
  "BugBear",
  "CaveTroll",
  "Lich",
  "Tinker",
  "Draconian",
  "HighSeaElf",
  "Archons",
  "\n"
};
::::::::::::::
db.c
::::::::::::::
/* ************************************************************************
*   File: db.c                                          Part of CircleMUD *
*  Usage: Loading/saving chars, booting/resetting world, internal funcs   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __DB_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "handler.h"
#include "spells.h"
#include "mail.h"
#include "interpreter.h"
#include "house.h"
#include "olc.h"
#include "clan.h"
#include "dg_scripts.h"
#include "quest.h"
#include "diskio.h"
#include "pfdefaults.h"

/**************************************************************************
*  declarations of most of the 'global' variables                         *
**************************************************************************/

extern const char *god_wiznames;

struct room_data *world = NULL; /* array of rooms                */
int top_of_world = 0;           /* ref to top element of world   */
struct raff_node *raff_list = NULL;  /* list of room affections */

struct char_data *character_list = NULL; /* global linked list of chars */

struct index_data **trig_index; /* index table for triggers      */
int top_of_trigt = 0;           /* top of trigger index table    */
long max_id = MOBOBJ_ID_BASE;   /* for unique mob/obj id's       */

struct index_data *mob_index;   /* index table for mobile file   */
struct char_data *mob_proto;    /* prototypes for mobs           */
int top_of_mobt = 0;            /* top of mobile index table     */

struct obj_data *object_list = NULL;    /* global linked list of objs    */
struct index_data *obj_index;   /* index table for object file   */
struct obj_data *obj_proto;     /* prototypes for objs           */
int top_of_objt = 0;            /* top of object index table     */

struct zone_data *zone_table;   /* zone table                    */
int top_of_zone_table = 0;      /* top element of zone tab       */
struct message_list fight_messages[MAX_MESSAGES];       /* fighting messages     */
struct aq_data *aquest_table;
int top_of_aquestt = 0;

struct player_index_element *player_table = NULL;       /* index to plr file     */
int top_of_p_table = 0;         /* ref to top of table           */
int top_of_p_file = 0;          /* ref of size of p file         */
long top_idnum = 0;             /* highest idnum in use          */

int no_mail = 0;                /* mail disabled?                */
int mini_mud = 0;               /* mini-mud mode?                */
int no_rent_check = 0;          /* skip rent check on boot?      */
time_t boot_time = 0;           /* time of mud boot              */
int circle_restrict = 0;        /* level of game restriction     */
sh_int r_mortal_start_room;     /* rnum of mortal start room     */
sh_int r_immort_start_room;     /* rnum of immort start room     */
sh_int r_frozen_start_room;     /* rnum of frozen start room     */
sh_int r_deadly_start_room;     /* rnum of frozen start room     */
sh_int total_p = 0;		/* who max 			 */

// Fenix - WHS
byte number_of_small_houses = 0;               /* Number of remaining small houses */
byte number_of_medium_houses = 0;               /* Number of remaining medium houses */
byte number_of_large_houses = 0;               /* Number of remaining large houses */

char *credits = NULL;           /* game credits                  */
char *news = NULL;              /* mud news                      */
char *motd = NULL;              /* message of the day - mortals */
char *imotd = NULL;             /* message of the day - immorts */
char *help = NULL;              /* help screen                   */
char *info = NULL;              /* info page                     */
char *wizlist = NULL;           /* list of higher gods           */
char *immlist = NULL;           /* list of peon gods             */
char *background = NULL;        /* background story              */
char *handbook = NULL;          /* handbook for new immortals    */
char *policies = NULL;          /* policies page                 */
char *bugs = NULL;              /* bugs page	                 */
char *typos = NULL;             /* typos page	                 */
char *ideas = NULL;             /* ideas page	                 */

struct help_index_element *help_table = 0;      /* the help table        */
int top_of_helpt = 0;           /* top of help index table       */

struct time_info_data time_info;/* the infomation about the time    */
struct weather_data weather_info;       /* the infomation about the weather */
struct player_special_data dummy_mob;   /* dummy spec area for mobs     */
struct reset_q_type reset_q;    /* queue of zones to be reset    */
struct message_data mess_info;  /* the information about the message */

struct quest_eqs *eqs_quest;
int top_qeq_table = 0;

/* local functions */
void setup_dir(FILE * fl, int room, int dir);
void index_boot(int mode);
void discrete_load(FILE * fl, int mode, char *filename);
void parse_quest(FILE * quest_f, int nr);
void parse_trigger(FILE *fl, int virtual_nr);
void parse_room(FILE * fl, int virtual_nr);
void parse_mobile(FILE * mob_f, int nr);
char *parse_object(FILE * obj_f, int nr);
void load_zones(FILE * fl, char *zonename);
void load_help(FILE *fl);
void assign_mobiles(void);
void assign_objects(void);
void assign_rooms(void);
void assign_the_shopkeepers(void);
void build_player_index(void);
int is_empty(int zone_nr);
void reset_zone(int zone);
int file_to_string(const char *name, char *buf);
int file_to_string_alloc(const char *name, char **buf);
void reboot_wizlists(void);
ACMD(do_reboot);
void boot_world(void);
int count_alias_records(FILE *fl);
int count_hash_records(FILE * fl);
long asciiflag_conv(char *flag);
void parse_simple_mob(FILE *mob_f, int i, int nr);
void interpret_espec(const char *keyword, const char *value, int i, int nr);
void parse_espec(char *buf, int i, int nr);
void parse_enhanced_mob(FILE *mob_f, int i, int nr);
void get_one_line(FILE *fl, char *buf);
void save_etext(struct char_data * ch);
void check_start_rooms(void);
void renum_world(void);
void renum_zone_table(void);
void log_zone_error(int zone, int cmd_no, const char *message);
void reset_time(void);
void save_char_file_u(struct char_file_u st);
void load_qeq_file();

/* external functions */
struct time_info_data *mud_time_passed(time_t t2, time_t t1);
void free_alias(struct alias * a);
void load_messages(void);
void weather_and_time(int mode);
void mag_assign_spells(void);
void boot_social_messages(void);
void create_command_list(void);
void update_obj_file(void);     /* In objsave.c */
void sort_commands(void);
void sort_spells(void);
void load_banned(void);
void Read_Invalid_List(void);
void boot_the_shops(FILE * shop_f, char *filename, int rec_count);
int find_name(char *name);
void read_quest(FILE * fp, int mob);
void read_mud_date_from_file(void);
void sprintbits(long vektor, char *outstring);
void tag_argument(char *argument, char *tag);
void clean_pfiles(void);
void stop_follower(struct char_data * ch);
void count_houses(void);
void init_room_sizes(void);

/* external vars */
extern int no_specials;
extern sh_int mortal_start_room;
extern sh_int immort_start_room;
extern sh_int frozen_start_room;
extern sh_int deadly_start_room;
extern struct descriptor_data *descriptor_list;
extern int min_wizlist_lev;

/* external ascii pfile vars */
extern struct pclean_criteria_data pclean_criteria[];
extern int selfdelete_fastwipe;
extern int auto_pwipe;

/* ascii pfiles - set this TRUE if you want poofin/poofout
   strings saved in the pfiles
*/
#define ASCII_SAVE_POOFS	FALSE

#define READ_SIZE 256

/*************************************************************************
*  routines for booting the system                                       *
*************************************************************************/

/* this is necessary for the autowiz system */
void reboot_wizlists(void)
{
  file_to_string_alloc(WIZLIST_FILE, &wizlist);
  file_to_string_alloc(IMMLIST_FILE, &immlist);
}


ACMD(do_reboot)
{
  int i;

  one_argument(argument, arg);

  if (!str_cmp(arg, "all") || *arg == '*') {
    sprintf(buf, "nice ../bin/autowiz %d %s %d %s %d &", min_wizlist_lev,
            WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
    mudlog("Initiating autowiz.", CMP, LVL_IMMORT, FALSE);
    system(buf);
//    file_to_string_alloc(WIZLIST_FILE, &wizlist);
//    file_to_string_alloc(IMMLIST_FILE, &immlist);
    file_to_string_alloc(NEWS_FILE, &news);
    file_to_string_alloc(CREDITS_FILE, &credits);
    file_to_string_alloc(MOTD_FILE, &motd);
    file_to_string_alloc(IMOTD_FILE, &imotd);
    file_to_string_alloc(HELP_PAGE_FILE, &help);
    file_to_string_alloc(INFO_FILE, &info);
    file_to_string_alloc(POLICIES_FILE, &policies);
    file_to_string_alloc(HANDBOOK_FILE, &handbook);
    file_to_string_alloc(BACKGROUND_FILE, &background);
  }
  else if (!str_cmp(arg, "wizlist")) {
    sprintf(buf, "nice ../bin/autowiz %d %s %d %s %d &", min_wizlist_lev,
            WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
    mudlog("Initiating autowiz.", CMP, LVL_IMMORT, FALSE);
    system(buf);
//    file_to_string_alloc(WIZLIST_FILE, &wizlist);
  }
  else if (!str_cmp(arg, "immlist")) {
    sprintf(buf, "nice ../bin/autowiz %d %s %d %s %d &", min_wizlist_lev,
            WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
    mudlog("Initiating autowiz.", CMP, LVL_IMMORT, FALSE);
    system(buf);
//    file_to_string_alloc(IMMLIST_FILE, &immlist);
  }
  else if (!str_cmp(arg, "news"))
    file_to_string_alloc(NEWS_FILE, &news);
  else if (!str_cmp(arg, "credits"))
    file_to_string_alloc(CREDITS_FILE, &credits);
  else if (!str_cmp(arg, "motd"))
    file_to_string_alloc(MOTD_FILE, &motd);
  else if (!str_cmp(arg, "imotd"))
    file_to_string_alloc(IMOTD_FILE, &imotd);
  else if (!str_cmp(arg, "help"))
    file_to_string_alloc(HELP_PAGE_FILE, &help);
  else if (!str_cmp(arg, "info"))
    file_to_string_alloc(INFO_FILE, &info);
  else if (!str_cmp(arg, "policy"))
    file_to_string_alloc(POLICIES_FILE, &policies);
  else if (!str_cmp(arg, "handbook"))
    file_to_string_alloc(HANDBOOK_FILE, &handbook);
  else if (!str_cmp(arg, "background"))
    file_to_string_alloc(BACKGROUND_FILE, &background);
  else if (!str_cmp(arg, "xhelp")) {
    if (help_table) {
      for (i = 0; i <= top_of_helpt; i++) {
       if (help_table[i].keywords)
	  free(help_table[i].keywords);
       if (help_table[i].entry)
          free(help_table[i].entry);
      }
      free(help_table);
    }
    top_of_helpt = 0;
    index_boot(DB_BOOT_HLP);
  } else {
    send_to_char("Unknown reload option.\r\n"
                 "Type HELP RELOAD for more info.\r\n", ch);
    return;
  }

  send_to_char(OK, ch);
}


void boot_world(void)
{

  log("Loading zone table.");
  index_boot(DB_BOOT_ZON);

  log("Loading triggers and generating index.");
  index_boot(DB_BOOT_TRG);

  log("Loading rooms.");
  index_boot(DB_BOOT_WLD);

  load_qeq_file();
  log("Loading questmaster.");

  log("Renumbering rooms.");
  renum_world();

  log("Checking start rooms.");
  check_start_rooms();

  log("Loading mobs and generating index.");
  index_boot(DB_BOOT_MOB);


  log("Loading objs and generating index.");
  index_boot(DB_BOOT_OBJ);

  log("Renumbering zone table.");
  renum_zone_table();

  if (!no_specials) {
    log("Loading shops.");
    index_boot(DB_BOOT_SHP);
  }
#if 1
  log("Loading quests.");
  index_boot(DB_BOOT_QST);
#endif


}



/* body of the booting system */
void boot_db(void)
{
  int i;

  log("Boot db -- BEGIN.");
 // leak_logging = 0;

  log("Resetting the game time:");
  reset_time();

  log("Reading news, credits, help, bground, info & motds.");
  file_to_string_alloc(NEWS_FILE, &news);
  file_to_string_alloc(CREDITS_FILE, &credits);
  file_to_string_alloc(MOTD_FILE, &motd);
  file_to_string_alloc(IMOTD_FILE, &imotd);
  file_to_string_alloc(HELP_PAGE_FILE, &help);
  file_to_string_alloc(INFO_FILE, &info);
  file_to_string_alloc(WIZLIST_FILE, &wizlist);
  file_to_string_alloc(IMMLIST_FILE, &immlist);
  file_to_string_alloc(POLICIES_FILE, &policies);
  file_to_string_alloc(HANDBOOK_FILE, &handbook);
  file_to_string_alloc(BACKGROUND_FILE, &background);

  boot_world();

  log("Loading help entries.");
  index_boot(DB_BOOT_HLP);

  log("Generating player index.");
  build_player_index();

  if(auto_pwipe) {
    log("Cleaning out the pfiles.");
    clean_pfiles();
  }

  log("Loading fight messages.");
  load_messages();

  log("Loading social messages.");
  boot_social_messages();

  log("Loading message of the day for who list.");
  read_message_from_file();

  create_command_list(); /* aedit patch -- M. Scott */

  log("Assigning function pointers:");

  if (!no_specials) {
    log("   Mobiles.");
    assign_mobiles();
    log("   Shopkeepers.");
    assign_the_shopkeepers();
    log("   Objects.");
    assign_objects();
    log("   Rooms.");
    assign_rooms();
  }
  log("   Spells.");
  mag_assign_spells();

  log("Assigning spell and skill levels.");
  init_spell_levels();

  log("Sorting command list and spells.");
  sort_commands();
  sort_spells();

  log("Booting mail system.");
  if (!scan_file()) {
    log("    Mail boot failed -- Mail system disabled");
    no_mail = 1;
  }

 // leak_logging = 0;

  log("Reading banned site and invalid-name list.");
  load_banned();
  Read_Invalid_List();

  if (!no_rent_check) {
    log("Deleting timed-out crash and rent files:");
    update_obj_file();
    log("Done.");
  }

  log("Booting clans.");
  carregar_clans();

  for (i = 0; i <= top_of_zone_table; i++) {
    log("Resetting %s (rooms %d-%d).", zone_table[i].name,
        (i ? (zone_table[i - 1].top + 1) : 0), zone_table[i].top);
    reset_zone(i);
  }

  /* Moved here so the object limit code works. -gg 6/24/98 */
  if (!mini_mud) {
	  log("Booting houses.");
	  House_boot();
  }

  reset_q.head = reset_q.tail = NULL;

  boot_time = time(0);

  log("Boot db -- DONE.");

 // leak_logging = 1;
}

void write_message_to_file(void)
{
  FILE *message_file;
  extern struct message_data mess_info;
  struct message_data write_message;

  message_file = fopen("etc/who.motd", "w");
  if(!message_file) {
    log("SYSERR: Failed to open file etc/who.motd in write_message_to_file.");
    return;
  }
  if (mess_info.writer)
    strcpy(write_message.writer, mess_info.writer);
    else {
      write_message.writer[0] = '\0';
      write_message.message[0] = '\0';
      mess_info.time = 0;
    }
  if (mess_info.message)
    strcpy(write_message.message, mess_info.message);
    else {
      write_message.writer[0] = '\0';
      write_message.message[0] = '\0';
      mess_info.time = 0;
    }
  if (mess_info.time)
    write_message.time = mess_info.time;
    else {
      write_message.writer[0] = '\0';
      write_message.message[0] = '\0';
      mess_info.time = 0;
    }
  fwrite(&write_message, sizeof(struct message_data), 1, message_file);
  fclose(message_file);
}

void read_message_from_file(void)
{
  extern struct message_data mess_info;
  FILE *message_file;
  struct message_data read_message;

  message_file = fopen("etc/who.motd", "r");
  if(!message_file) {
    log("SYSERR: Failed to open file etc/who.motd in read_message_from_file.");
    return;
  }
  fread(&read_message, sizeof(struct message_data), 1, message_file);
  strcpy(mess_info.writer, read_message.writer);
  strcpy(mess_info.message, read_message.message);
  mess_info.time = read_message.time;
  fclose(message_file);
}

/* reset the time in the game from file */
void reset_time(void)
{
#if defined(CIRCLE_MACINTOSH)
  long beginning_of_time = -1561789232;
#else
  long beginning_of_time = 650336715;
#endif

  time_info = *mud_time_passed(time(0), beginning_of_time);
  read_mud_date_from_file();

  if (time_info.hours <= 4)
    weather_info.sunlight = SUN_DARK;
  else if (time_info.hours == 5)
    weather_info.sunlight = SUN_RISE;
  else if (time_info.hours <= 20)
    weather_info.sunlight = SUN_LIGHT;
  else if (time_info.hours == 21)
    weather_info.sunlight = SUN_SET;
  else
    weather_info.sunlight = SUN_DARK;

  log("   Current Gametime: %dH %dD %dM %dY.", time_info.hours,
          time_info.day, time_info.month, time_info.year);

  weather_info.pressure = 960;
  if ((time_info.month >= 7) && (time_info.month <= 12))
    weather_info.pressure += dice(1, 50);
  else
    weather_info.pressure += dice(1, 80);

  weather_info.change = 0;

  if (weather_info.pressure <= 980)
    weather_info.sky = SKY_LIGHTNING;
  else if (weather_info.pressure <= 1000)
    weather_info.sky = SKY_RAINING;
  else if (weather_info.pressure <= 1020)
    weather_info.sky = SKY_CLOUDY;
  else
    weather_info.sky = SKY_CLOUDLESS;
}



/* generate index table for the player file */
void build_player_index(void)
{
  int rec_count = 0, i;
  FBFILE *plr_index;
  char index_name[40], line[256], bits[64];
  char arg2[80];

  sprintf(index_name, "%s", PLR_INDEX_FILE);
  if(!(plr_index = fbopen(index_name, FB_READ))) {
    top_of_p_table = -1;
    log("No player index file!  First new char will be OWNER!");
    return;
  }

  while(fbgetline(plr_index, line))
    if(*line != '~')
      rec_count++;
  fbrewind(plr_index);

  if(rec_count == 0) {
    player_table = NULL;
    top_of_p_file = top_of_p_table = -1;
    return;
  }

  CREATE(player_table, struct player_index_element, rec_count);
  for(i = 0; i < rec_count; i++) {
    fbgetline(plr_index, line);
    sscanf(line, "%ld %s %d %s %d", &player_table[i].id, arg2,
      &player_table[i].level, bits, (int *)&player_table[i].last);
    CREATE(player_table[i].name, char, strlen(arg2) + 1);
    strcpy(player_table[i].name, arg2);
    player_table[i].flags = asciiflag_conv(bits);
    top_idnum = MAX(top_idnum, player_table[i].id);
  }

  fbclose(plr_index);
  top_of_p_file = top_of_p_table = i - 1;
}

/*
 * Thanks to Andrey (andrey@alex-ua.com) for this bit of code, although I
 * did add the 'goto' and changed some "while()" into "do { } while()".
 *      -gg 6/24/98 (technically 6/25/98, but I care not.)
 */
int count_alias_records(FILE *fl)
{
  char key[READ_SIZE], next_key[READ_SIZE];
  char line[READ_SIZE], *scan;
  int total_keywords = 0;

  /* get the first keyword line */
  get_one_line(fl, key);

  while (*key != '$') {
    /* skip the text */
    do {
      get_one_line(fl, line);
      if (feof(fl))
        goto ackeof;
    } while (*line != '#');

    /* now count keywords */
    scan = key;
    do {
      scan = one_word(scan, next_key);
      ++total_keywords;
    } while (*next_key);

    /* get next keyword line (or $) */
    get_one_line(fl, key);

    if (feof(fl))
      goto ackeof;
  }

  return total_keywords;

  /* No, they are not evil. -gg 6/24/98 */
ackeof:
  log("SYSERR: Unexpected end of help file.");
  exit(1);      /* Some day we hope to handle these things better... */
}

/* function to count how many hash-mark delimited records exist in a file */
int count_hash_records(FILE * fl)
{
  char buf[128];
  int count = 0;

  while (fgets(buf, 128, fl))
    if (*buf == '#')
      count++;

  return count;
}



void index_boot(int mode)
{
  const char *index_filename;
  const char *prefix;
  FILE *index, *db_file;
  int rec_count = 0;

  switch (mode) {
  case DB_BOOT_TRG:
    prefix = TRG_PREFIX;
    break;
  case DB_BOOT_WLD:
    prefix = WLD_PREFIX;
    break;
  case DB_BOOT_MOB:
    prefix = MOB_PREFIX;
    break;
  case DB_BOOT_OBJ:
    prefix = OBJ_PREFIX;
    break;
  case DB_BOOT_ZON:
    prefix = ZON_PREFIX;
    break;
  case DB_BOOT_SHP:
    prefix = SHP_PREFIX;
    break;
  case DB_BOOT_HLP:
    prefix = HLP_PREFIX;
    break;
  case DB_BOOT_QST:
    prefix = QST_PREFIX;
    break;
  default:
    prefix = NULL;
    log("SYSERR: Unknown subcommand %d to index_boot!", mode);
    exit(1);
    break;
  }

  if (mini_mud)
    index_filename = MINDEX_FILE;
  else
    index_filename = INDEX_FILE;

  sprintf(buf2, "%s%s", prefix, index_filename);

  if (!(index = fopen(buf2, "r"))) {
    sprintf(buf1, "SYSERR: opening index file '%s'", buf2);
    perror(buf1);
    exit(1);
  }

  /* first, count the number of records in the file so we can malloc */
  fscanf(index, "%s\n", buf1);
  while (*buf1 != '$') {
    sprintf(buf2, "%s%s", prefix, buf1);
    if (!(db_file = fopen(buf2, "r"))) {
      perror(buf2);
      log("SYSERR: File '%s' listed in %s/%s not found.", buf2, prefix,
          index_filename);
      fscanf(index, "%s\n", buf1);
      continue;
    } else {
      if (mode == DB_BOOT_ZON)
        rec_count++;
      else if (mode == DB_BOOT_HLP)
        rec_count += count_alias_records(db_file);
      else
        rec_count += count_hash_records(db_file);
    }

    fclose(db_file);
    fscanf(index, "%s\n", buf1);
  }

  /* Exit if 0 records, unless this is shops */
  if (!rec_count) {
    if (mode == DB_BOOT_SHP)
      return;
    log("SYSERR: boot error - 0 records counted in %s/%s.", prefix,
        index_filename);
    exit(1);
  }

  rec_count++;

  /*
   * NOTE: "bytes" does _not_ include strings or other later malloc'd things.
   */
  switch (mode) {
  case DB_BOOT_TRG:
    CREATE(trig_index, struct index_data *, rec_count);
    break;
  case DB_BOOT_WLD:
    CREATE(world, struct room_data, rec_count);
    log("   %d rooms, %d bytes.", rec_count, sizeof(struct room_data) * rec_count);
    break;
  case DB_BOOT_MOB:
    CREATE(mob_proto, struct char_data, rec_count);
    CREATE(mob_index, struct index_data, rec_count);
    log("   %d mobs, %d bytes in index, %d bytes in prototypes.", rec_count, sizeof(struct index_data) * rec_count, sizeof(struct char_data) * rec_count);
    break;
  case DB_BOOT_OBJ:
    CREATE(obj_proto, struct obj_data, rec_count);
    CREATE(obj_index, struct index_data, rec_count);
    log("   %d objs, %d bytes in index, %d bytes in prototypes.", rec_count, sizeof(struct index_data) * rec_count, sizeof(struct obj_data) * rec_count);
    break;
  case DB_BOOT_ZON:
    CREATE(zone_table, struct zone_data, rec_count);
    log("   %d zones, %d bytes.", rec_count, sizeof(struct zone_data) * rec_count);
    break;
  case DB_BOOT_HLP:
    CREATE(help_table, struct help_index_element, rec_count);
    log("   %d entries, %d bytes.", rec_count, sizeof(struct help_index_element) * rec_count);
    break;
  case DB_BOOT_QST:
    CREATE(aquest_table, struct aq_data, rec_count);
    log("   %d quests, %d bytes.", rec_count, sizeof(struct aq_data) * rec_count);
    break;
  }

  rewind(index);
  fscanf(index, "%s\n", buf1);
  while (*buf1 != '$') {
    sprintf(buf2, "%s%s", prefix, buf1);
    if (!(db_file = fopen(buf2, "r"))) {
      perror(buf2);
      exit(1);
    }
    switch (mode) {
    case DB_BOOT_TRG:
    case DB_BOOT_WLD:
    case DB_BOOT_OBJ:
    case DB_BOOT_MOB:
    case DB_BOOT_QST:
      discrete_load(db_file, mode, buf2);
      break;
    case DB_BOOT_ZON:
      load_zones(db_file, buf2);
      break;
    case DB_BOOT_HLP:
      /*
       * If you think about it, we have a race here.  Although, this is the
       * "point-the-gun-at-your-own-foot" type of race.
       */
      load_help(db_file);
      break;
    case DB_BOOT_SHP:
      boot_the_shops(db_file, buf2, rec_count);
      break;
    }

    fclose(db_file);
    fscanf(index, "%s\n", buf1);
  }
  fclose(index);

}


void discrete_load(FILE * fl, int mode, char *filename)
{
   int nr = -1, last = 0, version = 1;
/*   char *line = get_buffer(256); */
/* George's buffers installed so you may have to keep the original */
   char line[256];

//  const char *modes[] = {"world", "mob", "obj"};
  const char *modes[] = {"world", "mob", "obj", "zon", "shp", "hlp", "trg", "qst"};
  /* modes positions correspond to DB_BOOT_xxx in db.h */

  for (;;) {
    /*
     * we have to do special processing with the obj files because they have
     * no end-of-record marker :(
     */
    if (mode != DB_BOOT_OBJ || nr < 0)
      if (!get_line(fl, line)) {
        if (nr == -1) {
          log("SYSERR: %s file %s is empty!", modes[mode], filename);
        } else {
          log("SYSERR: Format error in %s after %s #%d\n"
              "...expecting a new %s, but file ended!\n"
              "(maybe the file is not terminated with '$'?)", filename,
              modes[mode], nr, modes[mode]);
        }
        exit(1);
      }
      if (*line == '$')
       {
         return;
       }
       else if(*line=='@')
        {
         if(sscanf(line,"@Version: %d",&version)!=1)
           {
            log("SYSERR: Format error after %s #%d", modes[mode], last);
            log("SYSERR: ...Line: %s",line);
            exit(1);
           }
        }

    if (*line == '#') {
      last = nr;
      if (sscanf(line, "#%d", &nr) != 1) {
        log("SYSERR: Format error after %s #%d", modes[mode], last);
        exit(1);
      }
      if (nr >= 99999)
        return;
      else
        switch (mode) {
        case DB_BOOT_TRG:
          parse_trigger(fl, nr);
          break;
        case DB_BOOT_WLD:
          parse_room(fl, nr);
          break;
        case DB_BOOT_MOB:
          parse_mobile(fl, nr);
          break;
        case DB_BOOT_OBJ:
          strcpy(line, parse_object(fl, nr));
          break;
	case DB_BOOT_QST:
	  parse_quest(fl, nr);
        }
    } else {
      log("SYSERR: Format error in %s file %s near %s #%d", modes[mode],
          filename, modes[mode], nr);
      log("...offending line: '%s'", line);
      exit(1);
    }
  }
}


long asciiflag_conv(char *flag)
{
  long flags = 0;
  int is_number = 1;
  char *p;

  for (p = flag; *p; p++) {
    if (islower(*p))
      flags |= 1 << (*p - 'a');
    else if (isupper(*p))
      flags |= 1 << (26 + (*p - 'A'));

    if (!isdigit(*p))
      is_number = 0;
  }

  if (is_number)
    flags = atol(flag);

  return flags;
}

char fread_letter(FILE *fp)
{
  char c;
  do {
    c = getc(fp);
  } while (isspace(c));
  return c;
}

/* load the rooms */
void parse_room(FILE * fl, int virtual_nr)
{
  static int room_nr = 0, zone = 0;
  int t[10], i;
  char line[256], flags[128];
  struct extra_descr_data *new_descr;
  char letter;
  struct teleport_data *new_tele;

  world[room_nr].tele = NULL;

  sprintf(buf2, "room #%d", virtual_nr);

  if (virtual_nr <= (zone ? zone_table[zone - 1].top : -1)) {
    log("SYSERR: Room #%d is below zone %d.", virtual_nr, zone);
    exit(1);
  }
  while (virtual_nr > zone_table[zone].top)
    if (++zone > top_of_zone_table) {
      log("SYSERR: Room %d is outside of any zone.", virtual_nr);
      exit(1);
    }
  world[room_nr].zone = zone;
  world[room_nr].number = virtual_nr;
  world[room_nr].name = fread_string(fl, buf2);
  world[room_nr].description = fread_string(fl, buf2);

  if (!get_line(fl, line)) {
    log("SYSERR: Expecting roomflags/sector type of room #%d but file ended!",
        virtual_nr);
    exit(1);
  }

  if (sscanf(line, " %d %s %d ", t, flags, t + 2) != 3) {
    log("SYSERR: Format error in roomflags/sector type of room #%d",
        virtual_nr);
    exit(1);
  }
  /* t[0] is the zone number; ignored with the zone-file system */
  world[room_nr].room_flags = asciiflag_conv(flags);
  world[room_nr].sector_type = t[2];

  world[room_nr].func = NULL;
  world[room_nr].contents = NULL;
  world[room_nr].people = NULL;
  world[room_nr].light = 0;     /* Zero light sources */

  for (i = 0; i < NUM_OF_DIRS; i++)
    world[room_nr].dir_option[i] = NULL;

  world[room_nr].ex_description = NULL;

  sprintf(buf,"SYSERR: Format error in room #%d (expecting D/E/S)",virtual_nr);

  for (;;) {
    if (!get_line(fl, line)) {
      log("%s", buf);
      exit(1);
    }
    switch (*line) {
    case 'D':
      setup_dir(fl, room_nr, atoi(line + 1));
      break;
    case 'E':
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = fread_string(fl, buf2);
      new_descr->description = fread_string(fl, buf2);
      new_descr->next = world[room_nr].ex_description;
      world[room_nr].ex_description = new_descr;
      break;
    case 'T':
      if (!get_line(fl, line) || sscanf(line, " %d %s %d %d", t, flags,
                                        t+2, t+3) != 4) {
        fprintf(stderr, "Format error in room #%d's section T\n", virtual_nr);
        exit(1);
      }
      CREATE(new_tele, struct teleport_data, 1);
      world[room_nr].tele = new_tele;
      world[room_nr].tele->targ = t[0];
      world[room_nr].tele->mask = asciiflag_conv(flags);
      world[room_nr].tele->time = t[2];
      world[room_nr].tele->obj = t[3];
      break;
    case 'S':                   /* end of room */
      /* DG triggers -- script is defined after the end of the room */
      letter = fread_letter(fl);
      ungetc(letter, fl);
      while (letter=='T') {
        dg_read_trigger(fl, &world[room_nr], WLD_TRIGGER);
        letter = fread_letter(fl);
        ungetc(letter, fl);
      }
      top_of_world = room_nr++;
      return;
    default:
      log(buf);
      exit(1);
    }
  }
}



/* read direction data */
void setup_dir(FILE * fl, int room, int dir)
{
  int t[5];
  char line[256];

  sprintf(buf2, "room #%d, direction D%d", GET_ROOM_VNUM(room), dir);

  CREATE(world[room].dir_option[dir], struct room_direction_data, 1);
  world[room].dir_option[dir]->general_description = fread_string(fl, buf2);
  world[room].dir_option[dir]->keyword = fread_string(fl, buf2);

  if (!get_line(fl, line)) {
    log("SYSERR: Format error, %s", buf2);
    exit(1);
  }
  if (sscanf(line, " %d %d %d ", t, t + 1, t + 2) != 3) {
    log("SYSERR: Format error, %s", buf2);
    exit(1);
  }
  if (t[0] == 1)
    world[room].dir_option[dir]->exit_info = EX_ISDOOR;
  else if (t[0] == 2)
    world[room].dir_option[dir]->exit_info = EX_ISDOOR | EX_PICKPROOF;
  else
    world[room].dir_option[dir]->exit_info = 0;

  world[room].dir_option[dir]->key = t[1];
  world[room].dir_option[dir]->to_room = t[2];
}


/* make sure the start rooms exist & resolve their vnums to rnums */
void check_start_rooms(void)
{
  if ((r_mortal_start_room = real_room(mortal_start_room)) < 0) {
    log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
    exit(1);
  }
  if ((r_immort_start_room = real_room(immort_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Immort start room does not exist.  Change in config.c.");
    r_immort_start_room = r_mortal_start_room;
  }
  if ((r_frozen_start_room = real_room(frozen_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Frozen start room does not exist.  Change in config.c.");
    r_frozen_start_room = r_mortal_start_room;
  }
  if ((r_deadly_start_room = real_room(deadly_start_room)) < 0) {
    if (!mini_mud)
      log("SYSERR:  Warning: Deadly start room does not exist.  Change in config.c.");
    r_frozen_start_room = r_mortal_start_room;
  }
}


/* resolve all vnums into rnums in the world */
void renum_world(void)
{
  int room, door;

  for (room = 0; room <= top_of_world; room++)
    for (door = 0; door < NUM_OF_DIRS; door++)
      if (world[room].dir_option[door])
        if (world[room].dir_option[door]->to_room != NOWHERE)
          world[room].dir_option[door]->to_room =
            real_room(world[room].dir_option[door]->to_room);
}


#define ZCMD zone_table[zone].cmd[cmd_no]

/* resulve vnums into rnums in the zone reset tables */
void renum_zone_table(void)
{
  int zone, cmd_no, a, b, c, olda, oldb, oldc;
  char buf[128];

  for (zone = 0; zone <= top_of_zone_table; zone++)
    for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {
      a = b = c = 0;
      olda = ZCMD.arg1;
      oldb = ZCMD.arg2;
      oldc = ZCMD.arg3;
      switch (ZCMD.command) {
      case 'M':
        a = ZCMD.arg1 = real_mobile(ZCMD.arg1);
        c = ZCMD.arg3 = real_room(ZCMD.arg3);
        break;
      case 'O':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        if (ZCMD.arg3 != NOWHERE)
          c = ZCMD.arg3 = real_room(ZCMD.arg3);
        break;
      case 'G':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        break;
      case 'E':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        break;
      case 'P':
        a = ZCMD.arg1 = real_object(ZCMD.arg1);
        c = ZCMD.arg3 = real_object(ZCMD.arg3);
        break;
      case 'D':
        a = ZCMD.arg1 = real_room(ZCMD.arg1);
        break;
      case 'R': /* rem obj from room */
        a = ZCMD.arg1 = real_room(ZCMD.arg1);
        b = ZCMD.arg2 = real_object(ZCMD.arg2);
        break;
      }
      if (a < 0 || b < 0 || c < 0) {
        if (!mini_mud) {
          sprintf(buf,  "Invalid vnum %d, cmd disabled",
                         (a < 0) ? olda : ((b < 0) ? oldb : oldc));
          log_zone_error(zone, cmd_no, buf);
        }
        ZCMD.command = '*';
      }
    }
}



void parse_simple_mob(FILE *mob_f, int i, int nr)
{
  int j, t[10];
  char line[256];
  int temp;

  mob_proto[i].real_abils.str = 11;
  mob_proto[i].real_abils.intel = 11;
  mob_proto[i].real_abils.wis = 11;
  mob_proto[i].real_abils.dex = 11;
  mob_proto[i].real_abils.con = 11;
  mob_proto[i].real_abils.cha = 11;

  if (!get_line(mob_f, line)) {
    log("SYSERR: Format error in mob #%d, file ended after S flag!", nr);
    exit(1);
  }

  if (sscanf(line, " %d %d %d %dd%d+%d %dd%d+%d ",
          t, t + 1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7, t + 8) != 9) {
    log("SYSERR: Format error in mob #%d, first line after S flag\n"
        "...expecting line of form '# # # #d#+# #d#+#'", nr);
    exit(1);
  }

  GET_LEVEL(mob_proto + i) = t[0];
  mob_proto[i].points.hitroll = 20 - t[1];
  mob_proto[i].points.armor = 10 * t[2];

  /* max hit = 0 is a flag that H, M, V is xdy+z */
  mob_proto[i].points.max_hit = 0;
  mob_proto[i].points.hit = t[3];
  mob_proto[i].points.mana = t[4];
  mob_proto[i].points.move = t[5];

  mob_proto[i].points.max_mana = 10;
  mob_proto[i].points.max_move = 50;

  mob_proto[i].mob_specials.damnodice = t[6];
  mob_proto[i].mob_specials.damsizedice = t[7];
  mob_proto[i].points.damroll = t[8];

  if (!get_line(mob_f, line)) {
      log("SYSERR: Format error in mob #%d, second line after S flag\n"
          "...expecting line of form '# #', but file ended!", nr);
      exit(1);
    }

   if ((temp = (sscanf(line, " %d %d %d ", t, t + 1, t + 2))) > 3) {
    log("SYSERR: Format error in mob #%d, second line after S flag\n"
        "...expecting line of form '# #'", nr);
    exit(1);
  }

  GET_GOLD(mob_proto + i) = t[0];
  GET_EXP(mob_proto + i) = t[1];
  if (temp == 3)
   GET_REMORT(mob_proto + i) = t[2];
  else
   GET_REMORT(mob_proto + i) = 0;

  if (!get_line(mob_f, line)) {
    log("SYSERR: Format error in last line of mob #%d\n"
        "...expecting line of form '# # #', but file ended!", nr);
    exit(1);
  }

  if ((temp = sscanf(line, " %d %d %d %d %d ", t, t + 1, t + 2, t + 3, t + 4)) < 3) {
    log("SYSERR: Format error in last line of mob #%d\n"
        "...expecting line of form '# # # # #'", nr);
    exit(1);
  }

  mob_proto[i].char_specials.position = t[0];
  mob_proto[i].mob_specials.default_pos = t[1];
  mob_proto[i].player.sex = t[2];
  if (temp == 5){
   mob_proto[i].player.chclass = t[3];
   mob_proto[i].player.race = t[4];
  }
  else{
   mob_proto[i].player.chclass = -1;
   mob_proto[i].player.race = -1;
  }
  mob_proto[i].player.weight = 200;
  mob_proto[i].player.height = 198;

  /*
   * These are player specials! -gg
   */
#if 0
  for (j = 0; j < 3; j++)
    GET_COND(mob_proto + i, j) = -1;
#endif

  /*
   * these are now save applies; base save numbers for MOBs are now from
   * the warrior save table.
   */
  for (j = 0; j < 5; j++)
    GET_SAVE(mob_proto + i, j) = 0;
}


/*
 * interpret_espec is the function that takes espec keywords and values
 * and assigns the correct value to the mob as appropriate.  Adding new
 * e-specs is absurdly easy -- just add a new CASE statement to this
 * function!  No other changes need to be made anywhere in the code.
 */

#define CASE(test) if (!matched && !str_cmp(keyword, test) && (matched = 1))
#define RANGE(low, high) (num_arg = MAX((low), MIN((high), (num_arg))))

void interpret_espec(const char *keyword, const char *value, int i, int nr)
{
  int num_arg, matched = 0;

  num_arg = atoi(value);

  CASE("BareHandAttack") {
    RANGE(0, 99);
    mob_proto[i].mob_specials.attack_type = num_arg;
  }

  CASE("Str") {
    RANGE(3, 25);
    mob_proto[i].real_abils.str = num_arg;
  }

  CASE("StrAdd") {
    RANGE(0, 100);
    mob_proto[i].real_abils.str_add = num_arg;
  }

  CASE("Int") {
    RANGE(3, 25);
    mob_proto[i].real_abils.intel = num_arg;
  }

  CASE("Wis") {
    RANGE(3, 25);
    mob_proto[i].real_abils.wis = num_arg;
  }

  CASE("Dex") {
    RANGE(3, 25);
    mob_proto[i].real_abils.dex = num_arg;
  }

  CASE("Con") {
    RANGE(3, 25);
    mob_proto[i].real_abils.con = num_arg;
  }

  CASE("Cha") {
    RANGE(3, 25);
    mob_proto[i].real_abils.cha = num_arg;
  }
  CASE("Att2") {
    RANGE(1, 100);
    mob_proto[i].mob_specials.attack1 = num_arg;
   }

  CASE("Att3") {
    RANGE(1, 100);
    mob_proto[i].mob_specials.attack2 = num_arg;
   }

  CASE("Att4") {
    RANGE(1, 100);
   mob_proto[i].mob_specials.attack3 = num_arg;
 }
  if (!matched) {
    log("SYSERR: Warning: unrecognized espec keyword %s in mob #%d",
            keyword, nr);
  }
}

#undef CASE
#undef RANGE

void parse_espec(char *buf, int i, int nr)
{
  char *ptr;

  if ((ptr = strchr(buf, ':')) != NULL) {
    *(ptr++) = '\0';
    while (isspace(*ptr))
      ptr++;
#if 0   /* Need to evaluate interpret_espec()'s NULL handling. */
  }
#else
  } else
    ptr = "";
#endif
  interpret_espec(buf, ptr, i, nr);
}


void parse_enhanced_mob(FILE *mob_f, int i, int nr)
{
  char line[256];

  parse_simple_mob(mob_f, i, nr);

  while (get_line(mob_f, line)) {
    if (!strcmp(line, "E"))     /* end of the ehanced section */
      return;
    else if (*line == '#') {    /* we've hit the next mob, maybe? */
      log("SYSERR: Unterminated E section in mob #%d", nr);
      exit(1);
    } else
      parse_espec(line, i, nr);
  }

  log("SYESRR: Unexpected end of file reached after mob #%d", nr);
  exit(1);
}


void parse_mobile(FILE * mob_f, int nr)
{
  static int i = 0;
  int j, t[10];
  char line[256], *tmpptr, letter;
  char f1[128], f2[128];

  mob_index[i].vnum = nr;
  mob_index[i].number = 0;
  mob_index[i].func = NULL;

  clear_char(mob_proto + i);

  /*
   * Mobiles should NEVER use anything in the 'player_specials' structure.
   * The only reason we have every mob in the game share this copy of the
   * structure is to save newbie coders from themselves. -gg 2/25/98
   */
  mob_proto[i].player_specials = &dummy_mob;
  sprintf(buf2, "mob vnum %d", nr);

  /***** String data *****/
  mob_proto[i].player.name = fread_string(mob_f, buf2);
  tmpptr = mob_proto[i].player.short_descr = fread_string(mob_f, buf2);
  if (tmpptr && *tmpptr)
    if (!str_cmp(fname(tmpptr), "a") || !str_cmp(fname(tmpptr), "an") ||
        !str_cmp(fname(tmpptr), "the"))
      *tmpptr = LOWER(*tmpptr);
  mob_proto[i].player.long_descr = fread_string(mob_f, buf2);
  mob_proto[i].player.description = fread_string(mob_f, buf2);
  mob_proto[i].player.title = NULL;

  /* *** Numeric data *** */
  if (!get_line(mob_f, line)) {
    log("SYSERR: Format error after string section of mob #%d\n"
        "...expecting line of form '# # # {S | E}', but file ended!", nr);
    exit(1);
  }

#ifdef CIRCLE_ACORN     /* Ugh. */
  if (sscanf(line, "%s %s %d %s", f1, f2, t + 2, &letter) != 4) {
#else
  if (sscanf(line, "%s %s %d %c", f1, f2, t + 2, &letter) != 4) {
#endif
    log("SYSERR: Format error after string section of mob #%d\n"
        "...expecting line of form '# # # {S | E}'", nr);
    exit(1);
  }
  MOB_FLAGS(mob_proto + i) = asciiflag_conv(f1);
  SET_BIT(MOB_FLAGS(mob_proto + i), MOB_ISNPC);
  AFF_FLAGS(mob_proto + i) = asciiflag_conv(f2);
  GET_ALIGNMENT(mob_proto + i) = t[2];

  switch (UPPER(letter)) {
  case 'S':     /* Simple monsters */
    parse_simple_mob(mob_f, i, nr);
    break;
  case 'E':     /* Circle3 Enhanced monsters */
    parse_enhanced_mob(mob_f, i, nr);
    break;
  /* add new mob types here.. */
  default:
    log("SYSERR: Unsupported mob type '%c' in mob #%d", letter, nr);
    exit(1);
  }

  /* DG triggers -- script info follows mob S/E section */
  letter = fread_letter(mob_f);
  ungetc(letter, mob_f);
  while (letter=='T') {
    dg_read_trigger(mob_f, &mob_proto[i], MOB_TRIGGER);
    letter = fread_letter(mob_f);
    ungetc(letter, mob_f);
  }
  letter = fread_letter(mob_f);
  ungetc(letter, mob_f);
  while (letter == 'Q') {
    read_quest(mob_f, i);
    letter = fread_letter(mob_f);
    ungetc(letter, mob_f);
  }
  mob_proto[i].aff_abils = mob_proto[i].real_abils;

  for (j = 0; j < NUM_WEARS; j++)
    mob_proto[i].equipment[j] = NULL;

  mob_proto[i].nr = i;
  mob_proto[i].desc = NULL;

  top_of_mobt = i++;
}




/* read all objects from obj file; generate index and prototypes */
char *parse_object(FILE * obj_f, int nr)
{
  static int i = 0;
  static char line[256];
  int t[10], j = 0, retval;
  char *tmpptr;
  char f1[256], f2[256];
  struct extra_descr_data *new_descr;

  obj_index[i].vnum = nr;
  obj_index[i].number = 0;
  obj_index[i].func = NULL;

  clear_object(obj_proto + i);
  obj_proto[i].in_room = NOWHERE;
  obj_proto[i].item_number = i;

  sprintf(buf2, "object #%d", nr);

  /* *** string data *** */
  if ((obj_proto[i].name = fread_string(obj_f, buf2)) == NULL) {
    log("SYSERR: Null obj name or format error at or near %s", buf2);
    exit(1);
  }
  tmpptr = obj_proto[i].short_description = fread_string(obj_f, buf2);
  if (tmpptr && *tmpptr)
    if (!str_cmp(fname(tmpptr), "a") || !str_cmp(fname(tmpptr), "an") ||
        !str_cmp(fname(tmpptr), "the"))
      *tmpptr = LOWER(*tmpptr);

  tmpptr = obj_proto[i].description = fread_string(obj_f, buf2);
  if (tmpptr && *tmpptr)
    *tmpptr = UPPER(*tmpptr);
  obj_proto[i].action_description = fread_string(obj_f, buf2);

  /* *** numeric data *** */
  if (!get_line(obj_f, line)) {
    log("SYSERR: Expecting first numeric line of %s, but file ended!", buf2);
    exit(1);
  }
  if ((retval = sscanf(line, " %d %s %s %d ", t, f1, f2, t + 3)) < 3) {
    log("SYSERR: Format error in first numeric line (expecting 4 args, got %d), %s", retval, buf2);
    exit(1);
  }
  obj_proto[i].obj_flags.type_flag = t[0];
  obj_proto[i].obj_flags.extra_flags = asciiflag_conv(f1);
  obj_proto[i].obj_flags.wear_flags = asciiflag_conv(f2);
  if (retval > 3)
   obj_proto[i].obj_flags.bitvector = t[3];
  else
   obj_proto[i].obj_flags.bitvector = 0;


  if (!get_line(obj_f, line)) {
    log("SYSERR: Expecting second numeric line of %s, but file ended!", buf2);
    exit(1);
  }
  if ((retval = sscanf(line, "%d %d %d %d %d", t, t + 1, t + 2, t + 3, t + 4)) < 4) {
    log("SYSERR: Format error in second numeric line (expecting 4 args, got %d), %s", retval, buf2);
    exit(1);
  }
  obj_proto[i].obj_flags.value[0] = t[0];
  obj_proto[i].obj_flags.value[1] = t[1];
  obj_proto[i].obj_flags.value[2] = t[2];
  obj_proto[i].obj_flags.value[3] = t[3];
  if (retval > 4)
   obj_proto[i].obj_flags.cond = t[4];
  else
   obj_proto[i].obj_flags.cond = 100;

  if (!get_line(obj_f, line)) {
    log("SYSERR: Expecting third numeric line of %s, but file ended!", buf2);
    exit(1);
  }
  if ((retval = sscanf(line, "%d %d %d %d", t, t + 1, t + 2, t + 3)) < 3) {
    log("SYSERR: Format error in third numeric line (expecting 4 args, got %d), %s", retval, buf2);
    exit(1);
  }
  obj_proto[i].obj_flags.weight = t[0];
  obj_proto[i].obj_flags.cost = t[1];
  obj_proto[i].obj_flags.cost_per_day = t[2];
  if (retval > 3)
   obj_proto[i].obj_flags.obj_level = t[3];
  else
   obj_proto[i].obj_flags.obj_level = 0;

  /* check to make sure that weight of containers exceeds curr. quantity */
  if (obj_proto[i].obj_flags.type_flag == ITEM_DRINKCON ||
      obj_proto[i].obj_flags.type_flag == ITEM_FOUNTAIN) {
    if (obj_proto[i].obj_flags.weight < obj_proto[i].obj_flags.value[1])
      obj_proto[i].obj_flags.weight = obj_proto[i].obj_flags.value[1] + 5;
  }

  /* *** extra descriptions and affect fields *** */

  for (j = 0; j < MAX_OBJ_AFFECT; j++) {
    obj_proto[i].affected[j].location = APPLY_NONE;
    obj_proto[i].affected[j].modifier = 0;
  }

  strcat(buf2, ", after numeric constants\n"
         "...expecting 'E', 'A', 'C', 'T', '$', or next object number");
  j = 0;

  for (;;) {
    if (!get_line(obj_f, line)) {
      log("SYSERR: Format error in %s", buf2);
      exit(1);
    }
    switch (*line) {
    case 'E':
      CREATE(new_descr, struct extra_descr_data, 1);
      new_descr->keyword = fread_string(obj_f, buf2);
      new_descr->description = fread_string(obj_f, buf2);
      new_descr->next = obj_proto[i].ex_description;
      obj_proto[i].ex_description = new_descr;
      break;
    case 'A':
      if (j >= MAX_OBJ_AFFECT) {
        log("SYSERR: Too many A fields (%d max), %s", MAX_OBJ_AFFECT, buf2);
        exit(1);
      }
      if (!get_line(obj_f, line)) {
        log("SYSERR: Format error in 'A' field, %s\n"
            "...expecting 2 numeric constants but file ended!", buf2);
        exit(1);
      }

      if ((retval = sscanf(line, " %d %d ", t, t + 1)) != 2) {
        log("SYSERR: Format error in 'A' field, %s\n"
            "...expecting 2 numeric arguments, got %d\n"
            "...offending line: '%s'", buf2, retval, line);
        exit(1);
      }
      obj_proto[i].affected[j].location = t[0];
      obj_proto[i].affected[j].modifier = t[1];
      j++;
      break;

    case 'T':  /* DG triggers */
      dg_obj_trigger(line, &obj_proto[i]);
      break;
    case '$':
    case '#':
      top_of_objt = i++;
      return line;
    default:
      log("SYSERR: Format error in %s", buf2);
      exit(1);
    }
  }
}


#define Z       zone_table[zone]

/* load the zone table and command tables */
void load_zones(FILE * fl, char *zonename)
{
  static int zone = 0;
  int cmd_no = 0, num_of_cmds = 0, line_num = 0, tmp, error, version = 1;
  char *ptr, buf[256], zname[256];

  strcpy(zname, zonename);

  while (get_line(fl, buf))
    num_of_cmds++;              /* this should be correct within 3 or so */
  rewind(fl);

  if (num_of_cmds == 0) {
    log("SYSERR: %s is empty!", zname);
    exit(1);
  } else
    CREATE(Z.cmd, struct reset_com, num_of_cmds);

  line_num += get_line(fl, buf);

  if(*buf=='@') {
    if(sscanf(buf,"@Version: %d", &version)!=1)
     {
       log("SYSERR: Format error in %s (version)", zname);
       log("SYSERR: ...Line: %d", line_num);
       exit(1);
     }
      line_num+=get_line(fl,buf);
  }

  if (sscanf(buf, "#%d", &Z.number) != 1) {
    log("SYSERR: Format error in %s, line %d", zname, line_num);
    exit(1);
  }
  sprintf(buf2, "beginning of zone #%d", Z.number);

  line_num += get_line(fl, buf);

  if ((ptr = strchr(buf, '~')) != NULL) /* take off the '~' if it's there */
    *ptr = '\0';
  Z.name = str_dup(buf);

  line_num += get_line(fl, buf);

  if (version >= 2) {
    if  (sscanf(buf, " %d %d %d %d ", &Z.top, &Z.lifespan, &Z.reset_mode, &Z.zone_flags) != 4) {
      log("SYSERR: Format error in 4-constant line of %s", zname);
      exit(1);
    }
  }
  else {
    if (sscanf(buf, " %d %d %d ", &Z.top, &Z.lifespan, &Z.reset_mode) != 3) {
      log("SYSERR: Format error in 3-constant line of %s", zname);
      exit(1);
    }
  }

  cmd_no = 0;

  for (;;) {
    if ((tmp = get_line(fl, buf)) == 0) {
      log("Format error in %s - premature end of file", zname);
      exit(1);
    }
    line_num += tmp;
    ptr = buf;
    skip_spaces(&ptr);

    if ((ZCMD.command = *ptr) == '*')
      continue;

    ptr++;

    if (ZCMD.command == 'S' || ZCMD.command == '$') {
      ZCMD.command = 'S';
      break;
    }
    error = 0;
    if (strchr("MOEPD", ZCMD.command) == NULL) {        /* a 3-arg command */
      if (sscanf(ptr, " %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2) != 3)
        error = 1;
    } else {
      if (sscanf(ptr, " %d %d %d %d ", &tmp, &ZCMD.arg1, &ZCMD.arg2,
                 &ZCMD.arg3) != 4)
        error = 1;
    }

    ZCMD.if_flag = tmp;

    if (error) {
      log("SYSERR: Format error in %s, line %d: '%s'", zname, line_num, buf);
      exit(1);
    }
    ZCMD.line = line_num;
    cmd_no++;
  }

  top_of_zone_table = zone++;
}

#undef Z


void get_one_line(FILE *fl, char *buf)
{
  if (fgets(buf, READ_SIZE, fl) == NULL) {
    log("SYSERR: error reading help file: not terminated with $?");
    exit(1);
  }

  buf[strlen(buf) - 1] = '\0'; /* take off the trailing \n */
}

#if !defined(HAVE_STRLCPY)
/*
 * A 'strlcpy' function in the same fashion as 'strdup' below.
 *
 * This copies up to totalsize - 1 bytes from the source string, placing
 * them and a trailing NUL into the destination string.
 *
 * Returns the total length of the string it tried to copy, not including
 * the trailing NUL.  So a '>= totalsize' test says it was truncated.
 * (Note that you may have _expected_ truncation because you only wanted
 * a few characters from the source string.)
 */
size_t strlcpy(char *dest, const char *source, size_t totalsize)
{
  strncpy(dest, source, totalsize - 1);	/* strncpy: OK (we must assume 'totalsize' is correct) */
  dest[totalsize - 1] = '\0';
  return strlen(source);
}
#endif

void load_help(FILE *fl)
{
#if defined(CIRCLE_MACINTOSH)
  static char key[READ_SIZE + 1], next_key[READ_SIZE + 1], entry[32384]; /* too big for stack? */
#else
  char key[READ_SIZE + 1], next_key[READ_SIZE + 1], entry[32384];
#endif
  size_t entrylen;
  char line[READ_SIZE + 1], *scan;
  struct help_index_element el;

  /* get the first keyword line */
  get_one_line(fl, key);
  while (*key != '$') {
    strcat(key, "\r\n");	/* strcat: OK (READ_SIZE - "\n" + "\r\n" == READ_SIZE + 1) */
    entrylen = strlcpy(entry, key, sizeof(entry));

    /* read in the corresponding help entry */
    get_one_line(fl, line);
    while (*line != '#' && entrylen < sizeof(entry) - 1) {
      entrylen += strlcpy(entry + entrylen, line, sizeof(entry) - entrylen);

      if (entrylen + 2 < sizeof(entry) - 1) {
        strcpy(entry + entrylen, "\r\n");	/* strcpy: OK (size checked above) */
        entrylen += 2;
      }
      get_one_line(fl, line);
    }

    if (entrylen >= sizeof(entry) - 1) {
      int keysize;
      const char *truncmsg = "\r\n*TRUNCATED*\r\n";

      strcpy(entry + sizeof(entry) - strlen(truncmsg) - 1, truncmsg);	/* strcpy: OK (assuming sane 'entry' size) */

      keysize = strlen(key) - 2;
      log("SYSERR: Help entry exceeded buffer space: %.*s", keysize, key);

      /* If we ran out of buffer space, eat the rest of the entry. */
      while (*line != '#')
        get_one_line(fl, line);
    }

    /* now, add the entry to the index with each keyword on the keyword line */
    el.entry = strdup(entry);
    scan = one_word(key, next_key);
    while (*next_key) {
      el.keywords = strdup(next_key);
      help_table[top_of_helpt++] = el;
      scan = one_word(scan, next_key);
    }

    /* get next keyword line (or $) */
    get_one_line(fl, key);
  }
}

/*************************************************************************
*  procedures for resetting, both play-time and boot-time                *
*************************************************************************/

int vnum_mobile(char *searchname, struct char_data * ch)
{
  int nr, found = 0;

  for (nr = 0; nr <= top_of_mobt; nr++) {
    if (isname(searchname, mob_proto[nr].player.name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
              mob_index[nr].vnum,
              mob_proto[nr].player.short_descr);
      send_to_char(buf, ch);
    }
  }

  return (found);
}



int vnum_object(char *searchname, struct char_data * ch)
{
  int nr, found = 0;

  for (nr = 0; nr <= top_of_objt; nr++) {
    if (isname(searchname, obj_proto[nr].name)) {
      sprintf(buf, "%3d. [%5d] %s\r\n", ++found,
              obj_index[nr].vnum,
              obj_proto[nr].short_description);
      send_to_char(buf, ch);
    }
  }
  return (found);
}


/* create a character, and add it to the char list */
struct char_data *create_char(void)
{
  struct char_data *ch;

  CREATE(ch, struct char_data, 1);
  clear_char(ch);
  ch->next = character_list;
  character_list = ch;

  GET_ID(ch) = max_id++;
  return ch;
}


/* create a new mobile from a prototype */
struct char_data *read_mobile(int nr, int type)
{
  int i;
  struct char_data *mob;

  if (type == VIRTUAL) {
    if ((i = real_mobile(nr)) < 0) {
      sprintf(buf, "Mobile (V) %d does not exist in database.", nr);
      log(buf);
      return NULL;
    }
  } else
    i = nr;

  CREATE(mob, struct char_data, 1);

  clear_char(mob);
  *mob = mob_proto[i];
  mob->next = character_list;
  character_list = mob;

  if (!mob->points.max_hit) {
    mob->points.max_hit = dice(mob->points.hit, mob->points.mana) +
      mob->points.move;
  } else
    mob->points.max_hit = number(mob->points.hit, mob->points.mana);

  mob->points.hit = mob->points.max_hit;
  mob->points.mana = mob->points.max_mana;
  mob->points.move = mob->points.max_move;

  mob->player.time.birth = time(0);
  mob->player.time.played = 0;
  mob->player.time.logon = time(0);

  mob_index[i].number++;
  GET_ID(mob) = max_id++;
  assign_triggers(mob, MOB_TRIGGER);

  return mob;
}


/* create an object, and add it to the object list */
struct obj_data *create_obj(void)
{
  struct obj_data *obj;

  CREATE(obj, struct obj_data, 1);
  clear_object(obj);
  obj->next = object_list;
  object_list = obj;

  GET_ID(obj) = max_id++;
  assign_triggers(obj, OBJ_TRIGGER);

  return obj;
}


/* create a new object from a prototype */
struct obj_data *read_object(int nr, int type)
{
  struct obj_data *obj;
  int i;

  if (nr < 0) {
    log("SYSERR: Trying to create obj with negative (%d) num!", nr);
    return NULL;
  }
  if (type == VIRTUAL) {
    if ((i = real_object(nr)) < 0) {
      log("Object (V) %d does not exist in database.", nr);
      return NULL;
    }
  } else
    i = nr;

  CREATE(obj, struct obj_data, 1);

  clear_object(obj);
  *obj = obj_proto[i];
  obj->next = object_list;
  object_list = obj;

  obj_index[i].number++;

  GET_ID(obj) = max_id++;
  assign_triggers(obj, OBJ_TRIGGER);

  return obj;
}

#define ZO_DEAD  999

/* update zone ages, queue for reset if necessary, and dequeue when possible */
void zone_update(void)
{
  int i;
  struct reset_q_element *update_u, *temp;
  static int timer = 0;
/*  char buf[128]; */

  /* jelson 10/22/92 */
  if (((++timer * PULSE_ZONE) / PASSES_PER_SEC) >= 60) {
    /* one minute has passed */
    /*
     * NOT accurate unless PULSE_ZONE is a multiple of PASSES_PER_SEC or a
     * factor of 60
     */

    timer = 0;

    /* since one minute has passed, increment zone ages */
    for (i = 0; i <= top_of_zone_table; i++) {
      if (zone_table[i].age < zone_table[i].lifespan &&
          zone_table[i].reset_mode)
        (zone_table[i].age)++;

      if (zone_table[i].age >= zone_table[i].lifespan &&
          zone_table[i].age < ZO_DEAD && zone_table[i].reset_mode) {
        /* enqueue zone */

        CREATE(update_u, struct reset_q_element, 1);

        update_u->zone_to_reset = i;
        update_u->next = 0;

        if (!reset_q.head)
          reset_q.head = reset_q.tail = update_u;
        else {
          reset_q.tail->next = update_u;
          reset_q.tail = update_u;
        }

        zone_table[i].age = ZO_DEAD;
      }
    }
  }     /* end - one minute has passed */


  /* dequeue zones (if possible) and reset */
  /* this code is executed every 10 seconds (i.e. PULSE_ZONE) */
  for (update_u = reset_q.head; update_u; update_u = update_u->next)
    if (zone_table[update_u->zone_to_reset].reset_mode == 2 ||
        is_empty(update_u->zone_to_reset)) {
      reset_zone(update_u->zone_to_reset);
//      sprintf(buf, "Auto zone reset: %s",
//              zone_table[update_u->zone_to_reset].name);
//      mudlog(buf, CMP, LVL_GOD, FALSE);
      /* dequeue */
      if (update_u == reset_q.head)
        reset_q.head = reset_q.head->next;
      else {
        for (temp = reset_q.head; temp->next != update_u;
             temp = temp->next);

        if (!update_u->next)
          reset_q.tail = temp;

        temp->next = update_u->next;
      }

      free(update_u);
      break;
    }
}

void log_zone_error(int zone, int cmd_no, const char *message)
{
  char buf[256];

  sprintf(buf, "SYSERR: zone file: %s", message);
  mudlog(buf, NRM, LVL_GOD, TRUE);

  sprintf(buf, "SYSERR: ...offending cmd: '%c' cmd in zone #%d, line %d",
          ZCMD.command, zone_table[zone].number, ZCMD.line);
  mudlog(buf, NRM, LVL_GOD, TRUE);
}

#define ZONE_ERROR(message) \
        { log_zone_error(zone, cmd_no, message); last_cmd = 0; }

/* execute the reset command table of a given zone */
void reset_zone(int zone)
{
  int cmd_no, last_cmd = 0;
  struct char_data *mob = NULL;
  struct obj_data *obj, *obj_to;
  int room_vnum, room_rnum;

//  leak_logging = 0;

  for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++) {

    if (ZCMD.if_flag && !last_cmd)
      continue;

    switch (ZCMD.command) {
    case '*':                   /* ignore command */
      last_cmd = 0;
      break;

    case 'M':                   /* read a mobile */
      if (mob_index[ZCMD.arg1].number < ZCMD.arg2) {
        mob = read_mobile(ZCMD.arg1, REAL);
        char_to_room(mob, ZCMD.arg3);
        load_mtrigger(mob);
        last_cmd = 1;
      } else
        last_cmd = 0;
      break;

    case 'O':                   /* read an object */
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) {
        if (ZCMD.arg3 >= 0) {
          obj = read_object(ZCMD.arg1, REAL);
          obj_to_room(obj, ZCMD.arg3);
          load_otrigger(obj);
          last_cmd = 1;
        } else {
          obj = read_object(ZCMD.arg1, REAL);
          obj->in_room = NOWHERE;
          last_cmd = 1;
        }
      } else
        last_cmd = 0;
      break;

    case 'P':                   /* object to object */
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) {
        obj = read_object(ZCMD.arg1, REAL);
        if (!(obj_to = get_obj_num(ZCMD.arg3))) {
          ZONE_ERROR("target obj not found");
          break;
        }
        obj_to_obj(obj, obj_to);
        load_otrigger(obj);
        last_cmd = 1;
      } else
        last_cmd = 0;
      break;

    case 'G':                   /* obj_to_char */
      if (!mob) {
        ZONE_ERROR("attempt to give obj to non-existant mob");
        break;
      }
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) {
        obj = read_object(ZCMD.arg1, REAL);
        obj_to_char(obj, mob);
        load_otrigger(obj);
        last_cmd = 1;
      } else
        last_cmd = 0;
      break;

    case 'E':                   /* object to equipment list */
      if (!mob) {
        ZONE_ERROR("trying to equip non-existant mob");
        break;
      }
      if (obj_index[ZCMD.arg1].number < ZCMD.arg2) {
        if (ZCMD.arg3 < 0 || ZCMD.arg3 >= NUM_WEARS) {
          ZONE_ERROR("invalid equipment pos number");
        } else {
          obj = read_object(ZCMD.arg1, REAL);
          equip_char(mob, obj, ZCMD.arg3);
          load_otrigger(obj);
          last_cmd = 1;
        }
      } else
        last_cmd = 0;
      break;

    case 'R': /* rem obj from room */
      if ((obj = get_obj_in_list_num(ZCMD.arg2, world[ZCMD.arg1].contents)) != NULL) {
        obj_from_room(obj);
        extract_obj(obj);
      }
      last_cmd = 1;
      break;


    case 'D':                   /* set state of door */
      if (ZCMD.arg2 < 0 || ZCMD.arg2 >= NUM_OF_DIRS ||
          (world[ZCMD.arg1].dir_option[ZCMD.arg2] == NULL)) {
        ZONE_ERROR("door does not exist");
      } else
        switch (ZCMD.arg3) {
        case 0:
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                     EX_LOCKED);
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                     EX_CLOSED);
          break;
        case 1:
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          REMOVE_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                     EX_LOCKED);
          break;
        case 2:
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_LOCKED);
          SET_BIT(world[ZCMD.arg1].dir_option[ZCMD.arg2]->exit_info,
                  EX_CLOSED);
          break;
        }
      last_cmd = 1;
      break;

    default:
      ZONE_ERROR("unknown cmd in reset table; cmd disabled");
      ZCMD.command = '*';
      break;
    }
  }

  zone_table[zone].age = 0;

  /* handle reset_wtrigger's */
  room_vnum = zone_table[zone].number * 100;
  while (room_vnum <= zone_table[zone].top) {
    room_rnum = real_room(room_vnum);
    if (room_rnum != NOWHERE) reset_wtrigger(&world[room_rnum]);
    room_vnum++;
  }

//leak_logging = 1;
}



/* for use in reset_zone; return TRUE if zone 'nr' is free of PC's  */
int is_empty(int zone_nr)
{
  struct descriptor_data *i;

  for (i = descriptor_list; i; i = i->next)
    if (STATE(i) == CON_PLAYING)
      if (world[i->character->in_room].zone == zone_nr)
        return 0;

  return 1;
}





/*************************************************************************
*  stuff related to the save/load player system                          *
*************************************************************************/

long get_ptable_by_name(char *name)
{
  int i;

  one_argument(name, arg);
  for (i = 0; i <= top_of_p_table; i++)
    if (!strcmp(player_table[i].name, arg))
      return (i);

  return (-1);
}

long get_id_by_name(char *name)
{
  int i;

  one_argument(name, arg);
  for (i = 0; i <= top_of_p_table; i++)
    if (!strcmp((player_table + i)->name, arg))
      return ((player_table + i)->id);

  return -1;
}


char *get_name_by_id(long id)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++)
    if ((player_table + i)->id == id)
      return ((player_table + i)->name);

  return NULL;
}

#define NUM_OF_SAVE_THROWS	5

/* new load_char reads ascii pfiles */
/* Load a char, TRUE if loaded, FALSE if not */
int load_char(char *name, struct char_data *ch)
{
  int id, i, h, num = 0, num2 = 0, num3 = 0, num4 = 0, num5 = 0, num6 = 0, num7 = 0;
  FBFILE *fl;
  char filename[40];
  char buf[128], line[MAX_INPUT_LENGTH + 1], tag[6];
  struct affected_type af;

  if((id = find_name(name)) < 0)
    return (-1);
  else {
    sprintf(filename, "%s%s%c%s%s%s", PLR_PREFIX, SLASH, *player_table[id].name,
      SLASH, player_table[id].name, PLR_SUFFIX);
    if(!(fl = fbopen(filename, FB_READ))) {
      sprintf(buf, "SYSERR: Couldn't open player file %s", filename);
      mudlog(buf, NRM, LVL_GOD, TRUE);
      return (-1);
    }

    /* character initializations */
    /* initializations necessary to keep some things straight */
    if (ch->player_specials == NULL)
      CREATE(ch->player_specials, struct player_special_data, 1);

    ch->in_room = NOWHERE;
    ch->carrying = NULL;
    ch->next = NULL;
    ch->next_fighting = NULL;
    ch->next_in_room = NULL;
    FIGHTING(ch) = NULL;
    ch->char_specials.position = POS_STANDING;
    ch->mob_specials.default_pos = POS_STANDING;
    ch->char_specials.carry_weight = 0;
    ch->char_specials.carry_items = 0;
    ch->affected = NULL;
    for(i = 1; i <= MAX_SKILLS; i++)
      GET_SKILL_LS(ch, i) = 0;
    GET_SEX(ch) = PFDEF_SEX;
    GET_CLASS(ch) = PFDEF_CLASS;
    GET_LEVEL(ch) = PFDEF_LEVEL;
    GET_HOME(ch) = PFDEF_HOMETOWN;
    GET_HEIGHT(ch) = PFDEF_HEIGHT;
    GET_WEIGHT(ch) = PFDEF_WEIGHT;
    GET_ALIGNMENT(ch) = PFDEF_ALIGNMENT;
    PLR_FLAGS(ch) = PFDEF_PLRFLAGS;
    AFF_FLAGS(ch) = PFDEF_AFFFLAGS;
    AFF2_FLAGS(ch) = PFDEF_AFFFLAGS;
    AFF3_FLAGS(ch) = PFDEF_AFFFLAGS;

    for(i = 0; i < NUM_OF_SAVE_THROWS; i++)
      GET_SAVE(ch, i) = PFDEF_SAVETHROW;

    for(h = 0; h < MAX_REMORT; h++) {
      GET_CLASS_REMORT(ch, h) = -1;
      for(i = 0; i < MAX_RSKILLS; i++)
        GET_RSKILL(ch, h, i) = 0;
    }

    GET_LOADROOM(ch) = PFDEF_LOADROOM;
    GET_INVIS_LEV(ch) = PFDEF_INVISLEV;
    GET_FREEZE_LEV(ch) = PFDEF_FREEZELEV;
    GET_WIMP_LEV(ch) = PFDEF_WIMPLEV;
    GET_COND(ch, FULL) = PFDEF_HUNGER;
    GET_COND(ch, THIRST) = PFDEF_THIRST;
    GET_COND(ch, DRUNK) = PFDEF_DRUNK;
    GET_BAD_PWS(ch) = PFDEF_BADPWS;
    PRF_FLAGS(ch) = PFDEF_PREFFLAGS;
    PRF2_FLAGS(ch) = PFDEF_PREFFLAGS;
    GET_PRACTICES(ch) = PFDEF_PRACTICES;
    GET_GOLD(ch) = PFDEF_GOLD;
    GET_BANK_GOLD(ch) = PFDEF_BANK;
    GET_EXP(ch) = PFDEF_EXP;
    GET_HITROLL(ch) = PFDEF_HITROLL;
	HOUSE(ch) = 0;
    GET_DAMROLL(ch) = PFDEF_DAMROLL;
    GET_AC(ch) = PFDEF_AC;
    ch->real_abils.str = PFDEF_STR;
    ch->real_abils.str_add = PFDEF_STRADD;
    ch->real_abils.dex = PFDEF_DEX;
    ch->real_abils.intel = PFDEF_INT;
    ch->real_abils.wis = PFDEF_WIS;
    ch->real_abils.con = PFDEF_CON;
    ch->real_abils.cha = PFDEF_CHA;
    GET_HIT(ch) = PFDEF_HIT;
    GET_MAX_HIT(ch) = PFDEF_MAXHIT;
    GET_MANA(ch) = PFDEF_MANA;
    GET_MAX_MANA(ch) = PFDEF_MAXMANA;
    GET_MOVE(ch) = PFDEF_MOVE;
    GET_MAX_MOVE(ch) = PFDEF_MAXMOVE;
    GET_KILLED(ch) = PFDEF_WD;
    GET_FBI_POS(ch) = PFDEF_WD;
    GET_DIED(ch) = PFDEF_WD;
    GET_ARENA_KILLED(ch) = PFDEF_WD;
    GET_ARENA_DIED(ch) = PFDEF_WD;
    GET_TRANS(ch)	= PFDEF_WD;
    GET_TRANS_HP(ch) = PFDEF_WD;
    GET_TRANS_MANA(ch) = PFDEF_WD;
    GET_TRANS_MOVE(ch) = PFDEF_WD;
    GET_REMORT(ch) = PFDEF_WD;
    ch->current_quest = PFDEF_WD;
//    set_title(ch, NULL);
//    set_prename(ch, NULL);
    GET_POINTS(ch) = PFDEF_WD;
    GET_QP(ch) = PFDEF_WD;
    GET_CLAN(ch) = 0;
    GET_CLAN_POS(ch) = 0;
    ch->player_specials->saved.olc_zone = -1;
    GET_RACE(ch) = PFDEF_WD;
    GET_STYLE(ch) = PFDEF_WD;
    GET_CP(ch) = PFDEF_WD;
    LIBERDADE(ch) = 0;
    GET_RELIGION(ch) = PFDEF_WD;
    GET_RP(ch) = 0;

    while(fbgetline(fl, line)) {
      tag_argument(line, tag);
      num = atoi(line);

      switch (*tag) {
      case 'A':
	if(!strcmp(tag, "Ac  "))
	  GET_AC(ch) = num;
	else if(!strcmp(tag, "Act "))
	  PLR_FLAGS(ch) = num;
	else if(!strcmp(tag, "Aff "))
	  AFF_FLAGS(ch) = asciiflag_conv(line);
	else if(!strcmp(tag, "Aff2"))
	  AFF2_FLAGS(ch) = asciiflag_conv(line);
	else if(!strcmp(tag, "Aff3"))
	  AFF3_FLAGS(ch) = asciiflag_conv(line);
	else if(!strcmp(tag, "Affs")) {
	  i = 0;
	  do {
	    fbgetline(fl, line);
	    sscanf(line, "%d %d %d %d %d %d %d", &num, &num2, &num3, &num4, &num5, &num6, &num7);
	    if(num > 0) {
	      af.type = num;
	      af.duration = num2;
	      af.modifier = num3;
	      af.location = num4;
	      af.bitvector = num5;
	      af.bitvector2 = num6;
	      af.bitvector3 = num7;
	      affect_to_char(ch, &af);
	      i++;
	    }
	  } while (num != 0);
	} else if(!strcmp(tag, "Alin"))
	  GET_ALIGNMENT(ch) = num;
	else if(!strcmp(tag, "Arnk"))
	  GET_ARENA_KILLED(ch) = num;
	else if(!strcmp(tag, "Arnd"))
	  GET_ARENA_DIED(ch) = num;
	break;

      case 'B':
	if(!strcmp(tag, "Badp"))
	  GET_BAD_PWS(ch) = num;
	else if(!strcmp(tag, "Bank"))
	  GET_BANK_GOLD(ch) = num;
	else if(!strcmp(tag, "Brth"))
	  ch->player.time.birth = num;
	break;

      case 'C':
	if(!strcmp(tag, "Cha "))
	  ch->real_abils.cha = num;
	else if(!strcmp(tag, "Clas"))
	  GET_CLASS(ch) = num;
	else if(!strcmp(tag, "Con "))
	  ch->real_abils.con = num;
	else if(!strcmp(tag, "Cpo "))
	  GET_CP(ch) = num;
	break;

      case 'D':
/*	if(!strcmp(tag, "Desc"))
	  ch->player.description = fbgetstring(fl);
	else*/ if(!strcmp(tag, "Dex "))
	  ch->real_abils.dex = num;
	else if(!strcmp(tag, "Died"))
	  GET_DIED(ch) = num;
	else if(!strcmp(tag, "Drnk"))
	  GET_COND(ch, DRUNK) = num;
	else if(!strcmp(tag, "Drol"))
	  GET_DAMROLL(ch) = num;
	break;

      case 'E':
	if(!strcmp(tag, "Exp "))
	  GET_EXP(ch) = num;
	break;

      case 'F':
	if(!strcmp(tag, "Frez"))
	  GET_FREEZE_LEV(ch) = num;
	else if(!strcmp(tag, "Fbip"))
	  GET_FBI_POS(ch) = num;
	break;

      case 'G':
	if(!strcmp(tag, "Gold"))
	  GET_GOLD(ch) = num;
	break;

      case 'H':
	if(!strcmp(tag, "Hit ")) {
	  sscanf(line, "%d/%d", &num, &num2);
	  GET_HIT(ch) = num;
	  GET_MAX_HIT(ch) = num2;
	} else if(!strcmp(tag, "Hite"))
	  GET_HEIGHT(ch) = num;
	else if(!strcmp(tag, "Home"))
	  GET_HOME(ch) = num;
/*	else if(!strcmp(tag, "Host"))
	  ch->player_specials->host = str_dup(line);*/
	else if(!strcmp(tag, "Hrol"))
	  GET_HITROLL(ch) = num;
	else if(!strcmp(tag, "Hous"))
	  HOUSE(ch) = num;
	else if(!strcmp(tag, "Hung"))
	 GET_COND(ch, FULL) = num;
	break;

      case 'I':
	if(!strcmp(tag, "Id  "))
	  GET_IDNUM(ch) = num;
	else if(!strcmp(tag, "Int "))
	  ch->real_abils.intel = num;
	else if(!strcmp(tag, "Invs"))
	  GET_INVIS_LEV(ch) = num;
	break;

      case 'K':
	if(!strcmp(tag, "Kild"))
	  GET_KILLED(ch) = num;
	else if(!strcmp(tag, "Klan"))
	   GET_CLAN(ch) = num;
	else if(!strcmp(tag, "Klar"))
	    GET_CLAN_POS(ch) = num;
      break;

      case 'L':
	if(!strcmp(tag, "Last"))
	  ch->player.time.logon = num;
	else if(!strcmp(tag, "Lern"))
	  GET_PRACTICES(ch) = num;
	else if(!strcmp(tag, "Levl"))
	  GET_LEVEL(ch) = num;
	else if(!strcmp(tag, "Lbrd"))
	  LIBERDADE(ch) = num;
	break;

      case 'M':
	if(!strcmp(tag, "Mana")) {
	  sscanf(line, "%d/%d", &num, &num2);
	  GET_MANA(ch) = num;
	  GET_MAX_MANA(ch) = num2;
	} else if(!strcmp(tag, "Move")) {
	  sscanf(line, "%d/%d", &num, &num2);
	  GET_MOVE(ch) = num;
	  GET_MAX_MOVE(ch) = num2;
	} else if(!strcmp(tag, "Ment")) {
	  sscanf(line, "%d/%d", &num, &num2);
	  GET_MENTAL(ch) = num;
	  GET_MAX_MENTAL(ch) = num2;
	}
	break;

      case 'N':
	if(!strcmp(tag, "Name"))
	  GET_NAME(ch) = str_dup(line);
	break;

      case 'O':
	if(!strcmp(tag, "Oxi ")) {
	  sscanf(line, "%d/%d", &num, &num2);
	  GET_OXI(ch) = num;
	  GET_MAX_OXI(ch) = num2;
	} else if(!strcmp(tag, "OLCz"))
	  ch->player_specials->saved.olc_zone = num;
	break;

      case 'P':
	if(!strcmp(tag, "Pass"))
	  strcpy(GET_PASSWD(ch), line);
	else if(!strcmp(tag, "Plyd"))
	  ch->player.time.played = num;
#ifdef ASCII_SAVE_POOFS
	else if(!strcmp(tag, "PfIn"))
	  POOFIN(ch) = str_dup(line);
	else if(!strcmp(tag, "PfOt"))
	  POOFOUT(ch) = str_dup(line);
#endif
	else if(!strcmp(tag, "Pref"))
	  PRF_FLAGS(ch) = asciiflag_conv(line);
	else if(!strcmp(tag, "Pren"))
	  GET_PRENAME(ch) = str_dup(line);
	else if(!strcmp(tag, "Poin"))
	  GET_POINTS(ch) = num;
	else if(!strcmp(tag, "Prf2"))
	  PRF2_FLAGS(ch) = asciiflag_conv(line);
	break;

      case 'Q':
	if(!strcmp(tag, "Qust"))
	  ch->current_quest = num;
	else if(!strcmp(tag, "Qspo"))
	  GET_QP(ch) = num;
  	break;

      case 'R':
	if(!strcmp(tag, "Room"))
	  GET_LOADROOM(ch) = num;
	else if(!strcmp(tag, "Remt"))
	  GET_REMORT(ch) = num;
	else if(!strcmp(tag, "Race"))
	  GET_RACE(ch) = num;
	else if(!strcmp(tag, "Relg"))
	  GET_RELIGION(ch) = num;
	else if(!strcmp(tag, "Rppo"))
	  GET_RP(ch) = num;
	else if(!strcmp(tag, "RSkl")) {
	  do {
	    fbgetline(fl, line);
	    sscanf(line, "%d %d %d %d %d %d %d", &num, &num2, &num3, &num4, &num5, &num6, &num7);
	    GET_CLASS_REMORT(ch, num) = num2;
	    GET_RSKILL(ch, num, 0) = num3;
	    GET_RSKILL(ch, num, 1) = num4;
	    GET_RSKILL(ch, num, 2) = num5;
	    GET_RSKILL(ch, num, 3) = num6;
	    GET_RSKILL(ch, num, 4) = num7;
	  } while (num != 0);
	}
	break;

      case 'S':
	if(!strcmp(tag, "Sex "))
	  GET_SEX(ch) = num;
	else if(!strcmp(tag, "Skil")) {
	  do {
	    fbgetline(fl, line);
	    sscanf(line, "%d %d", &num, &num2);
	      if(num != 0)
		GET_SKILL_LS(ch, num) = num2;
	  } while (num != 0);
	} else if(!strcmp(tag, "Str ")) {
	  sscanf(line, "%d/%d", &num, &num2);
	  ch->real_abils.str = num;
	  ch->real_abils.str_add = num2;
	} else if(!strcmp(tag, "Styl"))
	  GET_STYLE(ch) = num;
	break;

      case 'T':
	if(!strcmp(tag, "Thir"))
	  GET_COND(ch, THIRST) = num;
	else if(!strcmp(tag, "Thr1"))
	  GET_SAVE(ch, 0) = num;
	else if(!strcmp(tag, "Thr2"))
	  GET_SAVE(ch, 1) = num;
	else if(!strcmp(tag, "Thr3"))
	  GET_SAVE(ch, 2) = num;
	else if(!strcmp(tag, "Thr4"))
	  GET_SAVE(ch, 3) = num;
	else if(!strcmp(tag, "Thr5"))
	  GET_SAVE(ch, 4) = num;
	else if(!strcmp(tag, "Titl"))
//	  set_title(ch, str_dup(line));
	  GET_TITLE(ch) = str_dup(line);
	else if(!strcmp(tag, "Trns"))
	  GET_TRANS(ch)	= num;
	else if(!strcmp(tag, "Trnh"))
	  GET_TRANS_HP(ch) = num;
	else if(!strcmp(tag, "Trnm"))
	  GET_TRANS_MANA(ch) = num;
	else if(!strcmp(tag, "Trnv"))
	  GET_TRANS_MOVE(ch) = num;
	break;

      case 'W':
	if(!strcmp(tag, "Wate"))
	  GET_WEIGHT(ch) = num;
	else if(!strcmp(tag, "Wimp"))
	  GET_WIMP_LEV(ch) = num;
	else if(!strcmp(tag, "Wis "))
	  ch->real_abils.wis = num;
/*	else if(!strcmp(tag, "Whoi"))
	  ch->player.whoisdesc = fbgetstring(fl);*/
	break;

      default:
	sprintf(buf, "SYSERR: Unknown tag %s in pfile %s", tag, name);
      }
    }
  }

  /* initialization for imms */
  if(GET_LEVEL(ch) >= LVL_ELDER) {
    for(i = 1; i <= MAX_SKILLS; i++)
      GET_SKILL_LS(ch, i) = 100;

    GET_COND(ch, FULL) = -1;
    GET_COND(ch, THIRST) = -1;
    GET_COND(ch, DRUNK) = -1;
  }

  fbclose(fl);
  return(id);
}

/* remove ^M's from file output */
/* There may be a similar function in Oasis (and I'm sure
   it's part of obuild).  Remove this if you get a
   multiple definition error or if it you want to use a
   substitute
*/
void kill_ems(char *str)
{
  char *ptr1, *ptr2, *tmp;

  tmp = str;
  ptr1 = str;
  ptr2 = str;

  while(*ptr1) {
    if((*(ptr2++) = *(ptr1++)) == '\r')
      if(*ptr1 == '\r')
	ptr1++;
  }
  *ptr2 = '\0';
}


void nsprintbits(long vektor, char *outstring)
{
  int i;
  char flags[53]="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

  strcpy(outstring,"");
  for (i=0;i<32;i++)
  {
    if (vektor & 1) {
      *outstring=flags[i];
      outstring++;
    };
    vektor>>=1;
  };
  *outstring=0;
}

/*
 * write the vital data of a player to the player file
 *
 * NOTE: load_room should be an *RNUM* now.  It is converted to a vnum here.
 */
/* This is the ascii pfiles save routine */
void save_char(struct char_data * ch, room_rnum load_room)
{
  FBFILE *fl;
  char outname[40], bits[127], buf[MAX_STRING_LENGTH];
  int i, h, id, save_index = FALSE;
  struct affected_type *aff, tmp_aff[MAX_AFFECT];
  struct obj_data *char_eq[NUM_WEARS];

  /* Unaffect everything a character can be affected by */
  if (IS_NPC(ch) || GET_PFILEPOS(ch) < 0)
   return;
  /* This version of save_char allows ch->desc to be null (to allow
     "set file" to use it).  This causes the player's last host
     and probably last login to null out.
  */

/*  if(ch->desc)
    ch->player_specials->host = ch->desc->host;*/

  if (!PLR_FLAGGED(ch, PLR_LOADROOM)) {
    if (load_room != NOWHERE)
      GET_LOADROOM(ch) = GET_ROOM_VNUM(load_room);
  }

  /*strcpy(player.pwd, GET_PASSWD(ch));*/

  {
    for (i = 0;
      (*(bits + i) = LOWER(*(GET_NAME(ch) + i))); i++);
    sprintf(outname, "%s%s%c%s%s%s", PLR_PREFIX, SLASH, *bits,
			SLASH, bits, PLR_SUFFIX);

    if (!(fl = fbopen(outname, FB_WRITE))) {
      sprintf(buf, "SYSERR: Couldn't open player file %s for write",
		outname);
      mudlog(buf, NRM, LVL_GOD, TRUE);
      return;
    }

    /* remove affects from eq and spells (from char_to_store) */
    /* Unaffect everything a character can be affected by */

    for (i = 0; i < NUM_WEARS; i++) {
      if (GET_EQ(ch, i))
        char_eq[i] = unequip_char(ch, i);
      else
        char_eq[i] = NULL;
    }

    for (aff = ch->affected, i = 0; i < MAX_AFFECT; i++) {
      if (aff) {
        tmp_aff[i] = *aff;
        tmp_aff[i].next = 0;
        aff = aff->next;
      } else {
        tmp_aff[i].type = 0;	/* Zero signifies not used */
        tmp_aff[i].duration = 0;
        tmp_aff[i].modifier = 0;
        tmp_aff[i].location = 0;
        tmp_aff[i].bitvector = 0;
        tmp_aff[i].bitvector2 = 0;
        tmp_aff[i].bitvector3 = 0;
        tmp_aff[i].next = 0;
      }
    }

    /*
     * remove the affections so that the raw values are stored; otherwise the
     * effects are doubled when the char logs back in.
     */

    while (ch->affected)
      affect_remove(ch, ch->affected);

    if ((i >= MAX_AFFECT) && aff && aff->next)
      log("SYSERR: WARNING: OUT OF STORE ROOM FOR AFFECTED TYPES!!!");

    ch->aff_abils = ch->real_abils;


    if(GET_NAME(ch))
      fbprintf(fl, "Name: %s\n", GET_NAME(ch));
    if(GET_PASSWD(ch))
      fbprintf(fl, "Pass: %s\n", GET_PASSWD(ch));
    if(GET_TITLE(ch))
      fbprintf(fl, "Titl: %s\n", GET_TITLE(ch));
    if(ch->player.description && *ch->player.description) {
      strcpy(buf, ch->player.description);
      kill_ems(buf);
      fbprintf(fl, "Desc:\n%s~\n", buf);
    }
#ifdef ASCII_SAVE_POOFS
    if(POOFIN(ch))
      fbprintf(fl, "PfIn: %s\n", POOFIN(ch));
    if(POOFOUT(ch))
      fbprintf(fl, "PfOt: %s\n", POOFOUT(ch));
#endif
    if(GET_SEX(ch) != PFDEF_SEX)
      fbprintf(fl, "Sex : %d\n", GET_SEX(ch));
    if(GET_CLASS(ch) != PFDEF_CLASS)
      fbprintf(fl, "Clas: %d\n", GET_CLASS(ch));
    if(GET_LEVEL(ch) != PFDEF_LEVEL)
      fbprintf(fl, "Levl: %d\n", GET_LEVEL(ch));
    if(GET_HOME(ch) != PFDEF_HOMETOWN)
      fbprintf(fl, "Home: %d\n", GET_HOME(ch));

    fbprintf(fl, "Brth: %d\n", (int) ch->player.time.birth);
    fbprintf(fl, "Plyd: %d\n", (int) ch->player.time.played);
    fbprintf(fl, "Last: %d\n", (int) ch->player.time.logon);

/*    if(ch->player_specials->host)
      fbprintf(fl, "Host: %s\n", ch->player_specials->host);*/

    if(GET_HEIGHT(ch) != PFDEF_HEIGHT)
      fbprintf(fl, "Hite: %d\n", GET_HEIGHT(ch));
    if(GET_WEIGHT(ch) != PFDEF_HEIGHT)
      fbprintf(fl, "Wate: %d\n", GET_WEIGHT(ch));

    if(GET_ALIGNMENT(ch) != PFDEF_ALIGNMENT)
      fbprintf(fl, "Alin: %d\n", GET_ALIGNMENT(ch));
    fbprintf(fl, "Id  : %ld\n", GET_IDNUM(ch));
    if(PLR_FLAGS(ch) != PFDEF_PLRFLAGS)
      fbprintf(fl, "Act : %ld\n", PLR_FLAGS(ch));
    if(AFF_FLAGS(ch) != PFDEF_AFFFLAGS) {
      nsprintbits(AFF_FLAGS(ch), bits);
      fbprintf(fl, "Aff : %s\n", bits);
    }
   if(AFF2_FLAGS(ch) != PFDEF_AFFFLAGS) {
      nsprintbits(AFF2_FLAGS(ch), bits);
      fbprintf(fl, "Aff2: %s\n", bits);
    }
   if(AFF3_FLAGS(ch) != PFDEF_AFFFLAGS) {
      nsprintbits(AFF3_FLAGS(ch), bits);
      fbprintf(fl, "Aff3: %s\n", bits);
    }
    if(GET_SAVE(ch, 0) != PFDEF_SAVETHROW)
      fbprintf(fl, "Thr1: %d\n", GET_SAVE(ch, 0));
    if(GET_SAVE(ch, 1) != PFDEF_SAVETHROW)
      fbprintf(fl, "Thr2: %d\n", GET_SAVE(ch, 1));
    if(GET_SAVE(ch, 2) != PFDEF_SAVETHROW)
      fbprintf(fl, "Thr3: %d\n", GET_SAVE(ch, 2));
    if(GET_SAVE(ch, 3) != PFDEF_SAVETHROW)
      fbprintf(fl, "Thr4: %d\n", GET_SAVE(ch, 3));
    if(GET_SAVE(ch, 4) != PFDEF_SAVETHROW)
      fbprintf(fl, "Thr5: %d\n", GET_SAVE(ch, 4));

    if(GET_LEVEL(ch) < LVL_ELDER) {
      fbprintf(fl, "Skil:\n");
      for(i = 1; i <= MAX_SKILLS; i++) {
	if(GET_SKILL_LS(ch, i))
	  fbprintf(fl, "%d %d\n", i, GET_SKILL_LS(ch, i));
      }
      fbprintf(fl, "0 0\n");
    }
    if(GET_LEVEL(ch) < LVL_ELDER && GET_REMORT(ch) > 0) {
      fbprintf(fl, "RSkl:\n");
      for(h = 1; h <= GET_REMORT(ch); h++) {
 	       fbprintf(fl, "%d %d", h, GET_CLASS_REMORT(ch, h));
	       for(i = 0; i < MAX_RSKILLS; i++)
		   fbprintf(fl, " %d", GET_RSKILL(ch, h, i));
	       fbprintf(fl, "\n");
      }
      fbprintf(fl, "0 0 0 0 0 0 0\n");
    }
    if(GET_WIMP_LEV(ch) != PFDEF_WIMPLEV)
      fbprintf(fl, "Wimp: %d\n", GET_WIMP_LEV(ch));
    if(GET_FREEZE_LEV(ch) != PFDEF_FREEZELEV)
      fbprintf(fl, "Frez: %d\n", GET_FREEZE_LEV(ch));
    if(GET_INVIS_LEV(ch) != PFDEF_INVISLEV)
      fbprintf(fl, "Invs: %d\n", GET_INVIS_LEV(ch));
    if(GET_LOADROOM(ch) != PFDEF_LOADROOM)
      fbprintf(fl, "Room: %d\n", GET_LOADROOM(ch));
    if(PRF_FLAGS(ch) != PFDEF_PREFFLAGS) {
      nsprintbits(PRF_FLAGS(ch), bits);
      fbprintf(fl, "Pref: %s\n", bits);
    }
    if(GET_BAD_PWS(ch) != PFDEF_BADPWS)
      fbprintf(fl, "Badp: %d\n", GET_BAD_PWS(ch));
    if(GET_COND(ch, FULL) != PFDEF_HUNGER && GET_LEVEL(ch) < LVL_IMMORT)
      fbprintf(fl, "Hung: %d\n", GET_COND(ch, FULL));
    if(GET_COND(ch, THIRST) != PFDEF_THIRST && GET_LEVEL(ch) < LVL_IMMORT)
      fbprintf(fl, "Thir: %d\n", GET_COND(ch, THIRST));
    if(GET_COND(ch, DRUNK) != PFDEF_DRUNK && GET_LEVEL(ch) < LVL_IMMORT)
      fbprintf(fl, "Drnk: %d\n", GET_COND(ch, DRUNK));
    if(GET_PRACTICES(ch) != PFDEF_PRACTICES)
      fbprintf(fl, "Lern: %d\n", GET_PRACTICES(ch));

    if(GET_STR(ch) != PFDEF_STR || GET_ADD(ch) != PFDEF_STRADD)
      fbprintf(fl, "Str : %d/%d\n", GET_STR(ch), GET_ADD(ch));
    if(GET_INT(ch) != PFDEF_INT)
      fbprintf(fl, "Int : %d\n", GET_INT(ch));
    if(GET_WIS(ch) != PFDEF_WIS)
      fbprintf(fl, "Wis : %d\n", GET_WIS(ch));
    if(GET_DEX(ch) != PFDEF_DEX)
      fbprintf(fl, "Dex : %d\n", GET_DEX(ch));
    if(GET_CON(ch) != PFDEF_CON)
      fbprintf(fl, "Con : %d\n", GET_CON(ch));
    if(GET_CHA(ch) != PFDEF_CHA)
      fbprintf(fl, "Cha : %d\n", GET_CHA(ch));
    if(GET_HIT(ch) != PFDEF_HIT || GET_MAX_HIT(ch) != PFDEF_MAXHIT)
      fbprintf(fl, "Hit : %d/%d\n", GET_HIT(ch), GET_MAX_HIT(ch));
    if(GET_MANA(ch) != PFDEF_MANA || GET_MAX_MANA(ch) != PFDEF_MAXMANA)
      fbprintf(fl, "Mana: %d/%d\n", GET_MANA(ch), GET_MAX_MANA(ch));
    if(GET_MOVE(ch) != PFDEF_MOVE || GET_MAX_MOVE(ch) != PFDEF_MAXMOVE)
      fbprintf(fl, "Move: %d/%d\n", GET_MOVE(ch), GET_MAX_MOVE(ch));
    if(GET_MENTAL(ch) != PFDEF_MOVE || GET_MAX_MENTAL(ch) != PFDEF_MAXMOVE)
      fbprintf(fl, "Ment: %d/%d\n", GET_MENTAL(ch), GET_MAX_MENTAL(ch));
    if(GET_OXI(ch) != PFDEF_MOVE || GET_MAX_OXI(ch) != PFDEF_MAXMOVE)
      fbprintf(fl, "Oxi : %d/%d\n", GET_OXI(ch), GET_MAX_OXI(ch));
    if(GET_AC(ch) != PFDEF_AC)
      fbprintf(fl, "Ac  : %d\n", GET_AC(ch));
    if(GET_GOLD(ch) != PFDEF_GOLD)
      fbprintf(fl, "Gold: %d\n", GET_GOLD(ch));
    if(GET_BANK_GOLD(ch) != PFDEF_BANK)
      fbprintf(fl, "Bank: %d\n", GET_BANK_GOLD(ch));
    if(GET_EXP(ch) != PFDEF_EXP)
      fbprintf(fl, "Exp : %d\n", GET_EXP(ch));
    if(GET_HITROLL(ch) != PFDEF_HITROLL)
      fbprintf(fl, "Hrol: %d\n", GET_HITROLL(ch));
    if(HOUSE(ch) != 0)
      fbprintf(fl, "Hous: %d\n", HOUSE(ch));
    if(GET_DAMROLL(ch))
      fbprintf(fl, "Drol: %d\n", GET_DAMROLL(ch));
    if(GET_KILLED(ch))
      fbprintf(fl, "Kild: %d\n", GET_KILLED(ch));
    if(GET_FBI_POS(ch))
      fbprintf(fl, "Fbip: %d\n", GET_FBI_POS(ch));
    if(GET_DIED(ch))
      fbprintf(fl, "Died: %d\n", GET_DIED(ch));
    if(GET_ARENA_KILLED(ch))
      fbprintf(fl, "Arnk: %d\n", GET_ARENA_KILLED(ch));
    if(GET_ARENA_DIED(ch))
      fbprintf(fl, "Arnd: %d\n", GET_ARENA_DIED(ch));
    if(GET_TRANS(ch))
      fbprintf(fl, "Trns: %d\n", GET_TRANS(ch));
    if(GET_TRANS_HP(ch))
      fbprintf(fl, "Trnh: %d\n", GET_TRANS_HP(ch));
    if(GET_TRANS_MANA(ch))
      fbprintf(fl, "Trnm: %d\n", GET_TRANS_MANA(ch));
    if(GET_TRANS_MOVE(ch))
      fbprintf(fl, "Trnv: %d\n", GET_TRANS_MOVE(ch));
    if(GET_REMORT(ch))
      fbprintf(fl, "Remt: %d\n", GET_REMORT(ch));
    if(ch->current_quest)
      fbprintf(fl, "Qust: %d\n", ch->current_quest);

    if(ch->player.whoisdesc && *ch->player.whoisdesc) {
      strcpy(buf, ch->player.whoisdesc);
      kill_ems(buf);
      fbprintf(fl, "Whoi:\n%s~\n", buf);
    }

    if (GET_PRENAME(ch))
      fbprintf(fl, "Pren: %s\n", GET_PRENAME(ch));
    if(GET_POINTS(ch))
      fbprintf(fl, "Poin: %d\n", GET_POINTS(ch));
    if(GET_QP(ch))
      fbprintf(fl, "Qspo: %d\n", GET_QP(ch));
    if(ch->player_specials->saved.olc_zone)
      fbprintf(fl, "OLCz: %d\n", ch->player_specials->saved.olc_zone);
    if(GET_CLAN(ch))
      fbprintf(fl, "Klan: %d\n", GET_CLAN(ch));
    if(GET_CLAN_POS(ch))
      fbprintf(fl, "Klar: %d\n", GET_CLAN_POS(ch));
    if(GET_RACE(ch))
      fbprintf(fl, "Race: %d\n", GET_RACE(ch));
    if(PRF2_FLAGS(ch) != PFDEF_PREFFLAGS) {
      nsprintbits(PRF2_FLAGS(ch), bits);
      fbprintf(fl, "Prf2: %s\n", bits);
    }
    if(GET_STYLE(ch))
      fbprintf(fl, "Styl: %d\n", GET_STYLE(ch));
    if(GET_CP(ch))
      fbprintf(fl, "Cpo : %d\n", GET_CP(ch));
    if(LIBERDADE(ch))
      fbprintf(fl, "Lbrd: %d\n", LIBERDADE(ch));
    if(GET_RELIGION(ch))
      fbprintf(fl, "Relg: %d\n", GET_RELIGION(ch));
    if(GET_RP(ch))
      fbprintf(fl, "Rppo: %d\n", GET_RP(ch));
    /* affected_type */
    if(tmp_aff[0].type > 0) {
      fbprintf(fl, "Affs:\n");
      for(i = 0; i < MAX_AFFECT; i++) {
	aff = &tmp_aff[i];
	if(aff->type)
	  fbprintf(fl, "%d %d %d %d %d %d %d\n", aff->type, aff->duration,
	    aff->modifier, aff->location, (int)aff->bitvector, (int)aff->bitvector2, (int)aff->bitvector3);
      }
      fbprintf(fl, "0 0 0 0 0\n");
    }

    fbclose(fl);

    for (i = 0; i < NUM_WEARS; i++) {
      if (char_eq[i])
        equip_char(ch, char_eq[i], i);
    }

    /* add spell and eq affections back in now */
    for (i = 0; i < MAX_AFFECT; i++) {
      if (tmp_aff[i].type)
        affect_to_char(ch, &tmp_aff[i]);
    }

    /* end char_to_store code */

    if((id = find_name(GET_NAME(ch))) < 0)
      return;

    /* update the player in the player index */
    if(player_table[id].level != GET_LEVEL(ch)) {
      save_index = TRUE;
      player_table[id].level = GET_LEVEL(ch);
    }
    if(player_table[id].last != ch->player.time.logon) {
      save_index = TRUE;
      player_table[id].last = ch->player.time.logon;
    }
    i = player_table[id].flags;
    if(PLR_FLAGGED(ch, PLR_DELETED))
      SET_BIT(player_table[id].flags, PINDEX_DELETED);
    else
      REMOVE_BIT(player_table[id].flags, PINDEX_DELETED);
    if(PLR_FLAGGED(ch, PLR_NODELETE) || PLR_FLAGGED(ch, PLR_CRYO))
      SET_BIT(player_table[id].flags, PINDEX_NODELETE);
    else
      REMOVE_BIT(player_table[id].flags, PINDEX_NODELETE);
    /*if(player_table[id].flags != i || save_index)
      save_player_index();*/
  }
}



void save_etext(struct char_data * ch)
{
/* this will be really cool soon */

}

/* create a new entry in the in-memory index table for the player file */
int create_entry(char *name)
{
  int i, pos;

  if (top_of_p_table == -1) {	/* no table */
    CREATE(player_table, struct player_index_element, 1);
    pos = top_of_p_table = 0;
  } else if ((pos = get_ptable_by_name(name)) == -1) {	/* new name */
    i = ++top_of_p_table + 1;

    RECREATE(player_table, struct player_index_element, i);
    pos = top_of_p_table;
  }

  CREATE(player_table[pos].name, char, strlen(name) + 1);

  /* copy lowercase equivalent of name to table field */
  for (i = 0; (player_table[pos].name[i] = LOWER(name[i])); i++)
	/* Nothing */;

  return (pos);
}



/************************************************************************
*  funcs of a (more or less) general utility nature                     *
************************************************************************/


/* read and allocate space for a '~'-terminated string from a given file */
char *fread_string(FILE * fl, char *error)
{
  char buf[MAX_STRING_LENGTH], tmp[512], *rslt;
  char *point;
  int done = 0, length = 0, templength = 0;

  *buf = '\0';

  do {
    if (!fgets(tmp, 512, fl)) {
      log("SYSERR: fread_string: format error at or near %s", error);
      exit(1);
    }
    /* If there is a '~', end the string; else put an "\r\n" over the '\n'. */
    if ((point = strchr(tmp, '~')) != NULL) {
      *point = '\0';
      done = 1;
    } else {
      point = tmp + strlen(tmp) - 1;
      *(point++) = '\r';
      *(point++) = '\n';
      *point = '\0';
    }

    templength = strlen(tmp);

    if (length + templength >= MAX_STRING_LENGTH) {
      log("SYSERR: fread_string: string too large (db.c)");
      log(error);
      exit(1);
    } else {
      strcat(buf + length, tmp);
      length += templength;
    }
  } while (!done);

  /* allocate space for the new string and copy it */
  if (strlen(buf) > 0) {
    CREATE(rslt, char, length + 1);
    strcpy(rslt, buf);
  } else
    rslt = NULL;

  return rslt;
}


/* release memory allocated for a char struct */
void free_char(struct char_data * ch)
{
  int i;
  struct alias *a;

  if (ch->player_specials != NULL && ch->player_specials != &dummy_mob) {
    while ((a = GET_ALIASES(ch)) != NULL) {
      GET_ALIASES(ch) = (GET_ALIASES(ch))->next;
      free_alias(a);
    }
    if (ch->player_specials->poofin)
      free(ch->player_specials->poofin);
    if (ch->player_specials->poofout)
      free(ch->player_specials->poofout);
    if (ch->player_specials->last_olc_targ)
      free(ch->player_specials->last_olc_targ);
    if (ch->player_specials->betted_on)
      free(ch->player_specials->betted_on);
    if (ch->player_specials->host)
      free(ch->player_specials->host);
    if (ch->player_specials)
      free(ch->player_specials);
    if (IS_NPC(ch))
      log("SYSERR: Mob %s (#%d) had player_specials allocated!", GET_NAME(ch), GET_MOB_VNUM(ch));
  }
  if (!IS_NPC(ch) || (IS_NPC(ch) && GET_MOB_RNUM(ch) == -1)) {
    /* if this is a player, or a non-prototyped non-player, free all */
    if (GET_NAME(ch))
      free(GET_NAME(ch));
    if (ch->player.title)
      free(ch->player.title);
    if (ch->player.short_descr)
      free(ch->player.short_descr);
    if (ch->player.long_descr)
      free(ch->player.long_descr);
    if (ch->player.description)
      free(ch->player.description);
    if (ch->player.whoisdesc)
      free(ch->player.whoisdesc);
    if (ch->player.prename)
      free(ch->player.prename);
    if(ch->player.challenger)
      free(ch->player.challenger);
  } else if ((i = GET_MOB_RNUM(ch)) > -1) {
    /* otherwise, free strings only if the string is not pointing at proto */
    if (ch->player.name && ch->player.name != mob_proto[i].player.name)
      free(ch->player.name);
    if (ch->player.title && ch->player.title != mob_proto[i].player.title)
      free(ch->player.title);
    if (ch->player.short_descr && ch->player.short_descr != mob_proto[i].player.short_descr)
      free(ch->player.short_descr);
    if (ch->player.long_descr && ch->player.long_descr != mob_proto[i].player.long_descr)
      free(ch->player.long_descr);
    if (ch->player.description && ch->player.description != mob_proto[i].player.description)
      free(ch->player.description);
  }
  while (ch->affected)
    affect_remove(ch, ch->affected);
  free(ch->affected);

  if (ch->desc)
    ch->desc->character = NULL;

  if (ch)
    free(ch);

  ch = NULL;
}

/* end of ascii pfile added functions */


/* new functions used by ascii pfiles */

/* Separate a 4-character id tag from the data it precedes */
void tag_argument(char *argument, char *tag)
{
  char *tmp = argument, *ttag = tag, *wrt = argument;
  int i;

  for(i = 0; i < 4; i++)
    *(ttag++) = *(tmp++);
  *ttag = '\0';

  while(*tmp == ':' || *tmp == ' ')
    tmp++;

  while(*tmp)
    *(wrt++) = *(tmp++);
  *wrt = '\0';
}


/* This function necessary to save a seperate ascii player index */
void save_player_index(void)
{
  int i;
  char bits[64];
  FBFILE *index_file;

  if(!(index_file = fbopen(PLR_INDEX_FILE, FB_WRITE))) {
    log("SYSERR:  Could not write player index file");
    return;
  }

  for(i = 0; i <= top_of_p_table; i++)
    if(*player_table[i].name) {
      sprintbits(player_table[i].flags, bits);
      fbprintf(index_file, "%ld %s %d %s %ld\n", player_table[i].id,
	player_table[i].name, player_table[i].level, *bits ? bits : "0",
	player_table[i].last);
    }
  fbprintf(index_file, "~\n");

  fbclose(index_file);
}

/* remove_player removes all files associated with a player who is
   self-deleted, deleted by an immortal, or deleted by the auto-wipe
   system (if enabled).  If you add more character files, you'll want
   to put a remover here.
*/
void remove_player(int pfilepos)
{
  struct char_data *tch;
  char pfile_name[128], rent_name[128], alias_name[128];

  if(!*player_table[pfilepos].name)
    return;

  CREATE(tch, struct char_data, 1);
  clear_char(tch);
  CREATE(tch->player_specials, struct player_special_data, 1);
  if (load_char(player_table[pfilepos].name, tch) > -1)
	if(GET_CLAN(tch) && GET_CLAN_POS(tch))
	  	remove_do_clan(tch);
  free_char(tch);

  sprintf(pfile_name, "%s%s%c%s%s%s", PLR_PREFIX, SLASH, *player_table[pfilepos].name,
      SLASH, player_table[pfilepos].name, PLR_SUFFIX);
  unlink(pfile_name);

  if (get_filename(player_table[pfilepos].name, rent_name, CRASH_FILE))
    unlink(rent_name);

  if (get_filename(player_table[pfilepos].name, alias_name, ALIAS_FILE))
    unlink(alias_name);

  sprintf(buf, "PCLEAN: %s Lev: %d Last: %s",
	player_table[pfilepos].name, player_table[pfilepos].level,
	asctime(localtime(&player_table[pfilepos].last)));
  log(buf);
  player_table[pfilepos].name[0] = '\0';
  save_player_index();
}


void clean_pfiles(void)
{
  int i, ci, timeout;

  for(i = 0; i <= top_of_p_table; i++) {
    if(IS_SET(player_table[i].flags, PINDEX_NODELETE))
      continue;
    timeout = -1;
    for(ci = 0; ci == 0 || (pclean_criteria[ci].level >
	pclean_criteria[ci - 1].level); ci++) {
      if((pclean_criteria[ci].level == -1 && IS_SET(player_table[i].flags,
		PINDEX_DELETED)) || player_table[i].level <=
		pclean_criteria[ci].level) {
	timeout = pclean_criteria[ci].days;
	break;
      }
    }
    if(timeout >= 0) {
      timeout *= SECS_PER_REAL_DAY;
      if((time(0) - player_table[i].last) > timeout)
	remove_player(i);
    }
  }
}

/* release memory allocated for an obj struct */
void free_obj(struct obj_data * obj)
{
  int nr;
  struct extra_descr_data *thisd, *next_one;

  if ((nr = GET_OBJ_RNUM(obj)) == -1) {
    if (obj->name)
      free(obj->name);
    if (obj->description)
      free(obj->description);
    if (obj->short_description)
      free(obj->short_description);
    if (obj->action_description)
      free(obj->action_description);
    if (obj->ex_description)
      for (thisd = obj->ex_description; thisd; thisd = next_one) {
        next_one = thisd->next;
        if (thisd->keyword)
          free(thisd->keyword);
        if (thisd->description)
          free(thisd->description);
        free(thisd);
      }
  } else {
    if (obj->name && obj->name != obj_proto[nr].name)
      free(obj->name);
    if (obj->description && obj->description != obj_proto[nr].description)
      free(obj->description);
    if (obj->short_description && obj->short_description != obj_proto[nr].short_description)
      free(obj->short_description);
    if (obj->action_description && obj->action_description != obj_proto[nr].action_description)
      free(obj->action_description);
    if (obj->ex_description && obj->ex_description != obj_proto[nr].ex_description)
      for (thisd = obj->ex_description; thisd; thisd = next_one) {
        next_one = thisd->next;
        if (thisd->keyword)
          free(thisd->keyword);
        if (thisd->description)
          free(thisd->description);
        free(thisd);
      }
  }
  if(obj)
    free(obj);

}



/* read contets of a text file, alloc space, point buf to it */
int file_to_string_alloc(const char *name, char **buf)
{
  char temp[MAX_STRING_LENGTH];

  if (*buf)
    free(*buf);

  if (file_to_string(name, temp) < 0) {
    *buf = NULL;
    return -1;
  } else {
    *buf = str_dup(temp);
    return 0;
  }
}


/* read contents of a text file, and place in buf */
int file_to_string(const char *name, char *buf)
{
  FILE *fl;
  char tmp[READ_SIZE+3];

  *buf = '\0';

  if (!(fl = fopen(name, "r"))) {
    sprintf(tmp, "SYSERR: reading %s", name);
    perror(tmp);
    return (-1);
  }
  do {
    fgets(tmp, READ_SIZE, fl);
    tmp[strlen(tmp) - 1] = '\0'; /* take off the trailing \n */
    strcat(tmp, "\r\n");

    if (!feof(fl)) {
      if (strlen(buf) + strlen(tmp) + 1 > MAX_STRING_LENGTH) {
        log("SYSERR: %s: string too big (%d max)", name,
                MAX_STRING_LENGTH);
        *buf = '\0';
        return -1;
      }
      strcat(buf, tmp);
    }
  } while (!feof(fl));

  fclose(fl);

  return (0);
}



/* clear some of the the working variables of a char */
void reset_char(struct char_data * ch)
{
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    GET_EQ(ch, i) = NULL;

  ch->followers = NULL;
  ch->master = NULL;
  ch->in_room = NOWHERE;
  ch->carrying = NULL;
  ch->next = NULL;
  ch->next_fighting = NULL;
  ch->next_in_room = NULL;
  FIGHTING(ch) = NULL;
  ch->char_specials.position = POS_STANDING;
  ch->mob_specials.default_pos = POS_STANDING;
  ch->char_specials.carry_weight = 0;
  ch->char_specials.carry_items = 0;

  if (GET_HIT(ch) <= 0)
    GET_HIT(ch) = 1;
  if (GET_MOVE(ch) <= 0)
    GET_MOVE(ch) = 1;
  if (GET_MANA(ch) <= 0)
    GET_MANA(ch) = 1;

  GET_LAST_TELL(ch) = NOBODY;
}



/* clear ALL the working variables of a char; do NOT free any space alloc'ed */
void clear_char(struct char_data * ch)
{
  memset((char *) ch, 0, sizeof(struct char_data));

  ch->in_room = NOWHERE;
  GET_PFILEPOS(ch) = -1;
  GET_MOB_RNUM(ch) = NOBODY;
  GET_WAS_IN(ch) = NOWHERE;
  GET_POS(ch) = POS_STANDING;
  ch->mob_specials.default_pos = POS_STANDING;

  GET_AC(ch) = 100;             /* Basic Armor */
  if (ch->points.max_mana < 1)
    ch->points.max_mana = 1;
}


void clear_object(struct obj_data * obj)
{
  memset((char *) obj, 0, sizeof(struct obj_data));

  obj->item_number = NOTHING;
  obj->in_room = NOWHERE;
  obj->worn_on = NOWHERE;
}

/* initialize a new character only if class is set */
void init_char(struct char_data * ch)
{
  int i;

  /* create a player_special structure */
  if (ch->player_specials == NULL)
    CREATE(ch->player_specials, struct player_special_data, 1);

  player_table[top_of_p_table].id = GET_IDNUM(ch) = ++top_idnum;

  /* *** if this is our first player --- he be God *** */

  ch->player_specials->saved.olc_zone = -1;

  if (top_of_p_table == 0) {
    GET_EXP(ch) = 2005000000;
    GET_LEVEL(ch) = LVL_IMPL;
    advance_level(ch);

    ch->points.max_hit = 500;
    ch->points.max_mana = 500;
    ch->points.max_move = 500;
    ch->points.max_mental = 500;
    ch->points.max_oxigen = 100;
  }

  set_title(ch, NULL);
  set_prename(ch, NULL);

  ch->player.short_descr = NULL;
  ch->player.long_descr = NULL;
  ch->player.description = NULL;
  ch->player.whoisdesc = NULL;

  GET_TRANS(ch) = -1;

  ch->current_quest = -1;

  ch->player.hometown = 1;

  ch->player.time.birth = time(0);
  ch->player.time.played = 0;
  ch->player.time.logon = time(0);

  for (i = 0; i < MAX_TONGUE; i++)
    GET_TALK(ch, i) = 0;

  /* make favors for sex */
  if (ch->player.sex == SEX_MALE) {
    ch->player.weight = number(120, 180);
    ch->player.height = number(160, 200);
  } else {
    ch->player.weight = number(100, 160);
    ch->player.height = number(150, 180);
  }

  ch->points.mana = GET_MAX_MANA(ch);
  ch->points.hit = GET_MAX_HIT(ch);
  ch->points.move = GET_MAX_MOVE(ch);
  ch->points.mental = GET_MAX_MENTAL(ch);
  ch->points.oxigen = GET_MAX_OXI(ch);

  ch->points.armor = 100;

  if ((i = get_ptable_by_name(GET_NAME(ch))) != -1)
    player_table[i].id = GET_IDNUM(ch) = ++top_idnum;
  else
    log("SYSERR: init_char: Character '%s' not found in player table.", GET_NAME(ch));

  for (i = 1; i <= MAX_SKILLS; i++) {
    if (GET_LEVEL(ch) < LVL_IMPL)
      SET_SKILL(ch, i, 0);
    else
      SET_SKILL(ch, i, 100);
  }

  ch->char_specials.saved.affected_by = 0;
  ch->char_specials.saved.affected2_by = 0;
  ch->char_specials.saved.affected3_by = 0;

  for (i = 0; i < 5; i++)
    GET_SAVE(ch, i) = 0;

  ch->real_abils.intel = 25;
  ch->real_abils.wis = 25;
  ch->real_abils.dex = 25;
  ch->real_abils.str = 25;
  ch->real_abils.str_add = 100;
  ch->real_abils.con = 25;
  ch->real_abils.cha = 25;
  ch->real_abils.luk = 25;

  for (i = 0; i < 3; i++)
    GET_COND(ch, i) = (GET_LEVEL(ch) == LVL_IMPL ? -1 : 24);

  GET_LOADROOM(ch) = NOWHERE;

  SET_BIT(PLR_FLAGS(ch), PLR_SITEOK);
  SET_BIT(PRF_FLAGS(ch), PRF_AUTOEXIT);
}



/* returns the real number of the room with given virtual number */
int real_room(int vnum)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_world;

  /* perform binary search on world-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((world + mid)->number == vnum)
      return mid;
    if (bot >= top)
      return NOWHERE;
    if ((world + mid)->number > vnum)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}



/* returns the real number of the monster with given virtual number */
int real_mobile(int vnum)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_mobt;

  /* perform binary search on mob-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((mob_index + mid)->vnum == vnum)
      return (mid);
    if (bot >= top)
      return (-1);
    if ((mob_index + mid)->vnum > vnum)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}



/* returns the real number of the object with given virtual number */
int real_object(int vnum)
{
  int bot, top, mid;

  bot = 0;
  top = top_of_objt;

  /* perform binary search on obj-table */
  for (;;) {
    mid = (bot + top) / 2;

    if ((obj_index + mid)->vnum == vnum)
      return (mid);
    if (bot >= top)
      return (-1);
    if ((obj_index + mid)->vnum > vnum)
      top = mid - 1;
    else
      bot = mid + 1;
  }
}
/*
void save_char_file_u(struct char_file_u st)
{
int player_i;
int find_name(char *name);

if((player_i = find_name(st.name)) >=0 )
  {
  fseek(player_fl, player_i * sizeof(struct char_file_u), SEEK_SET);
  fwrite(&st, sizeof(struct char_file_u), 1, player_fl);
  }
}
*/
void read_mud_date_from_file(void)
{
   FILE *f;
   struct time_write read_date;

   f = fopen("date_record", "r");
   if(!f) {
      log("SYSERR: File etc/date_record not found, mud date will be reset to default!");
      return;
   }

   fread(&read_date, sizeof(struct time_write), 1, f);
   time_info.year = read_date.year;
   time_info.month = read_date.month;
   time_info.day   = read_date.day;
   fclose(f);
}

void load_qeq_file()
{
	FILE *fl;
	int veq = 0, peq = 0, don = 0, num = 0;

	if(!(fl = fopen("etc/quest_eqs", "r")))
	{
		log("Could not load quest eq list.");
		exit(1);
	}


    while(fscanf(fl, "%d %d %d\n", &veq, &peq, &don))
	{
		if(veq == -1 && peq == -1 && don == -1)
			break;
		num++;
	}

	top_qeq_table = num;
	CREATE(eqs_quest, struct quest_eqs, num);

	num = 0;
	rewind(fl);

	while(fscanf(fl, "%d %d %d\n", &veq, &peq, &don))
	{
		if(veq == -1 && peq == -1 && don == -1)
			break;
		eqs_quest[num].vnum_eq = veq;
		eqs_quest[num].preco_eq = peq;
		eqs_quest[num].dono = don;
		num++;
	}
	fclose(fl);
}

void save_qeq_file()
{
	FILE *fl;
	int i;

	unlink("etc/quest_eqs");

	if(!(fl = fopen("etc/quest_eqs", "w")))
	{
		log("Could not load quest eq list.");
		exit(1);
	}

	for(i = 0; i < top_qeq_table; i++)
		fprintf(fl, "%d %d %d\n", eqs_quest[i].vnum_eq, eqs_quest[i].preco_eq,
			eqs_quest[i].dono);
	fprintf(fl, "-1 -1 -1\n");

	fclose(fl);
}
::::::::::::::
dg_comm.c
::::::::::::::
#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern struct descriptor_data *descriptor_list;

/* same as any_one_arg except that it stops at punctuation */
char *any_one_name(char *argument, char *first_arg)
{
    char* arg;

    /* Find first non blank */
    while(isspace(*argument))
        argument++; 
 
    /* Find length of first word */
    for(arg = first_arg ;
        *argument && !isspace(*argument) &&
          (!ispunct(*argument) || *argument == '#' || *argument == '-') ;
        arg++, argument++)
        *arg = LOWER(*argument);
    *arg = '\0';

    return argument;
}


void sub_write_to_char(char_data *ch, char *tokens[],
		       void *otokens[], char type[])
{
    char sb[MAX_STRING_LENGTH];
    int i;

    strcpy(sb,"");

    for (i = 0; tokens[i + 1]; i++)
    {
	strcat(sb,tokens[i]);

	switch (type[i])
	{
	case '~':
	    if (!otokens[i])
		strcat(sb,"someone");
	    else if ((char_data *)otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,PERS((char_data *)otokens[i], ch));
	    break;

	case '@':
	    if (!otokens[i])
		strcat(sb,"someone's");
	    else if ((char_data *)otokens[i] == ch)
		strcat(sb,"your");
	    else
	    {
		strcat(sb,PERS((char_data *) otokens[i], ch));
		strcat(sb,"'s");
	    }
	    break;

	case '^':
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"its");
	    else if (otokens[i] == ch)
		strcat(sb,"your");
	    else
		strcat(sb,HSHR((char_data *) otokens[i]));
	    break;
		
	case '&':
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"it");
	    else if (otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,HSSH((char_data *) otokens[i]));
	    break;
	    
	case '*':
	    if (!otokens[i] || !CAN_SEE(ch, (char_data *) otokens[i]))
		strcat(sb,"it");
	    else if (otokens[i] == ch)
		strcat(sb,"you");
	    else
		strcat(sb,HMHR((char_data *) otokens[i]));
	    break;

	case '`':
	    if (!otokens[i])
		strcat(sb,"something");
	    else
		strcat(sb,OBJS(((obj_data *) otokens[i]), ch));
	    break;
	}
    }

    strcat(sb,tokens[i]);
    strcat(sb,"\n\r");
    sb[0] = toupper(sb[0]);
    send_to_char(sb,ch);
}


void sub_write(char *arg, char_data *ch, byte find_invis, int targets)
{
    char str[MAX_INPUT_LENGTH * 2];
    char type[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
    char *tokens[MAX_INPUT_LENGTH], *s, *p;
    void *otokens[MAX_INPUT_LENGTH];
    char_data *to;
    obj_data *obj;
    int i, tmp;
    int to_sleeping = 1; /* mainly for windows compiles */

    if (!arg)
	return;
    
    tokens[0] = str;
    
    for (i = 0, p = arg, s = str; *p;)
    {
	switch (*p) {
	case '~':
	case '@':
	case '^':
	case '&':
	case '*':
	    /* get char_data, move to next token */
	    type[i] = *p;
	    *s = '\0';
	    p = any_one_name(++p, name);
	    (char_data *)otokens[i] =
		find_invis ? get_char(name) : get_char_room_vis(ch, name);
	    tokens[++i] = ++s;
	    break;
	    
	case '`':
	    /* get obj_data, move to next token */
	    type[i] = *p;
	    *s = '\0';
	    p = any_one_name(++p, name);
	    (obj_data *)otokens[i] =
		find_invis ? (obj = get_obj(name)) :
		    ((obj = get_obj_in_list_vis(ch, name,
				world[IN_ROOM(ch)].contents)) ? obj :
		     (obj = get_object_in_equip_vis(ch, name,
						    ch->equipment, &tmp)) ?
		     obj :
		     (obj = get_obj_in_list_vis(ch, name, ch->carrying)));
	    (obj_data *)otokens[i] = obj;
	    tokens[++i] = ++s;
	    break;

	case '\\':
	    p++;
	    *s++ = *p++;
	    break;
	    
	default:
	    *s++ = *p++;
	}
    }

    *s = '\0';
    tokens[++i] = NULL;

    if (IS_SET(targets, TO_CHAR) && SENDOK(ch))
	sub_write_to_char(ch, tokens, otokens, type);

    if (IS_SET(targets, TO_ROOM))
	for (to = world[ch->in_room].people;
	     to; to = to->next_in_room)
	    if (to != ch && SENDOK(to))
		sub_write_to_char(to, tokens, otokens, type);
}

void send_to_zone(char *messg, int zone_rnum)
{
  struct descriptor_data *i;

  if (!messg || !*messg)
    return;

  for (i = descriptor_list; i; i = i->next)
    if (!i->connected && i->character && AWAKE(i->character) &&
        (IN_ROOM(i->character) != NOWHERE) &&
        (world[IN_ROOM(i->character)].zone == zone_rnum))
      SEND_TO_Q(messg, i);
}
::::::::::::::
dg_db_scripts.c
::::::::::::::
/* ************************************************************************
*  File: db.script.c                             Part of Death's Gate MUD *
*                                                                         *
*  Usage: Contains routines to handle db functions for scripts and trigs  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/30 21:27:54 $
*  $Revision: 3.7 $
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "dg_scripts.h"
#include "utils.h"
#include "db.h"
#include "handler.h"
#include "dg_event.h"
#include "comm.h"

void trig_data_copy(trig_data *this_data, const trig_data *trg);
void trig_data_free(trig_data *this_data);

extern struct index_data **trig_index;
extern int top_of_trigt;

extern struct index_data *mob_index;
extern struct index_data *obj_index;

extern void half_chop(char *string, char *arg1, char *arg2);
extern long asciiflag_conv(char *flag);

void parse_trigger(FILE *trig_f, int nr)
{
    int t[2], k, attach_type;
    char line[256], *cmds, *s, flags[256];
    struct cmdlist_element *cle;
    index_data *index;
    trig_data *trig;

    CREATE(trig, trig_data, 1);
    CREATE(index, index_data, 1);

    index->vnum = nr;
    index->number = 0;
    index->func = NULL;
    index->proto = trig;

    sprintf(buf2, "trig vnum %d", nr);

    trig->nr = top_of_trigt;
    trig->name = fread_string(trig_f, buf2);

    get_line(trig_f, line);
    k = sscanf(line, "%d %s %d", &attach_type, flags, t);
    trig->attach_type = (byte)attach_type;
    trig->trigger_type = asciiflag_conv(flags);
    trig->narg = (k == 3) ? t[0] : 0;

    trig->arglist = fread_string(trig_f, buf2);
  
    cmds = s = fread_string(trig_f, buf2);

    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cle = trig->cmdlist;

    while ((s = strtok(NULL, "\n\r"))) {
	CREATE(cle->next, struct cmdlist_element, 1);
	cle = cle->next;
	cle->cmd = str_dup(s);
    }

    free(cmds);

    trig_index[top_of_trigt++] = index;
}


/*
 * create a new trigger from a prototype.
 * nr is the real number of the trigger.
 */
trig_data *read_trigger(int nr)
{
    index_data *index;
    trig_data *trig;

    if (nr >= top_of_trigt) return NULL;
    if ((index = trig_index[nr]) == NULL)
	return NULL;

    CREATE(trig, trig_data, 1);
    trig_data_copy(trig, index->proto);

    index->number++;

    return trig;
}


/* release memory allocated for a variable list */
void free_varlist(struct trig_var_data *vd)
{
    struct trig_var_data *i, *j;

    for (i = vd; i;) {
	j = i;
	i = i->next;
	if (j->name)
	    free(j->name);
	if (j->value)
	    free(j->value);
	free(j);
    }
}


/* release memory allocated for a script */
void free_script(struct script_data *sc)
{
    trig_data *t1, *t2;

    for (t1 = TRIGGERS(sc); t1 ;) {
	t2 = t1;
	t1 = t1->next;
	trig_data_free(t2);
    }

    free_varlist(sc->global_vars);

    free(sc);
}

void trig_data_init(trig_data *this_data)
{
    this_data->nr = NOTHING;
    this_data->data_type = 0;
    this_data->name = NULL;
    this_data->trigger_type = 0;
    this_data->cmdlist = NULL;
    this_data->curr_state = NULL;
    this_data->narg = 0;
    this_data->arglist = NULL;
    this_data->depth = 0;
    this_data->wait_event = NULL;
    this_data->purged = FALSE;
    this_data->var_list = NULL;

    this_data->next = NULL;  
}


void trig_data_copy(trig_data *this_data, const trig_data *trg)
{
    trig_data_init(this_data);

    this_data->nr = trg->nr;
    this_data->attach_type = trg->attach_type;
    this_data->data_type = trg->data_type;
    this_data->name = str_dup(trg->name);
    this_data->trigger_type = trg->trigger_type;
    this_data->cmdlist = trg->cmdlist;
    this_data->narg = trg->narg;
    if (trg->arglist) this_data->arglist = str_dup(trg->arglist);
}


void trig_data_free(trig_data *this_data)
{
/*    struct cmdlist_element *i, *j;*/

    free(this_data->name);

    /*
     * The command list is a memory leak right now!
     *
    if (cmdlist != trigg->cmdlist || this_data->proto)
	for (i = cmdlist; i;) {
	    j = i;
	    i = i->next;
	    free(j->cmd);
	    free(j);
	}
	*/

    really_free(this_data->arglist);
  
    free_varlist(this_data->var_list);

    if (this_data->wait_event)
	remove_event(this_data->wait_event);

    free(this_data);
}

/* for mobs and rooms: */
void dg_read_trigger(FILE *fp, void *proto, int type)
{
  char line[256];
  char junk[8];
  int vnum, rnum, count;
  char_data *mob;
  room_data *room;
  struct trig_proto_list *trg_proto, *new_trg;

  get_line(fp, line);
  count = sscanf(line,"%s %d",junk,&vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning trigger!");
    return;
  }

  rnum = real_trigger(vnum);
  if (rnum<0) {
    sprintf(line,"SYSERR: Trigger vnum #%d asked for but non-existant!", vnum);
    log(line);
    return;
  }

  switch(type) {
    case MOB_TRIGGER:
      CREATE(new_trg, struct trig_proto_list, 1);
      new_trg->vnum = vnum;
      new_trg->next = NULL;

      mob = (char_data *)proto;
      trg_proto = mob->proto_script;
      if (!trg_proto) {
        mob->proto_script = trg_proto = new_trg;
      } else {
        while (trg_proto->next) trg_proto = trg_proto->next;
        trg_proto->next = new_trg;
      }
      break;
    case WLD_TRIGGER:
      CREATE(new_trg, struct trig_proto_list, 1);
      new_trg->vnum = vnum;
      new_trg->next = NULL;
      room = (room_data *)proto;
      trg_proto = room->proto_script;
      if (!trg_proto) {
        room->proto_script = trg_proto = new_trg;
      } else {
        while (trg_proto->next) trg_proto = trg_proto->next;
        trg_proto->next = new_trg;
      }

      if (rnum>=0) {
        if (!(room->script))
          CREATE(room->script, struct script_data, 1);
        add_trigger(SCRIPT(room), read_trigger(rnum), -1);
      } else {
        sprintf(line,"SYSERR: non-existant trigger #%d assigned to room #%d",
          vnum, room->number);
        log(line);
      }
      break;
    default:
      sprintf(line,"SYSERR: Trigger vnum #%d assigned to non-mob/obj/room",
              vnum);
      log(line);
  }
}

void dg_obj_trigger(char *line, struct obj_data *obj)
{
  char junk[8];
  int vnum, rnum, count;
  struct trig_proto_list *trg_proto, *new_trg;

  count = sscanf(line,"%s %d",junk,&vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning trigger!");
    return;
  }

  rnum = real_trigger(vnum);
  if (rnum<0) {
    sprintf(line,"SYSERR: Trigger vnum #%d asked for but non-existant!", vnum);
    log(line);
    return;
  }

  CREATE(new_trg, struct trig_proto_list, 1);
  new_trg->vnum = vnum;
  new_trg->next = NULL;

  trg_proto = obj->proto_script;
  if (!trg_proto) {
    obj->proto_script = trg_proto = new_trg;
  } else {
    while (trg_proto->next) trg_proto = trg_proto->next;
    trg_proto->next = new_trg;
  }
}

void assign_triggers(void *i, int type)
{
  char_data *mob;
  obj_data *obj;
  struct room_data *room;
  int rnum;
  char buf[256];
  struct trig_proto_list *trg_proto;

  switch (type)
  {
    case MOB_TRIGGER:
      mob = (char_data *)i;
      trg_proto = mob->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existant, for mob #%d",
            trg_proto->vnum, mob_index[mob->nr].vnum);
          log(buf);
        } else {
          if (!SCRIPT(mob))
            CREATE(SCRIPT(mob), struct script_data, 1);
          add_trigger(SCRIPT(mob), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    case OBJ_TRIGGER:
      obj = (obj_data *)i;
      trg_proto = obj->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existant, for obj #%d",
            trg_proto->vnum, obj_index[obj->item_number].vnum);
          log(buf);
        } else {
          if (!SCRIPT(obj))
            CREATE(SCRIPT(obj), struct script_data, 1);
          add_trigger(SCRIPT(obj), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    case WLD_TRIGGER:
      room = (struct room_data *)i;
      trg_proto = room->proto_script;
      while (trg_proto) {
        rnum = real_trigger(trg_proto->vnum);
        if (rnum==-1) {
          sprintf(buf,"SYSERR: trigger #%d non-existant, for room #%d",
            trg_proto->vnum, room->number);
          log(buf);
        } else {
          if (!SCRIPT(room))
            CREATE(SCRIPT(room), struct script_data, 1);
          add_trigger(SCRIPT(room), read_trigger(rnum), -1);
        }
        trg_proto = trg_proto->next;
      }
      break;
    default:
      log("SYSERR: unknown type for assign_triggers()");
      break;
  }
}
::::::::::::::
dg_event.c
::::::::::::::
/*
** dg_event.c: This file contains a simplified event system to allow
** DG Script triggers to use the "wait" command, causing a delay in the
** middle of a script.
**
** NOTE: This is NOT the dg events package that is available!
**
** By: Mark A. Heilpern (Sammy @ eQuoria MUD   equoria.com:4000)
*/
#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "dg_event.h"

/*
** define statics
*/
static struct event_info *event_list = NULL;


/*
** Add an event to the current list
*/
struct event_info *
add_event(int time, EVENT(*func), void *info)
{
  struct event_info *this_data, *prev, *curr;

  CREATE(this_data, struct event_info, 1);
  this_data->time_remaining = time;
  this_data->func = func;
  this_data->info = info;

  /* sort the event into the list in next-to-fire order */
  if (event_list==NULL)
    event_list = this_data;
  else if (this_data->time_remaining <= event_list->time_remaining) {
    this_data->next = event_list;
    event_list = this_data;
  } else {
    prev = event_list;
    curr = prev->next;

    while (curr && (curr->time_remaining > this_data->time_remaining)) {
      prev = curr;
      curr = curr->next;
    }

    this_data->next = curr;
    prev->next = this_data;
  }

  return this_data;
}

void
remove_event(struct event_info *event)
{
  struct event_info *curr;

  if (event_list == event) {
    event_list = event->next;
  } else {
    curr = event_list;
    while (curr && (curr->next != event))
      curr = curr->next;
    if (!curr) return; /* failed to find it */
    curr->next = curr->next->next;
  }
  free(event);
}

void
process_events(void)
{
  struct event_info *e = event_list;
  struct event_info *del;

  while (e) {
    if (--(e->time_remaining) == 0) {
      e->func(e->info);
      del = e;
      e = e->next;
      remove_event(del);
    }  else
        e = e->next;
  }
}
::::::::::::::
dg_handler.c
::::::::::::::
#include "conf.h"
#include "sysdep.h"
    

#include "structs.h"
#include "buffer.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "handler.h"
#include "spells.h"
#include "dg_event.h"

extern struct index_data **trig_index;
extern struct trig_data *trigger_list;

void trig_data_free(trig_data *this_data);

/* return memory used by a trigger */
void free_trigger(struct trig_data *trig)
{
  /* threw this in for minor consistance in names with the rest of circle */
  trig_data_free(trig);
}


/* remove a single trigger from a mob/obj/room */
void extract_trigger(struct trig_data *trig)
{
  struct trig_data *temp;

  if (GET_TRIG_WAIT(trig)) {
    remove_event(GET_TRIG_WAIT(trig));
    GET_TRIG_WAIT(trig) = NULL;
  }

  trig_index[trig->nr]->number--; 

  /* walk the trigger list and remove this one */
  REMOVE_FROM_LIST(trig, trigger_list, next_in_world);

  free_trigger(trig);
}

/* remove all triggers from a mob/obj/room */
void extract_script(struct script_data *sc)
{
  struct trig_data *trig, *next_trig;

  for (trig = TRIGGERS(sc); trig; trig = next_trig) {
    next_trig = trig->next;
    extract_trigger(trig);
  }
  TRIGGERS(sc) = NULL;
}

/* erase the script memory of a mob */
void extract_script_mem(struct script_memory *sc)
{
  struct script_memory *next;
  while (sc) {
    next = sc->next;
    if (sc->cmd) free(sc->cmd);
    free(sc);
    sc = next;
  }
}

/* perhaps not the best place for this, but I didn't want a new file */
char *skill_percent(struct char_data *ch, char *skill)
{
  static char retval[16];
  int skillnum;

  skillnum = find_skill_num(skill);
  if (skillnum<=0) return("unknown skill");

  sprintf(retval,"%d",GET_SKILL(ch, skillnum));
  return retval;
}
::::::::::::::
dg_mobcmd.c
::::::::::::::
/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

/***************************************************************************
 *  The MOBprograms have been contributed by N'Atas-ha.  Any support for   *
 *  these routines should not be expected from Merc Industries.  However,  *
 *  under no circumstances should the blame for bugs, etc be placed on     *
 *  Merc Industries.  They are not guaranteed to work on all systems due   *
 *  to their frequent use of strxxx functions.  They are also not the most *
 *  efficient way to perform their tasks, but hopefully should be in the   *
 *  easiest possible way to install and begin using. Documentation for     *
 *  such installation can be found in INSTALL.  Enjoy........    N'Atas-Ha *
 ***************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "dg_scripts.h"
#include "db.h"
#include "utils.h"
#include "handler.h"
#include "interpreter.h"
#include "comm.h"
#include "spells.h"

extern struct descriptor_data *descriptor_list;
extern sh_int find_target_room(char_data * ch, char *rawroomstr);
extern struct index_data *mob_index;
extern struct room_data *world;
extern int dg_owner_purged;

void sub_write(char *arg, char_data *ch, byte find_invis, int targets);

/*
 * Local functions.
 */

/* attaches mob's name and vnum to msg and sends it to script_log */
void mob_log(char_data *mob, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Mob (%s, VNum %d): %s",
	    GET_SHORT(mob), GET_MOB_VNUM(mob), msg);
    script_log(buf);
}
/*
** macro to determine if a mob is permitted to use these commands
*/
#define MOB_OR_IMPL(ch) \
  (IS_NPC(ch) && (!(ch)->desc || GET_LEVEL((ch)->desc->original)>=LVL_IMPL))



/* mob commands */

/* prints the argument to all the rooms aroud the mobile */
ACMD(do_masound)
{
    sh_int was_in_room;
    int  door;
  
    if (!MOB_OR_IMPL(ch))
    {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (!*argument)
    {
	mob_log(ch, "masound called with no argument");
	return;
    }

    skip_spaces(&argument);
  
    was_in_room = IN_ROOM(ch);
    for (door = 0; door < NUM_OF_DIRS; door++)
    {
	struct room_direction_data *exit;
    
	if (((exit = world[was_in_room].dir_option[door]) != NULL) &&
	    exit->to_room != NOWHERE && exit->to_room != was_in_room)
	{
	    IN_ROOM(ch) = exit->to_room;
	    sub_write(argument, ch, TRUE, TO_ROOM);
	}
    }
  
    IN_ROOM(ch) = was_in_room;
}


/* lets the mobile kill any player or mobile without murder*/
ACMD(do_mkill)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    one_argument(argument, arg);
    
    if (!*arg) {
	mob_log(ch, "mkill called with no argument");
	return;
    }

    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mkill: victim (%s) not found",arg);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_room_vis(ch, arg))) {
        sprintf(buf, "mkill: victim (%s) not found",arg);
	mob_log(ch, buf);
	return;
    }

    if (victim == ch) {
	mob_log(ch, "mkill: victim is self");
	return;
    }

    if (IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim ) {
	mob_log(ch, "mkill: charmed mob attacking master");
	return;
    }

    if (FIGHTING(ch)) {
	mob_log(ch, "mkill: already fighting");
	return;
    }
    
    hit(ch, victim, TYPE_UNDEFINED);
    return;
}


/*
 * lets the mobile destroy an object in its inventory
 * it can also destroy a worn object and it can destroy 
 * items using all.xxxxx or just plain all of them
 */
ACMD(do_mjunk)
{
    char arg[MAX_INPUT_LENGTH];
    int pos;
    obj_data *obj;
    obj_data *obj_next;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;

    one_argument(argument, arg);
  
    if (!*arg) {
	mob_log(ch, "mjunk called with no argument");
	return;
    }
  
    if (find_all_dots(arg) != FIND_INDIV) {
	if ((obj=get_object_in_equip_vis(ch,arg,ch->equipment,&pos))!= NULL) {
	    unequip_char(ch, pos);
	    extract_obj(obj);
	    return;
	}
	if ((obj = get_obj_in_list_vis(ch, arg, ch->carrying)) != NULL )
	    extract_obj(obj);
	return;
    } else {
	for (obj = ch->carrying; obj != NULL; obj = obj_next) {
	    obj_next = obj->next_content;
	    if (arg[3] == '\0' || isname(arg+4, obj->name)) {
		extract_obj(obj);
	    }
	}
	while ((obj=get_object_in_equip_vis(ch,arg,ch->equipment,&pos)))
	{
	    unequip_char(ch, pos);
	    extract_obj(obj);
	}   
    }
    return;
}


/* prints the message to everyone in the room other than the mob and victim */
ACMD(do_mechoaround)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
    char *p;

    if (!MOB_OR_IMPL(ch)) {
	send_to_char( "Huh?!?\r\n", ch );
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    p = one_argument(argument, arg);
    skip_spaces(&p);
    
    if (!*arg) {
	mob_log(ch, "mechoaround called with no argument");
	return;
    }
  
    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mechoaround: victim (%s) does not exist",arg);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_room_vis(ch, arg))) {
        sprintf(buf, "mechoaround: victim (%s) does not exist",arg);
	mob_log(ch, buf);
	return;
    }

    sub_write(p, victim, TRUE, TO_ROOM);
}


/* sends the message to only the victim */
ACMD(do_msend)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
    char *p;

    if (!MOB_OR_IMPL(ch)) {
	send_to_char( "Huh?!?\r\n", ch );
	return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    p = one_argument(argument, arg);
    skip_spaces(&p);
  
    if (!*arg) {
	mob_log(ch, "msend called with no argument");
	return;
    }

    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "msend: victim (%s) does not exist",arg);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_room_vis(ch, arg))) {
        sprintf(buf, "msend: victim (%s) does not exist",arg);
	mob_log(ch, buf);
	return;
    }
  
    sub_write(p, victim, TRUE, TO_CHAR);
}


/* prints the message to the room at large */
ACMD(do_mecho)
{
    char *p;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char( "Huh?!?\r\n", ch );
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (!*argument) {
	mob_log(ch, "mecho called with no arguments");
	return;
    }
    p = argument;
    skip_spaces(&p);
  
    sub_write(p, ch, TRUE, TO_ROOM);
}


/*
 * lets the mobile load an item or mobile.  All items
 * are loaded into inventory, unless it is NO-TAKE. 
 */
ACMD(do_mload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0;
    char_data *mob;
    obj_data *object;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;

    if( ch->desc && GET_LEVEL(ch->desc->original) < LVL_IMPL)
	return;
  
    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
	mob_log(ch, "mload: bad syntax");
	return;
    }

    if (is_abbrev(arg1, "mob")) {
	if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
	    mob_log(ch, "mload: bad mob vnum");
	    return;
	}
	char_to_room(mob, IN_ROOM(ch));
        load_mtrigger(mob);
    }
  
    else if (is_abbrev(arg1, "obj")) {
	if ((object = read_object(number, VIRTUAL)) == NULL) {
	    mob_log(ch, "mload: bad object vnum");
	    return;
	}
	if (CAN_WEAR(object, ITEM_WEAR_TAKE)) {
	    obj_to_char(object, ch);
	} else {
	    obj_to_room(object, IN_ROOM(ch));
	}
        load_otrigger(object);
    }

    else
	mob_log(ch, "mload: bad type");
}


/*
 * lets the mobile purge all objects and other npcs in the room,
 * or purge a specified object or mob in the room.  It can purge
 *  itself, but this will be the last command it does.
 */
ACMD(do_mpurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *victim;
    obj_data  *obj;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;

    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;
  
    one_argument(argument, arg);
  
    if (!*arg) {
	/* 'purge' */
	char_data *vnext;
	obj_data  *obj_next;
    
	for (victim = world[IN_ROOM(ch)].people; victim; victim = vnext) {
	    vnext = victim->next_in_room;
	    if (IS_NPC(victim) && victim != ch)
		extract_char(victim);
	}
    
	for (obj = world[IN_ROOM(ch)].contents; obj; obj = obj_next) {
	    obj_next = obj->next_content;
	    extract_obj(obj);
	}
    
	return;
    }
  
    if (*arg == UID_CHAR)
      victim = get_char(arg);
    else victim = get_char_room_vis(ch, arg);

    if (victim == NULL) {
	if ((obj = get_obj_vis(ch, arg))) {
	    extract_obj(obj);
	} else 
	    mob_log(ch, "mpurge: bad argument");
	
	return;
    }
    
    if (!IS_NPC(victim)) {
	mob_log(ch, "mpurge: purging a PC");
	return;
    }

    if (victim==ch) dg_owner_purged = 1;
    
    extract_char(victim);
}


/* lets the mobile goto any location it wishes that is not private */
ACMD(do_mgoto)
{
    char arg[MAX_INPUT_LENGTH];
    sh_int location;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }

    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    one_argument(argument, arg);

    if (!*arg) {
	mob_log(ch, "mgoto called with no argument");
	return;
    }
  
    if ((location = find_target_room(ch, arg)) == NOWHERE) {
	mob_log(ch, "mgoto: invalid location");
	return;
    }
  
    if (FIGHTING(ch))
	stop_fighting(ch);
    
    char_from_room(ch);
    char_to_room(ch, location);
}


/* lets the mobile do a command at another location. Very useful */
ACMD(do_mat)
{
    char arg[MAX_INPUT_LENGTH];
    sh_int location;
    sh_int original;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    argument = one_argument( argument, arg );
  
    if (!*arg || !*argument) {
	mob_log(ch, "mat: bad argument");
	return;
    }
  
    if ((location = find_target_room(ch, arg)) == NOWHERE) {
	mob_log(ch, "mat: invalid location");
	return;
    }
  
    original = IN_ROOM(ch);
    char_from_room(ch);
    char_to_room(ch, location);
    command_interpreter(ch, argument);
    
    /*
     * See if 'ch' still exists before continuing!
     * Handles 'at XXXX quit' case.
     */
    if (IN_ROOM(ch) == location) {
	char_from_room(ch);
	char_to_room(ch, original);
    }
}


/*
 * lets the mobile transfer people.  the all argument transfers
 * everyone in the current room to the specified location
 */
ACMD(do_mteleport)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    sh_int target;
    char_data *vict, *next_ch;
  
    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;

    argument = two_arguments(argument, arg1, arg2);
    
    if (!*arg1 || !*arg2) {
	mob_log(ch, "mteleport: bad syntax");
	return;
    }

    target = find_target_room(ch, arg2);

    if (target == NOWHERE)
	mob_log(ch, "mteleport target is an invalid room");

    else if (!str_cmp(arg1, "all")) {
	if (target == IN_ROOM(ch)) {
	    mob_log(ch, "mteleport all target is itself");
	    return;
	}

	for (vict = world[IN_ROOM(ch)].people; vict; vict = next_ch) {
	    next_ch = vict->next_in_room;

	    if (GET_LEVEL(vict)<LVL_IMMORT) {
		char_from_room(vict);
		char_to_room(vict, target);
	    }
	}
    }

    else {
      if (*arg1 == UID_CHAR) {
        if (!(vict = get_char(arg1))) {
          sprintf(buf, "mteleport: victim (%s) does not exist",arg1);
          mob_log(ch, buf);
          return;
        }
      } else if (!(vict = get_char_vis(ch, arg1))) {
        sprintf(buf, "mteleport: victim (%s) does not exist",arg1);
	mob_log(ch, buf);
	return;
      }

      if (GET_LEVEL(vict)<LVL_IMMORT) {
	char_from_room(vict);
	char_to_room(vict, target);
      }
    }
}


/*
 * lets the mobile force someone to do something.  must be mortal level
 * and the all argument only affects those in the room with the mobile
 */
ACMD(do_mforce)
{
    char arg[MAX_INPUT_LENGTH];

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;
  
    argument = one_argument(argument, arg);
  
    if (!*arg || !*argument) {
	mob_log(ch, "mforce: bad syntax");
	return;
    }
  
    if (!str_cmp(arg, "all")) {
	struct descriptor_data *i;
	char_data *vch;
    
	for (i = descriptor_list; i ; i = i->next) {
	    if ((i->character != ch) && !i->connected &&
		(IN_ROOM(i->character) == IN_ROOM(ch))) {
		vch = i->character;
		if (GET_LEVEL(vch) < GET_LEVEL(ch) && CAN_SEE(ch, vch) &&
		    GET_LEVEL(vch)<LVL_IMMORT) {
		    command_interpreter(vch, argument);
		}
	    }
	}
    } else {
	char_data *victim;
	
        if (*arg == UID_CHAR) {
          if (!(victim = get_char(arg))) {
            sprintf(buf, "mforce: victim (%s) does not exist",arg);
	    mob_log(ch, buf);
	    return;
          }
	} else if ((victim = get_char_room_vis(ch, arg)) == NULL) {
	    mob_log(ch, "mforce: no such victim");
	    return;
	}
    
	if (victim == ch) {
	    mob_log(ch, "mforce: forcing self");
	    return;
	}
    
	if (GET_LEVEL(victim)<LVL_IMMORT)
	    command_interpreter(victim, argument);
    }
}


/* increases the target's exp */
ACMD(do_mexp)
{
    char_data *victim;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;  

    two_arguments(argument, name, amount);

    if (!*name || !*amount) {
	mob_log(ch, "mexp: too few arguments");
	return;
    }

    if (*name == UID_CHAR) {
      if (!(victim = get_char(name))) {
        sprintf(buf, "mexp: victim (%s) does not exist",name);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_vis(ch, name))) {
        sprintf(buf, "mexp: victim (%s) does not exist",name);
	mob_log(ch, buf);
	return;
    }
  
    gain_exp(victim, atoi(amount));      
}


/* increases the target's gold */
ACMD(do_mgold)
{
    char_data *victim;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;  

    two_arguments(argument, name, amount);

    if (!*name || !*amount) {
	mob_log(ch, "mgold: too few arguments");
	return;
    }

    if (*name == UID_CHAR) {
      if (!(victim = get_char(name))) {
        sprintf(buf, "mgold: victim (%s) does not exist",name);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_vis(ch, name))) {
        sprintf(buf, "mgold: victim (%s) does not exist",name);
	mob_log(ch, buf);
	return;
    }
  
    if ((GET_GOLD(victim) += atoi(amount)) < 0) {
	mob_log(ch, "mgold subtracting more gold than character has");
	GET_GOLD(victim) = 0;
    }
}


/* hunt for someone */
ACMD(do_mhunt)
{
    char_data *victim;
    char arg[MAX_INPUT_LENGTH];

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;
  
    one_argument(argument, arg);

    if (!*arg) {
	mob_log(ch, "mhunt called with no argument");
	return;
    }
  

    if (FIGHTING(ch)) return;

    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mhunt: victim (%s) does not exist", arg);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_vis(ch, arg))) {
        sprintf(buf, "mhunt: victim (%s) does not exist", arg);
	mob_log(ch, buf);
	return;
    }
    HUNTING(ch) = victim;
  

}


/* place someone into the mob's memory list */
ACMD(do_mremember)
{
    char_data *victim;
    struct script_memory *mem;
    char arg[MAX_INPUT_LENGTH];

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;
  
    argument = one_argument(argument, arg);
  
    if (!*arg) {
	mob_log(ch, "mremember: bad syntax");
	return;
    }

    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mremember: victim (%s) does not exist", arg);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_vis(ch, arg))) {
        sprintf(buf, "mremember: victim (%s) does not exist", arg);
	mob_log(ch, buf);
	return;
    }

    /* create a structure and add it to the list */
    CREATE(mem, struct script_memory, 1);
    if (!SCRIPT_MEM(ch)) SCRIPT_MEM(ch) = mem;
    else {
      struct script_memory *tmpmem = SCRIPT_MEM(ch);
      while (tmpmem->next) tmpmem = tmpmem->next;
      tmpmem->next = mem;
    }

    /* fill in the structure */
    mem->id = GET_ID(victim);
    if (argument && *argument) {
      mem->cmd = strdup(argument);
    }
}


/* remove someone from the list */
ACMD(do_mforget)
{
    char_data *victim;
    struct script_memory *mem, *prev;
    char arg[MAX_INPUT_LENGTH];

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc && (GET_LEVEL(ch->desc->original) < LVL_IMPL))
	return;
  
    one_argument(argument, arg);
  
    if (!*arg) {
	mob_log(ch, "mforget: bad syntax");
	return;
    }

    if (*arg == UID_CHAR) {
      if (!(victim = get_char(arg))) {
        sprintf(buf, "mforget: victim (%s) does not exist", arg);
	mob_log(ch, buf);
	return;
      }
    } else if (!(victim = get_char_vis(ch, arg))) {
        sprintf(buf, "mforget: victim (%s) does not exist", arg);
	mob_log(ch, buf);
	return;
    }

    mem = SCRIPT_MEM(ch);
    prev = NULL;
    while (mem) {
      if (mem->id == GET_ID(victim)) {
        if (mem->cmd) free(mem->cmd);
        if (prev==NULL) {
          SCRIPT_MEM(ch) = mem->next;
          free(mem);
          mem = SCRIPT_MEM(ch);
        } else {
          prev->next = mem->next;
          free(mem);
          mem = prev->next;
        }
      } else {
        prev = mem;
        mem = mem->next;
      }
   }
}


/* transform into a different mobile */
ACMD(do_mtransform)
{
  char arg[MAX_INPUT_LENGTH];
  char_data *m, tmpmob;
  obj_data *obj[NUM_WEARS];
  int pos;

    if (!MOB_OR_IMPL(ch)) {
	send_to_char("Huh?!?\r\n", ch);
	return;
    }
  
    if (AFF_FLAGGED(ch, AFF_CHARM))
	return;
  
    if (ch->desc) {
      send_to_char("You've got no VNUM to return to, dummy! try 'switch'\r\n",
        ch);
      return;
    }
  
  one_argument(argument, arg);

  if (!*arg)
    mob_log(ch, "mtransform: missing argument");
  else if (!isdigit(*arg)) 
    mob_log(ch, "mtransform: bad argument");
  else {
    m = read_mobile(atoi(arg), VIRTUAL);
    if (m==NULL) {
      mob_log(ch, "mtransform: bad mobile vnum");
      return;
    }

    /* move new obj info over to old object and delete new obj */

    for (pos = 0; pos < NUM_WEARS; pos++) {
      if (GET_EQ(ch, pos))
        obj[pos] = unequip_char(ch, pos);
      else
        obj[pos] = NULL;
    }

    /* put the mob in the same room as ch so extract will work */
    char_to_room(m, IN_ROOM(ch));

    memcpy(&tmpmob, m, sizeof(*m));
    tmpmob.id = ch->id;
    tmpmob.affected = ch->affected;
    tmpmob.carrying = ch->carrying;
    tmpmob.proto_script = ch->proto_script;
    tmpmob.script = ch->script;
    tmpmob.memory = ch->memory;
    tmpmob.next_in_room = ch->next_in_room;
    tmpmob.next = ch->next;
    tmpmob.next_fighting = ch->next_fighting;
    tmpmob.followers = ch->followers;
    tmpmob.master = ch->master;

    GET_WAS_IN(&tmpmob) = GET_WAS_IN(ch);
    GET_HIT(&tmpmob) = GET_HIT(ch);
    GET_MAX_HIT(&tmpmob) = GET_MAX_HIT(ch);
    GET_EXP(&tmpmob) = GET_EXP(ch);
    GET_GOLD(&tmpmob) = GET_GOLD(ch);
    GET_POS(&tmpmob) = GET_POS(ch);
    IS_CARRYING_W(&tmpmob) = IS_CARRYING_W(ch);
    IS_CARRYING_N(&tmpmob) = IS_CARRYING_N(ch);
    FIGHTING(&tmpmob) = FIGHTING(ch);
    HUNTING(&tmpmob) = HUNTING(ch);
    memcpy(ch, &tmpmob, sizeof(*ch));

    for (pos = 0; pos < NUM_WEARS; pos++) {
      if (obj[pos])
        equip_char(ch, obj[pos], pos);
    }

    extract_char(m);
  }
}
::::::::::::::
dg_objcmd.c
::::::::::::::
/**************************************************************************
*  File: objcmd.c                                                         *
*  Usage: contains the command_interpreter for objects,                   *
*         object commands.                                                *
*                                                                         *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/04 23:10:16 $
*  $Revision: 3.8 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern struct index_data *obj_index;
extern int dg_owner_purged;

char_data *get_char_by_obj(obj_data *obj, char *name);
obj_data *get_obj_by_obj(obj_data *obj, char *name);
void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
void die(struct char_data * ch, struct char_data *killer);

#define OCMD(name)  \
   void (name)(obj_data *obj, char *argument, int cmd, int subcmd)


struct obj_command_info {
   char *command;
   void	(*command_pointer)(obj_data *obj, char *argument, int cmd, int subcmd);
   int	subcmd;
};


/* do_osend */
#define SCMD_OSEND         0
#define SCMD_OECHOAROUND   1



/* attaches object name and vnum to msg and sends it to script_log */
void obj_log(obj_data *obj, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Obj (%s, VNum %d): %s",
	    obj->short_description, GET_OBJ_VNUM(obj), msg);
    script_log(buf);
}


/* returns the real room number that the object or object's carrier is in */
int obj_room(obj_data *obj)
{
    if (obj->in_room != NOWHERE)
	return obj->in_room;
    else if (obj->carried_by)
	return IN_ROOM(obj->carried_by);
    else if (obj->worn_by)
	return IN_ROOM(obj->worn_by);
    else if (obj->in_obj)
	return obj_room(obj->in_obj);
    else
	return NOWHERE;
}


/* returns the real room number, or NOWHERE if not found or invalid */
sh_int find_obj_target_room(obj_data *obj, char *rawroomstr)
{
    int tmp;
    sh_int location;
    char_data *target_mob;
    obj_data *target_obj;
    char roomstr[MAX_INPUT_LENGTH];

    one_argument(rawroomstr, roomstr);

    if (!*roomstr)
	return NOWHERE;

    if (isdigit(*roomstr) && !strchr(roomstr, '.'))
    {
	tmp = atoi(roomstr);
	if ((location = real_room(tmp)) < 0)
	    return NOWHERE;
    }

    else if ((target_mob = get_char_by_obj(obj, roomstr)))
	location = IN_ROOM(target_mob);
    else if ((target_obj = get_obj_by_obj(obj, roomstr)))
    {
	if (target_obj->in_room != NOWHERE)
	    location = target_obj->in_room;
	else 
	    return NOWHERE;
    }
    else
	return NOWHERE;
  
    /* a room has been found.  Check for permission */
    if (ROOM_FLAGGED(location, ROOM_GODROOM) || 
#ifdef ROOM_IMPROOM
	ROOM_FLAGGED(location, ROOM_IMPROOM) ||
#endif
	ROOM_FLAGGED(location, ROOM_HOUSE))
	return NOWHERE;

    if (ROOM_FLAGGED(location, ROOM_PRIVATE) &&
	world[location].people && world[location].people->next_in_room)
	return NOWHERE;

    return location;
}



/* Object commands */

OCMD(do_oecho)
{
    int room;

    skip_spaces(&argument);
  
    if (!*argument) 
	obj_log(obj, "oecho called with no args");

    else if ((room = obj_room(obj)) != NOWHERE)
    {
    	if (world[room].people)
	    sub_write(argument, world[room].people, TRUE, TO_ROOM | TO_CHAR);
    }
  
    else
	obj_log(obj, "oecho called by object in NOWHERE");
}


OCMD(do_oforce)
{
    char_data *ch, *next_ch;
    int room;
    char arg1[MAX_INPUT_LENGTH], *line;

    line = one_argument(argument, arg1);
  
    if (!*arg1 || !*line)
    {
	obj_log(obj, "oforce called with too few args");
	return;
    }
  
    if (!str_cmp(arg1, "all"))
    {
	if ((room = obj_room(obj)) == NOWHERE) 
	    obj_log(obj, "oforce called by object in NOWHERE");
	else
	{
	    for (ch = world[room].people; ch; ch = next_ch)
	    {
		next_ch = ch->next_in_room;
	
		if (GET_LEVEL(ch)<LVL_IMMORT)
		{
		    command_interpreter(ch, line);
		}
	    }
	}      
    }
  
    else
    {
	if ((ch = get_char_by_obj(obj, arg1)))
	{
	    if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
		command_interpreter(ch, line);
	    }
	}
    
	else
	    obj_log(obj, "oforce: no target found");
    }
}


OCMD(do_osend)
{
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;
  
    msg = any_one_arg(argument, buf);

    if (!*buf)
    {
	obj_log(obj, "osend called with no args");
	return;
    }

    skip_spaces(&msg);

    if (!*msg)
    {
	obj_log(obj, "osend called without a message");
	return;
    }

    if ((ch = get_char_by_obj(obj, buf)))
    {
	if (subcmd == SCMD_OSEND)
	    sub_write(msg, ch, TRUE, TO_CHAR);
	else if (subcmd == SCMD_OECHOAROUND)
	    sub_write(msg, ch, TRUE, TO_ROOM);
    }

    else
	obj_log(obj, "no target found for osend");
}

/* increases the target's exp */
OCMD(do_oexp)
{
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount)
    {
	obj_log(obj, "oexp: too few arguments");
	return;
    }
    
    if ((ch = get_char_by_obj(obj, name))) 
	gain_exp(ch, atoi(amount));
    else
    {
	obj_log(obj, "oexp: target not found");
	return;
    }
}


/* set the object's timer value */
OCMD(do_otimer)
{
  char arg[MAX_INPUT_LENGTH];

  one_argument(argument, arg);

  if (!*arg)
    obj_log(obj, "otimer: missing argument");
  else if (!isdigit(*arg)) 
    obj_log(obj, "otimer: bad argument");
  else
    GET_OBJ_TIMER(obj) = atoi(arg);
}


/* transform into a different object */
/* note: this shouldn't be used with containers unless both objects */
/* are containers! */
OCMD(do_otransform)
{
  char arg[MAX_INPUT_LENGTH];
  obj_data *o, tmpobj;
  struct char_data *wearer=NULL;
  int pos=-1;

  one_argument(argument, arg);

  if (!*arg)
    obj_log(obj, "otransform: missing argument");
  else if (!isdigit(*arg)) 
    obj_log(obj, "otransform: bad argument");
  else {
    o = read_object(atoi(arg), VIRTUAL);
    if (o==NULL) {
      obj_log(obj, "otransform: bad object vnum");
      return;
    }

    if (obj->worn_by) {
      pos = obj->worn_on;
      wearer = obj->worn_by;
      unequip_char(obj->worn_by, pos);
    }

    /* move new obj info over to old object and delete new obj */
    memcpy(&tmpobj, o, sizeof(*o));
    tmpobj.in_room = obj->in_room;
    tmpobj.carried_by = obj->carried_by;
    tmpobj.worn_by = obj->worn_by;
    tmpobj.worn_on = obj->worn_on;
    tmpobj.in_obj = obj->in_obj;
    tmpobj.contains = obj->contains;
    tmpobj.id = obj->id;
    tmpobj.proto_script = obj->proto_script;
    tmpobj.script = obj->script;
    tmpobj.next_content = obj->next_content;
    tmpobj.next = obj->next;
    memcpy(obj, &tmpobj, sizeof(*obj));

    if (wearer) {
      equip_char(wearer, obj, pos);
    }

    extract_obj(o);
  }
}


/* purge all objects an npcs in room, or specified object or mob */
OCMD(do_opurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *o, *next_obj;
    int rm;

    one_argument(argument, arg);
  
    if (!*arg)
    {
	if ((rm = obj_room(obj)) != NOWHERE)
	{
	    for (ch = world[rm].people; ch; ch = next_ch )
	    {
		next_ch = ch->next_in_room;
		if (IS_NPC(ch))
		    extract_char(ch);
	    }
    
	    for (o = world[rm].contents; o; o = next_obj )
	    {
		next_obj = o->next_content;
		if (o != obj)
		    extract_obj(o);
	    }
	}
    
	return;
    }
  
    if (!(ch = get_char_by_obj(obj, arg)))
    {
	if ((o = get_obj_by_obj(obj, arg))) {
            if (o==obj) dg_owner_purged = 1;
	    extract_obj(o);
        } else 
	    obj_log(obj, "opurge: bad argument");
    
	return;
    }
  
    if (!IS_NPC(ch))
    {
	obj_log(obj, "opurge: purging a PC");
	return;
    }
  
    extract_char(ch);
}


OCMD(do_oteleport)
{
    char_data *ch, *next_ch;
    sh_int target, rm;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2)
    {
	obj_log(obj, "oteleport called with too few args");
	return;
    }

    target = find_obj_target_room(obj, arg2);
  
    if (target == NOWHERE) 
	obj_log(obj, "oteleport target is an invalid room");
  
    else if (!str_cmp(arg1, "all"))
    {
	rm = obj_room(obj);
	if (target == rm)
	    obj_log(obj, "oteleport target is itself");

	for (ch = world[rm].people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;
	    
	    char_from_room(ch);
	    char_to_room(ch, target);
	}
    }
  
    else
    {
	if ((ch = get_char_by_obj(obj, arg1)))
	{
	    char_from_room(ch);
	    char_to_room(ch, target);
	}
    
	else
	    obj_log(obj, "oteleport: no target found");
    }
}


OCMD(do_dgoload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0, room;
    char_data *mob;
    obj_data *object;

    two_arguments(argument, arg1, arg2);

    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0))
    {
        obj_log(obj, "oload: bad syntax");
        return;
    }
 
    if ((room = obj_room(obj)) == NOWHERE)
    {
        obj_log(obj, "oload: object in NOWHERE trying to load");
        return;
    }
    
    if (is_abbrev(arg1, "mob"))
    {
        if ((mob = read_mobile(number, VIRTUAL)) == NULL)
        {
            obj_log(obj, "oload: bad mob vnum");
            return;
        }
        char_to_room(mob, room);
        load_mtrigger(mob);
    }
     
    else if (is_abbrev(arg1, "obj"))
    {
        if ((object = read_object(number, VIRTUAL)) == NULL)
        {
            obj_log(obj, "oload: bad object vnum");
            return;
        }

        obj_to_room(object, room);
        load_otrigger(object);
    }
         
    else
        obj_log(obj, "oload: bad type");

}

OCMD(do_odamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
	obj_log(obj, "odamage: bad syntax");
	return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_obj(obj, name))) {
	if (GET_LEVEL(ch)>=LVL_IMMORT) {
	    send_to_char("Being the cool immortal you are, you sidestep a trap, obviously placed to kill you.", ch);
	    return;
	}
	GET_HIT(ch) -= dam;
	update_pos(ch);
	switch (GET_POS(ch)) {
	case POS_MORTALLYW:
 	    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	    break;
	case POS_INCAP:
 	    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    	    break;
  	case POS_STUNNED:
   	    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    	    break;
  	case POS_DEAD:
    	    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You are dead!  Sorry...\r\n", ch);
    	    break;

  	default:			/* >= POSITION SLEEPING */
    	    if (dam > (GET_MAX_HIT(ch) >> 2))
      	        act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
 	    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
        	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	                CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
        	send_to_char(buf2, ch);
       	    }
	}
	if (GET_POS(ch) == POS_DEAD) {
	    if (!IS_NPC(ch)) {
		sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
	      		world[ch->in_room].name);
      		mudlog(buf2, BRF, 0, TRUE);
	    }
    	    die(ch, NULL);
	}
    }
    else
	obj_log(obj, "odamage: target not found");
}

const struct obj_command_info obj_cmd_info[] = {
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */

    { "oecho"      , do_oecho    , 0 },
    { "oechoaround", do_osend    , SCMD_OECHOAROUND },
    { "oexp"       , do_oexp     , 0 },
    { "oforce"     , do_oforce   , 0 },
    { "oload"	   , do_dgoload	 , 0 },
    { "opurge"     , do_opurge   , 0 },
    { "osend"      , do_osend    , SCMD_OSEND },
    { "oteleport"  , do_oteleport, 0 },
    { "odamage"    , do_odamage,   0 },
    { "otimer"     , do_otimer   , 0 },
    { "otransform" , do_otransform, 0 },
    
    { "\n", 0, 0 }	/* this must be last */
};



/*
 *  This is the command interpreter used by objects, called by script_driver.
 */
void obj_command_interpreter(obj_data *obj, char *argument)
{
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];
  
    skip_spaces(&argument);
  
    /* just drop to next line for hitting CR */
    if (!*argument)
	return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg),cmd = 0;
	 *obj_cmd_info[cmd].command != '\n'; cmd++)
	if (!strncmp(obj_cmd_info[cmd].command, arg, length))
	    break;
  
    if (*obj_cmd_info[cmd].command == '\n')
    {
	sprintf(buf2, "Unknown object cmd: '%s'", argument);
	obj_log(obj, buf2);
    }
    else
	((*obj_cmd_info[cmd].command_pointer) 
	 (obj, line, cmd, obj_cmd_info[cmd].subcmd));
}
::::::::::::::
dg_olc.c
::::::::::::::
/*
** dg_olc.c: this source file is used in extending Oasis style OLC for
** dg-scripts onto a CircleMUD that already has dg-scripts (as released
** by Mark Heilpern on 1/1/98) implemented.
**
** Parts of this file by Chris Jacobson of _Aliens vs Predator: The MUD_
*/


#define NO_CPS_LOGGING /* avoid logging of CHECK_PLAYER_SPECIALS on mobs */
#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "olc.h"
#include "dg_olc.h"
#include "dg_event.h"

/* declare externally defined globals */
extern struct index_data **trig_index;
extern const char *trig_types[], *otrig_types[], *wtrig_types[];
extern struct descriptor_data *descriptor_list;
extern struct trig_data *trigger_list;
extern int top_of_trigt;
extern struct zone_data *zone_table;


/* prototype externally defined functions */
void trig_data_copy(trig_data *this_data, const trig_data *trg);
void free_varlist(struct trig_var_data *vd);

void trigedit_disp_menu(struct descriptor_data *d);
void trigedit_save(struct descriptor_data *d);

/* copy an entire script from one holder (mob/obj/room) to another */
void script_copy(void *dst, void *src, int type)
{
  struct script_data *s_src = NULL;
  struct script_data *s_dst = NULL;
  trig_data *t_src, *t_dst;

  /* find the scripts of the source and destination */
  switch (type)
  {
    case MOB_TRIGGER:
      s_src = SCRIPT((struct char_data *)src);
      s_dst = SCRIPT((struct char_data *)dst);
      ((struct char_data *)dst)->proto_script =
        ((struct char_data *)src)->proto_script;
     break;
    case OBJ_TRIGGER:
      s_src = SCRIPT((struct obj_data *)src);
      s_dst = SCRIPT((struct obj_data *)dst);
      ((struct obj_data *)dst)->proto_script =
        ((struct obj_data *)src)->proto_script;
      break;
    case WLD_TRIGGER:
      s_src = SCRIPT((struct room_data *)src);
      s_dst = SCRIPT((struct room_data *)dst);
      ((struct room_data *)dst)->proto_script =
        ((struct room_data *)src)->proto_script;
      break;
    default:
      log("SYSERR: Unknown type code sent to script_copy()!");
      break;
  }

  /* make sure the dst doesnt already have a script       */
  /* if it does, delete it                                */
  if (s_dst) extract_script(s_dst);

  /* copy the scrip data */
  s_dst->types = s_src->types;
  t_src = TRIGGERS(s_src);
  while (t_src)
  {
    CREATE(t_dst, trig_data, 1);
    if (!TRIGGERS(s_dst)) TRIGGERS(s_dst) = t_dst;
    trig_data_copy(t_dst, t_src);
    t_dst = t_dst->next;
    t_src = t_src->next;
  }

}

/* called when a mob or object is being saved to disk, so its script can */
/* be saved */
void script_save_to_disk(FILE *fp, void *item, int type)
{
  struct trig_proto_list *t;

  if (type==MOB_TRIGGER)
    t = ((struct char_data *)item)->proto_script;
  else if (type==OBJ_TRIGGER)
    t = ((struct obj_data *)item)->proto_script;
  else if (type==WLD_TRIGGER)
    t = ((struct room_data *)item)->proto_script;
  else {
    log("SYSERR: Invalid type passed to script_save_mobobj_to_disk()");
    return;
  }

  while (t)
  {
    fprintf(fp,"T %d\n", t->vnum);
    t = t->next;
  }
}


void trigedit_setup_new(struct descriptor_data *d)
{
  struct trig_data *trig;
  
  /*
   * Allocate a scratch trigger structure
   */
  CREATE(trig, struct trig_data, 1);

  trig->nr = -1;

  /*
   * Set up some defaults
   */ 
  trig->name = str_dup("new trigger");
  trig->trigger_type = MTRIG_GREET;

  /* cmdlist will be a large char string until the trigger is saved */
  CREATE(OLC_STORAGE(d), char, MAX_CMD_LENGTH);
  strcpy(OLC_STORAGE(d),
    "say My trigger commandlist is not complete!\r\n");
  trig->narg = 100;

  OLC_TRIG(d) = trig;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
    
  trigedit_disp_menu(d);
}

void trigedit_setup_existing(struct descriptor_data *d, int rtrg_num)
{
  struct trig_data *trig;
  struct cmdlist_element *c;

  /*
   * Allocate a scratch trigger structure
   */
  CREATE(trig, struct trig_data, 1);

  trig_data_copy(trig, trig_index[rtrg_num]->proto);

  /* convert cmdlist to a char string */
  c = trig->cmdlist;
  CREATE(OLC_STORAGE(d), char, MAX_CMD_LENGTH);
  strcpy(OLC_STORAGE(d), "");
  
  while (c)
  {
    strcat(OLC_STORAGE(d), c->cmd);
    strcat(OLC_STORAGE(d), "\r\n");
    c = c->next;
  }
  /* now trig->cmdlist is something to pass to the text editor */
  /* it will be converted back to a real cmdlist_element list later */

  OLC_TRIG(d) = trig;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
    
  trigedit_disp_menu(d);
}


void trigedit_disp_menu(struct descriptor_data *d)
{
  struct trig_data *trig = OLC_TRIG(d);
  char *attach_type;
  char trgtypes[256];

  get_char_cols(d->character);

  if (trig->attach_type==OBJ_TRIGGER) {
    attach_type = "Objects";
    sprintbit(GET_TRIG_TYPE(trig), otrig_types, trgtypes);
  } else if (trig->attach_type==WLD_TRIGGER) {
    attach_type = "Rooms";
    sprintbit(GET_TRIG_TYPE(trig), wtrig_types, trgtypes);
  } else {
    attach_type = "Mobiles";
    sprintbit(GET_TRIG_TYPE(trig), trig_types, trgtypes);
  }
      
  sprintf(buf,
#if defined(CLEAR_SCREEN)
"[H[J"
#endif

  "Trigger Editor [%s%d%s]\r\n\r\n"
  "%s1)%s Name         : %s%s\r\n"
  "%s2)%s Intended for : %s%s\r\n"
  "%s3)%s Trigger types: %s%s\r\n"
  "%s4)%s Numberic Arg : %s%d\r\n"
  "%s5)%s Arguments    : %s%s\r\n"
  "%s6)%s Commands:\r\n%s%s\r\n"
  "%sQ)%s Quit\r\n"
  "Enter Choice :",

  grn, OLC_NUM(d), nrm, 			/* vnum on the title line */
  grn, nrm, yel, GET_TRIG_NAME(trig),		/* name                   */
  grn, nrm, yel, attach_type,			/* attach type            */
  grn, nrm, yel, trgtypes,			/* greet/drop/etc         */
  grn, nrm, yel, trig->narg,			/* numeric arg            */
  grn, nrm, yel, trig->arglist?trig->arglist:"",/* strict arg             */
  grn, nrm, cyn, OLC_STORAGE(d),		/* the command list       */
  grn, nrm);                                    /* quit colors            */

  send_to_char(buf, d->character);
  OLC_MODE(d) = TRIGEDIT_MAIN_MENU;
}

void trigedit_disp_types(struct descriptor_data *d)
{
  int i, columns = 0;
  const char **types;

  switch(OLC_TRIG(d)->attach_type)
  {
    case WLD_TRIGGER:
      types = wtrig_types;
      break;
    case OBJ_TRIGGER:
      types = otrig_types;
      break;
    case MOB_TRIGGER:
    default:
      types = trig_types;
      break;
  }

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_TRIG_TYPE_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, types[i],
              !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_TRIG_TYPE(OLC_TRIG(d)), types, buf1);
  sprintf(buf, "\r\nCurrent types : %s%s%s\r\nEnter type (0 to quit) : ",
                cyn, buf1, nrm);
  send_to_char(buf, d->character);

}

void trigedit_parse(struct descriptor_data *d, char *arg)
{
  int i = 0;

  switch (OLC_MODE(d)) {
    case TRIGEDIT_MAIN_MENU:
     switch (tolower(*arg)) {
       case 'q':
         if (OLC_VAL(d)) { /* Anything been changed? */
           if (!GET_TRIG_TYPE(OLC_TRIG(d))) {
             send_to_char("Invalid Trigger Type! Answer a to abort quit!\r\n",
               d->character);     
           }
           send_to_char("Do you wish to save the changes to the trigger? (y/n): ",
             d->character);     
           OLC_MODE(d) = TRIGEDIT_CONFIRM_SAVESTRING;
         } else
           cleanup_olc(d, CLEANUP_ALL);
           return;
         case '1':
           OLC_MODE(d) = TRIGEDIT_NAME;
           send_to_char("Name: ", d->character);
           break;
         case '2':
           OLC_MODE(d) = TRIGEDIT_INTENDED;
           send_to_char("0: Mobiles, 1: Objects, 2: Rooms: ", d->character);
           break;
         case '3':
           OLC_MODE(d) = TRIGEDIT_TYPES;
           trigedit_disp_types(d);
           break;
         case '4':
           OLC_MODE(d) = TRIGEDIT_NARG;
           send_to_char("Numeric argument: ", d->character);
           break;
         case '5':
           OLC_MODE(d) = TRIGEDIT_ARGUMENT;
           send_to_char("Argument: ", d->character);
           break;
         case '6':
           OLC_MODE(d) = TRIGEDIT_COMMANDS;
           send_to_char(
             "Enter trigger commands: (/s saves /h for help)\r\n\r\n",
             d->character);
           d->backstr = NULL;
           if (OLC_STORAGE(d)) {
             send_to_char(OLC_STORAGE(d), d->character);
             d->backstr = str_dup(OLC_STORAGE(d));
           }
           d->str = &OLC_STORAGE(d);
           d->max_str = MAX_CMD_LENGTH;
           d->mail_to = 0;
           OLC_VAL(d) = 1;

           break;
         default:
           trigedit_disp_menu(d);
           return;
     }
     return;
    
    case TRIGEDIT_CONFIRM_SAVESTRING:
      switch(tolower(*arg)) {
        case 'y':
          trigedit_save(d);
          sprintf(buf, "OLC: %s edits trigger %d", GET_NAME(d->character),
            OLC_NUM(d));
          mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
          /* fall through */
        case 'n':
          cleanup_olc(d, CLEANUP_ALL);
          return;
        case 'a': /* abort quitting */
          break;
        default:
          send_to_char("Invalid choice!\r\n", d->character);
          send_to_char("Do you wish to save the trigger? : ", d->character);
          return;
      }
      break;

    case TRIGEDIT_NAME:
      if (OLC_TRIG(d)->name)
        free(OLC_TRIG(d)->name);
      OLC_TRIG(d)->name = str_dup((arg && *arg) ? arg : "undefined");
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_INTENDED:
      if ((atoi(arg)>=MOB_TRIGGER) || (atoi(arg)<=WLD_TRIGGER))
        OLC_TRIG(d)->attach_type = atoi(arg);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_NARG:
      OLC_TRIG(d)->narg = atoi(arg);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_ARGUMENT:
      OLC_TRIG(d)->arglist = (*arg?str_dup(arg):NULL);
      OLC_VAL(d)++;
      break;

    case TRIGEDIT_TYPES:
      if ((i = atoi(arg)) == 0)
        break;
      else if (!((i < 0) || (i > NUM_TRIG_TYPE_FLAGS)))
        TOGGLE_BIT((GET_TRIG_TYPE(OLC_TRIG(d))), 1 << (i - 1));
      OLC_VAL(d)++;
      trigedit_disp_types(d);
      return;

    case TRIGEDIT_COMMANDS:
      break;

  }

  OLC_MODE(d) = TRIGEDIT_MAIN_MENU;
  trigedit_disp_menu(d);
}

/*
** print out the letter codes pertaining to the bits set in 'data'
*/
void sprintbits(int data, char *dest)
{
  int i;
  char *p = dest;

  for (i=0; i<32; i++) {
    if (data & (1<<i)) {
      *p = ((i<=25)?('a'+i):('A'+i));
      p++;
    }
  }
  *p = '\0';
}


/* save the zone's triggers to internal memory and to disk */
void trigedit_save(struct descriptor_data *d)
{
  int trig_rnum, i;
  int found = 0;
  char *s;
  trig_data *proto;
  trig_data *trig = OLC_TRIG(d);
  trig_data *live_trig;
  struct cmdlist_element *cmd, *next_cmd;
  struct index_data **new_index;
  struct descriptor_data *dsc;
  FILE *trig_file;
  int zone, top;
  char buf[MAX_CMD_LENGTH];
  char bitBuf[MAX_INPUT_LENGTH];
  char fname[MAX_INPUT_LENGTH];
  char logbuf[MAX_INPUT_LENGTH];


  if ((trig_rnum = real_trigger(OLC_NUM(d))) != -1) {
    proto = trig_index[trig_rnum]->proto;
    for (cmd = proto->cmdlist; cmd; cmd = next_cmd) { 
      next_cmd = cmd->next;
      if (cmd->cmd)
        free(cmd->cmd);
      free(cmd);
    }


    free(proto->arglist);
    free(proto->name);

    /* Recompile the command list from the new script */
    s = OLC_STORAGE(d);

    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cmd = trig->cmdlist;

    while ((s = strtok(NULL, "\n\r"))) {
      CREATE(cmd->next, struct cmdlist_element, 1);
      cmd = cmd->next;
      cmd->cmd = str_dup(s);
    }

    /* make the prorotype look like what we have */
    trig_data_copy(proto, trig);

    /* go through the mud and replace existing triggers         */
    live_trig = trigger_list;
    while (live_trig)
    {
      if (GET_TRIG_RNUM(live_trig) == trig_rnum) {
        if (live_trig->arglist) {
          free(live_trig->arglist);
          live_trig->arglist = NULL;
        }
        if (live_trig->name) {
          free(live_trig->name);
          live_trig->name = NULL;
        }

        if (proto->arglist)
          live_trig->arglist = str_dup(proto->arglist);
        if (proto->name)
          live_trig->name = str_dup(proto->name);

        live_trig->cmdlist = proto->cmdlist;
        live_trig->curr_state = live_trig->cmdlist;
        live_trig->trigger_type = proto->trigger_type;
        live_trig->attach_type = proto->attach_type;
        live_trig->narg = proto->narg;
        live_trig->data_type = proto->data_type;
        live_trig->depth = 0;
        live_trig->wait_event = NULL;
        if (GET_TRIG_WAIT(live_trig))
          remove_event(GET_TRIG_WAIT(live_trig));
        free_varlist(live_trig->var_list);
      }

      live_trig = live_trig->next_in_world;
    }
  } else {
    /* this is a new trigger */
    CREATE(new_index, struct index_data *, top_of_trigt + 2);

    /* Recompile the command list from the new script */
    s = OLC_STORAGE(d);
         
    CREATE(trig->cmdlist, struct cmdlist_element, 1);
    trig->cmdlist->cmd = str_dup(strtok(s, "\n\r"));
    cmd = trig->cmdlist;
                                
    while ((s = strtok(NULL, "\n\r"))) {
      CREATE(cmd->next, struct cmdlist_element, 1);
      cmd = cmd->next;
      cmd->cmd = str_dup(s);
    }

    for (i = 0; i < top_of_trigt; i++) {
      if (!found) {
        if (trig_index[i]->vnum > OLC_NUM(d)) {
          found = TRUE;
          trig_rnum = i;
                        
          CREATE(new_index[trig_rnum], struct index_data, 1);
          GET_TRIG_RNUM(OLC_TRIG(d)) = trig_rnum;
          new_index[trig_rnum]->vnum = OLC_NUM(d);
          new_index[trig_rnum]->number = 0; 
          new_index[trig_rnum]->func = NULL;
          CREATE(proto, struct trig_data, 1);
          new_index[trig_rnum]->proto = proto;
          trig_data_copy(proto, trig);

          if (trig->name)
            proto->name = str_dup(trig->name);
          if (trig->arglist)
            proto->arglist = str_dup(trig->arglist);  

          new_index[trig_rnum + 1] = trig_index[trig_rnum];

          proto = trig_index[trig_rnum]->proto;
          proto->nr = trig_rnum + 1;
        } else {
          new_index[i] = trig_index[i];
        }
      } else {
         new_index[i + 1] = trig_index[i];
         proto = trig_index[i]->proto;
         proto->nr = i + 1;
      }
    }

    if (!found) {
      trig_rnum = i;
      CREATE(new_index[trig_rnum], struct index_data, 1);
      GET_TRIG_RNUM(OLC_TRIG(d)) = trig_rnum;  
      new_index[trig_rnum]->vnum = OLC_NUM(d);
      new_index[trig_rnum]->number = 0;
      new_index[trig_rnum]->func = NULL;
                        
      CREATE(proto, struct trig_data, 1);
      new_index[trig_rnum]->proto = proto;
      trig_data_copy(proto, trig);

      if (trig->name)
        proto->name = str_dup(trig->name);
      if (trig->arglist)
        proto->arglist = str_dup(trig->arglist);  
    }
                
    free(trig_index);
                        
    trig_index = new_index;
    top_of_trigt++;         

    /* HERE IT HAS TO GO THROUGH AND FIX ALL SCRIPTS/TRIGS OF HIGHER RNUM */
    for (live_trig = trigger_list; live_trig; live_trig = live_trig->next_in_world)
      if (GET_TRIG_RNUM(live_trig) > trig_rnum)
        GET_TRIG_RNUM(live_trig)++;
        
    /*
     * Update other trigs being edited.
     */
     for (dsc = descriptor_list; dsc; dsc = dsc->next)
       if (dsc->connected == CON_TRIGEDIT)
         if (GET_TRIG_RNUM(OLC_TRIG(dsc)) >= trig_rnum)
           GET_TRIG_RNUM(OLC_TRIG(dsc))++;

  }

  /* now write the trigger out to disk, along with the rest of the  */
  /* triggers for this zone, of course                              */
  /* note: we write this to disk NOW instead of letting the builder */
  /* have control because if we lose this after having assigned a   */
  /* new trigger to an item, we will get SYSERR's upton reboot that */
  /* could make things hard to debug.                               */

  zone = zone_table[OLC_ZNUM(d)].number;
  top = zone_table[OLC_ZNUM(d)].top;

#ifdef CIRCLE_MAC
  sprintf(fname, "%s:%i.new", TRG_PREFIX, zone);
#else
  sprintf(fname, "%s/%i.new", TRG_PREFIX, zone);
#endif

  if (!(trig_file = fopen(fname, "w"))) {
    sprintf(logbuf,"SYSERR: OLC: Can't open trig file \"%s\"", fname);
    mudlog(logbuf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
    return;
  }
        
  for (i = zone * 100; i <= top; i++) {
    if ((trig_rnum = real_trigger(i)) != -1) {
      trig = trig_index[trig_rnum]->proto;

      if (fprintf(trig_file, "#%d\n", i) < 0) {
        sprintf(logbuf, "SYSERR: OLC: Can't write trig file!"); 
        mudlog(logbuf, BRF, MAX(LVL_GOD, GET_INVIS_LEV(d->character)), TRUE);
        fclose(trig_file);
        return;
      }
      sprintbits(GET_TRIG_TYPE(trig), bitBuf);
      fprintf(trig_file,      "%s~\n"
                              "%d %s %d\n"
                              "%s~\n",
           (GET_TRIG_NAME(trig)) ? (GET_TRIG_NAME(trig)) : "unknown trigger",
           trig->attach_type,
           bitBuf, GET_TRIG_NARG(trig),
           GET_TRIG_ARG(trig) ? GET_TRIG_ARG(trig) : "");
                
      /* Build the text for the script */
      strcpy(buf,"");
      for (cmd = trig->cmdlist; cmd; cmd = cmd->next) {
        strcat(buf, cmd->cmd);
        strcat(buf, "\r\n");
      }

      if (!buf[0])
        strcpy(buf, "* Empty script");
                
      fprintf(trig_file, "%s~\n", buf);
      *buf = '\0';
    }
  }
        
  fprintf(trig_file, "$~\n");
  fclose(trig_file);
                
#ifdef CIRCLE_MAC
  sprintf(buf, "%s:%d.trg", TRG_PREFIX, zone);
#else
  sprintf(buf, "%s/%d.trg", TRG_PREFIX, zone);
#endif
        
  rename(fname, buf);
}

void dg_olc_script_free(struct descriptor_data *d)
{
  struct trig_proto_list *editscript, *prevscript;

  editscript = OLC_SCRIPT(d);
  while (editscript) {
    prevscript = editscript;
    editscript = editscript->next;
    free(prevscript);
  }
}


void dg_olc_script_copy(struct descriptor_data *d)
{
  struct trig_proto_list *origscript, *editscript;

  if (OLC_ITEM_TYPE(d)==MOB_TRIGGER)
    origscript = OLC_MOB(d)->proto_script;
  else if (OLC_ITEM_TYPE(d)==OBJ_TRIGGER)
    origscript = OLC_OBJ(d)->proto_script;
  else origscript = OLC_ROOM(d)->proto_script;

  if (origscript) {
    CREATE(editscript, struct trig_proto_list, 1);
    OLC_SCRIPT(d) = editscript;

    while (origscript) {
      editscript->vnum = origscript->vnum;
      origscript = origscript->next;
      if (origscript)
        CREATE(editscript->next, struct trig_proto_list, 1);
      editscript = editscript->next;
    }
  } else
      OLC_SCRIPT(d) = NULL;
}

void dg_script_menu(struct descriptor_data *d)
{
  struct trig_proto_list *editscript;
  int i = 0;

  /* make sure our input parser gets used */
  OLC_MODE(d) = OLC_SCRIPT_EDIT;
  OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;


#if defined(CLEAR_SCREEN) /* done wierd to compile with the vararg send() */
#define FMT    "[H[J     Script Editor\r\n\r\n     Trigger List:\r\n"
#else
#define FMT    "     Script Editor\r\n\r\n     Trigger List:\r\n"
#endif
  send_to_char(FMT,d->character);
#undef FMT

  editscript = OLC_SCRIPT(d);
  while (editscript) {
    sprintf(buf,"     %2d) [%s%d%s] %s%s%s", ++i, cyn,
      editscript->vnum, nrm, cyn,
      trig_index[real_trigger(editscript->vnum)]->proto->name, nrm);
    send_to_char(buf, d->character);
    if (trig_index[real_trigger(editscript->vnum)]->proto->attach_type !=
        OLC_ITEM_TYPE(d))
      sprintf(buf,"   %s** Mis-matched Trigger Type **%s\r\n",grn,nrm);
    else
      sprintf(buf,"\r\n");
    send_to_char(buf, d->character);

    editscript = editscript->next;
  }
  if (i==0) send_to_char("     <none>\r\n", d->character);

  sprintf(buf, "\r\n"
    " %sN%s)  New trigger for this script\r\n"
    " %sD%s)  Delete a trigger in this script\r\n"
    " %sX%s)  Exit Script Editor\r\n\r\n"
    "     Enter choice :",
    grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf,d->character);
}

int dg_script_edit_parse(struct descriptor_data *d, char *arg)
{
  struct trig_proto_list *trig, *currtrig;
  int count, pos, vnum;

  switch(OLC_SCRIPT_EDIT_MODE(d)) {
    case SCRIPT_MAIN_MENU:
      switch(tolower(*arg)) {
        case 'x':
          if (OLC_ITEM_TYPE(d) == MOB_TRIGGER) {
            trig = OLC_MOB(d)->proto_script;
            OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
          } else if (OLC_ITEM_TYPE(d) == OBJ_TRIGGER) {
            trig = OLC_OBJ(d)->proto_script;
            OLC_OBJ(d)->proto_script = OLC_SCRIPT(d);
          } else {
            trig = OLC_ROOM(d)->proto_script;
            OLC_ROOM(d)->proto_script = OLC_SCRIPT(d);
          }

          while (trig) {
            currtrig = trig->next;
            free(trig);
            trig = currtrig;
          }
          return 0;
        case 'n':
          send_to_char("\r\nPlease enter trigger position, vnum (ex: 1, 200):",
            d->character);
          OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_NEW_TRIGGER;
          break;
        case 'd':
          send_to_char("     Which entry should be deleted?  0 to abort :",
            d->character);
          OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_DEL_TRIGGER;
          break;
        default:
          dg_script_menu(d);
          break;
      }
      return 1;

    case SCRIPT_NEW_TRIGGER:
      vnum = -1;
      count = sscanf(arg,"%d, %d",&pos,&vnum);
      if (count==1) {
        vnum = pos;
        pos = 999;
      }

      if (pos<=0) break; /* this aborts a new trigger entry */

      if (vnum==0) break; /* this aborts a new trigger entry */

      if (real_trigger(vnum)<0) {
        send_to_char("Invalid Trigger VNUM!\r\n"
            "Please enter a trigger position, vnum (ex: 1, 200):",
            d->character);
        return 1;
      }

      /* add the new info in position */
      currtrig = OLC_SCRIPT(d);
      CREATE(trig, struct trig_proto_list, 1);
      trig->vnum = vnum;

      if (pos==1 || !currtrig) {
        trig->next = OLC_SCRIPT(d);
        OLC_SCRIPT(d) = trig;
      } else {
        while (currtrig->next && --pos) {
          currtrig = currtrig->next;
        }
        trig->next = currtrig->next;
        currtrig->next = trig;
      }
      OLC_VAL(d)++;
      break;

    case SCRIPT_DEL_TRIGGER:
      pos = atoi(arg);
      if (pos<=0) break;

      if (pos==1 && OLC_SCRIPT(d)) {
        OLC_VAL(d)++;
        currtrig = OLC_SCRIPT(d);
        OLC_SCRIPT(d) = currtrig->next;
        free(currtrig);
        break;
      }

      pos--;
      currtrig = OLC_SCRIPT(d);

      while (--pos && currtrig) currtrig = currtrig->next;
      /* now curtrig points one before the target */
      if (currtrig && currtrig->next) {
        OLC_VAL(d)++;
        trig = currtrig->next;
        currtrig->next = trig->next;
        free(trig);
      }
      break;
  }

  dg_script_menu(d);
  return 1;      
}
::::::::::::::
dg_scripts.c
::::::::::::::
/**************************************************************************
*  File: scripts.c                                                        *
*  Usage: contains general functions for using scripts.                   *
*                                                                         *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/24 03:48:42 $
*  $Revision: 3.25 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"

 
#include "structs.h"
#include "buffer.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "dg_event.h"
#include "db.h"
#include "screen.h"

#define PULSES_PER_MUD_HOUR     (SECS_PER_MUD_HOUR*PASSES_PER_SEC)


/* external vars from db.c */
extern int top_of_trigt;
extern struct index_data **trig_index;

/* external vars from triggers.c */
extern const char *trig_types[], *otrig_types[], *wtrig_types[];

/* other external vars */
extern struct room_data *world;
extern int top_of_world;
extern struct char_data *character_list;
extern struct obj_data *object_list;
extern const char *item_types[];
extern const char *genders[];
extern const char *pc_class_types[];
extern const char *pc_race_types[];
extern const char *exit_bits[];
extern struct index_data *mob_index;
extern struct index_data *obj_index;

/* external functions */
sh_int find_target_room(char_data * ch, char *rawroomstr);
void free_varlist(struct trig_var_data *vd);
int obj_room(obj_data *obj);
int is_empty(int zone_nr);
sh_int find_target_room(struct char_data * ch, char *rawroomstr);
trig_data *read_trigger(int nr);
struct obj_data *get_object_in_equip(struct char_data * ch, char *name);
void extract_trigger(struct trig_data *trig);
int eval_lhs_op_rhs(char *expr, char *result, void *go, struct script_data *sc,
		    trig_data *trig, int type);
char *skill_percent(struct char_data *ch, char *skill);
int find_eq_pos(struct char_data * ch, struct obj_data * obj, char *arg);


/* function protos from this file */
void extract_value(struct script_data *sc, trig_data *trig, char *cmd);
int script_driver(void *go, trig_data *trig, int type, int mode);
int trgvar_in_room(int vnum);
void script_log(char *msg);
struct cmdlist_element *find_done(struct cmdlist_element *cl);
struct cmdlist_element * \
  find_case(struct trig_data *trig, struct cmdlist_element *cl, \
          void *go, struct script_data *sc, int type, char *cond);

/* local structures */
struct wait_event_data {
  trig_data *trigger;
  void *go;
  int type;
};


struct trig_data *trigger_list = NULL;  /* all attached triggers */

/* Return pointer to first occurrence in string ct in */
/* cs, or NULL if not present.  Case insensitive */
char *str_str(char *cs, char *ct)
{
  char *s, *t;

  if (!cs || !ct)
    return NULL;

  while (*cs) {
    t = ct;

    while (*cs && (LOWER(*cs) != LOWER(*t)))
      cs++;
 
    s = cs;
 
    while (*t && *cs && (LOWER(*cs) == LOWER(*t))) {
      t++;
      cs++;
    }

    if (!*t)
      return s;
  }

  return NULL;
}


int trgvar_in_room(int vnum) {
    int i = 0;
    char_data *ch;

    if (NOWHERE == real_room(vnum)) {
	script_log("people.vnum: world[vnum] does not exist");
	return (-1);
    }

    for (ch = world[vnum].people; ch !=NULL; ch = ch->next_in_room)
	i++;

    return i;
}

obj_data *get_obj_in_list(char *name, obj_data *list)
{
    obj_data *i;
    long id;
    
    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);
     
        for (i = list; i; i = i->next_content)
            if (id == GET_ID(i))
                return i;
    }
    else
    {
        for (i = list; i; i = i->next_content)
            if (isname(name, i->name))
                return i;
    }
        
    return NULL;
}

obj_data *get_object_in_equip(char_data * ch, char *name)
{
    int j, n = 0, number;
    obj_data *obj;
    char tmpname[MAX_INPUT_LENGTH];
    char *tmp = tmpname; 
    long id;

    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);
            
        for (j = 0; j < NUM_WEARS; j++)
            if ((obj = GET_EQ(ch, j)))
                if (id == GET_ID(obj))
                    return (obj);
    }
    else
    {
        strcpy(tmp, name);
        if (!(number = get_number(&tmp)))
            return NULL;

        for (j = 0; (j < NUM_WEARS) && (n <= number); j++)
            if ((obj = GET_EQ(ch, j)))
                if (isname(tmp, obj->name))
                    if (++n == number)
                        return (obj);
    }
    
    return NULL;
}

/************************************************************
 * search by number routines
 ************************************************************/
 
/* return char with UID n */
struct char_data *find_char(long n)
{
  struct char_data *ch;

  for (ch = character_list; ch; ch=ch->next)
  {
    if (GET_ID(ch)==n) return (ch);
  }
 
  return NULL;
}


/* return object with UID n */
obj_data *find_obj(long n)
{
    obj_data *i;
    
    for (i = object_list; i; i = i->next)
        if (n == GET_ID(i))
            return i;
 
    return NULL;
}

/* return room with UID n */
room_data *find_room(long n)
{
    n -= ROOM_ID_BASE;
    
    if ((n >= 0) && (n <= top_of_world))
        return &world[n];

    return NULL;
}



/************************************************************
 * generic searches based only on name
 ************************************************************/

/* search the entire world for a char, and return a pointer */
char_data *get_char(char *name)
{
    char_data *i;

    if (*name == UID_CHAR)
    {
        i = find_char(atoi(name + 1));

        if (i && ((i->player_specials == &dummy_mob) || !GET_INVIS_LEV(i)))
            return i;
    }
    else
    {
        for (i = character_list; i; i = i->next)
            if (isname(name, i->player.name) &&
                ((i->player_specials == &dummy_mob) ||
                  !GET_INVIS_LEV(i)))
                return i;
    }

    return NULL;
}


/* returns the object in the world with name name, or NULL if not found */
obj_data *get_obj(char *name)  
{
    obj_data *obj;
    long id;
    
    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);
        
        for (obj = object_list; obj; obj = obj->next)
            if (id == GET_ID(obj))
                return obj;
    }      
    else
    {
        for (obj = object_list; obj; obj = obj->next)
            if (isname(name, obj->name))
                return obj;
    }

    return NULL;
}
 

/* finds room by with name.  returns NULL if not found */
room_data *get_room(char *name)
{
    int nr; 

    if (*name == UID_CHAR)
        return find_room(atoi(name + 1));
    else if ((nr = real_room(atoi(name))) == NOWHERE)
        return NULL;
    else
        return &world[nr];
}


/*
 * returns a pointer to the first character in world by name name,
 * or NULL if none found.  Starts searching with the person owing the object
 */
char_data *get_char_by_obj(obj_data *obj, char *name)
{
    char_data *ch;

    if (*name == UID_CHAR)
    {
        ch = find_char(atoi(name + 1));
            
        if (ch && ((ch->player_specials == &dummy_mob) || !GET_INVIS_LEV(ch)))
            return ch;
    }
    else
    {
        if (obj->carried_by &&
            isname(name, obj->carried_by->player.name) &&
            ((obj->carried_by->player_specials == &dummy_mob) ||
              !GET_INVIS_LEV(obj->carried_by)))
            return obj->carried_by;
     
        if (obj->worn_by &&
            isname(name, obj->worn_by->player.name) &&
            ((obj->worn_by->player_specials == &dummy_mob) ||
              !GET_INVIS_LEV(obj->worn_by)))
            return obj->worn_by;
     
        for (ch = character_list; ch; ch = ch->next)
            if (isname(name, ch->player.name) &&
                ((ch->player_specials == &dummy_mob) ||
                  !GET_INVIS_LEV(ch)))
                return ch;
    }
        
    return NULL;
}
            
                
/*
 * returns a pointer to the first character in world by name name,
 * or NULL if none found.  Starts searching in room room first
 */
char_data *get_char_by_room(room_data *room, char *name)
{    
    char_data *ch;

    if (*name == UID_CHAR)
    {
        ch = find_char(atoi(name + 1));
 
        if (ch && ((ch->player_specials == &dummy_mob) || !GET_INVIS_LEV(ch)))
            return ch;
    }
    else
    {
        for (ch = room->people; ch; ch = ch->next_in_room)
            if (isname(name, ch->player.name) &&
                ((ch->player_specials == &dummy_mob) ||
                  !GET_INVIS_LEV(ch)))
                return ch;
        
        for (ch = character_list; ch; ch = ch->next)
            if (isname(name, ch->player.name) &&
                ((ch->player_specials == &dummy_mob) ||
                  !GET_INVIS_LEV(ch)))
                return ch;
    }
            
    return NULL;
}


/*
 * returns the object in the world with name name, or NULL if not found
 * search based on obj
 */  
obj_data *get_obj_by_obj(obj_data *obj, char *name)
{
    obj_data *i = NULL;  
    int rm;
    long id;

    if (!str_cmp(name, "self") || !str_cmp(name, "me"))
        return obj;
    
    if (obj->contains && (i = get_obj_in_list(name, obj->contains)))
        return i;
    
    if (obj->in_obj)
    {
        if (*name == UID_CHAR)
        {
            id = atoi(name + 1);
        
            if (id == GET_ID(obj->in_obj))
                return obj->in_obj;
        }
        else if (isname(name, obj->in_obj->name))
            return obj->in_obj;
    }   
     
    else if (obj->worn_by && (i = get_object_in_equip(obj->worn_by, name)))
        return i;
    else if (obj->carried_by &&
             (i = get_obj_in_list(name, obj->carried_by->carrying)))
        return i;
    else if (((rm = obj_room(obj)) != NOWHERE) &&
             (i = get_obj_in_list(name, world[rm].contents)))
        return i;
                        
    if (*name == UID_CHAR)
    {           
        id = atoi(name + 1);
 
        for (i = object_list; i; i = i->next)
            if (id == GET_ID(i))
                break;
    }

    else
    {
        for (i = object_list; i; i = i->next)
            if (isname(name, i->name))
                break;
    }

    return i;
}   

        
/* returns obj with name */
obj_data *get_obj_by_room(room_data *room, char *name)
{
    obj_data *obj;
    long id;
     
    if (*name == UID_CHAR)
    {
        id = atoi(name + 1);
        
        for (obj = room->contents; obj; obj = obj->next_content)
            if (id == GET_ID(obj)) 
                return obj;
        
        for (obj = object_list; obj; obj = obj->next)
            if (id == GET_ID(obj))
                return obj;
    }
    else
    {
        for (obj = room->contents; obj; obj = obj->next_content)
            if (isname(name, obj->name))
                return obj;
             
        for (obj = object_list; obj; obj = obj->next)
            if (isname(name, obj->name))
                return obj;
    }           
        
    return NULL;
}



/* checks every PLUSE_SCRIPT for random triggers */
void script_trigger_check(void)
{
  char_data *ch;
  obj_data *obj;
  struct room_data *room=NULL;
  int nr;
  struct script_data *sc;

  for (ch = character_list; ch; ch = ch->next) {
    if (!ch) return;
    if (SCRIPT(ch)) {
      sc = SCRIPT(ch);

      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_RANDOM) &&
	  (!is_empty(world[IN_ROOM(ch)].zone) ||
	   IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
	random_mtrigger(ch);
    }
  }
  
  for (obj = object_list; obj; obj = obj->next) {
    if (!obj) return;
    if (SCRIPT(obj)) {
      sc = SCRIPT(obj);

      if (IS_SET(SCRIPT_TYPES(sc), OTRIG_RANDOM))
	random_otrigger(obj);
    }
  }

  for (nr = 0; nr <= top_of_world; nr++) {
    if (SCRIPT(&world[nr])) {
      room = &world[nr];
      sc = SCRIPT(room);
      
      if (IS_SET(SCRIPT_TYPES(sc), WTRIG_RANDOM) &&
	  (!is_empty(room->zone) ||
	   IS_SET(SCRIPT_TYPES(sc), WTRIG_GLOBAL)))
	random_wtrigger(room);
    }
  }
}


EVENT(trig_wait_event)
{
  struct wait_event_data *wait_event_obj = (struct wait_event_data *)info;
  trig_data *trig;
  void *go;
  int type;

  trig = wait_event_obj->trigger;
  go = wait_event_obj->go;
  type = wait_event_obj->type;

  free(wait_event_obj);  
  GET_TRIG_WAIT(trig) = NULL;

  script_driver(go, trig, type, TRIG_RESTART);
}


void do_stat_trigger(struct char_data *ch, trig_data *trig)
{
    struct cmdlist_element *cmd_list;
    char sb[MAX_STRING_LENGTH];

    if (!trig)
    {
	log("SYSERR: NULL trigger passed to do_stat_trigger.");
	return;
    }

    sprintf(sb, "Name: '%s%s%s',  VNum: [%s%5d%s], RNum: [%5d]\r\n",
	      CCYEL(ch, C_NRM), GET_TRIG_NAME(trig), CCNRM(ch, C_NRM),
	      CCGRN(ch, C_NRM), GET_TRIG_VNUM(trig), CCNRM(ch, C_NRM),
	      GET_TRIG_RNUM(trig));

    if (trig->attach_type==OBJ_TRIGGER) {
      send_to_char("Trigger Intended Assignment: Objects\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), otrig_types, buf);
    } else if (trig->attach_type==WLD_TRIGGER) {
      send_to_char("Trigger Intended Assignment: Rooms\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), wtrig_types, buf);
    } else {
      send_to_char("Trigger Intended Assignment: Mobiles\r\n", ch);
      sprintbit(GET_TRIG_TYPE(trig), trig_types, buf);
    }
    
    sprintf(sb, "Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n",
	      buf, GET_TRIG_NARG(trig), 
	      ((GET_TRIG_ARG(trig) && *GET_TRIG_ARG(trig))
	       ? GET_TRIG_ARG(trig) : "None"));

    strcat(sb,"Commands:\r\n   ");

    cmd_list = trig->cmdlist;
    while (cmd_list)
    {
	if (cmd_list->cmd)
	{
	    strcat(sb,cmd_list->cmd);
	    strcat(sb,"\r\n   ");
	}

	cmd_list = cmd_list->next;
    }

    page_string(ch->desc, sb, 1);
}


/* find the name of what the uid points to */
void find_uid_name(char *uid, char *name)
{
  char_data *ch;
  obj_data *obj;

  if ((ch = get_char(uid)))
    strcpy(name, ch->player.name);
  else if ((obj = get_obj(uid)))
    strcpy(name, obj->name);
  else
    sprintf(name, "uid = %s, (not found)", uid + 1);
}


/* general function to display stats on script sc */
void script_stat (char_data *ch, struct script_data *sc)
{
  struct trig_var_data *tv;
  trig_data *t;
  char name[MAX_INPUT_LENGTH];
  char namebuf[512];

  sprintf(buf, "Global Variables: %s\r\n", sc->global_vars ? "" : "None");
  send_to_char(buf, ch);
  sprintf(buf, "Global context: %ld\r\n", sc->context);
  send_to_char(buf, ch);

  for (tv = sc->global_vars; tv; tv = tv->next) {
    sprintf(namebuf,"%s:%ld", tv->name, tv->context);
    if (*(tv->value) == UID_CHAR) {
      find_uid_name(tv->value, name);
      sprintf(buf, "    %15s:  %s\r\n", tv->context?namebuf:tv->name, name);
    } else 
      sprintf(buf, "    %15s:  %s\r\n", tv->context?namebuf:tv->name,
              tv->value);
    send_to_char(buf, ch);
  }

  for (t = TRIGGERS(sc); t; t = t->next) {
    sprintf(buf, "\r\n  Trigger: %s%s%s, VNum: [%s%5d%s], RNum: [%5d]\r\n",
	    CCYEL(ch, C_NRM), GET_TRIG_NAME(t), CCNRM(ch, C_NRM),
	    CCGRN(ch, C_NRM), GET_TRIG_VNUM(t), CCNRM(ch, C_NRM),
	    GET_TRIG_RNUM(t));
    send_to_char(buf, ch);

    if (t->attach_type==OBJ_TRIGGER) {
      send_to_char("  Trigger Intended Assignment: Objects\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), otrig_types, buf1);
    } else if (t->attach_type==WLD_TRIGGER) {
      send_to_char("  Trigger Intended Assignment: Rooms\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), wtrig_types, buf1);
    } else {
      send_to_char("  Trigger Intended Assignment: Mobiles\r\n", ch);
      sprintbit(GET_TRIG_TYPE(t), trig_types, buf1);
    }
    
    sprintf(buf, "  Trigger Type: %s, Numeric Arg: %d, Arg list: %s\r\n", 
	    buf1, GET_TRIG_NARG(t), 
	    ((GET_TRIG_ARG(t) && *GET_TRIG_ARG(t)) ? GET_TRIG_ARG(t) :
	     "None"));
    send_to_char(buf, ch);

    if (GET_TRIG_WAIT(t)) {
      sprintf(buf, "    Wait: %d, Current line: %s\r\n",
	      GET_TRIG_WAIT(t)->time_remaining, t->curr_state->cmd);
      send_to_char(buf, ch);

      sprintf(buf, "  Variables: %s\r\n", GET_TRIG_VARS(t) ? "" : "None");
      send_to_char(buf, ch);

      for (tv = GET_TRIG_VARS(t); tv; tv = tv->next) {
	if (*(tv->value) == UID_CHAR) {
	  find_uid_name(tv->value, name);
	  sprintf(buf, "    %15s:  %s\r\n", tv->name, name);
	} else 
	  sprintf(buf, "    %15s:  %s\r\n", tv->name, tv->value);
	send_to_char(buf, ch);
      }
    }
  }  
}


void do_sstat_room(struct char_data * ch)
{
  struct room_data *rm = &world[ch->in_room];

  send_to_char("Script information:\r\n", ch);
  if (!SCRIPT(rm)) {
    send_to_char("  None.\r\n", ch);
    return;
  }

  script_stat(ch, SCRIPT(rm));
}


void do_sstat_object(char_data *ch, obj_data *j)
{
  send_to_char("Script information:\r\n", ch);
  if (!SCRIPT(j)) {
    send_to_char("  None.\r\n", ch);
    return;
  }

  script_stat(ch, SCRIPT(j));
}


void do_sstat_character(char_data *ch, char_data *k)
{
  send_to_char("Script information:\r\n", ch);
  if (!SCRIPT(k)) {
    send_to_char("  None.\r\n", ch);
    return;
  }
  
  script_stat(ch, SCRIPT(k));
}


/*
 * adds the trigger t to script sc in in location loc.  loc = -1 means
 * add to the end, loc = 0 means add before all other triggers.
 */
void add_trigger(struct script_data *sc, trig_data *t, int loc)
{
  trig_data *i;
  int n;

  for (n = loc, i = TRIGGERS(sc); i && i->next && (n != 0); n--, i = i->next);

  if (!loc) {
          t->next = TRIGGERS(sc);
    TRIGGERS(sc) = t;
  } else if (!i)
    TRIGGERS(sc) = t;
  else {
    t->next = i->next;
    i->next = t;
  }

  SCRIPT_TYPES(sc) |= GET_TRIG_TYPE(t);

  t->next_in_world = trigger_list;
  trigger_list = t;
}


ACMD(do_attach) 
{
  char_data *victim;
  obj_data *object;
  trig_data *trig;
  char targ_name[MAX_INPUT_LENGTH], trig_name[MAX_INPUT_LENGTH];
  char loc_name[MAX_INPUT_LENGTH];
  int loc, room, tn, rn;


  argument = two_arguments(argument, arg, trig_name);
  two_arguments(argument, targ_name, loc_name);

  if (!*arg || !*targ_name || !*trig_name) {
    send_to_char("Usage: attach { mtr | otr | wtr } { trigger } { name } [ location ]\r\n", ch);
    return;
  }
  
  tn = atoi(trig_name);
  loc = (*loc_name) ? atoi(loc_name) : -1;
  
  if (is_abbrev(arg, "mtr")) {
    if ((victim = get_char_vis(ch, targ_name))) {
      if (IS_NPC(victim))  {
	
	/* have a valid mob, now get trigger */
       rn = real_trigger(tn);
	if ((rn >= 0) && (trig = read_trigger(rn))) {

	  if (!SCRIPT(victim))
	    CREATE(SCRIPT(victim), struct script_data, 1);
	  add_trigger(SCRIPT(victim), trig, loc);
	  
	  sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		  tn, GET_TRIG_NAME(trig), GET_SHORT(victim));
	  send_to_char(buf, ch);
	} else
	  send_to_char("That trigger does not exist.\r\n", ch);
      } else
	send_to_char("Players can't have scripts.\r\n", ch);
    } else
      send_to_char("That mob does not exist.\r\n", ch);
  }

  else if (is_abbrev(arg, "otr")) {
    if ((object = get_obj_vis(ch, targ_name))) {
	
      /* have a valid obj, now get trigger */
      rn = real_trigger(tn);
      if ((rn >= 0) && (trig = read_trigger(rn))) {
	
	  if (!SCRIPT(object))
	    CREATE(SCRIPT(object), struct script_data, 1);
	  add_trigger(SCRIPT(object), trig, loc);
	  
	  sprintf(buf, "Trigger %d (%s) attached to %s.\r\n",
		  tn, GET_TRIG_NAME(trig), 
		  (object->short_description ?
		   object->short_description : object->name));
	  send_to_char(buf, ch);
      } else
	send_to_char("That trigger does not exist.\r\n", ch);
    } else
      send_to_char("That object does not exist.\r\n", ch); 
  }

  else if (is_abbrev(arg, "wtr")) {
    if (isdigit(*targ_name) && !strchr(targ_name, '.')) {
      if ((room = find_target_room(ch, targ_name)) != NOWHERE) {
	
	/* have a valid room, now get trigger */
	rn = real_trigger(tn);
	if ((rn >= 0) && (trig = read_trigger(rn))) {

	  if (!(world[room].script))
	    CREATE(world[room].script, struct script_data, 1);
	  add_trigger(world[room].script, trig, loc);
	  
	  sprintf(buf, "Trigger %d (%s) attached to room %d.\r\n",
		  tn, GET_TRIG_NAME(trig), world[room].number);
	  send_to_char(buf, ch);
	} else
	  send_to_char("That trigger does not exist.\r\n", ch);
      }
    } else
      send_to_char("You need to supply a room number.\r\n", ch);
  }

  else
    send_to_char("Please specify 'mtr', otr', or 'wtr'.\r\n", ch);
}


/* adds a variable with given name and value to trigger */
void add_var(struct trig_var_data **var_list, char *name, char *value, long id)
{
  struct trig_var_data *vd;

  for (vd = *var_list; vd && str_cmp(vd->name, name); vd = vd->next);

  if (vd) {
    free(vd->value);
    CREATE(vd->value, char, strlen(value) + 1);
  }

  else {
    CREATE(vd, struct trig_var_data, 1);
    
    CREATE(vd->name, char, strlen(name) + 1);
    strcpy(vd->name, name);
    
    CREATE(vd->value, char, strlen(value) + 1);

    vd->next = *var_list;
    *var_list = vd;
  }

  strcpy(vd->value, value);
}


/*
 *  removes the trigger specified by name, and the script of o if
 *  it removes the last trigger.  name can either be a number, or
 *  a 'silly' name for the trigger, including things like 2.beggar-death.
 *  returns 0 if did not find the trigger, otherwise 1.  If it matters,
 *  you might need to check to see if all the triggers were removed after
 *  this function returns, in order to remove the script.
 */
int remove_trigger(struct script_data *sc, char *name)
{
  trig_data *i, *j;
  int num = 0, string = FALSE, n;
  char *cname;
      
        
  if (!sc)
    return 0;
   
  if ((cname = strstr(name,".")) || (!isdigit(*name)) ) {
    string = TRUE;
    if (cname) {
      *cname = '\0';
      num = atoi(name);
      name = ++cname;
    }
  } else
    num = atoi(name);
  
  for (n = 0, j = NULL, i = TRIGGERS(sc); i; j = i, i = i->next) {
    if (string) {
      if (isname(name, GET_TRIG_NAME(i)))
        if (++n >= num)
          break;
    }
        
    else if (++n >= num)
      break;
  }
      
  if (i) {
    if (j) {
      j->next = i->next;
      extract_trigger(i);
    }
  
    /* this was the first trigger */
    else {
      TRIGGERS(sc) = i->next;
      extract_trigger(i);
    }
 
    /* update the script type bitvector */
    SCRIPT_TYPES(sc) = 0;
    for (i = TRIGGERS(sc); i; i = i->next)
      SCRIPT_TYPES(sc) |= GET_TRIG_TYPE(i);
 
    return 1;
  } else
    return 0; 
}     

ACMD(do_detach)
{  
  char_data *victim = NULL;
  obj_data *object = NULL;
  struct room_data *room;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH], arg3[MAX_INPUT_LENGTH];
  char *trigger = 0;   
  int tmp;

  argument = two_arguments(argument, arg1, arg2);
  one_argument(argument, arg3);
  
  if (!*arg1 || !*arg2) {
    send_to_char("Usage: detach [ mob | object | room ] { target } { trigger |"
                 " 'all' }\r\n", ch);
    return;
  }
     
  if (!str_cmp(arg1, "room")) {
    room = &world[IN_ROOM(ch)];
    if (!SCRIPT(room))
      send_to_char("This room does not have any triggers.\r\n", ch);
    else if (!str_cmp(arg2, "all")) {
      extract_script(SCRIPT(room));
      SCRIPT(room) = NULL;
      send_to_char("All triggers removed from room.\r\n", ch);
    }
     
    else if (remove_trigger(SCRIPT(room), arg2)) {
      send_to_char("Trigger removed.\r\n", ch);
      if (!TRIGGERS(SCRIPT(room))) {
        extract_script(SCRIPT(room));
        SCRIPT(room) = NULL;
      }
    } else
      send_to_char("That trigger was not found.\r\n", ch);
  }
    
  else {
    if (is_abbrev(arg1, "mob")) {
      if (!(victim = get_char_vis(ch, arg2)))
        send_to_char("No such mobile around.\r\n", ch);
      else if (!arg3 || !*arg3)
        send_to_char("You must specify a trigger to remove.\r\n", ch);
      else
        trigger = arg3;
    }
   
    else if (is_abbrev(arg1, "object")) {
      if (!(object = get_obj_vis(ch, arg2)))
        send_to_char("No such object around.\r\n", ch);
      else if (!*arg3)
        send_to_char("You must specify a trigger to remove.\r\n", ch);
      else
        trigger = arg3;
    }
    else  {
      if ((object = get_object_in_equip_vis(ch, arg1, ch->equipment, &tmp)));
      else if ((object = get_obj_in_list_vis(ch, arg1, ch->carrying)));
      else if ((victim = get_char_room_vis(ch, arg1)));
      else if ((object = get_obj_in_list_vis(ch, arg1, world[IN_ROOM(ch)].contents)));
      else if ((victim = get_char_vis(ch, arg1)));
      else if ((object = get_obj_vis(ch, arg1)));
      else
        send_to_char("Nothing around by that name.\r\n", ch);
    
      trigger = arg2;
    }
      
    if (victim) {
      if (!IS_NPC(victim))
        send_to_char("Players don't have triggers.\r\n", ch);
     
      else if (!SCRIPT(victim))
        send_to_char("That mob doesn't have any triggers.\r\n", ch);
      else if (!str_cmp(arg2, "all")) {
        extract_script(SCRIPT(victim));
        SCRIPT(victim) = NULL;
        sprintf(buf, "All triggers removed from %s.\r\n", GET_SHORT(victim));
        send_to_char(buf, ch);
      }
   
      else if (trigger && remove_trigger(SCRIPT(victim), trigger)) {
        send_to_char("Trigger removed.\r\n", ch);
        if (!TRIGGERS(SCRIPT(victim))) {
          extract_script(SCRIPT(victim));
          SCRIPT(victim) = NULL;
        }
      } else
        send_to_char("That trigger was not found.\r\n", ch);
    }
     
    else if (object) {
      if (!SCRIPT(object))
        send_to_char("That object doesn't have any triggers.\r\n", ch);
        
      else if (!str_cmp(arg2, "all")) {
        extract_script(SCRIPT(object));
        SCRIPT(object) = NULL;
        sprintf(buf, "All triggers removed from %s.\r\n",
                object->short_description ? object->short_description :
                object->name);
        send_to_char(buf, ch);
      }
       
      else if (remove_trigger(SCRIPT(object), trigger)) {
        send_to_char("Trigger removed.\r\n", ch);
        if (!TRIGGERS(SCRIPT(object))) {
          extract_script(SCRIPT(object));
          SCRIPT(object) = NULL;
        }
      } else
        send_to_char("That trigger was not found.\r\n", ch);
    }
  }  
}    


/* frees memory associated with var */
void free_var_el(struct trig_var_data *var)
{
  free(var->name);
  free(var->value);
  free(var);
}


/*
 * remove var name from var_list
 * returns 1 if found, else 0
 */
int remove_var(struct trig_var_data **var_list, char *name)
{
  struct trig_var_data *i, *j;

  for (j = NULL, i = *var_list; i && str_cmp(name, i->name);
       j = i, i = i->next);

  if (i) {
    if (j) {
      j->next = i->next;
      free_var_el(i);
    } else {
      *var_list = i->next;
      free_var_el(i);
    }

    return 1;      
  }
  
  return 0;
}


/*  
 *  Logs any errors caused by scripts to the system log.
 *  Will eventually allow on-line view of script errors.
 */
void script_log(char *msg)
{
  char buf[256];

  sprintf(buf,"SCRIPT ERR: %s", msg);
  mudlog(buf, NRM, LVL_GOD, TRUE);
}

int text_processed(char *field, struct trig_var_data *vd, char *str)
{
  char *p, *p2;

  if (!str_cmp(field, "strlen")) {                     /* strlen    */
    sprintf(str, "%d", strlen(vd->value));
    return TRUE;
  } else if (!str_cmp(field, "trim")) {                /* trim      */
    /* trim whitespace from ends */
    p = vd->value;
    p2 = vd->value + strlen(vd->value) - 1;
    while (*p && isspace(*p)) p++;
    while ((p>=p2) && isspace(*p2)) p2--;
    if (p>p2) { /* nothing left */
      *str = '\0';
      return TRUE;
    }
    while (p<=p2)
      *str++ = *p++;
    *str = '\0';
    return TRUE;
  } else if (!str_cmp(field, "car")) {                 /* car       */
    char *car = vd->value;
    while (*car && !isspace(*car))
      *str++ = *car++;
    *str = '\0';
    return TRUE;
  } else if (!str_cmp(field, "cdr")) {                 /* cdr       */
    char *cdr = vd->value;
    while (*cdr && !isspace(*cdr)) cdr++; /* skip 1st field */
    while (*cdr && isspace(*cdr)) cdr++;  /* skip to next */
    while (*cdr)
      *str++ = *cdr++;
    *str = '\0';
    return TRUE;
  }

  return FALSE;
}


/* sets str to be the value of var.field */
void find_replacement(void *go, struct script_data *sc, trig_data *trig,
                int type, char *var, char *field, char *subfield, char *str)
{
  struct trig_var_data *vd;
  char_data *ch, *c = NULL, *rndm;
  obj_data *obj, *o = NULL;
  struct room_data *room, *r = NULL;
  char *name;
  int num, count;

  switch (trig->attach_type) {
  case MOB_TRIGGER:
    break;
  case OBJ_TRIGGER:
    break;
  case WLD_TRIGGER:
    break;
  }

  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, var))
      break;
  
  if (!vd)
    for (vd = sc->global_vars; vd; vd = vd->next)
      if (!str_cmp(vd->name, var) &&
          (vd->context==0 || vd->context==sc->context))
	break; 

  if (!*field) {
    if (vd)
      strcpy(str, vd->value);
    else {
      if (!str_cmp(var, "self"))
	strcpy(str, "self");
      else
	*str = '\0';
    }

    return;
  }

  else {
    if (vd) {
      name = vd->value;

      switch (type) {
      case MOB_TRIGGER:
	ch = (char_data *) go;

	if ((o = get_object_in_equip(ch, name)));
	else if ((o = get_obj_in_list(name, ch->carrying)));
	else if ((c = get_char_room(name, IN_ROOM(ch))));
	else if ((o = get_obj_in_list(name,world[IN_ROOM(ch)].contents)));
	else if ((c = get_char(name)));
	else if ((o = get_obj(name)));
	else if ((r = get_room(name))) {}

	break;
      case OBJ_TRIGGER:
	obj = (obj_data *) go;

	if ((c = get_char_by_obj(obj, name)));
	else if ((o = get_obj_by_obj(obj, name)));
	else if ((r = get_room(name))) {}

	break;
      case WLD_TRIGGER:
	room = (struct room_data *) go;

	if ((c = get_char_by_room(room, name)));
	else if ((o = get_obj_by_room(room, name)));
	else if ((r = get_room(name))) {}

	break;
      }
    }

    else {
      if (!str_cmp(var, "self")) {
	switch (type) {
	case MOB_TRIGGER:
	  c = (char_data *) go;
	  break;
	case OBJ_TRIGGER:
	  o = (obj_data *) go;
	  break;
	case WLD_TRIGGER:
	  r = (struct room_data *) go;
	  break;
	}
      }
      
      else if (!str_cmp(var, "people")) {
	sprintf(str,"%d",((num = atoi(field)) > 0) ? trgvar_in_room(num) : 0);	
	return;
      }
      else if (!str_cmp(var, "random")) {
	if (!str_cmp(field, "char")) {
	  rndm = NULL;
	  count = 0;

	  if (type == MOB_TRIGGER) {
	    ch = (char_data *) go;
	    for (c = world[IN_ROOM(ch)].people; c; c = c->next_in_room)
	      if (!PRF_FLAGGED(c, PRF_NOHASSLE) && (c != ch) &&
		  CAN_SEE(ch, c)) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }
	  
	  else if (type == OBJ_TRIGGER) {
	    for (c = world[obj_room((obj_data *) go)].people; c;
		 c = c->next_in_room)
	      if ((c->player_specials == &dummy_mob) ||
                  (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c))) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }
	  
	  else if (type == WLD_TRIGGER) {
	    for (c = ((struct room_data *) go)->people; c;
		 c = c->next_in_room)
	      if ((c->player_specials == &dummy_mob) ||
                  (!PRF_FLAGGED(c, PRF_NOHASSLE) && !GET_INVIS_LEV(c))) {
		if (!number(0, count))
		  rndm = c;
		count++;
	      }
	  }
	  
	  if (rndm)
	    sprintf(str, "%c%ld", UID_CHAR, GET_ID(rndm));
	  else
	    *str = '\0';
	}

	else
	  sprintf(str, "%d", ((num = atoi(field)) > 0) ? number(1, num) : 0);
	
	return;
      }
    }
    
    if (c) {
      if (text_processed(field, vd, str)) return;

      else if (!str_cmp(field, "name"))
        if (GET_SHORT(c))
          strcpy(str, GET_SHORT(c));
        else
          strcpy(str, GET_NAME(c));

      else if (!str_cmp(field, "id"))
	sprintf(str, "%ld", GET_ID(c));

      else if (!str_cmp(field, "alias"))
	strcpy(str, GET_NAME(c));

      else if (!str_cmp(field, "level"))
	sprintf(str, "%d", GET_LEVEL(c));

      else if (!str_cmp(field, "align"))
	sprintf(str, "%d", GET_ALIGNMENT(c));

      else if (!str_cmp(field, "gold"))
	sprintf(str, "%d", GET_GOLD(c));

      else if (!str_cmp(field, "sex"))
	strcpy(str, genders[(int)GET_SEX(c)]);

      else if (!str_cmp(field, "weight"))
	sprintf(str, "%d", GET_WEIGHT(c));

      else if (!str_cmp(field, "canbeseen")) {
	if ((type == MOB_TRIGGER) && !CAN_SEE(((char_data *)go), c))
	  strcpy(str, "0");
	else
	  strcpy(str, "1");
      }

      else if (!str_cmp(field, "class"))
	sprinttype(GET_CLASS(c), pc_class_types, str);

#ifdef GET_RACE
      else if (!str_cmp(field, "race"))
	sprinttype(GET_RACE(c), pc_race_types, str);
#endif

      else if (!str_cmp(field, "fighting"))
        if (FIGHTING(c))
          sprintf(str, "%c%ld", UID_CHAR, GET_ID(FIGHTING(c)));
        else *str = '\0';

#ifdef RIDING
      else if (!str_cmp(field, "riding"))
        if (RIDING(c))
          sprintf(str, "%c%ld", UID_CHAR, GET_ID(RIDING(c)));
        else *str = '\0';
#endif

#ifdef RIDDEN_BY
      else if (!str_cmp(field, "ridden_by"))
        if (RIDDEN_BY(c))
          sprintf(str, "%c%ld", UID_CHAR, GET_ID(RIDDEN_BY(c)));
        else *str = '\0';
#endif

      else if (!str_cmp(field, "vnum"))
	sprintf(str, "%d", GET_MOB_VNUM(c));

      else if (!str_cmp(field, "str"))
	sprintf(str, "%d", GET_STR(c));

      else if (!str_cmp(field, "stradd"))
        if (GET_STR(c)==18)
          sprintf(str, "%d", GET_ADD(c));
        else sprintf(str, "0");

      else if (!str_cmp(field, "int"))
	sprintf(str, "%d", GET_INT(c));

      else if (!str_cmp(field, "wis"))
	sprintf(str, "%d", GET_WIS(c));

      else if (!str_cmp(field, "dex"))
	sprintf(str, "%d", GET_DEX(c));

      else if (!str_cmp(field, "con"))
	sprintf(str, "%d", GET_CON(c));

      else if (!str_cmp(field, "cha"))
	sprintf(str, "%d", GET_CHA(c));

      else if (!str_cmp(field, "room"))
	sprintf(str, "%d", world[IN_ROOM(c)].number);

      else if (!str_cmp(field, "skill"))
        strcpy(str,skill_percent(c, subfield));

      else if (!str_cmp(field, "eq")) {
        int pos = find_eq_pos(c, NULL, subfield);
        if (pos==-1 && isdigit(*subfield))
          pos = atoi(subfield);
        if (!subfield || !*subfield || pos < 0 || pos > NUM_WEARS)
          strcpy(str,"");
        else
          sprintf(str,"%c%ld",UID_CHAR, GET_ID(GET_EQ(c, pos)));
      }

      else {
        if (SCRIPT(c)) {
          for (vd = (SCRIPT(c))->global_vars; vd; vd = vd->next)
            if (!str_cmp(vd->name, field))
              break;
          if (vd)
            sprintf(str, "%s", vd->value);
          else {
            *str = '\0';
            sprintf(buf2, 
                   "Trigger: %s, VNum %d. unknown char field: '%s'",
                   GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), field);
            script_log(buf2);
          }
        } else {
          *str = '\0';
          sprintf(buf2, 
                 "Trigger: %s, VNum %d. unknown char field: '%s'",
                 GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), field);
          script_log(buf2);
        }
      }
    }

    else if (o) {
      if (text_processed(field, vd, str)) return;

      else if (!str_cmp(field, "name"))
	strcpy(str, o->name);

      else if (!str_cmp(field, "id"))
	sprintf(str, "%ld", GET_ID(o));

      else if (!str_cmp(field, "shortdesc"))
	strcpy(str, o->short_description);

      else if (!str_cmp(field, "vnum"))
	sprintf(str, "%d", GET_OBJ_VNUM(o));

      else if (!str_cmp(field, "type"))
	sprinttype(GET_OBJ_TYPE(o), item_types, str);

      else if (!str_cmp(field, "timer"))
        sprintf(str, "%d", GET_OBJ_TIMER(o));
      
      else if (!str_cmp(field, "val0"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 0));
      
      else if (!str_cmp(field, "val1"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 1));
      
      else if (!str_cmp(field, "val2"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 2));
      
      else if (!str_cmp(field, "val3"))
	sprintf(str, "%d", GET_OBJ_VAL(o, 3));
      
      else {
	*str = '\0';
	sprintf(buf2,
		"Trigger: %s, VNum %d, type: %d. unknown object field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
	script_log(buf2);
      }
    }

    else if (r) {
      if (text_processed(field, vd, str)) return;

      else if (!str_cmp(field, "name"))
	strcpy(str, r->name);
      else if (!str_cmp(field, "north")) {
	if (r->dir_option[NORTH])
	  sprintbit(r->dir_option[NORTH]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "east")) {
	if (r->dir_option[EAST])
	  sprintbit(r->dir_option[EAST]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "south")) {
	if (r->dir_option[SOUTH])
	  sprintbit(r->dir_option[SOUTH]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "west")) {
	if (r->dir_option[WEST])
	  sprintbit(r->dir_option[WEST]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "up")) {
	if (r->dir_option[UP])
	  sprintbit(r->dir_option[UP]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "down")) {
	if (r->dir_option[DOWN])
	  sprintbit(r->dir_option[DOWN]->exit_info ,exit_bits, str);
	else
	  *str = '\0';
      } else if (!str_cmp(field, "vnum")) {
          sprintf(str,"%d",r->number); 
      } else {
	*str = '\0';
	sprintf(buf2,
		"Trigger: %s, VNum %d, type: %d. unknown room field: '%s'",
		GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), type, field);
	script_log(buf2);
      }
    }

    else
      *str = '\0';
  }
}


/* substitutes any variables into line and returns it as buf */
void var_subst(void *go, struct script_data *sc, trig_data *trig,
	       int type, char *line, char *buf)
{
  char tmp[MAX_INPUT_LENGTH], repl_str[MAX_INPUT_LENGTH], *var, *field, *p;
  char *subfield_p, subfield[MAX_INPUT_LENGTH];
  int left, len;
  int paren_count = 0;

  if (!strchr(line, '%')) {
    strcpy(buf, line);
    return;
  }
  
  p = strcpy(tmp, line);
  subfield_p = subfield;
  
  left = MAX_INPUT_LENGTH - 1;
  
  while (*p && (left > 0)) {

    while (*p && (*p != '%') && (left > 0)) {
      *(buf++) = *(p++);
      left--;
    }
    
    *buf = '\0';
    
    /* double % */
    if (*p && (*(++p) == '%') && (left > 0)) {
      *(buf++) = *(p++);
      *buf = '\0';
      left--;
      continue;
    }

    else if (*p && (left > 0)) {
      
      for (var = p; *p && (*p != '%') && (*p != '.'); p++);

      field = p;
      if (*p == '.') {
	*(p++) = '\0';
	for (field = p; *p && ((*p != '%')||(paren_count)); p++) {
          if (*p=='(') {
            *p = '\0';
            paren_count++;
          } else if (*p==')') {
            *p = '\0';
            paren_count--;
          } else if (paren_count) *subfield_p++ = *p;
        }
      }

      *(p++) = '\0';
      *subfield_p = '\0';

      find_replacement(go, sc, trig, type, var, field, subfield, repl_str);
      
      strncat(buf, repl_str, left);
      len = strlen(repl_str);
      buf += len;
      left -= len;
    }
  }  
}


/* returns 1 if string is all digits, else 0 */
int is_num(char *num)
{
  while (*num && (isdigit(*num) || *num=='-'))
    num++;

  if (!*num || isspace(*num))
    return 1;
  else
    return 0;
}


/* evaluates 'lhs op rhs', and copies to result */
void eval_op(char *op, char *lhs, char *rhs, char *result, void *go,
	     struct script_data *sc, trig_data *trig)
{
  char *p;
  int n;

  /* strip off extra spaces at begin and end */
  while (*lhs && isspace(*lhs)) 
    lhs++;
  while (*rhs && isspace(*rhs))
    rhs++;
  
  for (p = lhs; *p; p++);
  for (--p; isspace(*p) && (p > lhs); *p-- = '\0');
  for (p = rhs; *p; p++);
  for (--p; isspace(*p) && (p > rhs); *p-- = '\0');  


  /* find the op, and figure out the value */
  if (!strcmp("||", op)) {
    if ((!*lhs || (*lhs == '0')) && (!*rhs || (*rhs == '0')))
      strcpy(result, "0");
    else
      strcpy(result, "1");
  }

  else if (!strcmp("&&", op)) {
    if (!*lhs || (*lhs == '0') || !*rhs || (*rhs == '0'))
      strcpy (result, "0");
    else
      strcpy (result, "1");
  }

  else if (!strcmp("==", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) == atoi(rhs));
    else
      sprintf(result, "%d", !str_cmp(lhs, rhs));
  }   

  else if (!strcmp("!=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) != atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs));
  }   

  else if (!strcmp("<=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) <= atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) <= 0);
  }

  else if (!strcmp(">=", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) >= atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) <= 0);
  }

  else if (!strcmp("<", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) < atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) < 0);
  }

  else if (!strcmp(">", op)) {
    if (is_num(lhs) && is_num(rhs))
      sprintf(result, "%d", atoi(lhs) > atoi(rhs));
    else
      sprintf(result, "%d", str_cmp(lhs, rhs) > 0);
  }

  else if (!strcmp("/=", op))
    sprintf(result, "%c", str_str(lhs, rhs) ? '1' : '0');

  else if (!strcmp("*", op))
    sprintf(result, "%d", atoi(lhs) * atoi(rhs));
  
  else if (!strcmp("/", op))
    sprintf(result, "%d", (n = atoi(rhs)) ? (atoi(lhs) / n) : 0);

  else if (!strcmp("+", op)) 
    sprintf(result, "%d", atoi(lhs) + atoi(rhs));

  else if (!strcmp("-", op))
    sprintf(result, "%d", atoi(lhs) - atoi(rhs));

  else if (!strcmp("!", op)) {
    if (is_num(rhs))
      sprintf(result, "%d", !atoi(rhs));
    else
      sprintf(result, "%d", !*rhs);
  }
}


/*
 * p points to the first quote, returns the matching
 * end quote, or the last non-null char in p.
*/
char *matching_quote(char *p)
{
  for (p++; *p && (*p != '"'); p++) {
    if (*p == '\\')
      p++;
  }

  if (!*p)
    p--;

  return p;
}

/*
 * p points to the first paren.  returns a pointer to the
 * matching closing paren, or the last non-null char in p.
 */
char *matching_paren(char *p)
{
  int i;

  for (p++, i = 1; *p && i; p++) {
    if (*p == '(')
      i++;
    else if (*p == ')')
      i--;
    else if (*p == '"')
      p = matching_quote(p);
  }

  return --p;
}


/* evaluates line, and returns answer in result */
void eval_expr(char *line, char *result, void *go, struct script_data *sc,
	       trig_data *trig, int type)
{
  char expr[MAX_INPUT_LENGTH], *p;

  while (*line && isspace(*line))
    line++;
  
  if (eval_lhs_op_rhs(line, result, go, sc, trig, type));

  else if (*line == '(') {
    p = strcpy(expr, line);
    p = matching_paren(expr);
    *p = '\0';
    eval_expr(expr + 1, result, go, sc, trig, type);
  }

  else
    var_subst(go, sc, trig, type, line, result);
}


/*
 * evaluates expr if it is in the form lhs op rhs, and copies
 * answer in result.  returns 1 if expr is evaluated, else 0
 */
int eval_lhs_op_rhs(char *expr, char *result, void *go, struct script_data *sc,
		    trig_data *trig, int type)
{
  char *p, *tokens[MAX_INPUT_LENGTH];
  char line[MAX_INPUT_LENGTH], lhr[MAX_INPUT_LENGTH], rhr[MAX_INPUT_LENGTH];
  int i, j;
  
  /*
   * valid operands, in order of priority
   * each must also be defined in eval_op()
   */
  static char *ops[] = {
    "||",
    "&&",
    "==",
    "!=",
    "<=",
    ">=",
    "<",
    ">",
    "/=",
    "-",
    "+",
    "/",
    "*",
    "!",
    "\n"
  };

  p = strcpy(line, expr);

  /*
   * initialize tokens, an array of pointers to locations
   * in line where the ops could possibly occur.
   */
  for (j = 0; *p; j++) {
    tokens[j] = p;
    if (*p == '(')
      p = matching_paren(p) + 1;
    else if (*p == '"')
      p = matching_quote(p) + 1;
    else if (isalnum(*p))
      for (p++; *p && (isalnum(*p) || isspace(*p)); p++);
    else
      p++;
  }
  tokens[j] = NULL;

  for (i = 0; *ops[i] != '\n'; i++)
    for (j = 0; tokens[j]; j++)
      if (!strn_cmp(ops[i], tokens[j], strlen(ops[i]))) {
	*tokens[j] = '\0';
	p = tokens[j] + strlen(ops[i]);

	eval_expr(line, lhr, go, sc, trig, type);
	eval_expr(p, rhr, go, sc, trig, type);
	eval_op(ops[i], lhr, rhr, result, go, sc, trig);

	return 1;
      }

  return 0;
}



/* returns 1 if cond is true, else 0 */
int process_if(char *cond, void *go, struct script_data *sc,
	       trig_data *trig, int type)
{
  char result[MAX_INPUT_LENGTH], *p;

  eval_expr(cond, result, go, sc, trig, type);
  
  p = result;
  skip_spaces(&p);

  if (!*p || *p == '0')
    return 0;
  else
    return 1;
}


/*
 * scans for end of if-block.
 * returns the line containg 'end', or the last
 * line of the trigger if not found.
 */
struct cmdlist_element *find_end(struct cmdlist_element *cl)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("if ", p, 3))
      c = find_end(c);
    else if (!strn_cmp("end", p, 3))
      return c;
  }
  
  return c;
}


/*
 * searches for valid elseif, else, or end to continue execution at.
 * returns line of elseif, else, or end if found, or last line of trigger.
 */
struct cmdlist_element *find_else_end(trig_data *trig,
				      struct cmdlist_element *cl, void *go,
				      struct script_data *sc, int type)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("if ", p, 3))
      c = find_end(c);

    else if (!strn_cmp("elseif ", p, 7)) {
      if (process_if(p + 7, go, sc, trig, type)) {
	GET_TRIG_DEPTH(trig)++;
	return c;
      }
    }
    
    else if (!strn_cmp("else", p, 4)) {
      GET_TRIG_DEPTH(trig)++;
      return c;
    }

    else if (!strn_cmp("end", p, 3))
      return c;
  }

  return c;
}


/* processes any 'wait' commands in a trigger */
void process_wait(void *go, trig_data *trig, int type, char *cmd,
		  struct cmdlist_element *cl)
{
  char buf[MAX_INPUT_LENGTH], *arg;
  struct wait_event_data *wait_event_obj;
  long time, hr, min, ntime;
  char c;

  extern struct time_info_data time_info;
  extern long dg_global_pulse;


  arg = any_one_arg(cmd, buf);
  skip_spaces(&arg);
  
  if (!*arg) {
    sprintf(buf2, "Trigger: %s, VNum %d. wait w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cl->cmd);
    script_log(buf2);
  }

  else if (!strn_cmp(arg, "until ", 6)) {

    /* valid forms of time are 14:30 and 1430 */
    if (sscanf(arg, "until %ld:%ld", &hr, &min) == 2)
      min += (hr * 60);
    else
      min = (hr % 100) + ((hr / 100) * 60);

    /* calculate the pulse of the day of "until" time */
    ntime = (min * SECS_PER_MUD_HOUR * PASSES_PER_SEC) / 60;

    /* calculate pulse of day of current time */
    time = (dg_global_pulse % (SECS_PER_MUD_HOUR * PASSES_PER_SEC)) +
      (time_info.hours * SECS_PER_MUD_HOUR * PASSES_PER_SEC);
    
    if (time >= ntime) /* adjust for next day */
      time = (SECS_PER_MUD_DAY * PASSES_PER_SEC) - time + ntime;
    else
      time = ntime - time;
  }

  else {
    if (sscanf(arg, "%ld %c", &time, &c) == 2) {
      if (c == 't')
	time *= PULSES_PER_MUD_HOUR;
      else if (c == 's')
	time *= PASSES_PER_SEC;
    }
  }

  CREATE(wait_event_obj, struct wait_event_data, 1);
  wait_event_obj->trigger = trig;
  wait_event_obj->go = go;
  wait_event_obj->type = type;

  GET_TRIG_WAIT(trig) = add_event(time, trig_wait_event, wait_event_obj);
  trig->curr_state = cl->next;
}


/* processes a script set command */
void process_set(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH], *value;
  
  value = two_arguments(cmd, arg, name);

  skip_spaces(&value);

  if (!*name) {
    sprintf(buf2, "Trigger: %s, VNum %d. set w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  add_var(&GET_TRIG_VARS(trig), name, value, sc->context);

}

/* processes a script eval command */
void process_eval(void *go, struct script_data *sc, trig_data *trig,
		 int type, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], name[MAX_INPUT_LENGTH];
  char result[MAX_INPUT_LENGTH], *expr;
  
  expr = two_arguments(cmd, arg, name);

  skip_spaces(&expr);

  if (!*name) {
    sprintf(buf2, "Trigger: %s, VNum %d. eval w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  eval_expr(expr, result, go, sc, trig, type);
  add_var(&GET_TRIG_VARS(trig), name, result, sc->context);
}


/* create a UID variable from the id number */
void makeuid_var(void *go, struct script_data *sc, trig_data *trig,
		 int type, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], varname[MAX_INPUT_LENGTH];
  char result[MAX_INPUT_LENGTH], *uid_p;
  char uid[MAX_INPUT_LENGTH];
  
  uid_p = two_arguments(cmd, arg, varname);
  skip_spaces(&uid_p);

  if (!*varname) {
    sprintf(buf2, "Trigger: %s, VNum %d. makeuid w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  if (!uid_p || !*uid_p || atoi(uid_p)==0) {
    sprintf(buf2, "Trigger: %s, VNum %d. makeuid invalid id arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  eval_expr(uid_p, result, go, sc, trig, type);
  sprintf(uid,"%c%s",UID_CHAR, result);
  add_var(&GET_TRIG_VARS(trig), varname, uid, sc->context);
}

/*
 * processes a script return command.
 * returns the new value for the script to return.
 */
int process_return(trig_data *trig, char *cmd)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  
  two_arguments(cmd, arg1, arg2);
  
  if (!*arg2) {
    sprintf(buf2, "Trigger: %s, VNum %d. return w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return 1;
  }

  return atoi(arg2);
}


/*
 * removes a variable from the global vars of sc,
 * or the local vars of trig if not found in global list.
 */
void process_unset(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], *var;

  var = any_one_arg(cmd, arg);

  skip_spaces(&var);

  if (!*var) {
    sprintf(buf2, "Trigger: %s, VNum %d. unset w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  if (!remove_var(&(sc->global_vars), var))
    remove_var(&GET_TRIG_VARS(trig), var);
}


/*
 * copy a locally owned variable to the globals of another script
 *     'remote <variable_name> <uid>'
 */
void process_remote(struct script_data *sc, trig_data *trig, char *cmd)
{
  struct trig_var_data *vd;
  struct script_data *sc_remote=NULL;
  char *line, *var, *uid_p;
  char arg[MAX_INPUT_LENGTH];
  long uid;
  room_data *room;
  char_data *mob;
  obj_data *obj;

  line = any_one_arg(cmd, arg);
  two_arguments(line, buf, buf2);
  var = buf;
  uid_p = buf2;
  skip_spaces(&var);
  skip_spaces(&uid_p);
  

  if (!*buf || !*buf2) {
    sprintf(buf2, "Trigger: %s, VNum %d. remote: invalid arguments '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  /* find the locally owned variable */
  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, buf))
      break;

  if (!vd)
    for (vd = sc->global_vars; vd; vd = vd->next)
      if (!str_cmp(vd->name, var) &&
          (vd->context==0 || vd->context==sc->context))
	break; 

  if (!vd) {
    sprintf(buf2, "Trigger: %s, VNum %d. local var '%s' not found in remote call",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), buf);
    script_log(buf2);
    return;
  }    

  /* find the target script from the uid number */
  uid = atoi(buf2);
  if (uid<=0) {
    sprintf(buf, "Trigger: %s, VNum %d. remote: illegal uid '%s'",
            GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), buf2);
    script_log(buf2);
    return;
  } else if (uid<ROOM_ID_BASE) {
    sprintf(buf, "Trigger: %s, VNum %d. remote: uid '%ld' is a PC?",
            GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), uid);
    script_log(buf2);
    return;
  }

  if ((room = find_room(uid))) {
    sc_remote = SCRIPT(room);
  } else if ((mob = find_char(uid))) {
    sc_remote = SCRIPT(mob);
  } else if ((obj = find_obj(uid))) {
    sc_remote = SCRIPT(obj);
  } else {
    sprintf(buf, "Trigger: %s, VNum %d. remote: uid '%ld' invalid",
            GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), uid);
    script_log(buf2);
    return;
  }

  if (sc_remote==NULL) return; /* no script to assign */

  add_var(&(sc_remote->global_vars), vd->name, vd->value, vd->context);
}

/*
 * makes a local variable into a global variable
 */
void process_global(struct script_data *sc, trig_data *trig, char *cmd, long id)
{
  struct trig_var_data *vd;
  char arg[MAX_INPUT_LENGTH], *var;

  var = any_one_arg(cmd, arg);

  skip_spaces(&var);

  if (!*var) {
    sprintf(buf2, "Trigger: %s, VNum %d. global w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  for (vd = GET_TRIG_VARS(trig); vd; vd = vd->next)
    if (!str_cmp(vd->name, var))
      break;

  if (!vd) {
    sprintf(buf2, "Trigger: %s, VNum %d. local var '%s' not found in global call",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), var);
    script_log(buf2);
    return;
  }    

  add_var(&(sc->global_vars), vd->name, vd->value, id);
  remove_var(&GET_TRIG_VARS(trig), vd->name);
}


/* set the current context for a script */
void process_context(struct script_data *sc, trig_data *trig, char *cmd)
{
  char arg[MAX_INPUT_LENGTH], *var;
  
  var = any_one_arg(cmd, arg);

  skip_spaces(&var);

  if (!*var) {
    sprintf(buf2, "Trigger: %s, VNum %d. context w/o an arg: '%s'",
	    GET_TRIG_NAME(trig), GET_TRIG_VNUM(trig), cmd);
    script_log(buf2);
    return;
  }

  sc->context = atol(var);
}

void extract_value(struct script_data *sc, trig_data *trig, char *cmd)
{
  char buf[MAX_INPUT_LENGTH];
  char buf2[MAX_INPUT_LENGTH];
  char *buf3;
  char to[128];
  int num;

  buf3 = any_one_arg(cmd, buf);
  half_chop(buf3, buf2, buf);
  strcpy(to, buf2);

  num = atoi(buf);
  if (num < 1) {
    script_log("extract number < 1!");
    return;
  }

  half_chop(buf, buf3, buf2);

  while (num>0) {
    half_chop(buf2, buf, buf2);
    num--;
  }

  add_var(&GET_TRIG_VARS(trig), to, buf, sc->context);
}

int dg_owner_purged;

/*  This is the core driver for scripts. */
int script_driver(void *go, trig_data *trig, int type, int mode)
{
  static int depth = 0;
  int ret_val = 1;
  struct cmdlist_element *cl;
  char cmd[MAX_INPUT_LENGTH], *p;
  struct script_data *sc = 0;
  struct cmdlist_element *temp;
  unsigned long loops = 0;


  void obj_command_interpreter(obj_data *obj, char *argument);
  void wld_command_interpreter(struct room_data *room, char *argument);

  if (depth > MAX_SCRIPT_DEPTH) {
    script_log("Triggers recursed beyond maximum allowed depth.");
    return ret_val;
  }

  depth++;

  switch (type) {
  case MOB_TRIGGER:
    sc = SCRIPT((char_data *) go);
    break;
  case OBJ_TRIGGER:
    sc = SCRIPT((obj_data *) go);
    break;
  case WLD_TRIGGER:
    sc = SCRIPT((struct room_data *) go);
    break;
  }

  if (mode == TRIG_NEW) {
    GET_TRIG_DEPTH(trig) = 1;
    GET_TRIG_LOOPS(trig) = 0;
    sc->context = 0;
  }

  dg_owner_purged = 0;
  
  for (cl = (mode == TRIG_NEW) ? trig->cmdlist : trig->curr_state;
       cl && GET_TRIG_DEPTH(trig); cl = cl->next) {
    for (p = cl->cmd; *p && isspace(*p); p++);

    if (*p == '*') /* comment */
      continue;

    else if (!strn_cmp(p, "if ", 3)) {
      if (process_if(p + 3, go, sc, trig, type))
	GET_TRIG_DEPTH(trig)++;
      else
	cl = find_else_end(trig, cl, go, sc, type);
    }
    
    else if (!strn_cmp("elseif ", p, 7) ||
	     !strn_cmp("else", p, 4)) {
      cl = find_end(cl);
      GET_TRIG_DEPTH(trig)--;
    } else if (!strn_cmp("while ", p, 6)) {
      temp = find_done(cl);  
      if (process_if(p + 6, go, sc, trig, type)) {
         temp->original = cl;
      } else {
         cl = temp;
         loops = 0;
      }
    } else if (!strn_cmp("switch ", p, 7)) {
      cl = find_case(trig, cl, go, sc, type, p + 7);
    } else if (!strn_cmp("end", p, 3)) {   
      GET_TRIG_DEPTH(trig)--;
    } else if (!strn_cmp("done", p, 4)) {
      if (cl->original && process_if(cl->original->cmd + 6, go, sc, trig,
          type)) {
        cl = cl->original;
        loops++;   
        GET_TRIG_LOOPS(trig)++;
        if (loops == 30) {
          process_wait(go, trig, type, "wait 1", cl);
           depth--;
          return ret_val;
        }
        if (GET_TRIG_LOOPS(trig) == 100) {
          sprintf(buf2, "SCRIPTERR: Trigger VNum %d has looped 100 times!!!",
            GET_TRIG_VNUM(trig));
          mudlog(buf2, NRM, LVL_GOD, TRUE);

        }
      }
    } else if (!strn_cmp("break", p, 5)) {
      cl = find_done(cl);
    } else if (!strn_cmp("case", p, 4)) { 
       /* Do nothing, this allows multiple cases to a single instance */
    }
    
      
    else {
      
      var_subst(go, sc, trig, type, p, cmd);

      if (!strn_cmp(cmd, "eval ", 5))
	process_eval(go, sc, trig, type, cmd);

      else if (!strn_cmp(cmd, "extract ", 8))
        extract_value(sc, trig, cmd);

      else if (!strn_cmp(cmd, "makeuid ", 8))
	makeuid_var(go, sc, trig, type, cmd);

      else if (!strn_cmp(cmd, "halt", 4))
	break;

      else if (!strn_cmp(cmd, "global ", 7))
	process_global(sc, trig, cmd, sc->context);

      else if (!strn_cmp(cmd, "context ", 8))
	process_context(sc, trig, cmd);

      else if (!strn_cmp(cmd, "remote ", 7))
	process_remote(sc, trig, cmd);

      else if (!strn_cmp(cmd, "return ", 7))
	ret_val = process_return(trig, cmd);
      
      else if (!strn_cmp(cmd, "set ", 4))
	process_set(sc, trig, cmd);
      
      else if (!strn_cmp(cmd, "unset ", 6))
	process_unset(sc, trig, cmd);
      
      else if (!strn_cmp(cmd, "wait ", 5)) {
	process_wait(go, trig, type, cmd, cl);
	depth--;
	return ret_val;
      }

      else if (!strn_cmp(cmd, "version", 7))
        mudlog(DG_SCRIPT_VERSION, NRM, LVL_GOD, TRUE);
      
      else {
	switch (type) {
	case MOB_TRIGGER:
	  command_interpreter((char_data *) go, cmd);
	  break;
	case OBJ_TRIGGER:
	  obj_command_interpreter((obj_data *) go, cmd);
	  break;
	case WLD_TRIGGER:
	  wld_command_interpreter((struct room_data *) go, cmd);
	  break;
	}
        if (dg_owner_purged) return ret_val;
      }

    }
  }

  free_varlist(GET_TRIG_VARS(trig));
  GET_TRIG_VARS(trig) = NULL;
  GET_TRIG_DEPTH(trig) = 0;

  depth--;
  return ret_val;
}

ACMD(do_tlist)
{

  int first, last, nr, found = 0;
  char pagebuf[65536];

  strcpy(pagebuf,"");

  two_arguments(argument, buf, buf2);

  if (!*buf) {
    send_to_char("Usage: tlist <begining number or zone> [<ending number>]\r\n", ch);
    return;
  }

  first = atoi(buf);
  if (*buf2) last = atoi(buf2);
  else {
    first *= 100;
    last = first+99;
  }

  if ((first < 0) || (first > 99999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }

  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }

  for (nr = 0; nr < top_of_trigt && (trig_index[nr]->vnum <= last); nr++)
  {
    if (trig_index[nr]->vnum >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
              trig_index[nr]->vnum,
              trig_index[nr]->proto->name);
      strcat(pagebuf, buf);
    }
  }

  if (!found)
    send_to_char("No triggers were found in those parameters.\n\r", ch);
  else page_string(ch->desc, pagebuf, TRUE);
}

int real_trigger(int vnum)
{
  int rnum;

  for (rnum=0; rnum < top_of_trigt; rnum++)
  {
    if (trig_index[rnum]->vnum==vnum) break;
  }

  if (rnum==top_of_trigt) rnum = -1;
  return (rnum);
}

ACMD(do_tstat)
{
  int vnum, rnum;
  char str[MAX_INPUT_LENGTH];

  half_chop(argument, str, argument);
  if (*str) {
    vnum = atoi(str);
    rnum = real_trigger(vnum);
    if (rnum<0) {
      send_to_char("That vnum does not exist.\r\n", ch);
      return;
    }

    do_stat_trigger(ch, trig_index[rnum]->proto);
  } else send_to_char("Usage: tstat <vnum>\r\n", ch);
}

/*
* scans for a case/default instance
* returns the line containg the correct case instance, or the last
* line of the trigger if not found.
*/
struct cmdlist_element *
find_case(struct trig_data *trig, struct cmdlist_element *cl,
          void *go, struct script_data *sc, int type, char *cond)
{
  struct cmdlist_element *c;
  char *p;

  if (!(cl->next))
    return cl;  
        
  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);
      
    if (!strn_cmp("while ", p, 6) || !strn_cmp("switch", p, 6))
      c = find_done(c);
    else if (!strn_cmp("case ", p, 5)) {
      sprintf(buf2, "(%s) == (%s)", cond, p + 5);
      if (process_if(buf2, go, sc, trig, type)) {
        return c;
      }
    } else if (!strn_cmp("default", p, 7))
      return c;
    else if (!strn_cmp("done", p, 3))   
     return c;
  }
  return c;
}        
       
/*
* scans for end of while/switch-blocks.   
* returns the line containg 'end', or the last
* line of the trigger if not found.     
*/
struct cmdlist_element *
find_done(struct cmdlist_element *cl)
{
  struct cmdlist_element *c;
  char *p;
  
  if (!(cl->next))
    return cl;

  for (c = cl->next; c->next; c = c->next) {
    for (p = c->cmd; *p && isspace(*p); p++);

    if (!strn_cmp("while ", p, 6) || !strn_cmp("switch ", p, 7))
      c = find_done(c);
    else if (!strn_cmp("done", p, 3))
      return c;
  }
    
  return c;
}
::::::::::::::
dg_triggers.c
::::::::::::::
/**************************************************************************
*  File: triggers.c                                                       *
*                                                                         *
*  Usage: contains all the trigger functions for scripts.                 *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Death's Gate MUD is based on CircleMUD, Copyright (C) 1993, 94.        *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/05 23:32:08 $
*  $Revision: 3.9 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "olc.h"

extern struct index_data **trig_index;
extern struct room_data *world;
extern char *dirs[];

#ifndef LVL_BUILDER
#define LVL_BUILDER LVL_GOD
#endif


/* external functions from scripts.c */
void add_var(struct trig_var_data **var_list, char *name, char *value, long id);
int script_driver(void *go, trig_data *trig, int type, int mode);
char *matching_quote(char *p);
char *str_str(char *cs, char *ct);


/* mob trigger types */
char *trig_types[] = {
  "Global", 
  "Random",
  "Command",
  "Speech",
  "Act",
  "Death",
  "Greet",
  "Greet-All",
  "Entry",
  "Receive",
  "Fight",
  "HitPrcnt",
  "Bribe",
  "Load",
  "Memory",
  "\n"
};


/* obj trigger types */
char *otrig_types[] = {
  "Global",
  "Random",
  "Command",
  "UNUSED",
  "UNUSED",
  "Timer",
  "Get",
  "Drop",
  "Give",
  "Wear",
  "UNUSED",
  "Remove",
  "UNUSED",
  "Load",
  "UNUSED",
  "\n"
};


/* wld trigger types */
char *wtrig_types[] = {
  "Global",
  "Random",
  "Command",
  "Speech",
  "UNUSED",
  "Zone Reset",
  "Enter",
  "Drop",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "UNUSED",
  "\n"
};


/*
 *  General functions used by several triggers
 */


/*
 * Copy first phrase into first_arg, returns rest of string
 */
char *one_phrase(char *arg, char *first_arg)
{
    skip_spaces(&arg);

    if (!*arg)
	*first_arg = '\0';

    else if (*arg == '"')
    {
	char *p, c;

	p = matching_quote(arg);
	c = *p;
	*p = '\0';
	strcpy(first_arg, arg + 1);
	if (c == '\0')
	    return p;
	else
	    return p + 1;
    }

    else
    {
	char *s, *p;

	s = first_arg;
	p = arg;
	
	while (*p && !isspace(*p) && *p != '"')
	    *s++ = *p++;

	*s = '\0';
	return p;
    }

    return arg;
}


int is_substring(char *sub, char *string)
{
    char *s;

    if ((s = str_str(string, sub)))
    {
	int len = strlen(string);
	int sublen = strlen(sub);
	
	/* check front */
	if ((s == string || isspace(*(s - 1)) || ispunct(*(s - 1))) &&

	    /* check end */
	    ((s + sublen == string + len) || isspace(s[sublen]) ||
	     ispunct(s[sublen])))
	    return 1;
    }

    return 0;
}


/*
 * return 1 if str contains a word or phrase from wordlist.
 * phrases are in double quotes (").
 * if wrdlist is NULL, then return 1, if str is NULL, return 0.
 */
int word_check(char *str, char *wordlist)
{
    char words[MAX_INPUT_LENGTH], phrase[MAX_INPUT_LENGTH], *s;

    if (*wordlist=='*') return 1;

    strcpy(words, wordlist);
    
    for (s = one_phrase(words, phrase); *phrase; s = one_phrase(s, phrase))
	if (is_substring(phrase, str))
	    return 1;

    return 0;
}

	

/*
 *  mob triggers
 */

void random_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_RANDOM) || AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RANDOM) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void bribe_mtrigger(char_data *ch, char_data *actor, int amount)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_BRIBE) || AFF_FLAGGED(ch, AFF_CHARM))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_BRIBE) && (amount >= GET_TRIG_NARG(t))) {

      sprintf(buf, "%d", amount);
      add_var(&GET_TRIG_VARS(t), "amount", buf, 0);
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void greet_memory_mtrigger(char_data *actor)
{
  trig_data *t;
  char_data *ch;
  struct script_memory *mem;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!SCRIPT_CHECK(ch, MTRIG_MEMORY) ||
        !SCRIPT_MEM(ch) ||
	!AWAKE(ch) || FIGHTING(ch) || (ch == actor) || 
	AFF_FLAGGED(ch, AFF_CHARM))
      continue;

    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (IS_SET(GET_TRIG_TYPE(t), MTRIG_MEMORY) &&
          CAN_SEE(ch, actor) &&
          !GET_TRIG_DEPTH(t) &&
          number(1, 100) <= GET_TRIG_NARG(t)) {
        for (mem = SCRIPT_MEM(ch); mem && SCRIPT_MEM(ch); mem=mem->next) {
          if (GET_ID(actor)!=mem->id) continue;
          if (mem->cmd) command_interpreter(ch, mem->cmd);
          else {
            ADD_UID_VAR(buf, t, actor, "actor", 0);
            script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
          }
          /* delete the memory */
          if (SCRIPT_MEM(ch)==mem) {
            SCRIPT_MEM(ch) = mem->next;
          } else {
            struct script_memory *prev;
            prev = SCRIPT_MEM(ch);
            while (prev->next != mem) prev = prev->next;
            prev->next = mem->next;
          }
          if (mem->cmd) free(mem->cmd);
          free(mem);
        }
      }
    }
  }
}


int greet_mtrigger(char_data *actor, int dir)
{
  trig_data *t;
  char_data *ch;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };
  int intermediate, final=TRUE;
 
  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch->next_in_room) {
    if (!SCRIPT_CHECK(ch, MTRIG_GREET | MTRIG_GREET_ALL) || 
	!AWAKE(ch) || FIGHTING(ch) || (ch == actor) || 
	AFF_FLAGGED(ch, AFF_CHARM))
      continue;
    
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
      if (((IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET) && CAN_SEE(ch, actor)) ||
	   IS_SET(GET_TRIG_TYPE(t), MTRIG_GREET_ALL)) && 
	  !GET_TRIG_DEPTH(t) && (number(1, 100) <= GET_TRIG_NARG(t))) {
        add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]], 0);
	ADD_UID_VAR(buf, t, actor, "actor", 0);
	intermediate =  script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
        if (!intermediate) final = FALSE;
	continue;
      }
    }
  }
  return final;
}


void entry_memory_mtrigger(char_data *ch)
{
  trig_data *t;
  char_data *actor;
  struct script_memory *mem;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_MEMORY) || AFF_FLAGGED(ch, AFF_CHARM))
    return;
  if (!SCRIPT_MEM(ch))
    return;


  for (actor = world[IN_ROOM(ch)].people; actor && SCRIPT_MEM(ch);
       actor = actor->next_in_room) {
    if (actor!=ch && SCRIPT_MEM(ch)) {
      for (mem = SCRIPT_MEM(ch); mem && SCRIPT_MEM(ch); mem = mem->next) {
        if (GET_ID(actor)==mem->id) {
          struct script_memory *prev;
          if (mem->cmd) command_interpreter(ch, mem->cmd);
          else {
            for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
              if (TRIGGER_CHECK(t, MTRIG_MEMORY) && (number(1, 100) <=
                  GET_TRIG_NARG(t))){
                ADD_UID_VAR(buf, t, actor, "actor", 0);
                script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
                break;
              }
            }
          }
          /* delete the memory */
          if (SCRIPT_MEM(ch)==mem) {
            SCRIPT_MEM(ch) = mem->next;
          } else {
            prev = SCRIPT_MEM(ch);
            while (prev->next != mem) prev = prev->next;
            prev->next = mem->next;
          }
          if (mem->cmd) free(mem->cmd);
          free(mem);
        }
      } /* for (mem =..... */
    }
  }
}

int entry_mtrigger(char_data *ch)
{
  trig_data *t;
  
  if (!SCRIPT_CHECK(ch, MTRIG_ENTRY) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_ENTRY) && (number(1, 100) <= GET_TRIG_NARG(t))){
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }

  return 1;
}

int command_mtrigger(char_data *actor, char *cmd, char *argument)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next) {
    ch_next = ch->next_in_room;

    if (SCRIPT_CHECK(ch, MTRIG_COMMAND) && !AFF_FLAGGED(ch, AFF_CHARM) &&
        (actor!=ch)) {
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_COMMAND))
          continue;
        
        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Command Trigger #%d has no text argument!",
            GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
          continue;
        }

        if (*GET_TRIG_ARG(t)=='*' ||
            !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(GET_TRIG_ARG(t)))) {
	  ADD_UID_VAR(buf, t, actor, "actor", 0);
	  skip_spaces(&argument);
	  add_var(&GET_TRIG_VARS(t), "arg", argument, 0);
	  skip_spaces(&cmd);
	  add_var(&GET_TRIG_VARS(t), "cmd", cmd, 0);
	  
	  if (script_driver(ch, t, MOB_TRIGGER, TRIG_NEW))
	    return 1;
	}
      }
    }
  }

  return 0;
}
  

void speech_mtrigger(char_data *actor, char *str)
{
  char_data *ch, *ch_next;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  for (ch = world[IN_ROOM(actor)].people; ch; ch = ch_next)
  {
    ch_next = ch->next_in_room;

    if (SCRIPT_CHECK(ch, MTRIG_SPEECH) && AWAKE(ch) &&
        !AFF_FLAGGED(ch, AFF_CHARM) && (actor!=ch))
      for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
        if (!TRIGGER_CHECK(t, MTRIG_SPEECH))
          continue;

        if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
          sprintf(buf,"SYSERR: Speech Trigger #%d has no text argument!",
            GET_TRIG_VNUM(t));
          mudlog(buf, NRM, LVL_BUILDER, TRUE);
          continue;
        }

        if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
             (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
          ADD_UID_VAR(buf, t, actor, "actor", 0);
          add_var(&GET_TRIG_VARS(t), "speech", str, 0);
          script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
          break;
        }
      }
  }
}


void act_mtrigger(char_data *ch, char *str, char_data *actor, 
		  char_data *victim, obj_data *object,
		  obj_data *target, char *arg)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (SCRIPT_CHECK(ch, MTRIG_ACT) && !AFF_FLAGGED(ch, AFF_CHARM) &&
      (actor!=ch))
    for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next)  {
      if (!TRIGGER_CHECK(t, MTRIG_ACT))
        continue;

      if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
        sprintf(buf,"SYSERR: Act Trigger #%d has no text argument!",
          GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
        continue;
      }

      if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
           (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
	
	if (actor)
	  ADD_UID_VAR(buf, t, actor, "actor", 0);
	if (victim)
	  ADD_UID_VAR(buf, t, victim, "victim", 0);
	if (object)
	  ADD_UID_VAR(buf, t, object, "object", 0);
	if (target)
	  ADD_UID_VAR(buf, t, target, "target", 0);
	if (arg) {
	  skip_spaces(&arg);
	  add_var(&GET_TRIG_VARS(t), "arg", arg, 0);
	}	  
	script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
	break;
      }	
    }
}


void fight_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_FIGHT) || !FIGHTING(ch) || 
      AFF_FLAGGED(ch, AFF_CHARM))
    return;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_FIGHT) &&
	(number(1, 100) <= GET_TRIG_NARG(t))){

      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor", 0)
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


void hitprcnt_mtrigger(char_data *ch)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if(!ch)
    return;

  if (!SCRIPT_CHECK(ch, MTRIG_HITPRCNT) || !FIGHTING(ch) ||
      AFF_FLAGGED(ch, AFF_CHARM))
    return;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_HITPRCNT) && GET_MAX_HIT(ch) &&
	(((GET_HIT(ch) * 100) / GET_MAX_HIT(ch)) <= GET_TRIG_NARG(t))) {

      ADD_UID_VAR(buf, t, FIGHTING(ch), "actor", 0)
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int receive_mtrigger(char_data *ch, char_data *actor, obj_data *obj)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(ch, MTRIG_RECEIVE) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_RECEIVE) &&
	(number(1, 100) <= GET_TRIG_NARG(t))){

      ADD_UID_VAR(buf, t, actor, "actor", 0);
      ADD_UID_VAR(buf, t, obj, "object", 0);
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int death_mtrigger(char_data *ch, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (!SCRIPT_CHECK(ch, MTRIG_DEATH) || AFF_FLAGGED(ch, AFF_CHARM))
    return 1;
  
  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_DEATH)) {

      if (actor)
	ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

void load_mtrigger(char_data *ch)
{
  trig_data *t;

  if (!SCRIPT_CHECK(ch, MTRIG_LOAD))
    return;

  for (t = TRIGGERS(SCRIPT(ch)); t; t = t->next) {
    if (TRIGGER_CHECK(t, MTRIG_LOAD) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(ch, t, MOB_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


/*
 *  object triggers
 */

void random_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_RANDOM) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


void timer_otrigger(struct obj_data *obj)
{
  trig_data *t;
      
  if (!SCRIPT_CHECK(obj, OTRIG_TIMER))
    return;
  
  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_TIMER))
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);       
  }  
     
  return;
}


int get_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GET))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GET) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


/* checks for command trigger on specific object. assumes obj has cmd trig */
int cmd_otrig(obj_data *obj, char_data *actor, char *cmd,
	      char *argument, int type)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  
  if (obj && SCRIPT_CHECK(obj, OTRIG_COMMAND))
    for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
      if (!TRIGGER_CHECK(t, OTRIG_COMMAND))
        continue;
 
      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t))) {
        sprintf(buf,"SYSERR: O-Command Trigger #%d has no text argument!",
          GET_TRIG_VNUM(t));
        mudlog(buf, NRM, LVL_BUILDER, TRUE);
        continue;
      }
       
      if (IS_SET(GET_TRIG_NARG(t), type) &&
          (*GET_TRIG_ARG(t)=='*' ||
          !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(GET_TRIG_ARG(t))))) {
	
	ADD_UID_VAR(buf, t, actor, "actor", 0);
	skip_spaces(&argument);
	add_var(&GET_TRIG_VARS(t), "arg", argument, 0);
	skip_spaces(&cmd);
	add_var(&GET_TRIG_VARS(t), "cmd", cmd, 0);
	
	if (script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW))
	  return 1;
      }
    }

  return 0;
}


int command_otrigger(char_data *actor, char *cmd, char *argument)
{
  obj_data *obj;
  int i;

  for (i = 0; i < NUM_WEARS; i++)
    if (cmd_otrig(GET_EQ(actor, i), actor, cmd, argument, OCMD_EQUIP))
      return 1;
  
  for (obj = actor->carrying; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_INVEN))
      return 1;

  for (obj = world[IN_ROOM(actor)].contents; obj; obj = obj->next_content)
    if (cmd_otrig(obj, actor, cmd, argument, OCMD_ROOM))
      return 1;

  return 0;
}


int wear_otrigger(obj_data *obj, char_data *actor, int where)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_WEAR))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_WEAR)) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int remove_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_REMOVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_REMOVE)) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int drop_otrigger(obj_data *obj, char_data *actor)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_DROP))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_DROP) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int give_otrigger(obj_data *obj, char_data *actor, char_data *victim)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!SCRIPT_CHECK(obj, OTRIG_GIVE))
    return 1;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_GIVE) && (number(1, 100) <= GET_TRIG_NARG(t))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      ADD_UID_VAR(buf, t, victim, "victim", 0);
      return script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}

void load_otrigger(obj_data *obj)
{
  trig_data *t;

  if (!SCRIPT_CHECK(obj, OTRIG_LOAD))
    return;

  for (t = TRIGGERS(SCRIPT(obj)); t; t = t->next) {
    if (TRIGGER_CHECK(t, OTRIG_LOAD) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(obj, t, OBJ_TRIGGER, TRIG_NEW);
      break;
    }
  }
}



/*
 *  world triggers
 */

void reset_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RESET))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RESET) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

void random_wtrigger(struct room_data *room)
{
  trig_data *t;

  if (!SCRIPT_CHECK(room, WTRIG_RANDOM))
    return;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_RANDOM) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}


int enter_wtrigger(struct room_data *room, char_data *actor, int dir)
{
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];
  int rev_dir[] = { SOUTH, WEST, NORTH, EAST, DOWN, UP };

  if (!SCRIPT_CHECK(room, WTRIG_ENTER))
    return 1;

  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (TRIGGER_CHECK(t, WTRIG_ENTER) && 
	(number(1, 100) <= GET_TRIG_NARG(t))) {
      add_var(&GET_TRIG_VARS(t), "direction", dirs[rev_dir[dir]], 0);
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }

  return 1;
}


int command_wtrigger(char_data *actor, char *cmd, char *argument)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_COMMAND))
    return 0;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_COMMAND))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Command Trigger #%d has no text argument!",
        GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
      continue;
    }

    if (*GET_TRIG_ARG(t)=='*' ||
        !strn_cmp(GET_TRIG_ARG(t), cmd, strlen(GET_TRIG_ARG(t)))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      skip_spaces(&argument);
      add_var(&GET_TRIG_VARS(t), "arg", argument, 0);
      skip_spaces(&cmd);
      add_var(&GET_TRIG_VARS(t), "cmd", cmd, 0);
      
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
    }
  }
  
  return 0;
}


void speech_wtrigger(char_data *actor, char *str)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_SPEECH))
    return;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) {
    if (!TRIGGER_CHECK(t, WTRIG_SPEECH))
      continue;

    if (!GET_TRIG_ARG(t) || !*GET_TRIG_ARG(t)) {
      sprintf(buf,"SYSERR: W-Speech Trigger #%d has no text argument!",
        GET_TRIG_VNUM(t));
      mudlog(buf, NRM, LVL_BUILDER, TRUE);
      continue;
    }

    if (((GET_TRIG_NARG(t) && word_check(str, GET_TRIG_ARG(t))) ||
         (!GET_TRIG_NARG(t) && is_substring(GET_TRIG_ARG(t), str)))) {
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      add_var(&GET_TRIG_VARS(t), "speech", str, 0);
      script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }
  }
}

int drop_wtrigger(obj_data *obj, char_data *actor)
{
  struct room_data *room;
  trig_data *t;
  char buf[MAX_INPUT_LENGTH];

  if (!actor || !SCRIPT_CHECK(&world[IN_ROOM(actor)], WTRIG_DROP))
    return 1;

  room = &world[IN_ROOM(actor)];
  for (t = TRIGGERS(SCRIPT(room)); t; t = t->next) 
    if (TRIGGER_CHECK(t, WTRIG_DROP) &&
	(number(1, 100) <= GET_TRIG_NARG(t))) {	
      
      ADD_UID_VAR(buf, t, actor, "actor", 0);
      ADD_UID_VAR(buf, t, obj, "object", 0);
      return script_driver(room, t, WLD_TRIGGER, TRIG_NEW);
      break;
    }	

  return 1;
}
::::::::::::::
dg_wldcmd.c
::::::::::::::
/**************************************************************************
*  File: wldcmd.c                                                         *
*  Usage: contains the command_interpreter for rooms,                     *
*         room commands.                                                  *
*                                                                         *
*                                                                         *
*  $Author: galion $
*  $Date: 1996/08/05 03:27:07 $
*  $Revision: 3.12 $
**************************************************************************/

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "screen.h"
#include "dg_scripts.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"

extern struct room_data *world;
extern const char *dirs[];
extern struct zone_data *zone_table;
extern int top_of_zone_table;

void die(struct char_data * ch, struct char_data * killer);
void sub_write(char *arg, char_data *ch, byte find_invis, int targets);
void send_to_zone(char *messg, int zone_rnum);
long asciiflag_conv(char *flag);
char_data *get_char_by_room(room_data *room, char *name);
room_data *get_room(char *name);
obj_data *get_obj_by_room(room_data *room, char *name);

#define WCMD(name)  \
    void (name)(room_data *room, char *argument, int cmd, int subcmd)


struct wld_command_info {
    char *command;
    void (*command_pointer)
           (room_data *room, char *argument, int cmd, int subcmd);
    int	subcmd;
};


/* do_wsend */
#define SCMD_WSEND        0
#define SCMD_WECHOAROUND  1



/* attaches room vnum to msg and sends it to script_log */
void wld_log(room_data *room, char *msg)
{
    char buf[MAX_INPUT_LENGTH + 100];

    void script_log(char *msg);

    sprintf(buf, "Wld (room %d): %s", room->number, msg);
    script_log(buf);
}


/* sends str to room */
void act_to_room(char *str, room_data *room)
{
    /* no one is in the room */
    if (!room->people)
	return;

    /*
     * since you can't use act(..., TO_ROOM) for an room, send it
     * TO_ROOM and TO_CHAR for some char in the room.
     * (just dont use $n or you might get strange results)
     */
    act(str, FALSE, room->people, 0, 0, TO_ROOM);
    act(str, FALSE, room->people, 0, 0, TO_CHAR);
}



/* World commands */

/* prints the argument to all the rooms aroud the room */
WCMD(do_wasound)
{
    int  door;
 
    skip_spaces(&argument);

    if (!*argument) {
	wld_log(room, "wasound called with no argument");
	return;
    }
  
    for (door = 0; door < NUM_OF_DIRS; door++) {
	struct room_direction_data *exit;
	
	if ((exit = room->dir_option[door]) && (exit->to_room != NOWHERE) &&
	    room != &world[exit->to_room])
	    act_to_room(argument, &world[exit->to_room]);
    }
}


WCMD(do_wecho)
{
    skip_spaces(&argument);

    if (!*argument) 
	wld_log(room, "wecho called with no args");

    else 
	act_to_room(argument, room);
}


WCMD(do_wsend)
{
    char buf[MAX_INPUT_LENGTH], *msg;
    char_data *ch;
  
    msg = any_one_arg(argument, buf);

    if (!*buf)
    {
	wld_log(room, "wsend called with no args");
	return;
    }

    skip_spaces(&msg);

    if (!*msg)
    {
	wld_log(room, "wsend called without a message");
	return;
    }

    if ((ch = get_char_by_room(room, buf)))
    {
	if (subcmd == SCMD_WSEND)
	    sub_write(msg, ch, TRUE, TO_CHAR);
	else if (subcmd == SCMD_WECHOAROUND)
	    sub_write(msg, ch, TRUE, TO_ROOM);
    }

    else
	wld_log(room, "no target found for wsend");
}

static int real_zone(int number)
{
  int counter;
      
  for (counter = 0; counter <= top_of_zone_table; counter++)
    if ((number >= (zone_table[counter].number * 100)) &&
      (number <= (zone_table[counter].top)))
      return counter;
 
  return -1;
}

WCMD(do_wzoneecho)
{
    int zone;
    char zone_name[MAX_INPUT_LENGTH], buf[MAX_INPUT_LENGTH], *msg;
  
    msg = any_one_arg(argument, zone_name);
    skip_spaces(&msg);

    if (!*zone_name || !*msg)
	wld_log(room, "wzoneecho called with too few args");

    else if ((zone = real_zone(atoi(zone_name))) < 0)
	wld_log(room, "wzoneecho called for nonexistant zone");

    else { 
	sprintf(buf, "%s\r\n", msg);
	send_to_zone(buf, zone);
    }
}


WCMD(do_wdoor)
{
    char target[MAX_INPUT_LENGTH], direction[MAX_INPUT_LENGTH];
    char field[MAX_INPUT_LENGTH], *value;
    room_data *rm;
    struct room_direction_data *exit;
    int dir, fd, to_room;

    const char *door_field[] = {
	"purge",
	"description",
	"flags",
	"key",
	"name",
	"room",
	"\n"
    };


    argument = two_arguments(argument, target, direction);
    value = one_argument(argument, field);
    skip_spaces(&value);

    if (!*target || !*direction || !*field) {
	wld_log(room, "wdoor called with too few args");
	return;
    }
  
    if ((rm = get_room(target)) == NULL) {
	wld_log(room, "wdoor: invalid target");
	return;
    }
  
    if ((dir = search_block(direction, dirs, FALSE)) == -1) {
	wld_log(room, "wdoor: invalid direction");
	return;
    }

    if ((fd = search_block(field, door_field, FALSE)) == -1) {
	wld_log(room, "wdoor: invalid field");
	return;
    }

    exit = rm->dir_option[dir];

    /* purge exit */
    if (fd == 0) {
	if (exit) {
	    if (exit->general_description)
		free(exit->general_description);
	    if (exit->keyword)
		free(exit->keyword);
	    free(exit);
	    rm->dir_option[dir] = NULL;
	}
    }

    else {
	if (!exit) {
	    CREATE(exit, struct room_direction_data, 1);
	    rm->dir_option[dir] = exit; 
	}
    
	switch (fd) {
	case 1:  /* description */
	    if (exit->general_description)
		free(exit->general_description);
	    CREATE(exit->general_description, char, strlen(value) + 3);
	    strcpy(exit->general_description, value);
	    strcat(exit->general_description, "\r\n");
	    break;
	case 2:  /* flags       */
	    exit->exit_info = (sh_int)asciiflag_conv(value);
	    break;
	case 3:  /* key         */
	    exit->key = atoi(value);
	    break;
	case 4:  /* name        */
	    if (exit->keyword)
		free(exit->keyword);
	    CREATE(exit->keyword, char, strlen(value) + 1);
	    strcpy(exit->keyword, value);
	    break;
	case 5:  /* room        */
	    if ((to_room = real_room(atoi(value))) != NOWHERE)
		exit->to_room = to_room;
	    else
		wld_log(room, "wdoor: invalid door target");
	    break;
	}
    }
}


WCMD(do_wteleport)
{
    char_data *ch, *next_ch;
    sh_int target, nr;
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2) {
	wld_log(room, "wteleport called with too few args");
	return;
    }

    nr = atoi(arg2);
    target = real_room(nr);
  
    if (target == NOWHERE) 
	wld_log(room, "wteleport target is an invalid room");
  
    else if (!str_cmp(arg1, "all")) {
	if (nr == room->number) {
	    wld_log(room, "wteleport all target is itself");
	    return;
	}

	for (ch = room->people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;

	    char_from_room(ch);
	    char_to_room(ch, target);
	}
    }
  
    else
    {
	if ((ch = get_char_by_room(room, arg1))) {
	    char_from_room(ch);
	    char_to_room(ch, target);
	}
	
	else
	    wld_log(room, "wteleport: no target found");
    }
}


WCMD(do_wforce)
{
    char_data *ch, *next_ch;
    char arg1[MAX_INPUT_LENGTH], *line;

    line = one_argument(argument, arg1);
  
    if (!*arg1 || !*line) {
	wld_log(room, "wforce called with too few args");
	return;
    }
  
    if (!str_cmp(arg1, "all"))
    {
	for (ch = room->people; ch; ch = next_ch)
	{
	    next_ch = ch->next_in_room;
      
	    if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
		command_interpreter(ch, line);
	    }
	}
    }
  
    else
    {
	if ((ch = get_char_by_room(room, arg1)))
	{
	    if (GET_LEVEL(ch)<LVL_IMMORT)
	    {
		command_interpreter(ch, line);
	    }
	}
    
	else
	    wld_log(room, "wforce: no target found");
    }
}


/* increases the target's exp */
WCMD(do_wexp)
{
    char_data *ch;
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];

    two_arguments(argument, name, amount);

    if (!*name || !*amount) {
	wld_log(room, "wexp: too few arguments");
	return;
    }

    if ((ch = get_char_by_room(room, name))) 
	gain_exp(ch, atoi(amount));
    else {
	wld_log(room, "wexp: target not found");
	return;
    }
}


/* purge all objects an npcs in room, or specified object or mob */
WCMD(do_wpurge)
{
    char arg[MAX_INPUT_LENGTH];
    char_data *ch, *next_ch;
    obj_data *obj, *next_obj;

    one_argument(argument, arg);
  
    if (!*arg) {
	for (ch = room->people; ch; ch = next_ch ) {
	    next_ch = ch->next_in_room;
	    if (IS_NPC(ch))
		extract_char(ch);
	}
	
	for (obj = room->contents; obj; obj = next_obj ) {
	    next_obj = obj->next_content;
	    extract_obj(obj);
	}
    
	return;
    }
  
    if (!(ch = get_char_by_room(room, arg))) {
	if ((obj = get_obj_by_room(room, arg))) {
	    extract_obj(obj);
	} else 
	    wld_log(room, "wpurge: bad argument");
    
	return;
    }
  
    if (!IS_NPC(ch)) {
	wld_log(room, "wpurge: purging a PC");
	return;
    }
    
    extract_char(ch);
}


/* loads a mobile or object into the room */
WCMD(do_wload)
{
    char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int number = 0;
    char_data *mob;
    obj_data *object;
  

    two_arguments(argument, arg1, arg2);
  
    if (!*arg1 || !*arg2 || !is_number(arg2) || ((number = atoi(arg2)) < 0)) {
	wld_log(room, "wload: bad syntax");
	return;
    }

    if (is_abbrev(arg1, "mob")) {
	if ((mob = read_mobile(number, VIRTUAL)) == NULL) {
	    wld_log(room, "wload: bad mob vnum");
	    return;
	}
	char_to_room(mob, real_room(room->number));
        load_mtrigger(mob);
    }
  
    else if (is_abbrev(arg1, "obj")) {
	if ((object = read_object(number, VIRTUAL)) == NULL) {
	    wld_log(room, "wload: bad object vnum");
	    return;
	}

	obj_to_room(object, real_room(room->number)); 
        load_otrigger(object);
    }

    else
	wld_log(room, "wload: bad type");
}

WCMD(do_wdamage) {
    char name[MAX_INPUT_LENGTH], amount[MAX_INPUT_LENGTH];
    int dam = 0;
    char_data *ch;

    two_arguments(argument, name, amount);

    if (!*name || !*amount || !isdigit(*amount)) {
	wld_log(room, "wdamage: bad syntax");
	return;
    }

    dam = atoi(amount);

    if ((ch = get_char_by_room(room, name))) {
	if (GET_LEVEL(ch)>=LVL_IMMORT) {
	    send_to_char("Being a god, you carefully avoid a trap.", ch);
	    return;
	}
        GET_HIT(ch) -= dam;
        if (dam < 0) {
          send_to_char("You feel rejuvinated.\r\n", ch);
          return;
        }

	update_pos(ch);
	switch (GET_POS(ch)) {
	case POS_MORTALLYW:
 	    act("$n is mortally wounded, and will die soon, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are mortally wounded, and will die soon, if not aided.\r\n", ch);
	    break;
	case POS_INCAP:
 	    act("$n is incapacitated and will slowly die, if not aided.", TRUE, ch, 0, 0, TO_ROOM);
 	    send_to_char("You are incapacitated an will slowly die, if not aided.\r\n", ch);
    	    break;
  	case POS_STUNNED:
   	    act("$n is stunned, but will probably regain consciousness again.", TRUE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You're stunned, but will probably regain consciousness again.\r\n", ch);
    	    break;
  	case POS_DEAD:
    	    act("$n is dead!  R.I.P.", FALSE, ch, 0, 0, TO_ROOM);
    	    send_to_char("You are dead!  Sorry...\r\n", ch);
    	    break;

  	default:			/* >= POSITION SLEEPING */
    	    if (dam > (GET_MAX_HIT(ch) >> 2))
      	        act("That really did HURT!", FALSE, ch, 0, 0, TO_CHAR);
 	    if (GET_HIT(ch) < (GET_MAX_HIT(ch) >> 2)) {
        	sprintf(buf2, "%sYou wish that your wounds would stop BLEEDING so much!%s\r\n",
	                CCRED(ch, C_SPR), CCNRM(ch, C_SPR));
        	send_to_char(buf2, ch);
    	    }
	}
	if (GET_POS(ch) == POS_DEAD) {
	    if (!IS_NPC(ch)) {
		sprintf(buf2, "%s killed by a trap at %s", GET_NAME(ch),
	      		world[ch->in_room].name);
      		mudlog(buf2, BRF, 0, TRUE);
    	    }
    	    die(ch, NULL);
	}
    }
    else
	wld_log(room, "wdamage: target not found");
}

WCMD(do_wat) {
    char location[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
    int vnum = 0;    
    room_data *r2;
 
    void wld_command_interpreter(room_data *room, char *argument);

    half_chop(argument, location, arg2);

    if (!*location || !*arg2 || !isdigit(*location)) {
	wld_log(room, "wat: bad syntax");
	return;
    }
    vnum = atoi(location);
    if (NOWHERE == real_room(vnum)) {
	wld_log(room, "wat: location not found");
	return;
    }

    r2 = &world[vnum];
    wld_command_interpreter(r2, arg2);
}

const struct wld_command_info wld_cmd_info[] = {
    { "RESERVED", 0, 0 },/* this must be first -- for specprocs */
    
    { "wasound"    , do_wasound   , 0 },
    { "wdoor"      , do_wdoor     , 0 },
    { "wecho"      , do_wecho     , 0 },
    { "wechoaround", do_wsend     , SCMD_WECHOAROUND },
    { "wexp"       , do_wexp      , 0 },
    { "wforce"     , do_wforce    , 0 },
    { "wload"      , do_wload     , 0 },
    { "wpurge"     , do_wpurge    , 0 },
    { "wsend"      , do_wsend     , SCMD_WSEND },
    { "wteleport"  , do_wteleport , 0 },
    { "wzoneecho"  , do_wzoneecho , 0 },
    { "wdamage"    , do_wdamage,    0 },
    { "wat"        , do_wat,        0 },
    { "\n", 0, 0 }	/* this must be last */
};


/*
 *  This is the command interpreter used by rooms, called by script_driver.
 */
void wld_command_interpreter(room_data *room, char *argument)
{
    int cmd, length;
    char *line, arg[MAX_INPUT_LENGTH];
  
    skip_spaces(&argument);
  
    /* just drop to next line for hitting CR */
    if (!*argument)
	return;

    line = any_one_arg(argument, arg);


    /* find the command */
    for (length = strlen(arg), cmd = 0;
	 *wld_cmd_info[cmd].command != '\n'; cmd++)
	if (!strncmp(wld_cmd_info[cmd].command, arg, length))
	    break;
  
    if (*wld_cmd_info[cmd].command == '\n') {
	sprintf(buf2, "Unknown world cmd: '%s'", argument);
	wld_log(room, buf2);
    } else
	((*wld_cmd_info[cmd].command_pointer) 
	 (room, line, cmd, wld_cmd_info[cmd].subcmd));
}
::::::::::::::
diskio.c
::::::::::::::
/*
	diskio.c	Fast file buffering

	(C) Copyright 1998 by Brian Boyle

	Version 1.3
*/

#include "conf.h"
#include "sysdep.h"

#include <sys/stat.h>

#include "diskio.h"


int fbgetline(FBFILE *fbfl, char *line)
{
  char *r = fbfl->ptr, *w = line;

  if(!fbfl || !line || !*fbfl->ptr)
    return FALSE;

  for(; *r && *r != '\n' && r <= fbfl->buf + fbfl->size; r++)
    *(w++) = *r;

  while(*r == '\r' || *r == '\n')
    r++;

  *w = '\0';

  if(r > fbfl->buf + fbfl->size)
    return FALSE;
  else {
    fbfl->ptr = r;
    return TRUE;
  }
}


int find_string_size(char *str)
{
  int i;
  char *p;

  if(!str || !*str || *str == '~')
    return 0;

  for(i = 1, p = str; *p; i++) {
    switch(*p) {
    case '\r':
      i++;
      if(*(++p) == '\n')
	p++;
      break;
    case '\n':
      i++;
      if(*(++p) == '\r') {
        *(p - 1) = '\r';
	*(p++) = '\n';
      } else
	p++;
      break;
    case '~':
      if(*(p - 1) == '\r' || *(p - 1) == '\n' ||
	*(p + 1) == '\r' || *(p + 1) == '\n' || *(p + 1) == '\0')
	return i;
      else
	p++;
      break;
    default:
      p++;
    }
  }
  return i;
}


char *fbgetstring(FBFILE *fl)
{
  int size;
  char *str, *r, *w;

  if(!fl || !*fl->ptr)
    return NULL;

  if(!(size = find_string_size(fl->ptr)))
    return NULL;

  str = (char *)malloc(size + 1);
  *str = '\0';
  r = fl->ptr;
  w = str;

  for( ; *r; r++, w++) {
    switch(*r) {
    case '\r':
      *(w++) = '\r';
      *w = '\n';
      if(*(r + 1) == '\n')
	r++;
      break;
    case '\n':
      *(w++) = '\r';
      *w = '\n';
      break;
    case '~':
      if(*(r - 1) == '\r' || *(r - 1) == '\n' ||
	*(r + 1) == '\r' || *(r + 1) == '\n' || *(r + 1) == '\0') {
	*w = '\0';
	for(r++; *r == '\r' || *r == '\n'; r++);
	fl->ptr = r;
	return str;
      } else
      *w = *r;
      break;
    case '\0':
      *w = '\0';
      fl->ptr = r;
      return str;
    default:
      *w = *r;
    }
  }
  fl->ptr = r;
  return str;
}


FBFILE *fbopen_for_read(char *fname)
{
  int err;
  FILE *fl;
  struct stat sb;
  FBFILE *fbfl;

  if(!(fbfl = (FBFILE *)malloc(sizeof(FBFILE))))
    return NULL;

  if(!(fl = fopen(fname, "r"))) {
    free(fbfl);
    return NULL;
  }

  err = fstat(fileno(fl), &sb);
  if(err < 0 || sb.st_size <= 0) {
    free(fbfl);
    fclose(fl);
    return NULL;
  }

  fbfl->size = sb.st_size;
  if(!(fbfl->buf = malloc(fbfl->size))) {
    free(fbfl);
    return NULL;
  }
  if(!(fbfl->name = malloc(strlen(fname) + 1))) {
    free(fbfl->buf);
    free(fbfl);
    return NULL;
  }
  fbfl->ptr = fbfl->buf;
  fbfl->flags = FB_READ;
  strcpy(fbfl->name, fname);
  fread(fbfl->buf, sizeof(char), fbfl->size, fl);
  fclose(fl);

  return fbfl;
}


FBFILE *fbopen_for_write(char *fname, int mode)
{
  FBFILE *fbfl;

  if(!(fbfl = (FBFILE *)malloc(sizeof(FBFILE))))
    return NULL;

  if(!(fbfl->buf = malloc(FB_STARTSIZE))) {
    free(fbfl);
    return NULL;
  }
  if(!(fbfl->name = malloc(strlen(fname) + 1))) {
    free(fbfl->buf);
    free(fbfl);
    return NULL;
  }
  strcpy(fbfl->name, fname);
  fbfl->ptr = fbfl->buf;
  fbfl->size = FB_STARTSIZE;
  fbfl->flags = mode;

  return fbfl;
}


FBFILE *fbopen(char *fname, int mode)
{
  if(!fname || !*fname || !mode)
    return NULL;

  if(IS_SET(mode, FB_READ))
    return fbopen_for_read(fname);
  else if(IS_SET(mode, FB_WRITE) || IS_SET(mode, FB_APPEND))
    return fbopen_for_write(fname, mode);
  else
    return NULL;
}


int fbclose_for_read(FBFILE *fbfl)
{
  if(!fbfl)
    return 0;

  if(fbfl->buf)
    free(fbfl->buf);
  if(fbfl->name)
    free(fbfl->name);
  free(fbfl);
  return 1;
}


int fbclose_for_write(FBFILE *fbfl)
{
  char *arg, *tname;
  int len, bytes_written;
  FILE *fl;

  if(!fbfl || !fbfl->name || !fbfl->buf || fbfl->ptr == fbfl->buf)
    return 0;

  if(IS_SET(fbfl->flags, FB_APPEND))
    arg = "wa";
  else
    arg = "w";

  if(!(tname = malloc(strlen(fbfl->name) + 6)))
    return 0;

  len = strlen(fbfl->buf);
  if(!len)
    return 0;
  sprintf(tname, "%s.tmp", fbfl->name);

  if(!(fl = fopen(tname, arg))) {
    free(tname);
    return 0;
  }

  if((bytes_written = fwrite(fbfl->buf, sizeof(char), len, fl)) < len) {
    fclose(fl);
    remove(tname);
    free(tname);
    return 0;
  }

  fclose(fl);
  remove(fbfl->name);
  rename(tname, fbfl->name);
  free(tname);
  free(fbfl->name);
  free(fbfl->buf);
  free(fbfl);
  return bytes_written;
}


int fbclose(FBFILE *fbfl)
{
  if(!fbfl)
    return 0;

  if(IS_SET(fbfl->flags, FB_READ))
    return fbclose_for_read(fbfl);
  else if(IS_SET(fbfl->flags, FB_WRITE | FB_APPEND))
    return fbclose_for_write(fbfl);
  else
    return 0;
}


int fbprintf(FBFILE *fbfl, const char *format, ...)
{
  int bytes_written = 0, length = 0;
  va_list args;

  if(fbfl->ptr - fbfl->buf > (FB_STARTSIZE * 3) / 4) {
    length = fbfl->ptr - fbfl->buf;
    if(!(fbfl->buf = realloc(fbfl->buf, fbfl->size + FB_STARTSIZE)))
      return 0;
    fbfl->ptr = fbfl->buf + length;
    fbfl->size += FB_STARTSIZE;
  }

  va_start(args, format);
  bytes_written = vsprintf(fbfl->ptr, format, args);
  va_end(args);

  fbfl->ptr += bytes_written;
  return bytes_written;
}


void fbrewind(FBFILE *fbfl)
{
  fbfl->ptr = fbfl->buf;
}


int fbcat(char *fromfilename, FBFILE *tofile)
{
  struct stat sb;
  FILE *fromfile;
  char *in_buf = 0;
  int errnum = 0, length = 0;

  if(!fromfilename || !*fromfilename || !tofile)
    return 0;

  if(!(fromfile = fopen(fromfilename, "r+b")))
    return 0;

  errnum = fstat(fileno(fromfile), &sb);
  if(errnum < 0 || sb.st_size <= 0)
    return 0;

  length = tofile->ptr - tofile->buf;
  tofile->buf = realloc(tofile->buf, tofile->size + sb.st_size);
  tofile->ptr = tofile->buf + length;
  tofile->size += sb.st_size;
  in_buf = malloc(sb.st_size + 1);
  in_buf[0] = 0;
  errnum = fread(in_buf, sb.st_size, 1, fromfile);
  fbprintf(tofile, "%s", in_buf);
  fclose(fromfile);
  free(in_buf);
  return 1;
}
::::::::::::::
fbi.c
::::::::::::::
/***************************************************************************
* File: fbi.c                                       a part of DungeonMUD   *
*                                                                          *
* Description: Is a code of a FBI service... it will be used to turn       *
* players agents of your mud.                                              *
*                                                                          *
* By Archangel(Paulo Mello) Implementor of DungeonMUD                      *
****************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "screen.h"
#include "fbi.h"
#include "buffer.h"

void send_fbi_option(struct char_data * ch)
{

	send_to_char("You can use this options to the FBI system:\r\n"
	             "	Fbi enjoy	<player>\r\n"
	             "	Fbi promote	<player>\r\n"
	             "	Fbi demote	<player>\r\n"
	             "	Fbi dismiss	<player>\r\n", ch);

}

void fbi_enjoy(struct char_data * ch, char *arg)
{
	struct char_data *vict;

	if(!*arg){
		send_to_char("You need a player to enjoy the fbi...\r\n", ch);
		send_fbi_option(ch);
		return;
	}

	if(!(vict = get_char_vis(ch, arg)) || IS_NPC(vict)) {
		send_to_char("Who you want enjoy FBI??\r\n",ch);
		send_fbi_option(ch);
		return;
	}

	if(GET_FBI_POS(vict) > 0){
		send_to_char("He is already a FBI agent...\r\n", ch);
		return;
	}


	sprintf(buf, "%s enjoy you to the secret service of Dungeon MUD.\r\n", GET_NAME(ch));
	send_to_char(buf, vict);
	sprintf(buf, "You enjoy %s to the secret service of Dungeon MUD.\r\n", GET_NAME(vict));
	send_to_char(buf, ch);
	sprintf(buf, "(FBI) %s enjoys %s to the FBI service.", GET_NAME(ch), GET_NAME(vict));
	mudlog(buf, BRF, LVL_SUPGOD, TRUE);
	GET_FBI_POS(vict) = FBI_AGENT;

}

void fbi_promote(struct char_data *ch, char *arg)
{

	struct char_data *vict;

	if(!*arg){
		send_to_char("You need a player to promote...\r\n", ch);
		send_fbi_option(ch);
		return;
	}

	if(!(vict = get_char_vis(ch, arg)) || IS_NPC(vict)) {
		send_to_char("Who you want promote in FBI??\r\n",ch);
		send_fbi_option(ch);
		return;
	}

	if(GET_FBI_POS(vict) > 0 && GET_FBI_POS(vict) < 3){
		sprintf(buf, "%s promotes you in the secret service of Dungeon MUD.\r\n", GET_NAME(ch));
		send_to_char(buf, vict);
		sprintf(buf, "You promotes %s in the secret service of Dungeon MUD.\r\n", GET_NAME(vict));
		send_to_char(buf, ch);
		sprintf(buf, "(FBI) %s promotes %s in the FBI service.", GET_NAME(ch), GET_NAME(vict));
		mudlog(buf, BRF, LVL_SUPGOD, TRUE);
		GET_FBI_POS(vict) += 1;
	} else
		send_to_char("You can't promote...\r\n", ch);
		return;
}

void fbi_demote(struct char_data *ch, char *arg)
{

	struct char_data *vict;

	if(!*arg){
		send_to_char("You need a player to demote...\r\n", ch);
		send_fbi_option(ch);
		return;
	}

	if(!(vict = get_char_vis(ch, arg)) || GET_FBI_POS(vict) < 1 || IS_NPC(vict)) {
		send_to_char("Who you want demote in FBI??\r\n",ch);
		send_fbi_option(ch);
		return;
	}

	if(GET_FBI_POS(vict) > 1 && GET_FBI_POS(vict) <= 3){
		sprintf(buf, "%s demotes you in the secret service of Dungeon MUD.\r\n", GET_NAME(ch));
		send_to_char(buf, vict);
		sprintf(buf, "You demote %s in the secret service of Dungeon MUD.\r\n", GET_NAME(vict));
		send_to_char(buf, ch);
		sprintf(buf, "(FBI) %s demotes %s in the FBI service.", GET_NAME(ch), GET_NAME(vict));
		mudlog(buf, BRF, LVL_SUPGOD, TRUE);
		GET_FBI_POS(vict) -= 1;
	} else
		send_to_char("You can't demote...\r\n", ch);
		return;
}

void fbi_dismiss(struct char_data * ch, char *arg)
{
	struct char_data *vict;

	if(!*arg){
		send_to_char("You need a player to dismiss...\r\n", ch);
		send_fbi_option(ch);
		return;
	}

	if(!(vict = get_char_vis(ch, arg)) || IS_NPC(vict)) {
		send_to_char("Who you want dismiss FBI??\r\n", ch);
		send_fbi_option(ch);
		return;
	}

	if(GET_FBI_POS(vict) < 1){
		send_to_char("He is'n a FBI agent...\r\n", ch);
		return;
	}

	sprintf(buf, "%s dismiss you of the secret service of Dungeon MUD...\r\nYou don't have acess to the secret base of FBI service.\r\n", GET_NAME(ch));
	send_to_char(buf, vict);
	sprintf(buf, "You dismiss %s of the secret service of Dungeon MUD.\r\n", GET_NAME(vict));
	send_to_char(buf, ch);
	sprintf(buf, "(FBI) %s dismiss %s of the FBI service.", GET_NAME(ch), GET_NAME(vict));
	mudlog(buf, BRF, LVL_SUPGOD, TRUE);
	GET_FBI_POS(vict) = 0;

}

ACMD(do_fbi)
{
	char arg1[MAX_INPUT_LENGTH];
	char arg2[MAX_INPUT_LENGTH];

	argument = two_arguments(argument, arg1, arg2);

	if(!*arg1){
		send_fbi_option(ch);
		return;
	}

	if (!str_cmp("enjoy", arg1)){
		fbi_enjoy(ch, arg2);
		return;
	}
	if (!str_cmp("promote", arg1)){
		fbi_promote(ch, arg2);
		return;
	}
	if (!str_cmp("demote", arg1)){
		fbi_demote(ch, arg2);
		return;
	}
	if (!str_cmp("dismiss", arg1)){
		fbi_dismiss(ch, arg2);
		return;
	}
}
::::::::::::::
fight.c
::::::::::::::
/* ************************************************************************
*   File: fight.c                                       Part of CircleMUD *
*  Usage: Combat system                                                   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "spells.h"
#include "screen.h"
#include "dg_scripts.h"
#include "quest.h"

/* Structures */
struct char_data *combat_list = NULL;   /* head of l-list of fighting chars */
struct char_data *next_combat_list = NULL;
struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];

/* External structures */

extern struct index_data *obj_index;
extern struct index_data *mob_index;
extern struct str_app_type str_app[];
extern struct dex_app_type dex_app[];
extern struct room_data *world;
extern struct message_list fight_messages[MAX_MESSAGES];
extern struct obj_data *object_list;
extern struct aq_data *aquest_table;
extern int pk_allowed;          /* see config.c */
extern int auto_save;           /* see config.c -- not used in this file */
extern int free_rent;           /* see config.c */
extern int max_exp_gain;        /* see config.c */
extern int max_exp_loss;        /* see config.c */
extern int top_of_world;
extern int max_npc_corpse_time, max_pc_corpse_time;
extern sh_int r_mortal_start_room;

/* External procedures */
char *fread_action(FILE * fl, int nr);
ACMD(do_flee);
int backstab_mult(int level);
int thaco(int ch_class, int level);
int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim);
int level_exp(int remort, int level);
void Crash_rentsave(struct char_data * ch, int cost);
char *make_bar(int val, int max, int len);
void diag_char_to_char(struct char_data * i, struct char_data * ch);
void DamageStuff(struct char_data *ch);
int alvo_better(struct char_data *ch);
int contar_briga(struct char_data *ch);
struct char_data *melhor_alvo(struct char_data *ch);
void mob_ia(struct char_data *ch);
int mag_savingthrow(struct char_data *ch , int type) ;

/* local functions */
void perform_group_gain(struct char_data * ch, int base, struct char_data * victim);
void dam_message(int dam, struct char_data * ch, struct char_data * victim, int w_type);
void appear(struct char_data * ch);
void load_messages(void);
void check_killer(struct char_data * ch, struct char_data * vict);
void make_corpse(struct char_data * ch);
void change_alignment(struct char_data * ch, struct char_data * victim);
void death_cry(struct char_data * ch);
void raw_kill(struct char_data * ch, struct char_data * killer);
void die(struct char_data * ch, struct char_data * killer);
void die_in_dt(struct char_data * ch);
void group_gain(struct char_data * ch, struct char_data * victim);
void solo_gain(struct char_data * ch, struct char_data * victim);
char *replace_string(const char *str, const char *weapon_singular, const char *weapon_plural);
void perform_violence(void);
int return_wanted_gain(struct char_data * ch, struct char_data * victim);
int can_pk(struct char_data * ch, struct char_data * vt);
int app_style[][3];
void dragon_spec(struct char_data *ch , int message) ; // procedimento generico para dragoes


void dragon_spec(struct char_data *ch, int message)
{
 int dam, num  ;
 struct char_data *vict ;


 vict = FIGHTING(ch) ;

 dam = GET_LEVEL(ch)  ;
 dam = dam + (GET_REMORT(ch) * 150) ;

 num = 1 + (GET_REMORT(ch)/4)  ;

 while(num > 0)
 {
  vict = FIGHTING(ch) ;

  if((vict == NULL) || (ch->in_room != vict->in_room))
   return ;

  if(mag_savingthrow(vict, SAVING_BREATH))
   dam = dam / 2 ;

  num-- ;

  damage(ch, vict, dam, message) ;
 }
}

/* Weapon attack texts */
struct attack_hit_type attack_hit_text[] =
{
  {"hit", "hits"},              /* 0 */
  {"sting", "stings"},
  {"whip", "whips"},
  {"slash", "slashes"},
  {"bite", "bites"},
  {"bludgeon", "bludgeons"},    /* 5 */
  {"crush", "crushes"},
  {"pound", "pounds"},
  {"claw", "claws"},
  {"maul", "mauls"},
  {"thrash", "thrashes"},       /* 10 */
  {"pierce", "pierces"},
  {"blast", "blasts"},
  {"punch", "punches"},
  {"stab", "stabs"}
};

#define IS_WEAPON(type) (((type) >= TYPE_HIT) && ((type) < TYPE_SUFFERING))

/* The Fight related routines */


int encumberance_level(struct char_data *ch)
{
  int weight_worn=0,i, level=0, items_worn = 0;

  for (i=0; i < NUM_WEARS; i++)
    if (ch->equipment[i]){
      weight_worn += ch->equipment[i]->obj_flags.weight;
      items_worn++;
    }
  //weight_worn /= 2;
  //items_worn /= 3;
  if ((IS_CARRYING_W(ch) + weight_worn) > (4*CAN_CARRY_W(ch))/3)
    level = 8;
  else if ((IS_CARRYING_W(ch) + weight_worn) > (3.5*CAN_CARRY_W(ch))/3)
    level = 7;
  else if ((IS_CARRYING_W(ch) + weight_worn) > (3*CAN_CARRY_W(ch))/3)
    level = 6;
  else if ((IS_CARRYING_W(ch) + weight_worn) > (2.5*CAN_CARRY_W(ch))/3)
    level = 5;
  else if ((IS_CARRYING_W(ch) + weight_worn) > (2*CAN_CARRY_W(ch))/3)
    level = 4;
  else if ((IS_CARRYING_W(ch) + weight_worn) > (1.5*CAN_CARRY_W(ch))/3)
    level = 3;
  else if ((IS_CARRYING_W(ch) + weight_worn) > (CAN_CARRY_W(ch))/3)
    level = 2;
  if ((IS_CARRYING_N(ch) + items_worn) > (4*CAN_CARRY_N(ch))/5)
    level += 8;
  else if ((IS_CARRYING_N(ch) + items_worn) > (3.5*CAN_CARRY_N(ch))/5)
    level += 7;
  else if ((IS_CARRYING_N(ch) + items_worn) > (3*CAN_CARRY_N(ch))/5)
    level += 6;
  else if ((IS_CARRYING_N(ch) + items_worn) > (2.5*CAN_CARRY_N(ch))/5)
    level += 5;
  else if ((IS_CARRYING_N(ch) + items_worn) > (2*CAN_CARRY_N(ch))/5)
    level += 4;
  else if ((IS_CARRYING_N(ch) + items_worn) > (1.5*CAN_CARRY_N(ch))/5)
    level += 3;
  else if ((IS_CARRYING_N(ch) + items_worn) > (CAN_CARRY_N(ch))/5)
    level += 2;

  level *= 6;
  return(level);
}


void appear(struct char_data * ch)
{
  if (affected_by_spell(ch, SPELL_INVISIBLE))
    affect_from_char(ch, SPELL_INVISIBLE);

  REMOVE_BIT(AFF_FLAGS(ch), AFF_INVISIBLE | AFF_HIDE);

  if (GET_LEVEL(ch) < LVL_IMMORT)
    act("$n slowly fades into existence.", FALSE, ch, 0, 0, TO_ROOM);
  else
    act("You feel a strange presence as $n appears, seemingly from nowhere.",
        FALSE, ch, 0, 0, TO_ROOM);
}

void load_messages(void)
{
  FILE *fl;
  int i, type;
  struct message_type *messages;
  char chk[128];

  if (!(fl = fopen(MESS_FILE, "r"))) {
    sprintf(buf2, "SYSERR: Error reading combat message file %s", MESS_FILE);
    perror(buf2);
    exit(1);
  }
  for (i = 0; i < MAX_MESSAGES; i++) {
    fight_messages[i].a_type = 0;
    fight_messages[i].number_of_attacks = 0;
    fight_messages[i].msg = 0;
  }


  fgets(chk, 128, fl);
  while (!feof(fl) && (*chk == '\n' || *chk == '*'))
    fgets(chk, 128, fl);

  while (*chk == 'M') {
    fgets(chk, 128, fl);
    sscanf(chk, " %d\n", &type);
    for (i = 0; (i < MAX_MESSAGES) && (fight_messages[i].a_type != type) &&
         (fight_messages[i].a_type); i++);
    if (i >= MAX_MESSAGES) {
      log("SYSERR: Too many combat messages.  Increase MAX_MESSAGES and recompile.");
      exit(1);
    }
    CREATE(messages, struct message_type, 1);
    fight_messages[i].number_of_attacks++;
    fight_messages[i].a_type = type;
    messages->next = fight_messages[i].msg;
    fight_messages[i].msg = messages;

    messages->die_msg.attacker_msg = fread_action(fl, i);
    messages->die_msg.victim_msg = fread_action(fl, i);
    messages->die_msg.room_msg = fread_action(fl, i);
    messages->miss_msg.attacker_msg = fread_action(fl, i);
    messages->miss_msg.victim_msg = fread_action(fl, i);
    messages->miss_msg.room_msg = fread_action(fl, i);
    messages->hit_msg.attacker_msg = fread_action(fl, i);
    messages->hit_msg.victim_msg = fread_action(fl, i);
    messages->hit_msg.room_msg = fread_action(fl, i);
    messages->god_msg.attacker_msg = fread_action(fl, i);
    messages->god_msg.victim_msg = fread_action(fl, i);
    messages->god_msg.room_msg = fread_action(fl, i);
    fgets(chk, 128, fl);
    while (!feof(fl) && (*chk == '\n' || *chk == '*'))
      fgets(chk, 128, fl);
  }

  fclose(fl);
}


void update_pos(struct char_data * victim)
{
  if ((GET_HIT(victim) > 0) && (GET_POS(victim) > POS_STUNNED))
    return;
  else if (GET_HIT(victim) > 0 && AFF_FLAGGED(victim, AFF_SLEEP))
	affect_from_char(victim, SPELL_SLEEP);
  else if (GET_HIT(victim) > 0)
    GET_POS(victim) = POS_STANDING;
  else if (GET_HIT(victim) <= -11)
    GET_POS(victim) = POS_DEAD;
  else if (GET_HIT(victim) <= -6)
    GET_POS(victim) = POS_MORTALLYW;
  else if (GET_HIT(victim) <= -3)
    GET_POS(victim) = POS_INCAP;
  else
    GET_POS(victim) = POS_STUNNED;
}


void check_killer(struct char_data * ch, struct char_data * vict)
{
  if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
     return;

    if (!PLR_FLAGGED(vict, PLR_KILLER) && !PLR_FLAGGED(vict, PLR_THIEF) && !PLR_FLAGGED(ch, PLR_KILLER) && !IS_NPC(ch) && !IS_NPC(vict) && (ch != vict))
  {
      char buf[256];
      SET_BIT(PLR_FLAGS(ch), PLR_KILLER);
      sprintf(buf, "PC Killer bit set on %s for initiating attack on %s at %s.", GET_NAME(ch), GET_NAME(vict), world[vict->in_room].name);
      mudlog(buf, BRF, LVL_IMMORT, TRUE);
      send_to_char("If you want to be a PLAYER KILLER, so be it...\r\n", ch);
  }
}


/* start one char fighting another (yes, it is horrible, I know... )  */
void set_fighting(struct char_data * ch, struct char_data * vict)
{
  if (ch == vict)
    return;

  if (FIGHTING(ch)) {
    core_dump();
    return;
  }

  ch->next_fighting = combat_list;
  combat_list = ch;

  if (AFF_FLAGGED(ch, AFF_SLEEP))
    affect_from_char(ch, SPELL_SLEEP);

  FIGHTING(ch) = vict;
  GET_POS(ch) = POS_FIGHTING;

/*  if (!pk_allowed)
    check_killer(ch, vict);*/
}

void unentangle(struct char_data *ch)
{
  if (AFF_FLAGGED(ch, AFF_TANGLED))
    {
      send_to_char("You are finally free of the vines that bind.\r\n", ch);
      affect_from_char(ch, SPELL_ENTANGLE);
      act("$n is free of the vines that bind.",TRUE,ch,0,0,TO_ROOM);
    }
}

/* remove a char from the list of fighting chars */
void stop_fighting(struct char_data * ch)
{
  struct char_data *temp;

  if (ch == next_combat_list)
    next_combat_list = ch->next_fighting;

  REMOVE_FROM_LIST(ch, combat_list, next_fighting);
  ch->next_fighting = NULL;
  FIGHTING(ch) = NULL;
  GET_POS(ch) = POS_STANDING;

  if (!IS_NPC(ch) && IS_AFFECTED(ch, AFF_BERZERK)) {
	send_to_char("&nYou become humble again.&n\n\r", ch);
	act("&n$n becomes humble again.&n", TRUE, ch, 0, 0, TO_ROOM);
	REMOVE_BIT(AFF_FLAGS(ch), AFF_BERZERK);
  }

  update_pos(ch);
  unentangle(ch);

}

void make_corpse(struct char_data * ch)
{
  struct obj_data *corpse, *o;
  struct obj_data *money;
  int i;

  /* check if trying to re-nuke a corpse, bail otherwise
     since a corpse was prob already made, -taerin 4/22/99 */
  if (ch == NULL || ch->in_room == NOWHERE)
    return;

    if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
  {

    corpse = create_obj();

    corpse->item_number = NOTHING;
    corpse->in_room = NOWHERE;
    corpse->name = str_dup("head");

    sprintf(buf2, "%s's head is lying here.", GET_NAME(ch));
    corpse->description = str_dup(buf2);
    sprintf(buf2, "%s's head", GET_NAME(ch));
    corpse->short_description = str_dup(buf2);

    GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
    GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE;
    GET_OBJ_EXTRA(corpse) = ITEM_NODONATE;
    GET_OBJ_VAL(corpse, 0) = 0;   /* You can't store stuff in a corpse */
    GET_OBJ_VAL(corpse, 3) = (0);   /* no corpse identifier */
    GET_OBJ_WEIGHT(corpse) = 0;
    GET_OBJ_RENT(corpse) = 100000;

  }

  else{
    corpse = create_obj();

    corpse->item_number = NOTHING;
    corpse->in_room = NOWHERE;
    corpse->name = str_dup("corpse");

    sprintf(buf2, "The corpse of %s is lying here.", GET_NAME(ch));
    corpse->description = str_dup(buf2);

    sprintf(buf2, "the corpse of %s", GET_NAME(ch));
    corpse->short_description = str_dup(buf2);

    GET_OBJ_TYPE(corpse) = ITEM_CONTAINER;
    GET_OBJ_WEAR(corpse) = ITEM_WEAR_TAKE;
    GET_OBJ_EXTRA(corpse) = ITEM_NODONATE;
    GET_OBJ_VAL(corpse, 0) = 0;   // You can't store stuff in a corpse
    GET_OBJ_VAL(corpse, 3) = (IS_NPC(ch) ? 2 : 1);   // corpse identifier
    GET_OBJ_WEIGHT(corpse) = GET_WEIGHT(ch) + IS_CARRYING_W(ch);
    GET_OBJ_RENT(corpse) = 100000;

    if (IS_NPC(ch))
      GET_OBJ_TIMER(corpse) = max_npc_corpse_time;
    else
      GET_OBJ_TIMER(corpse) = max_pc_corpse_time;


     corpse->contains = ch->carrying;  // transfer character's inventory to the corpse
     	for (o = corpse->contains; o != NULL; o = o->next_content)
             o->in_obj = corpse;
             object_list_new_owner(corpse, NULL);


        for (i = 0; i < NUM_WEARS; i++) // transfer character's equipment to the corpse
             if (GET_EQ(ch, i))
             obj_to_obj(unequip_char(ch, i), corpse);


        if (GET_GOLD(ch) > 0) // transfer gold
      {
        if (IS_NPC(ch) || (!IS_NPC(ch) && ch->desc)) // following 'if' clause added to fix gold duplication loophole
       {
            money = create_money(GET_GOLD(ch));
            obj_to_obj(money, corpse);
       }
       GET_GOLD(ch) = 0;
     }
       ch->carrying = NULL;
       IS_CARRYING_N(ch) = 0;
       IS_CARRYING_W(ch) = 0;
    }
    obj_to_room(corpse, ch->in_room);
}


/* When ch kills victim */
void change_alignment(struct char_data * ch, struct char_data * victim)
{
  return  ;

  /*
   * new alignment change algorithm: if you kill a monster with alignment A,
   * you move 1/16th of the way to having alignment -A.  Simple and fast.
   */
  GET_ALIGNMENT(ch) += (-GET_ALIGNMENT(victim) - GET_ALIGNMENT(ch)) / 16;
}



void death_cry(struct char_data * ch)
{
  int door, was_in;

  act("&rYour blood freezes as you hear &R$n's &rdeath cry.&n", FALSE, ch, 0, 0, TO_ROOM);
  was_in = ch->in_room;

  for (door = 0; door < NUM_OF_DIRS; door++) {
    if (CAN_GO(ch, door)) {
      ch->in_room = world[was_in].dir_option[door]->to_room;
      act("&rYour blood freezes as you hear someone's death cry.&n", FALSE, ch, 0, 0, TO_ROOM);
      ch->in_room = was_in;
    }
  }
}

void raw_kill(struct char_data * ch, struct char_data * killer)

{
  if (FIGHTING(ch))
    stop_fighting(ch);

  if (!ROOM_FLAGGED(ch->in_room, ROOM_ARENA)){
    while (ch->affected)
      affect_remove(ch, ch->affected);

    if (killer) {
      autoquest_trigger_check(killer, ch, NULL, AQ_MOB_KILL);
      if (death_mtrigger(ch, killer))
        death_cry(ch);
    } else
        death_cry(ch);

    if (ch && killer)
      if ((!IS_NPC(ch)) && (!IS_NPC(killer)))
        REMOVE_BIT(PLR_FLAGS(ch), PLR_THIEF);

    if(killer && !IS_NPC(killer))
     GET_DIED(ch) += 1;

     GET_DIED_S(ch) += 1;

  if(GET_MOB_VNUM(ch) != 11 && GET_MOB_VNUM(ch) != 15 &&
     GET_MOB_VNUM(ch) != 16 && GET_MOB_VNUM(ch) != 20)
	make_corpse(ch);

	if (!IS_NPC(ch))
	{
	  sprintf(buf, "\r\n&W%s, after the last event you lost your fisical body...&n\r\n"
  	       "&WFor now your are dead.&n\r\n"
  	       "&WWait in the purgatory for your judgement.&n\r\n\r\n", GET_NAME(ch));
	  send_to_char(buf, ch);
  	  GET_HIT(ch) = 1;
  	  GET_MANA(ch) = 1;
  	  GET_MOVE(ch) = 1;
	  LIBERDADE(ch) = 30;

	  if(GET_LEVEL(ch) < LVL_IMMORT)
	    SET_BIT(PLR_FLAGS(ch), PLR_DEAD);

	    if (ch->in_room != NOWHERE)
	      char_from_room(ch);
	    char_to_room(ch, real_room(10));
	    act("&B$n &bappears in a strange wortex of light, created by the &BW&ba&Br&bD&Bo&bm&Be.&n", FALSE, ch, 0, 0, TO_NOTVICT);
          look_at_room(ch, 0);
	  update_pos(ch);

	} else {
	  if (free_rent)
	     Crash_rentsave(ch, 0);
	   extract_char(ch);           /* Char is saved in extract char */
	}
  } else {
	   if(!IS_NPC(ch)){
	    act("$n is magically whisked away.", FALSE, ch, 0, 0, TO_ROOM);
	    make_corpse(ch);
	    char_from_room(ch);
	    char_to_room(ch, r_mortal_start_room);
	    look_at_room(ch, 0);
	    act("&w$n falls from the sky.", FALSE, ch, 0, 0, TO_ROOM);
	    act("&w$n looks like he had a bad day", FALSE, ch, 0, 0, TO_ROOM);
	    GET_HIT(ch) = ch->desc->hp;
	    GET_MANA(ch) = ch->desc->mana;
	    GET_MOVE(ch) = ch->desc->move;
	    GET_MENTAL(ch) = GET_MAX_MENTAL(ch);
	    GET_ARENA_DIED(ch) += 1;
	    GET_DIED_S(ch) += 1;
	    GET_OXI(ch) = GET_MAX_OXI(ch);
	   if (ch->affected)
	     while (ch->affected)
	       affect_remove(ch, ch->affected);
	     GET_POS(ch) = POS_STANDING;
	   } else {
	     act("$n's body glows brightly and then slowly fades away.\r\n"
        	, FALSE, ch, 0, 0, TO_ROOM);
	        extract_char(ch);
           }
  }
  if (killer)
    autoquest_trigger_check(killer, NULL, NULL, AQ_MOB_SAVE);
}

void die_in_dt(struct char_data * ch)
{

  if (FIGHTING(ch))
    stop_fighting(ch);

  while (ch->affected)
    affect_remove(ch, ch->affected);

  death_cry(ch);

  /*if ((!IS_NPC(ch)) && (!IS_NPC(killer)))
    REMOVE_BIT(PLR_FLAGS(ch), PLR_KILLER | PLR_THIEF);*/

  GET_DIED_S(ch) += 1;

	  sprintf(buf, "\r\n&W%s, after the last action you lost your fisical body...&n"
	  	       "&WFor now your are dead.&n\r\n"
	  	       "&WWait in the purgatory for your judgement.&n\r\n\r\n", GET_NAME(ch));
	  send_to_char(buf, ch);
  	  GET_HIT(ch) = 1;
  	  GET_MANA(ch) = 1;
  	  GET_MOVE(ch) = 1;
	  SET_BIT(PLR_FLAGS(ch), PLR_DEAD);
	    if (ch->in_room != NOWHERE)
	      char_from_room(ch);
	    char_to_room(ch, 3);
	    act("&B$n &bappears in a strange wortex of light, created by the &BW&ba&Br&bD&Bo&bm&Be.&n", FALSE, ch, 0, 0, TO_NOTVICT);
	  update_pos(ch);
          look_at_room(ch, 0);
}

void die(struct char_data * ch, struct char_data * killer)
{
  if (ch && killer)
    if ((!IS_NPC(ch)) && (!IS_NPC(killer)))
      REMOVE_BIT(PLR_FLAGS(ch), PLR_THIEF);

  raw_kill(ch, killer);
}



void perform_group_gain(struct char_data * ch, int base,
                             struct char_data * victim)
{
  int share, exp_max, penalti = 0;

  if(IS_NPC(ch))
   return;

  if(!IS_NPC(victim))
   return;

  if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
   return;

  if(GET_LEVEL(ch) < LVL_IMMORT)
	exp_max = (level_exp(GET_REMORT(ch), GET_LEVEL(ch) + 1) / MAX(1,(15 - (GET_REMORT(ch)))));
  else
	exp_max = 1;

  share = MIN(exp_max, MAX(1, base));

  /* Calculate level-difference bonus */
  if (IS_NPC(victim)) {
    if(GET_LEVEL(ch) > GET_LEVEL(victim)) {
	penalti = GET_LEVEL(ch)-GET_LEVEL(victim);
	penalti /= 10;
	penalti = (penalti > 10 ? 10 : penalti);
    }
    if(penalti > 0) {
	share *= (penalti == 10 ? 11 - penalti : 10 - penalti);
	share /= 12;
    }
  }

  if(AFF_FLAGGED(victim, AFF_HOLDED))
	share -= share / 10;

  if(GET_REMORT(ch) > GET_REMORT(victim))
  	share /= (GET_REMORT(ch) - GET_REMORT(victim));

  if(GET_REMORT(ch) == 0) // incentivo de jogo para
    share = share * 1.4 ; // players nao remorters

  if (share > 1) {
    sprintf(buf2, "&wYou receive your share of experience -- %s points.&n\r\n", add_points(share));
    send_to_char(buf2, ch);
  } else
    send_to_char("&wYou receive your share of experience -- &Wone &wmeasly little point!&n\r\n", ch);

  gain_exp(ch, share);
  change_alignment(ch, victim);
}


void group_gain(struct char_data * ch, struct char_data * victim)
{
  int tot_members, base, tot_gain;
  struct char_data *k;
  struct follow_type *f;

  if (!(k = ch->master))
    k = ch;

  if (AFF_FLAGGED(k, AFF_GROUP) && (k->in_room == ch->in_room))
    tot_members = 1;
  else
    tot_members = 0;

  for (f = k->followers; f; f = f->next)
    if (AFF_FLAGGED(f->follower, AFF_GROUP) && f->follower->in_room == ch->in_room)
      tot_members++;

  /* round up to the next highest tot_members */
  tot_gain = (GET_EXP(victim)) + tot_members - 1;

  /* prevent illegal xp creation when killing players */
  if (!IS_NPC(victim))
    tot_gain = MIN(max_exp_loss * 2 / 3, tot_gain);

  if (tot_members >= 1)
    base = MAX(1, tot_gain / tot_members);
  else
    base = 0;

  if (AFF_FLAGGED(k, AFF_GROUP) && k->in_room == ch->in_room)
    perform_group_gain(k, base, victim);

  for (f = k->followers; f; f = f->next)
    if (AFF_FLAGGED(f->follower, AFF_GROUP) && f->follower->in_room == ch->in_room)
      perform_group_gain(f->follower, base, victim);
}


void solo_gain(struct char_data * ch, struct char_data * victim)
{
  int exp, exp_max, penalti = 0;

  if(IS_NPC(ch))
   return;

  if(!IS_NPC(victim))
   return;

  if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
   return;

  if(GET_LEVEL(ch) < LVL_IMMORT)
	exp_max = (level_exp(GET_REMORT(ch), GET_LEVEL(ch) + 1) / MAX(1,(15 - (GET_REMORT(ch)))));
  else
	exp_max = 1;

  exp = MIN(exp_max, GET_EXP(victim));

  /* Calculate level-difference bonus */
  if (IS_NPC(victim)) {
    if(GET_LEVEL(ch) > GET_LEVEL(victim)) {
	penalti = GET_LEVEL(ch)-GET_LEVEL(victim);
	penalti /= 10;
	penalti = (penalti > 10 ? 10 : penalti);
    }
    if(penalti > 0) {
	exp *= (penalti == 10 ? 11 - penalti : 10 - penalti);
	exp /= 12;
    }
  }

  if(AFF_FLAGGED(victim, AFF_HOLDED))
	exp -= exp / 10;

  exp = MAX(exp, 1);

  if(GET_REMORT(ch) > GET_REMORT(victim))
  	exp /= (GET_REMORT(ch) - GET_REMORT(victim));

  if(GET_REMORT(ch) == 0) // incentivo de jogo para
    exp = exp * 1.4 ; // players nao remorters

  if (exp > 1) {
    sprintf(buf2, "&wYou receive &W%s &wexperience points.&n\r\n", add_points(exp));
    send_to_char(buf2, ch);
  } else
    send_to_char("&wYou receive &Wone &wlousy experience point.&n\r\n", ch);

  gain_exp(ch, exp);
  change_alignment(ch, victim);
}


char *replace_string(const char *str, const char *weapon_singular, const char *weapon_plural)
{
  static char buf[256];
  char *cp = buf;

  for (; *str; str++) {
    if (*str == '#') {
      switch (*(++str)) {
      case 'W':
        for (; *weapon_plural; *(cp++) = *(weapon_plural++));
        break;
      case 'w':
        for (; *weapon_singular; *(cp++) = *(weapon_singular++));
        break;
      default:
        *(cp++) = '#';
        break;
      }
    } else
      *(cp++) = *str;

    *cp = 0;
  }                             /* For */

  return (buf);
}
const char *porradinha[] =
{
"&ntickles",
"&nbruises",
"&nscratches",
"&ngrazes",
"&nnicks",
};

const char *porrada[] =
{
"&nscars",
"&nhits",
"&ninjures",
"&nwounds",
"&nmauls",
"&nmaims",
"&nmangles",
"&nmars",
"&GLACERATES",
"&BDECIMATES",
};

const char *porradona[] =
{
"&MDEVASTATES",
"&bERADICATES",
"&WOBLITERATES",
"&gEXTIRPATES",
"&CINCINERATES",
"&CMUTILATES",
"&RDISMEMBERS",
"&RMASSACRES",
"&BDISMEMBERS",
"&BRENDS",
"&Y- BLASTS -",
"&M-= DEMOLISHES =-",
"&Y** &WSHREDS &Y**",
"&M****&W DESTROYS&M ****",
};

const char *super_porrada[] =
{
"&W*****&C PULVERIZES&W *****",
"&B-=- VAPORIZES -=-",
"&M<-==-> &CATOMIZES &M<-==->",
"&C<&W-:-&C> &WASPHYXIATES &C<&W-:-&C>",
"&W<-*->&C RAVAGES &W<-*->",
"&M<>*<> &CFISSURES &M<>*<>",
"&Y<*>&R<*> &bLIQUIDATES &R<*>&Y<*>",
"&c<*>&Y<*> &GEVAPORATES &Y<*>&c<*>",
"&Y<-=-> &RSUNDERS &Y<-=->",
"&W<&G-&W><&G=&W> &GTEARS INTO &W<&G=&W><&G-&W>",
"&Y<->&B*&Y<=> &bWASTES &Y<->&B*&Y<=>",
"&R<-&W+&R-> &WCREMATES &R<-&W+&R->",
"&M<*>&R<*> ANNIHILATES <*>&M<*>",
"&g<--&G*&g-->&b IMPLODES &g<--&G*&g-->",
"&C<&W-&C><-=-> &WEXTERMINATES &C<-=->&C<&W-&C>",
};

const char *mega_porrada[] =
{
"&R<-=->&G<-=-> &RSHATTERS&G <-=->&R<-=->",
"&W<&G-&W:&G-&W> &YSLAUGHTERS &W<&G-&W:&G-&W>",
"&M<->&C<-*-> &MRUPTURES &C<-*->&M<->",
"&Y<-*->&R<*> &GNUKES &R<*>&Y<-*->",
"&B*&w#&B* &YEXPLODES &B*&w#&B*",
"&W<[=-=]&b<&w:&b> &WGLACIATES &b<&w:&b>&W[=-=]>",
"&R<-&w:&R-&w*&R-&w:&R-> &RMETEORITES &R<-&w:&R-&w*&R-&w:&R->",
"&Y<-&R:&Y-&R*&Y-&R:&Y-> &WSUPERNOVAS &Y<-&R:&Y-&R*&Y-&R:&Y->",
};

void nome_maiusculo(char *saida, char *entrada);

void nome_minusculo(char *saida, char *entrada)
{
	strcpy(saida, entrada);
	*saida = LOWER(entrada[0]);
}

void dam_message(int dam, struct char_data * ch, struct char_data * victim, int w_type)
{
	char pancada[5000], mens[MAX_INPUT_LENGTH], nome[2000];

	if(dam == 0)
		strcpy(pancada, "misses");
	else if(dam <= 10)
		strcpy(pancada, porradinha[(dam/2)-1]);
	else if(dam <= 30)
		strcpy(pancada, porrada[(dam/3)-1]);
	else if(dam <= 100)
		strcpy(pancada, porradona[(dam/7)-1]);
	else if(dam <= 300)
		strcpy(pancada, super_porrada[(dam/20)-1]);
	else if(dam <= 1000)
		strcpy(pancada, mega_porrada[(dam/125)-1]);
	else
		strcpy(pancada, mega_porrada[7]);

	w_type -= TYPE_HIT;

	sprintf(mens, "&c$U$n &W%s %s &c$u$N&W.&n",	attack_hit_text[w_type].singular,
			pancada);
  	act(mens, FALSE, ch, NULL, victim, TO_NOTVICT);

	nome_minusculo(nome, GET_NAME(victim));
	sprintf(mens, "&cYour &W%s %s &R%s&W. [&R%d&W]&n\r\n",
			attack_hit_text[w_type].singular, pancada, nome, dam);
	send_to_char(mens, ch);

	nome_maiusculo(nome, GET_NAME(ch));
	sprintf(mens, "&R%s &W%s %s &cyou&W. [&R%s%d&W]&n\r\n", nome,
			attack_hit_text[w_type].singular, pancada,
			((dam == 0) ? "" : "-"), dam);
	send_to_char(mens, victim);
}


/*
 * message for doing damage with a spell or skill
 *  C3.0: Also used for weapon damage on miss and death blows
 */
int skill_message(int dam, struct char_data * ch, struct char_data * vict,
                      int attacktype)
{
  int i, j, nr;
  struct message_type *msg;

  struct obj_data *weap = GET_EQ(ch, WEAR_WIELD);

  for (i = 0; i < MAX_MESSAGES; i++) {
    if (fight_messages[i].a_type == attacktype) {
      nr = dice(1, fight_messages[i].number_of_attacks);
      for (j = 1, msg = fight_messages[i].msg; (j < nr) && msg; j++)
        msg = msg->next;

      if (!IS_NPC(vict) && (GET_LEVEL(vict) >= LVL_IMMORT)) {
        act(msg->god_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
        act(msg->god_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT);
        act(msg->god_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
      } else if (dam != 0) {
        if (GET_POS(vict) == POS_DEAD) {
          send_to_char(CCYEL(ch, C_CMP), ch);
          act(msg->die_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
          send_to_char(CCNRM(ch, C_CMP), ch);

          send_to_char(CCRED(vict, C_CMP), vict);
          act(msg->die_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
          send_to_char(CCNRM(vict, C_CMP), vict);

          act(msg->die_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
        } else {
          send_to_char(CCYEL(ch, C_CMP), ch);
          act(msg->hit_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
          send_to_char(CCNRM(ch, C_CMP), ch);

          send_to_char(CCRED(vict, C_CMP), vict);
          act(msg->hit_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
          send_to_char(CCNRM(vict, C_CMP), vict);

          act(msg->hit_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
        }
      } else if (ch != vict) {  /* Dam == 0 */
        send_to_char(CCYEL(ch, C_CMP), ch);
        act(msg->miss_msg.attacker_msg, FALSE, ch, weap, vict, TO_CHAR);
        send_to_char(CCNRM(ch, C_CMP), ch);

        send_to_char(CCRED(vict, C_CMP), vict);
        act(msg->miss_msg.victim_msg, FALSE, ch, weap, vict, TO_VICT | TO_SLEEP);
        send_to_char(CCNRM(vict, C_CMP), vict);

        act(msg->miss_msg.room_msg, FALSE, ch, weap, vict, TO_NOTVICT);
      }
      return 1;
    }
  }
  return 0;
}

/*
 * Alert: As of bpl14, this function returns the following codes:
 *      < 0     Victim died.
 *      = 0     No damage.
 *      > 0     How much damage done.
 */
int damage(struct char_data * ch, struct char_data * victim, int dam, int attacktype)
{
  ACMD(do_get);
  ACMD(do_split);
  long local_gold = 0;
  int gb, ga;
  char local_buf[256];
  int dam_to_mana = 0, lucky, exp_max, x = 0, mvgasto, oxgasto = 0;
  struct obj_data *objX = GET_EQ(ch, WEAR_WIELD);


  if (GET_POS(victim) <= POS_DEAD) {
    log("SYSERR: Attempt to damage corpse '%s' in room #%d by '%s'.",
                GET_NAME(victim), GET_ROOM_VNUM(IN_ROOM(victim)), GET_NAME(ch));
    die(victim, ch);
    return 0;                   /* -je, 7/7/92 */
  }

  if(attacktype < 699 && attacktype > 614)
  {
  	sprintf(buf, "SYSERR: %s tentou derrubar usando arma alterada! Avisar Zaaroth!", GET_NAME(ch));
	mudlog(buf, BRF, LVL_ELDER, TRUE);
	return 0;
  }

  if(AFF2_FLAGGED(ch, AFF2_TERROR)) {
   send_to_char("You are too panicky to fight!!!\r\n", ch);
   return (0);
  }

  if (GET_MOB_VNUM(victim) == 16) {
    send_to_char("You hit the air when you cross the illusion.\r\n", ch);
    return 0;
  }

  /* peaceful rooms */
  if (ch != victim && ROOM_FLAGGED(ch->in_room, ROOM_PEACEFUL)) {
    send_to_char("&wThis room just has such a peaceful, easy feeling...&n\r\n", ch);
    return 0;
  }

  /* travar mobs atacando players fora do pk range */
  if(IS_NPC(ch) && ch->master) {
    if(!IS_NPC(victim) && !IS_NPC(ch->master) && !(attacktype == TYPE_SUFFERING || attacktype == SPELL_POISON)){
      if(!can_pk(ch->master, victim)){
        return 0;
      }
    }
  }

  /* travar players atacando mobs charmados fora do pk range */
  if(IS_NPC(victim) && victim->master) {
    if(!IS_NPC(ch) && !IS_NPC(victim->master) && !(attacktype == TYPE_SUFFERING || attacktype == SPELL_POISON)) {
      if(!can_pk(ch, victim->master)) {
        send_to_char("You cannot kill a charmed mob out of PK RANGE.\r\n", ch);
        return 0;
      }
    }
  }


  if(!IS_NPC(victim) && !IS_NPC(ch) && !(attacktype == TYPE_SUFFERING || attacktype == SPELL_POISON)){
    if(!can_pk(ch, victim)){
      send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
      return 0;
    }
  }

  /* entangled */
  if (IS_AFFECTED(ch, AFF_TANGLED)) {
    send_to_char("You struggle against your bonds...\r\n", ch);

    if(number(0, 30) < number(10, 50))
       unentangle(ch);

    return 0;
  }

  /* shopkeeper protection */
  if (!ok_damage_shopkeeper(ch, victim))
    dam = 0;

  /* You can't damage an immortal! */
  if (!IS_NPC(victim) && (GET_LEVEL(victim) >= LVL_IMMORT))
    dam = 0;

  if (victim != ch) {
    /* Start the attacker fighting the victim */
    if (GET_POS(ch) > POS_STUNNED && (FIGHTING(ch) == NULL))
      set_fighting(ch, victim);

    /* Start the victim fighting the attacker */
    if (GET_POS(victim) > POS_STUNNED && (FIGHTING(victim) == NULL)) {
      set_fighting(victim, ch);
      if (MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch))
        remember(victim, ch);
    }
  }

  if(GET_RACE(victim) == RACE_ORC)
   if(objX)
    if (GET_OBJ_VNUM(objX) == 10113)
     dam = dam * 2 ;


  if(attacktype < 0 || attacktype >= MAX_SPELLS) {
    /* gastar movimento quando bate :) */
    if(!IS_NPC(ch) && GET_LEVEL(ch) < LVL_IMMORT && GET_LEVEL(ch) > 5) {
      if (GET_MOVE(ch) <= 5) {
         send_to_char("&WYou can't hit, you are too exhausted to move yourself.&n\r\n", ch);
         return (0);
      } else {
         mvgasto = number(1, 3);
         GET_MOVE(ch) -= mvgasto;
      }
    }

     oxgasto = 1 ;
  // gastar oxigenao
    if(!IS_NPC(ch) && GET_LEVEL(ch) < LVL_IMMORT && GET_LEVEL(ch) > 5){
     if (GET_OXI(ch) <= 5){
        send_to_char("&CYou can't hit anymore. &WYou are out of gas, take a break!&n\r\n", ch);
         return (0);
     } else
        GET_OXI(ch) -= oxgasto;
    }
  }

  /* If you attack a pet, it hates your guts */
  if (victim->master == ch)
    stop_follower(victim);

  /* If the attacker is invisible, he becomes visible */
  if (AFF_FLAGGED(ch, AFF_INVISIBLE | AFF_HIDE))
    appear(ch);

  /* Cut damage in half if victim has sanct, to a minimum 1 */
  if (AFF_FLAGGED(victim, AFF_SANCTUARY) && dam >= 2)
    dam -= dam / 6;

 if(AFF2_FLAGGED(victim, AFF2_DEATHDANCE))
      dam *= 1.3;

 if(AFF2_FLAGGED(ch, AFF2_DEATHDANCE))
      dam *= 1.3;

 if(AFF2_FLAGGED(ch, AFF2_MUIR1))
 {  
  if(IS_EVIL(victim))
    dam = dam + GET_LEVEL(ch);
 }

 if(AFF2_FLAGGED(victim, AFF2_ILMANATEUR1))
  dam = dam * 0.5 ; 

 if(GET_CHA(victim) > 11)
      dam = dam * 31 / (GET_CHA(victim) + 20) ; // diminui um pouco o dano
                                              // pra quem tem carisma > 11

  if(AFF2_FLAGGED(victim, AFF2_BANSHEE) && !AFF2_FLAGGED(ch, AFF2_BANSHEE)){
   if( dam/2 > 0 && number(0,1))
   {
    damage(victim,ch, dam/2, SPELL_BANSHEE_AURA);
    if(ch == NULL)
     return 0 ;
    if (GET_POS(ch) <= POS_DEAD)
     return 0;
   }
  }

  /* Cut damage in half if victim has satan, to a minimum 1 */
  if (AFF_FLAGGED(victim, AFF_SATAN) && dam >= 2)
    dam -= dam / 5;

  /* Cut damage in half if victim has god, to a minimum 1 */
  if (AFF_FLAGGED(victim, AFF_GOD) && dam >= 2)
    dam -= dam / 5;

  if (!IS_NPC(victim) && GET_SKILL(victim, SKILL_AGILITY)
   && number(0, 360) <= GET_SKILL(victim, SKILL_AGILITY) / 2 + GET_DEX(victim) / 5
   && !(attacktype == TYPE_SUFFERING || attacktype == SPELL_POISON)){
    improve_skill(victim, SKILL_AGILITY);
    dam /= 2;
    x = 1;
  }

  /* Check for PK if this is not a PK MUD */
/*  if (!pk_allowed) {
    check_killer(ch, victim);
    if (PLR_FLAGGED(ch, PLR_KILLER) && (ch != victim))
      dam = 0;
  }*/

  /* Set the maximum damage per round and subtract the hit points */
  lucky = number(0, 150);
  if (GET_LUK(ch) > lucky) {
      if ((attacktype >= TYPE_HIT) && (attacktype <= TYPE_STAB))
	 dam = MAX(MIN((dam * 1.25), 5000), 0);
      else
         dam = MAX(MIN((dam * 1.25), 10000), 0);

  } else if (!IS_NPC(ch) && GET_SKILL(ch, SKILL_CRITICAL_ATTACK) > number(1, 150)) {
	if ((attacktype >= TYPE_HIT) && (attacktype <= TYPE_STAB))
	 dam = MAX(MIN((dam * 1.175), 5000), 0);
	else
	 dam = MAX(MIN((dam * 1.175), 10000), 0);
	improve_skill(ch, SKILL_CRITICAL_ATTACK);
  } else
       if ((attacktype >= TYPE_HIT) && (attacktype <= TYPE_STAB))
	 dam = MAX(MIN(dam, 5000), 0);
       else
         dam = MAX(MIN(dam, 10000), 0) ;

   if (!IS_NPC(victim) && (GET_LEVEL(victim) <= 5 ) && (GET_LEVEL(ch) <= 6 )){
       dam = dam/1.5;
   }

  /* FIRESHIELD retorna um ataque com 1/3 do damage de quem atacou */
  if (dam >= 0) {
   if ((attacktype >= TYPE_HIT) && (attacktype <= TYPE_STAB) &&
     (number(1, 200) < GET_LEVEL(victim)) )   {
      if (IS_AFFECTED(victim, AFF_FIRESHIELD) &&
         !IS_AFFECTED(ch, AFF_FIRESHIELD))      {
	if (damage(victim, ch, MAX(1,MIN((dam/(number(1,4))), 100)),
           TYPE_UNDEFINED) ){
          if(ch == NULL)
           return 0 ;
          if (GET_POS(ch) <= POS_DEAD)
           return 0;
          act("You burned in the $N's fire shield.", FALSE, ch, 0, victim, TO_CHAR);
          act("$U$n burns in your fire shield.", FALSE, ch, 0, victim, TO_VICT);
	}
      }
    }
  }

  if (affected_by_spell(victim, SPELL_MANA_SHIELD)) {
    dam_to_mana = dam * 1.4 ;
    if (dam_to_mana > GET_MANA(victim)) {
      affect_from_char(victim, SPELL_MANA_SHIELD);
      act("&w$U$n destroys $N's magic barrier!!&n", FALSE, ch, NULL, victim, TO_NOTVICT);
      act("&wYou destroy $N's magic barrier!!&n", FALSE, ch, NULL, victim, TO_CHAR);
      act("&w$U$n destroys your magic barrier!!&n", FALSE, ch, NULL, victim, TO_VICT | TO_SLEEP);
      dam_to_mana = GET_MANA(victim);
    }
    GET_MANA(victim) -= dam_to_mana;
    dam = dam - (dam_to_mana/1.7) ;
  }

  GET_HIT(victim) -= dam;

  /* Gain exp for the hit */
  if(GET_LEVEL(ch) < LVL_IMMORT)
	exp_max = (level_exp(GET_REMORT(ch), GET_LEVEL(ch) + 1) / 200);
  else
	exp_max = 1;

  if (ch != victim && IS_NPC(victim) && !ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
    gain_exp(ch, MIN(7500, (((GET_EXP(victim)*0.1)*dam)/(GET_LEVEL(ch)*100))));

  update_pos(victim);

  /*
   * skill_message sends a message from the messages file in lib/misc.
   * dam_message just sends a generic "You hit $n extremely hard.".
   * skill_message is preferable to dam_message because it is more
   * descriptive.
   *
   * If we are _not_ attacking with a weapon (i.e. a spell), always use
   * skill_message. If we are attacking with a weapon: If this is a miss or a
   * death blow, send a skill_message if one exists; if not, default to a
   * dam_message. Otherwise, always send a dam_message.
   */
  if(!x){
    if (!IS_WEAPON(attacktype))
      skill_message(dam, ch, victim, attacktype);
    else {
      if (GET_POS(victim) == POS_DEAD || dam == 0) {
        if (!skill_message(dam, ch, victim, attacktype))
          dam_message(dam, ch, victim, attacktype);
      } else {
        dam_message(dam, ch, victim, attacktype);
      }
    }
  } else {
    act("&yYou &Yevade&y $N &yattack and suffer a lower &Ydamage&y!&n", FALSE, victim, 0, ch, TO_CHAR);
    act("&y$U$n &Yevades&y your &yattack and suffer a lower &Ydamage&y!&n", FALSE, victim, 0, ch, TO_VICT);
    act("&y$U$n &Yevades&y $N's &yattack and suffer a lower &Ydamage&y!&n", FALSE, victim, 0, ch, TO_NOTVICT);
  }

  if(!IS_NPC(victim) && !(attacktype == TYPE_SUFFERING || attacktype == SPELL_POISON))
     DamageStuff(victim);

  /* Use send_to_char -- act() doesn't send message if you are DEAD. */
  switch (GET_POS(victim)) {
  case POS_MORTALLYW:
    act("&r$U$n is mortally wounded, and will die soon, if not aided.&n", TRUE, victim, 0, 0, TO_ROOM);
    send_to_char("&RYou are mortally wounded, and will die soon, if not aided.&n\r\n", victim);
    break;
  case POS_INCAP:
    act("&r$U$n is incapacitated and will slowly die, if not aided.&n", TRUE, victim, 0, 0, TO_ROOM);
    send_to_char("&RYou are incapacitated an will slowly die, if not aided.&n\r\n", victim);
    break;
  case POS_STUNNED:
    act("&r$U$n is stunned, but will probably regain consciousness again.&n", TRUE, victim, 0, 0, TO_ROOM);
    send_to_char("&RYou're stunned, you just can see the stars around you.&n\r\n", victim);
    break;
  case POS_DEAD:
    act("&R$U$n is dead!  &RR&r.&RI&r.&RP.&n", FALSE, victim, 0, 0, TO_ROOM);
    send_to_char("&RYou are dead!  Sorry...&n\r\n", victim);
    break;

  default:                      /* >= POSITION SLEEPING */
    if (dam > (GET_MAX_HIT(victim) / 4))
      act("&rThat really did &RHURT!&n", FALSE, victim, 0, 0, TO_CHAR);

    if (GET_HIT(victim) < (GET_MAX_HIT(victim) / 6)) {
      sprintf(buf2, "&rYou wish that your wounds would stop &RBLEEDING &rso much!&n\r\n");
      send_to_char(buf2, victim);
      if (ch != victim && MOB_FLAGGED(victim, MOB_WIMPY))
        do_flee(victim, NULL, 0, 0);
    }
  }


  /* stop someone from fighting if they're stunned or worse */
  if ((GET_POS(victim) <= POS_STUNNED) && (FIGHTING(victim) != NULL))
    stop_fighting(victim);

  /* Uh oh.  Victim died. */
  if (GET_POS(victim) == POS_DEAD) {
    if ((ch != victim) && (IS_NPC(victim) || victim->desc)) {
      if (AFF_FLAGGED(ch, AFF_GROUP))
        group_gain(ch, victim);
      else
        solo_gain(ch, victim);
    }

    if (!IS_NPC(victim)) {
      if(!IS_NPC(ch))
      	GET_KPS(ch) += 1;

      if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA))
          GET_ARENA_KILLED(ch) += 1;
      else
          GET_KILLED(ch) += 1;

      sprintf(buf2, "%s (%d) %s by %s (%d) at %s [%d]",
              GET_NAME(victim), GET_LEVEL(victim),
              (IS_NPC(ch)?"killed":"assassinated"),
              GET_NAME(ch), GET_LEVEL(ch),
              world[victim->in_room].name, GET_ROOM_VNUM(victim->in_room));
      mudlog(buf2, BRF, LVL_ELDER, TRUE);
    } else {
      if(!IS_NPC(ch))
       	GET_KMS(ch) += 1;
    }

      if (MOB_FLAGGED(ch, MOB_MEMORY))
        forget(ch, victim);

    if (IS_NPC(victim)) {
      local_gold = GET_GOLD(victim);
      sprintf(local_buf, "%ld", (long)local_gold);
    }

    die(victim, ch);
    return_wanted_gain(ch, victim);

    gb = 0;
    ga = 0;

    if (IS_NPC(victim) && !IS_NPC(ch) && PRF_FLAGGED(ch, PRF_AUTOLOOT)) {
      send_to_char("\r\n", ch);
      gb = GET_GOLD(ch);
      do_get(ch,"all corpse",0,0);
      ga = GET_GOLD(ch);
    }
    if (IS_NPC(victim) && !IS_NPC(ch) && PRF_FLAGGED(ch, PRF_AUTOGOLD) &&
       (local_gold > 0) && !PRF_FLAGGED(ch, PRF_AUTOLOOT)) {
      send_to_char("\r\n", ch);
      gb = GET_GOLD(ch);
      do_get(ch,"all.gold corpse",0,0);
      ga = GET_GOLD(ch);
    }
    if (!IS_NPC(ch) && IS_AFFECTED(ch, AFF_GROUP) && (local_gold > 0) &&
        PRF_FLAGGED(ch, PRF_AUTOSPLIT) && (PRF_FLAGGED(ch, PRF_AUTOLOOT)
        || PRF_FLAGGED(ch, PRF_AUTOGOLD)))
      if (ga > gb)
        do_split(ch,local_buf,0,0);


    return -1;
  }
  return dam;
}

int prof_ac(struct char_data * ch)
{
  struct obj_data *wielded = GET_EQ(ch, WEAR_WIELD);
  int i, acprof = 0;

  for (i = MAX_SPELLS + 1; i < MAX_SKILLS + 1; i++)
   if (!IS_NPC(ch))
    if ((i >= SKILL_HIT && i <= SKILL_STAB) && GET_SKILL(ch, i) > 0)
      if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON && (GET_OBJ_VAL(wielded, 3) == (i - SKILL_HIT))){
 	acprof = GET_SKILL(ch, i)/2;
        improve_skill(ch, i);
      }

 return (acprof);
}

int defender(struct char_data *ch, struct char_data *victim)
{
   double x;

   x = app_style[GET_STYLE(victim)+1][0];
   x *= 3;
   x /= 10;
   x = 1 - x;

   if (!IS_NPC(victim) && (GET_SKILL(victim, SKILL_PARRY) > 0) && (number(1, 300) < ((GET_SKILL(victim, SKILL_PARRY)*x)-encumberance_level(victim))) && (GET_POS(victim) == POS_FIGHTING)) {
    act("&BYou skillfully &Cparry&B $N attack!&n", FALSE, victim, 0, ch, TO_CHAR);
    act("&B$n skillfully &Cparries&B your attack!&n", FALSE, victim, 0, ch, TO_VICT);
    act("&B$n skillfully &Cparries&B $N attack!&n", FALSE, victim, 0, ch, TO_NOTVICT);
    improve_skill(victim, SKILL_PARRY);
    return 1;
  }
  else if (!IS_NPC(victim) && (GET_SKILL(victim, SKILL_DODGE) > 0) && (number(1, 300) < ((GET_SKILL(victim, SKILL_DODGE)*x)-encumberance_level(victim))) && (GET_POS(victim) == POS_FIGHTING)) {
    act("&BYou skillfully &Cdodge&B $N attack!&n", FALSE, victim, 0, ch, TO_CHAR);
    act("&B$n skillfully &Cdodges&B your attack!&n", FALSE, victim, 0, ch, TO_VICT);
    act("&B$n skillfully &Cdodges&B $N attack!&n", FALSE, victim, 0, ch, TO_NOTVICT);
    improve_skill(victim, SKILL_DODGE);
    return 1;
  }

  else if (!IS_NPC(victim) && (GET_SKILL(victim, SKILL_TUMBLE) > 0) && (number(1, 300) < ((GET_SKILL(victim, SKILL_TUMBLE)*x)-encumberance_level(victim))) && (GET_POS(victim) == POS_FIGHTING)) {
    act("&BYou skillfully &Ctumble&B $N attack!&n", FALSE, victim, 0, ch, TO_CHAR);
    act("&B$n skillfully &Ctumbles&B your attack!&n", FALSE, victim, 0, ch, TO_VICT);
    act("&B$n skillfully &Ctumbles&B $N attack!&n", FALSE, victim, 0, ch, TO_NOTVICT);
    improve_skill(victim, SKILL_TUMBLE);
    return 1;
  }
  else if (!IS_NPC(victim) && (GET_SKILL(victim, SKILL_SHIELD_BLOCK) > 0) && (GET_EQ(victim, WEAR_SHIELD)) && (number(1, 300) < ((GET_SKILL(victim, SKILL_SHIELD_BLOCK)*x)-encumberance_level(victim))) && (GET_POS(victim) == POS_FIGHTING)){
    act("&BYou skillfully &Cshield block&B $N attack!&n", FALSE, victim, 0, ch, TO_CHAR);
    act("&B$n skillfully &Cshield blocks&B your attack!&n", FALSE, victim, 0, ch, TO_VICT);
    act("&B$n skillfully &Cshield blocks&B $N attack!&n", FALSE, victim, 0, ch, TO_NOTVICT);
    improve_skill(victim, SKILL_SHIELD_BLOCK);
    return 1;
  }
  else if (AFF2_FLAGGED(victim, AFF2_BLINK) && (number(1, 500) <
GET_SKILL(victim, SPELL_BLINK))) {
    act("$N blinks away from your attack.", FALSE, ch, 0, victim, TO_CHAR);
    act("$N blinks out of $n's way.", FALSE, ch, 0, victim, TO_NOTVICT);
    act("You blink out of $n's way.", FALSE, ch, 0, victim, TO_VICT);
    return 1;
  }
 return 0;
}

void hit(struct char_data * ch, struct char_data * victim, int type)
{
  struct obj_data *wielded = GET_EQ(ch, WEAR_WIELD);
  int w_type, victim_ac, calc_thaco, dam, diceroll;

  if (victim == NULL)
    return;

  if(AFF_FLAGGED(ch, AFF_HOLDED))
    return;

  if(!IS_NPC(victim) && type != SKILL_BACKSTAB)
     if(defender(ch, victim))
        return;

  /* check if the character has a fight trigger */
  fight_mtrigger(ch);

  if (ch->in_room != victim->in_room) {
    if (FIGHTING(ch) && FIGHTING(ch) == victim)
      stop_fighting(ch);
    return;
  }

  /* Find the weapon type (for display purposes only) */
  if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON)
    w_type = GET_OBJ_VAL(wielded, 3) + TYPE_HIT;
  else {
    if (IS_NPC(ch) && (ch->mob_specials.attack_type != 0))
      w_type = ch->mob_specials.attack_type + TYPE_HIT;
    else
      w_type = TYPE_HIT;
  }

  /* Calculate the THAC0 of the attacker */
  if (!IS_NPC(ch))
    calc_thaco = thaco((int) GET_CLASS(ch), (int) GET_LEVEL(ch));
  else          /* THAC0 for monsters is set in the HitRoll */
    calc_thaco = (18 - (GET_LEVEL(ch) / 9.9));

  calc_thaco -= str_app[STRENGTH_APPLY_INDEX(ch)].tohit;
  if (!IS_NPC(ch))
   calc_thaco -= GET_HITROLL(ch)/2;
  else
   calc_thaco -= GET_HITROLL(ch)/2;
  calc_thaco -= (int) ((GET_INT(ch) - 13) / 2);       /* Intelligence helps! */
  calc_thaco -= (int) ((GET_WIS(ch) - 13) / 2);       /* So does wisdom */

  /* Calculate the raw armor including magic armor.  Lower AC is better. */
  victim_ac = (GET_AC(victim) + prof_ac(ch)) / 10;
  if (IS_AFFECTED(victim, AFF_BERZERK))
	victim_ac += 2;
  else if (AWAKE(victim))
    victim_ac += dex_app[GET_DEX(victim)].defensive;

  victim_ac = MAX(-100, victim_ac);      /* -10 is lowest */

  /* roll the die and take your chances... */
  diceroll = number(1, 20);

  /* decide whether this is a hit or a miss */
  if ((((diceroll < 20) && AWAKE(victim)) &&
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac)))) {
    /* the attacker missed the victim */
    if (type == SKILL_BACKSTAB)
      damage(ch, victim, 0, SKILL_BACKSTAB);
    else
      damage(ch, victim, 0, w_type);
    return;
  } else {
    /* okay, we know the guy has been hit.  now calculate damage. */

    /* Start with the damage bonuses: the damroll and strength apply */
    dam = str_app[STRENGTH_APPLY_INDEX(ch)].todam;

    dam += GET_DAMROLL(ch);

    /* Maybe holding arrow? */
    if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON) {
      /* Add weapon-based damage if a weapon is being wielded */
      dam += ((dice(GET_OBJ_VAL(wielded, 1), GET_OBJ_VAL(wielded, 2))*GET_OBJ_COND(wielded))/100);
    } else {
      /* If no weapon, add bare hand damage instead */
      if (IS_NPC(ch)) {
	dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice);
      } else {
        dam += number(GET_LEVEL(ch) / 40, GET_LEVEL(ch) / 20);
      }
    }

 /* se ele tiver a hand damage skill aumenta o dano em no max 5 */
    if(!IS_NPC(ch)){
       if (!wielded && GET_SKILL(ch, SKILL_HAND_DAMAGE)){
          dam += 1 + (SKILL_HAND_DAMAGE / 50);
	  improve_skill(ch, SKILL_HAND_DAMAGE);
       }
    }

    /*
     * Include a damage multiplier if victim isn't ready to fight:
     *
     * Position sitting  1.33 x normal
     * Position resting  1.66 x normal
     * Position sleeping 2.00 x normal
     * Position stunned  2.33 x normal
     * Position incap    2.66 x normal
     * Position mortally 3.00 x normal
     *
     * Note, this is a hack because it depends on the particular
     * values of the POSITION_XXX constants.
     */
    if (GET_POS(victim) < POS_FIGHTING)
      dam *= 1 + (POS_FIGHTING - GET_POS(victim)) / 3;

    /* at least 1 hp damage min per hit */
    dam = MAX(1, dam);
	if (IS_AFFECTED(ch, AFF_BERZERK))
	    dam += number(1, MAX(1,(dam/4)) );

    if(GET_RACE(ch) == RACE_HILL_OGRE || (GET_RACE(ch) == RACE_DRACONIAN && number(1,12) ==
3)) dam = dam * 1.2 ;

    if(GET_RACE(victim) == RACE_NAUGRIM || (GET_RACE(victim) == RACE_DRACONIAN &&
number(1,12)== 3)) dam = MAX(1 , dam * 0.8) ;

    if (type == SKILL_BACKSTAB) {
      dam *= backstab_mult(GET_LEVEL(ch));
      if(GET_CLASS(ch) == CLASS_THIEF)
       dam = dam * 2 ;
      damage(ch, victim, dam, SKILL_BACKSTAB);
    }
    else if (type == SKILL_COMBO) {
      dam *= 0.90;
      damage(ch, victim, dam, w_type);
    }
    else
      damage(ch, victim, dam, w_type);
  }

  /* check if the victim has a hitprcnt trigger */
 // hitprcnt_mtrigger(victim);
}

void hit2(struct char_data * ch, struct char_data * victim, int type)
{
  struct obj_data *wielded = GET_EQ(ch, WEAR_DWIELD);
  int w_type, victim_ac, calc_thaco, dam, diceroll;

  if (victim == NULL)
    return;
  if(!IS_NPC(victim) && (!IS_NPC(ch) && (PLR_FLAGGED(ch, PLR_NOPK)))
     && (!(ROOM_FLAGGED(ch->in_room, ROOM_ARENA))) && (!(ROOM_FLAGGED(ch->in_room, ROOM_ARENA)))){
    send_to_char("&wYou can't fight because you aren't a player killer...&n\r\n", ch);
    return;
  }
  if(!IS_NPC(ch) && (!IS_NPC(victim) && (PLR_FLAGGED(victim, PLR_NOPK)))
     && (!(ROOM_FLAGGED(ch->in_room, ROOM_ARENA))) && (!(ROOM_FLAGGED(ch->in_room, ROOM_ARENA)))){
    send_to_char("&wYou can't fight because your opponent isn't a player killer...&n\r\n", ch);
    return;
  }
  if(AFF_FLAGGED(ch, AFF_HOLDED))
    return;

  if(!IS_NPC(victim) && type != SKILL_BACKSTAB)
     if(defender(ch, victim))
        return;

  /* check if the character has a fight trigger */
  fight_mtrigger(ch);

  if (ch->in_room != victim->in_room) {
    if (FIGHTING(ch) && FIGHTING(ch) == victim)
      stop_fighting(ch);
    return;
  }

  /* Find the weapon type (for display purposes only) */
  if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON)
    w_type = GET_OBJ_VAL(wielded, 3) + TYPE_HIT;
  else {
    if (IS_NPC(ch) && (ch->mob_specials.attack_type != 0))
      w_type = ch->mob_specials.attack_type + TYPE_HIT;
    else
      w_type = TYPE_HIT;
  }

  /* Calculate the THAC0 of the attacker */
  if (!IS_NPC(ch))
    calc_thaco = thaco((int) GET_CLASS(ch), (int) GET_LEVEL(ch));
  else          /* THAC0 for monsters is set in the HitRoll */
    calc_thaco = (19 - (GET_LEVEL(ch) / 9.9));
  calc_thaco -= str_app[STRENGTH_APPLY_INDEX(ch)].tohit;
  if (!IS_NPC(ch))
   calc_thaco -= GET_HITROLL(ch)/2;
  else
   calc_thaco -= GET_HITROLL(ch)/2;
  calc_thaco -= (int) ((GET_INT(ch) - 13) / 2);       /* Intelligence helps! */
  calc_thaco -= (int) ((GET_WIS(ch) - 13) / 2);       /* So does wisdom */

  /* Calculate the raw armor including magic armor.  Lower AC is better. */
  victim_ac = (GET_AC(victim) + prof_ac(ch)) / 10;
  if (IS_AFFECTED(victim, AFF_BERZERK))
	victim_ac += 2;
  else if (AWAKE(victim))
    victim_ac += dex_app[GET_DEX(victim)].defensive;

  victim_ac = MAX(-30, victim_ac);      /* -10 is lowest */

  /* roll the die and take your chances... */
  diceroll = number(1, 20);

  /* decide whether this is a hit or a miss */
  if ((((diceroll < 20) && AWAKE(victim)) &&
       ((diceroll == 1) || ((calc_thaco - diceroll) > victim_ac)))) {
    /* the attacker missed the victim */
    if (type == SKILL_BACKSTAB)
      damage(ch, victim, 0, SKILL_BACKSTAB);
    else
      damage(ch, victim, 0, w_type);
    return;
  } else {
    /* okay, we know the guy has been hit.  now calculate damage. */

    /* Start with the damage bonuses: the damroll and strength apply */
    dam = str_app[STRENGTH_APPLY_INDEX(ch)].todam;

    dam += (GET_DAMROLL(ch))*0.4;

    if (wielded) {
      /* Add weapon-based damage if a weapon is being wielded */
      if (IS_NPC(ch)){
       if ((dice(GET_OBJ_VAL(wielded, 1), GET_OBJ_VAL(wielded, 2))) >
       	  (dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice)*0.6)){
        dam += (((dice(GET_OBJ_VAL(wielded, 1), GET_OBJ_VAL(wielded, 2))*0.4)*(GET_OBJ_COND(wielded)))/100);
       }
       else{
        dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice)*0.6;
       }
      }
      else {
       dam += (((dice(GET_OBJ_VAL(wielded, 1), GET_OBJ_VAL(wielded, 2))*0.4)*(GET_OBJ_COND(wielded)))/100);
      }
    } else {
      /* If no weapon, add bare hand damage instead */
      if (IS_NPC(ch)) {
        dam += dice(ch->mob_specials.damnodice, ch->mob_specials.damsizedice)*0.6;
      } else {
        dam += number(GET_LEVEL(ch) / 40, GET_LEVEL(ch) / 20);
      }
    }

 /* se ele tiver a hand damage skill aumenta o dano em no max 5 */
    if(!IS_NPC(ch)){
       if (!wielded && GET_SKILL(ch, SKILL_HAND_DAMAGE))
          dam += 1 + (SKILL_HAND_DAMAGE / 50);
	  improve_skill(ch, SKILL_HAND_DAMAGE);
    }

    /*
     * Include a damage multiplier if victim isn't ready to fight:
     *
     * Position sitting  1.33 x normal
     * Position resting  1.66 x normal
     * Position sleeping 2.00 x normal
     * Position stunned  2.33 x normal
     * Position incap    2.66 x normal
     * Position mortally 3.00 x normal
     *
     * Note, this is a hack because it depends on the particular
     * values of the POSITION_XXX constants.
     */
    if (GET_POS(victim) < POS_FIGHTING)
      dam *= 1 + (POS_FIGHTING - GET_POS(victim)) / 3;

    /* at least 1 hp damage min per hit */
    dam = MAX(1, dam);
	if (IS_AFFECTED(ch, AFF_BERZERK))
	    dam += number(1, MAX(1,(dam/4)) );

    if(GET_RACE(ch) == RACE_HILL_OGRE || (GET_RACE(ch) == RACE_DRACONIAN && number(1,12) ==
3)) dam = dam * 1.2 ;

    if(GET_RACE(victim) == RACE_NAUGRIM || (GET_RACE(victim) == RACE_DRACONIAN &&
number(1,12) == 3)) dam = MAX(1 , dam * 0.8) ;

    if (type == SKILL_BACKSTAB) {
      dam *= backstab_mult(GET_LEVEL(ch));
      if(GET_CLASS(ch) == CLASS_THIEF)
       dam = dam * 2 ;

      damage(ch, victim, dam, SKILL_BACKSTAB);
    }
    else if (type == SKILL_COMBO) {
      dam *= 0.90;
      damage(ch, victim, dam, w_type);
    }
    else
      damage(ch, victim, dam, w_type);
  }

  /* check if the victim has a hitprcnt trigger */
// hitprcnt_mtrigger(victim);
}

#define MAX_STYLES	4

const char *estyles[] = {
/*-1*/     NULL,
/*0*/      "standard",
/*1*/      "defensive",
/*2*/      "offensive",
/*3*/      "pro",
/*END*/    "\n"
};

ACMD(do_style)
{
  int x = 0;
  bool t = FALSE;

  one_argument(argument, arg);

  if(!*arg) {
	sprintf(buf2, "&WYou current style is &g%s&W.&n\r\n", estyles[GET_STYLE(ch)+1]);
	send_to_char(buf2, ch);
	return;
  } else {
	for(x = 0; x < MAX_STYLES; x++)
	  if(isname(arg, estyles[x+1])) {
	     if(x == 3 && !GET_SKILL(ch, SKILL_STYLE_PRO)) {
	        send_to_char("You need to learn the pro style to fight like that.\r\n", ch);
		return;
	     }
	     GET_STYLE(ch) = x;
	     t = TRUE;
        }

	if(t) {
          sprintf(buf2, "&WYou changed your style to &g%s&W.&n\r\n", estyles[GET_STYLE(ch)+1]);
	  send_to_char(buf2, ch);
	} else
	  send_to_char("&WUsage: &Bstyle &W<&cdefensive&W/&Roffensive&W/&nstandard&W/&Cpro&W>&n\r\n", ch);
  }
}

/* 2 ruim, 1 medio, 0 bom */
int app_style[][3] = {
/*		DEFESA		ATAQUE		qqcoisa	*/
/*standard*/	{2, 		2,		 2},
/*standard*/	{1, 		1,		 2},
/*defensive*/	{0, 		2,		 1},
/*offensive*/	{2, 		0,		 3},
/*  pro	*/	{0, 		0,		 3}
};

void atacar(struct char_data *ch)
{
   sh_int max = 0, norm = 0, prob = 0, num = 0, at = 0;
   double x;

   max += GET_SKILL_LS(ch, SKILL_SECOND_ATTACK);
   max += GET_SKILL_LS(ch, SKILL_THIRD_ATTACK);
   max += GET_SKILL_LS(ch, SKILL_FOURTH_ATTACK);

   at += (GET_SKILL_LS(ch, SKILL_SECOND_ATTACK) ? 1 : 0);
   at += (GET_SKILL_LS(ch, SKILL_THIRD_ATTACK) ? 1 : 0);
   at += (GET_SKILL_LS(ch, SKILL_FOURTH_ATTACK) ? 1 : 0);

   norm = max/(app_style[GET_STYLE(ch)+1][1]+1);

   prob = number(0, max);
   prob += (IS_CARRYING_W(ch)/10);
   if(GET_EQ(ch, WEAR_WIELD))
     prob += GET_OBJ_WEIGHT(GET_EQ(ch, WEAR_WIELD));

   norm += GET_DEX(ch)*2;

   if(AFF2_FLAGGED(ch, AFF2_SLOW))
   		norm *= 0.15;

   x = app_style[GET_STYLE(ch)+1][2];
   x /= 10;
   for(; at && norm > prob && num < app_style[GET_STYLE(ch)+1][2]; at--)
   {
       	hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
       	norm -= norm*x;
		improve_skill(ch, (SKILL_SECOND_ATTACK+num));
		num++;
   }
}

/* control the fights going on.  Called every 2 seconds from comm.c. */
void perform_violence(void)
{
  struct char_data *ch;
  struct follow_type *k;
  int perc, val;

  ACMD(do_assist);

  for (ch = combat_list; ch; ch = next_combat_list) {
    next_combat_list = ch->next_fighting;

    if (FIGHTING(ch) == NULL || ch->in_room != FIGHTING(ch)->in_room) {
      stop_fighting(ch);
      continue;
    }

    if (IS_NPC(ch)) {
      if(contar_briga(ch) > 1)
      FIGHTING(ch) = melhor_alvo(ch);

      if (GET_MOB_WAIT(ch) > 0) {
        GET_MOB_WAIT(ch) -= PULSE_VIOLENCE;
        continue;
      }
      GET_MOB_WAIT(ch) = 0;

      if (GET_POS(ch) < POS_FIGHTING) {
        GET_POS(ch) = POS_FIGHTING;
        act("&w$U$n scrambles to $s feet!&n", TRUE, ch, 0, 0, TO_ROOM);
      }
    }

    if (GET_POS(ch) < POS_FIGHTING) {
      send_to_char("&WYou can't fight while sitting!!!&n\r\n", ch);
      continue;
    }

    /*mob_ia(ch);*/
    hit(ch, FIGHTING(ch), TYPE_UNDEFINED);

    for (k = ch->followers; k; k=k->next) {
      if (!IS_NPC(k->follower) && PRF_FLAGGED(k->follower, PRF_AUTOASSIST) &&
         (k->follower->in_room == ch->in_room) && GET_POS(k->follower) > POS_FIGHTING)
         do_assist(k->follower, GET_NAME(ch), 0, 0);
    }

    if (!IS_NPC(ch))
    {
      	atacar(ch);
      	if ((GET_EQ(ch, WEAR_DWIELD)) && GET_SKILL(ch, SKILL_DUAL_WIELD) && number(0, 101) <= GET_SKILL(ch, SKILL_DUAL_WIELD) / 2 + GET_DEX(ch))
      	{
      	  hit2(ch, FIGHTING(ch), TYPE_UNDEFINED);
			improve_skill(ch, SKILL_DUAL_WIELD);
      	}
    }

     if (IS_NPC(ch))
     {
	  perc = number(1, 101);
	  val = (AFF2_FLAGGED(ch, AFF2_SLOW) ? ch->mob_specials.attack1*0.85: ch->mob_specials.attack1);
	  if (val > perc)
            hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
	  perc = number(1,101);
	  val = (AFF2_FLAGGED(ch, AFF2_SLOW) ? ch->mob_specials.attack2*0.85: ch->mob_specials.attack2);
	  if (val > perc)
            hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
	  perc = number(1,101);
	  val = (AFF2_FLAGGED(ch, AFF2_SLOW) ? ch->mob_specials.attack3*0.85: ch->mob_specials.attack3);
	  if (val > perc)
            hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
     }

    if (AFF_FLAGGED(ch, AFF_HASTE)) {
		if (number(0, 101) <= GET_DEX(ch) * 4)
			hit(ch, FIGHTING(ch), TYPE_UNDEFINED);
    }

    if (!IS_NPC(ch) && GET_WIMP_LEV(ch) && (ch != FIGHTING(ch)) &&
	!IS_AFFECTED(ch, AFF_BERZERK) &&
        GET_HIT(ch) < GET_WIMP_LEV(ch) && GET_HIT(ch) > 0) {
      send_to_char("&WYou wimp out, and attempt to flee!&n\r\n", ch);
      do_flee(ch, NULL, 0, 0);
    }

    /* XXX: Need to see if they can handle "" instead of NULL. */
    if (MOB_FLAGGED(ch, MOB_SPEC) && mob_index[GET_MOB_RNUM(ch)].func != NULL)
      (mob_index[GET_MOB_RNUM(ch)].func) (ch, ch, 0, "");
   }
 }
ACMD(do_revive)
{
  int exp, min_exp = 0;
  struct affected_type af;

  if (IS_NPC(ch) || GET_LEVEL(ch) >= LVL_ELDER ||
      	!PLR_FLAGGED(ch, PLR_DEAD)){
	send_to_char("&WYou don't need this...&n\r\n", ch);
  	return;
  }

  exp = (level_exp(GET_REMORT(ch), (GET_LEVEL(ch) + 1))/2);
  if(GET_LEVEL(ch) > 1 && GET_EXP(ch) < exp){
    send_to_char("&WYou haven't reached the experience to revive, so the gods shoot a curse on you....&n\r\n", ch);

    af.type = SPELL_DAMNED_CURSE;
    af.location = APPLY_HITROLL;
    af.duration = 5;
    af.modifier = -20 - (GET_LEVEL(ch) / 30);
    af.bitvector = AFF_DAMNED_CURSE;
    af.bitvector2 = APPLY_NONE;
    af.bitvector3 = APPLY_NONE;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE);

    af.type = SPELL_DAMNED_CURSE;
    af.location = APPLY_DAMROLL;
    af.duration = 5;
    af.modifier = -20 - (GET_LEVEL(ch) / 30);
    af.bitvector = AFF_DAMNED_CURSE;
    af.bitvector2 = APPLY_NONE;
    af.bitvector3 = APPLY_NONE;
    affect_join(ch, &af, FALSE, FALSE, FALSE, FALSE);

  }

  send_to_char("\r\n&WYou feel your fisical body appearing again...&n\r\n"
	       "&WYour strenght is back to the normal, but your are so tired.&n\r\n"
               "&WYou are acquitted in the judgement.\r\nYou can be a mortal again.&n\r\n\r\n"
 	       "&WGood Luck, and enjoy WarDome.&n\r\n\r\n", ch);

  min_exp -= level_exp(GET_REMORT(ch), (GET_LEVEL(ch) + 1));
  if (PLR_FLAGGED(ch, PLR_KILLER)) {
  	GET_EXP(ch) = GET_EXP(ch);
 } else {
  if(GET_LEVEL(ch) > 1) {
    if(GET_EXP(ch)-exp >= min_exp)
      GET_EXP(ch) -= exp;
    else
      GET_EXP(ch) = min_exp;
  }
}

  GET_HIT(ch) = GET_MAX_HIT(ch) / 10;
  GET_MANA(ch) = GET_MAX_MANA(ch) / 10;
  GET_MOVE(ch) = GET_MAX_MOVE(ch) / 10;
//  GET_MENTAL(ch) = GET_MAX_MENTAL(ch) / 10;
  GET_OXI(ch) = GET_MAX_OXI(ch) / 10;

  REMOVE_BIT(PLR_FLAGS(ch), PLR_DEAD);
  REMOVE_BIT(PLR_FLAGS(ch), PLR_DEAD);

  if (ch->in_room != NOWHERE)
    char_from_room(ch);
    char_to_room(ch, real_room(500));
    act("&B$n &bappears in a strange wortex of light, created by the &BW&ba&Br&bD&Bo&bm&Be.&n", FALSE, ch, 0, 0, TO_NOTVICT);
    look_at_room(ch, 0);

    sprintf(buf, "(REVIVE) %s revives after %s dead.", GET_NAME(ch), (GET_SEX(ch) == SEX_MALE ? "his" : "her"));
    mudlog(buf, BRF, LVL_ELDER, TRUE);

  save_char(ch, ch->in_room);

}
int check_wanted(struct char_data * ch);
int check_wanted_gain_gold(struct char_data * ch);
int check_wanted_gain_qp(struct char_data * ch);


int return_wanted_gain(struct char_data * ch, struct char_data * victim)
{

	if(IS_NPC(ch) || IS_NPC(victim))
	   return FALSE;

	if(!check_wanted(victim))
	   return FALSE;

	if (ROOM_FLAGGED(ch->in_room, ROOM_ARENA) ||
		ROOM_FLAGGED(victim->in_room, ROOM_ARENA))
	   return FALSE;

	if(GET_CLAN(ch) >= 0) {
	  if(GET_CLAN(ch) == GET_CLAN(victim))
	   return FALSE;
	}

        if(!str_cmp(ch->desc->host, victim->desc->host)){
	  GET_POINTS(ch) -= 75;
  	  GET_POINTS(victim) -= 75;
	  GET_QP(ch) -= 75;
  	  GET_QP(victim) -= 75;
	  send_to_char("&WYou &Rlose &C75 &Bholy points&W and &C75 &Gquest points &Win this &Rtrick&W.&n\r\n", ch);
	  send_to_char("&WYou &Rlose &C75 &Bholy points&W and &C75 &Gquest points &Win this &Rtrick&W.&n\r\n", victim);
          return FALSE;
	}
        sprintf(buf, "You win %d questpoints and %s gold coins./r/n",
                check_wanted_gain_qp(victim), add_points(check_wanted_gain_gold(victim)));
        send_to_char(buf, ch);

        GET_QP(ch) += check_wanted_gain_qp(victim);
        GET_GOLD(ch) += check_wanted_gain_gold(victim);
	GET_KILLED(victim) = 0;

	return TRUE;
}

ACMD(do_pk)
{

	if(LIBERDADE(ch) > 0)
	{
		send_to_char("&RYou can be attacked now.&n\r\n", ch);
		LIBERDADE(ch) = 0;
		return;
	}


	if(GET_REMORT(ch) > 1 || GET_LEVEL(ch) > 10){
		send_to_char("You are too experienced to choose.\r\n", ch);
		return;
	}

	if(GET_LEVEL(ch) < 10){
		send_to_char("You need be more experienced to choose.\r\n", ch);
		return;
	}

        REMOVE_BIT(PLR_FLAGS(ch), PLR_NOPK);
        send_to_char("&WBe Careful now. You are a &BPlayer &RKiller&W.\r\n", ch);

}

int can_pk(struct char_data * ch, struct char_data * vt)
{
  int i;

  if(ROOM_FLAGGED(ch->in_room, ROOM_ARENA) && ROOM_FLAGGED(vt->in_room, ROOM_ARENA))
	return TRUE;
  /* PARA A QUEST DO VANDYKE */
  if(PLR_FLAGGED(ch, PLR_KILLER) && PLR_FLAGGED(vt, PLR_KILLER))
        return TRUE;
  if(!PLR_FLAGGED(ch, PLR_KILLER) && PLR_FLAGGED(vt, PLR_KILLER))
        return FALSE;
  if(PLR_FLAGGED(ch, PLR_KILLER) && !PLR_FLAGGED(vt, PLR_KILLER))
        return FALSE;

  if(!IS_NPC(vt) && LIBERDADE(ch) > 0)
  	LIBERDADE(ch) = 0;

  if(LIBERDADE(vt))
  	return FALSE;

  if(FIGHTING(ch) == vt)
        return TRUE;

 if(PLR_FLAGGED(vt, PLR_THIEF) || check_wanted(vt))
        return TRUE;


    if(GET_REMORT(ch) > 0 && GET_REMORT(vt) == 0)
    return FALSE;

    if(GET_REMORT(ch) == 0 && GET_REMORT(vt) > 0)
	return FALSE;



  i = (GET_LEVEL(vt) - GET_LEVEL(ch));
  if(!PLR_FLAGGED(ch, PLR_NOPK) && !PLR_FLAGGED(vt, PLR_NOPK))
     if(i < PK_MIN_LEVEL && i > -PK_MIN_LEVEL)
        return TRUE;

  return FALSE;
}

::::::::::::::
graph.c
::::::::::::::
/* ************************************************************************
*   File: graph.c                                       Part of CircleMUD *
*  Usage: various graph algorithms                                        *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "buffer.h"


/* external functions */
ACMD(do_say);
extern struct char_data *character_list;
extern int top_of_world;
extern const char *dirs[];
extern struct room_data *world;

/* external variables */
extern const char *dirs[];

/* local functions */
int VALID_EDGE(room_rnum x, int y);
void bfs_enqueue(room_rnum room, int dir);
void bfs_dequeue(void);
void bfs_clear_queue(void);
int find_first_step(room_rnum src, room_rnum target);
ACMD(do_track);
void hunt_victim(struct char_data *ch);

struct bfs_queue_struct {
  room_rnum room;
  char dir;
  struct bfs_queue_struct *next;
};

static struct bfs_queue_struct *queue_head = 0, *queue_tail = 0;

int track_through_doors = 0;

/* Utility macros */
#define MARK(room)	(SET_BIT(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define UNMARK(room)	(REMOVE_BIT(ROOM_FLAGS(room), ROOM_BFS_MARK))
#define IS_MARKED(room)	(ROOM_FLAGGED(room, ROOM_BFS_MARK))
#define TOROOM(x, y)	(world[(x)].dir_option[(y)]->to_room)
#define IS_CLOSED(x, y)	(EXIT_FLAGGED(world[(x)].dir_option[(y)], EX_CLOSED))

int VALID_EDGE(room_rnum x, int y)
{
  if (world[x].dir_option[y] == NULL || TOROOM(x, y) == NOWHERE)
    return 0;
  if (track_through_doors == FALSE && IS_CLOSED(x, y))
    return 0;
  if (ROOM_FLAGGED(TOROOM(x, y), ROOM_NOTRACK) || IS_MARKED(TOROOM(x, y)))
    return 0;

  return 1;
}

void bfs_enqueue(room_rnum room, int dir)
{
  struct bfs_queue_struct *curr;

  CREATE(curr, struct bfs_queue_struct, 1);
  curr->room = room;
  curr->dir = dir;
  curr->next = 0;

  if (queue_tail) {
    queue_tail->next = curr;
    queue_tail = curr;
  } else
    queue_head = queue_tail = curr;
}


void bfs_dequeue(void)
{
  struct bfs_queue_struct *curr;

  curr = queue_head;

  if (!(queue_head = queue_head->next))
    queue_tail = 0;
  free(curr);
}


void bfs_clear_queue(void)
{
  while (queue_head)
    bfs_dequeue();
}


/* 
 * find_first_step: given a source room and a target room, find the first
 * step on the shortest path from the source to the target.
 *
 * Intended usage: in mobile_activity, give a mob a dir to go if they're
 * tracking another mob or a PC.  Or, a 'track' skill for PCs.
 */
int find_first_step(room_rnum src, room_rnum target)
{
  int curr_dir;
  room_rnum curr_room;

  if (src < 0 || src > top_of_world || target < 0 || target > top_of_world) {
    log("SYSERR: Illegal value %d or %d passed to find_first_step. (%s)", src, target, __FILE__);
    return (BFS_ERROR);
  }
  if (src == target)
    return (BFS_ALREADY_THERE);

  /* clear marks first, some OLC systems will save the mark. */
  for (curr_room = 0; curr_room <= top_of_world; curr_room++)
    UNMARK(curr_room);

  MARK(src);

  /* first, enqueue the first steps, saving which direction we're going. */
  for (curr_dir = 0; curr_dir < NUM_OF_DIRS; curr_dir++)
    if (VALID_EDGE(src, curr_dir)) {
      MARK(TOROOM(src, curr_dir));
      bfs_enqueue(TOROOM(src, curr_dir), curr_dir);
    }

  /* now, do the classic BFS. */
  while (queue_head) {
    if (queue_head->room == target) {
      curr_dir = queue_head->dir;
      bfs_clear_queue();
      return (curr_dir);
    } else {
      for (curr_dir = 0; curr_dir < NUM_OF_DIRS; curr_dir++)
	if (VALID_EDGE(queue_head->room, curr_dir)) {
	  MARK(TOROOM(queue_head->room, curr_dir));
	  bfs_enqueue(TOROOM(queue_head->room, curr_dir), queue_head->dir);
	}
      bfs_dequeue();
    }
  }

  return (BFS_NO_PATH);
}


/********************************************************
* Functions and Commands which use the above functions. *
********************************************************/

ACMD(do_track)
{
  struct char_data *vict;
  int dir;

  /* The character must have the track skill. */
  if (IS_NPC(ch) || !GET_SKILL(ch, SKILL_TRACK)) {
    send_to_char("You have no idea how.\r\n", ch);
    return;
  }
  one_argument(argument, arg);
  if (!*arg) {
    send_to_char("Whom are you trying to track?\r\n", ch);
    return;
  }
  /* The person can't see the victim. */
  if (!(vict = get_char_vis(ch, arg)) ||
      world[ch->in_room].zone != world[vict->in_room].zone) {
    send_to_char("No one is around by that name.\r\n", ch);
    return;
  }
  /* We can't track the victim. */
  if (AFF_FLAGGED(vict, AFF_NOTRACK)) {
    send_to_char("You sense no trail.\r\n", ch);
    return;
  }

  /* 101 is a complete failure, no matter what the proficiency. */
  if (number(0, 101) >= GET_SKILL(ch, SKILL_TRACK)) {
    int tries = 10;
    /* Find a random direction. :) */
    do {
      dir = number(0, NUM_OF_DIRS - 1);
    } while (!CAN_GO(ch, dir) && --tries);
    sprintf(buf, "You sense a trail %s from here!\r\n", dirs[dir]);
    send_to_char(buf, ch);
    improve_skill(ch, SKILL_TRACK);
    return;
  }

  /* They passed the skill check. */
  dir = find_first_step(ch->in_room, vict->in_room);

  switch (dir) {
  case BFS_ERROR:
    send_to_char("Hmm.. something seems to be wrong.\r\n", ch);
    break;
  case BFS_ALREADY_THERE:
    send_to_char("You're already in the same room!!\r\n", ch);
    break;
  case BFS_NO_PATH:
    sprintf(buf, "You can't sense a trail to %s from here.\r\n", HMHR(vict));
    send_to_char(buf, ch);
    break;
  default:	/* Success! */
    sprintf(buf, "You sense a trail %s from here!\r\n", dirs[dir]);
    send_to_char(buf, ch);
    break;
  }
}


void hunt_victim(struct char_data *ch)
{
  int dir;
  byte found;
  struct char_data *tmp;

  if (!ch || !HUNTING(ch) || FIGHTING(ch))
    return;

  /* make sure the char still exists */
  for (found = FALSE, tmp = character_list; tmp && !found; tmp = tmp->next)
    if (HUNTING(ch) == tmp)
      found = TRUE;

  if (!found) {
    do_say(ch, "Damn!  My prey is gone!!", 0, 0);
    HUNTING(ch) = NULL;
    return;
  }
  if ((dir = find_first_step(ch->in_room, HUNTING(ch)->in_room)) < 0) {
    sprintf(buf, "Damn!  I lost %s!", HMHR(HUNTING(ch)));
    do_say(ch, buf, 0, 0);
    HUNTING(ch) = NULL;
  } else {
    perform_move(ch, dir, 1);
    if (ch->in_room == HUNTING(ch)->in_room)
      hit(ch, HUNTING(ch), TYPE_UNDEFINED);
  }
}
::::::::::::::
handler.c
::::::::::::::
/* ************************************************************************
*   File: handler.c                                     Part of CircleMUD *
*  Usage: internal funcs: moving and finding chars/objs                   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "handler.h"
#include "interpreter.h"
#include "spells.h"
#include "dg_scripts.h"
#include "quest.h"

/* external vars */
extern int top_of_world;
extern struct char_data *combat_list;
extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
extern char *MENU;
extern struct aq_data *aquest_table;

/* local functions */
int apply_ac(struct char_data * ch, int eq_pos);
void update_object(struct obj_data * obj, int use);
void update_char_objects(struct char_data * ch);

/* external functions */
int invalid_class(struct char_data *ch, struct obj_data *obj);
//int invalid_race(struct char_data *ch, struct obj_data *obj);
void remove_follower(struct char_data * ch);
void clearMemory(struct char_data * ch);
void die_follower(struct char_data * ch);
char *add_points(int value);

ACMD(do_return);

char *fname(char *namelist)
{
  static char holder[30];
  char *point;

  for (point = holder; isalpha(*namelist); namelist++, point++)
    *point = *namelist;

  *point = '\0';

  return (holder);
}

int exact_isname(const char *str, const char *namelist)
{
  const char *curname, *curstr;
  int use_abbrevs = FALSE;

  curname = namelist;
  for (;;) {
    for (curstr = str;; curstr++, curname++) {
      if (!*curstr && (use_abbrevs || (!*curname)))
	return (1);

      if (!*curname)
	return (0);

      if ((use_abbrevs && !*curstr) || *curname == ' ')
	break;

      if (LOWER(*curstr) != LOWER(*curname))
	break;
    }

    while (isalpha(*curname))
      curname++;

    if (!*curname)
      return (0);

    curname++;
  }
}

int use_abbrevs = TRUE;

int single_isname(const char *str, const char *namelist)
{
  const char *curname, *curstr;

  curname = namelist;
  for (;;) {
    for (curstr = str;; curstr++, curname++) {
      if (!*curstr && (use_abbrevs || !isalpha(*curname)))
	return (1);

      if (!*curname)
	return (0);

      if ((use_abbrevs && !*curstr) || *curname == ' ')
	break;

      if (LOWER(*curstr) != LOWER(*curname))
	break;
    }

    while (isalpha(*curname))
      curname++;

    if (!*curname)
      return (0);

    curname++;
  }
}

#define MULTINAME_CHAR	' '

int isname(const char *str, const char *namelist)
{
  char token[MAX_INPUT_LENGTH], *tokp;

  if (str == NULL || namelist == NULL) {
    log("SYSERR: NULL str (%p) or namelist (%p) passed to isname().",
	str, namelist);
    return (0);
  }

  while (*str) {
    while (!isalpha(*str) || *str == MULTINAME_CHAR)
      str++;
    if (!*str)
      break;

    for (tokp = token; *str && *str != MULTINAME_CHAR; str++)
      *tokp++ = *str;
    *tokp = '\0';
    if (!single_isname(token, namelist))
      return (0);
  }
  return (1);
}


int is_name(const char *str, const char *namelist)
{
	if(ispunct(*namelist)&&(*namelist!=*str))
		namelist++;
	while(namelist)
	{
		while((tolower(*str)==tolower(*namelist))&&(str))
		{
			str++;
			namelist++;
		}
		if(*str==' ')
			str++;
		else
			return (!*str);
		while((*namelist!=' ')&&(*namelist))namelist++;
		if(*namelist)
			namelist++;
	}
	return (0);
}

void affect_modify(struct char_data * ch, byte loc, int mod, long bitv,
                        long bitv2, long bitv3, bool add)
{
  int maxabil;

  if (add) {
    SET_BIT(AFF_FLAGS(ch), bitv);
    SET_BIT(AFF2_FLAGS(ch), bitv2);
    SET_BIT(AFF3_FLAGS(ch), bitv3);
  } else {
    REMOVE_BIT(AFF_FLAGS(ch), bitv);
    REMOVE_BIT(AFF2_FLAGS(ch), bitv2);
    REMOVE_BIT(AFF3_FLAGS(ch), bitv3);
    mod = -mod;
  }


  maxabil = (IS_NPC(ch) ? 25 : 18);

  switch (loc) {
  case APPLY_NONE:
    break;

  case APPLY_STR:
    GET_STR(ch) += mod;
    break;
  case APPLY_DEX:
    GET_DEX(ch) += mod;
    break;
  case APPLY_INT:
    GET_INT(ch) += mod;
    break;
  case APPLY_WIS:
    GET_WIS(ch) += mod;
    break;
  case APPLY_CON:
    GET_CON(ch) += mod;
    break;
  case APPLY_CHA:
    GET_CHA(ch) += mod;
    break;

  case APPLY_CLASS:
    /* ??? GET_CLASS(ch) += mod; */
    break;

  /*
   * My personal thoughts on these two would be to set the person to the
   * value of the apply.  That way you won't have to worry about people
   * making +1 level things to be imp (you restrict anything that gives
   * immortal level of course).  It also makes more sense to set someone
   * to a class rather than adding to the class number. -gg
   */

  case APPLY_LEVEL:
    /* ??? GET_LEVEL(ch) += mod; */
    break;

  case APPLY_AGE:
    ch->player.time.birth -= (mod * SECS_PER_MUD_YEAR);
    break;

  case APPLY_CHAR_WEIGHT:
    GET_WEIGHT(ch) += mod;
    break;

  case APPLY_CHAR_HEIGHT:
    GET_HEIGHT(ch) += mod;
    break;

  case APPLY_MANA:
    GET_MAX_MANA(ch) += mod;
    break;

  case APPLY_HIT:
    GET_MAX_HIT(ch) += mod;
    break;

  case APPLY_MOVE:
    GET_MAX_MOVE(ch) += mod;
    break;

  case APPLY_GOLD:
    break;

  case APPLY_EXP:
    break;

  case APPLY_AC:
    GET_AC(ch) += mod;
    break;

  case APPLY_HITROLL:
    GET_HITROLL(ch) += mod;
    break;

  case APPLY_DAMROLL:
    GET_DAMROLL(ch) += mod;
    break;

  case APPLY_SAVING_PARA:
    GET_SAVE(ch, SAVING_PARA) += mod;
    break;

  case APPLY_SAVING_ROD:
    GET_SAVE(ch, SAVING_ROD) += mod;
    break;

  case APPLY_SAVING_PETRI:
    GET_SAVE(ch, SAVING_PETRI) += mod;
    break;

  case APPLY_SAVING_BREATH:
    GET_SAVE(ch, SAVING_BREATH) += mod;
    break;

  case APPLY_SAVING_SPELL:
    GET_SAVE(ch, SAVING_SPELL) += mod;
    break;

  default:
    log("SYSERR: Unknown apply adjust %d attempt (%s, affect_modify).", loc, __FILE__);
    break;

  } /* switch */
}



/* This updates a character by subtracting everything he is affected by */
/* restoring original abilities, and then affecting all again           */
void affect_total(struct char_data * ch)
{
  struct affected_type *af;
  int i, j;

  for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.bitvector, 0, 0, FALSE);
  }


  for (af = ch->affected; af; af = af->next)
    affect_modify(ch, af->location, af->modifier, af->bitvector, af->bitvector2, af->bitvector3, FALSE);

  ch->aff_abils = ch->real_abils;

  for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.bitvector, 0, 0, TRUE);
  }


  for (af = ch->affected; af; af = af->next)
    affect_modify(ch, af->location, af->modifier, af->bitvector, af->bitvector2, af->bitvector3, TRUE);

  /* Make certain values are between 0..25, not < 0 and not > 25! */

  i = (IS_NPC(ch) ? 25 : (18 + (GET_RACE(ch) > 11) * 2));
 
  GET_DEX(ch) = MAX(0, MIN(GET_DEX(ch), i));
  GET_INT(ch) = MAX(0, MIN(GET_INT(ch), i));
  GET_WIS(ch) = MAX(0, MIN(GET_WIS(ch), i));
  GET_CON(ch) = MAX(0, MIN(GET_CON(ch), i));
  GET_STR(ch) = MAX(0, GET_STR(ch));
  GET_CHA(ch) = MAX(0, MIN(GET_CHA(ch), i + 2));

  if (IS_NPC(ch)) {
    GET_STR(ch) = MIN(GET_STR(ch), i);
  } else {
    if (GET_STR(ch) > 18) {
      i = GET_ADD(ch) + ((GET_STR(ch) - 18) * 10);
      GET_ADD(ch) = MIN(i, 100);
      GET_STR(ch) = 18  ;
      if( (i > 109) && (GET_RACE(ch) > 11)) {
       GET_STR(ch) = MIN( 18 + ((i - 100)/10), 20) ;
       GET_ADD(ch) = 0 ;
      }
    }
  }
}



/* Insert an affect_type in a char_data structure
   Automatically sets apropriate bits and apply's */
void affect_to_char(struct char_data * ch, struct affected_type * af)
{
  struct affected_type *affected_alloc;

  CREATE(affected_alloc, struct affected_type, 1);

  *affected_alloc = *af;
  affected_alloc->next = ch->affected;
  ch->affected = affected_alloc;

  affect_modify(ch, af->location, af->modifier, af->bitvector, af->bitvector2, af->bitvector3, TRUE);
  affect_total(ch);
}



/*
 * Remove an affected_type structure from a char (called when duration
 * reaches zero). Pointer *af must never be NIL!  Frees mem and calls
 * affect_location_apply
 */
void affect_remove(struct char_data * ch, struct affected_type * af)
{
  struct affected_type *temp;

  if (ch->affected == NULL) {
    core_dump();
    return;
  }

  affect_modify(ch, af->location, af->modifier, af->bitvector, af->bitvector2, af->bitvector3, FALSE);
  REMOVE_FROM_LIST(af, ch->affected, next);
  free(af);
  affect_total(ch);
}



/* Call affect_remove with every spell of spelltype "skill" */
void affect_from_char(struct char_data * ch, int type)
{
  struct affected_type *hjp, *next;

  for (hjp = ch->affected; hjp; hjp = next) {
    next = hjp->next;
    if (hjp->type == type)
      affect_remove(ch, hjp);
  }
}



/*
 * Return if a char is affected by a spell (SPELL_XXX), NULL indicates
 * not affected
 */
bool affected_by_spell(struct char_data * ch, int type)
{
  struct affected_type *hjp;

  for (hjp = ch->affected; hjp; hjp = hjp->next)
    if (hjp->type == type)
      return TRUE;

  return FALSE;
}



void affect_join(struct char_data * ch, struct affected_type * af,
                      bool add_dur, bool avg_dur, bool add_mod, bool avg_mod)
{
  struct affected_type *hjp;
  bool found = FALSE;

  for (hjp = ch->affected; !found && hjp; hjp = hjp->next) {

    if ((hjp->type == af->type) && (hjp->location == af->location)) {
      if (add_dur)
        af->duration += hjp->duration;
      if (avg_dur)
        af->duration /= 2;

      if (add_mod)
        af->modifier += hjp->modifier;
      if (avg_mod)
        af->modifier /= 2;

      affect_remove(ch, hjp);
      affect_to_char(ch, af);
      found = TRUE;
    }
  }
  if (!found)
    affect_to_char(ch, af);
}


/* move a player out of a room */
void char_from_room(struct char_data * ch)
{
  struct char_data *temp;

  if (ch == NULL || ch->in_room == NOWHERE) {
    log("SYSERR: NULL character or NOWHERE in %s, char_from_room", __FILE__);
    exit(1);
  }

  if (FIGHTING(ch) != NULL)
    stop_fighting(ch);

  if (GET_EQ(ch, WEAR_LIGHT) != NULL)
    if (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT)
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))       /* Light is ON */
        world[ch->in_room].light--;

  REMOVE_FROM_LIST(ch, world[ch->in_room].people, next_in_room);
  ch->in_room = NOWHERE;
  ch->next_in_room = NULL;
}


/* place a character in a room */
void char_to_room(struct char_data * ch, room_rnum room)
{
  if (ch == NULL || room < 0 || room > top_of_world)
    log("SYSERR: Illegal value(s) passed to char_to_room. (Room: %d/%d Ch: %p",
                room, top_of_world, ch);
  else {
    ch->next_in_room = world[room].people;
    world[room].people = ch;
    ch->in_room = room;

    if (GET_EQ(ch, WEAR_LIGHT))
      if (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT)
        if (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2))     /* Light ON */
          world[room].light++;

    /* Stop fighting now, if we left. */
    if (FIGHTING(ch) && IN_ROOM(ch) != IN_ROOM(FIGHTING(ch))) {
      stop_fighting(FIGHTING(ch));
      stop_fighting(ch);
    }
    autoquest_trigger_check(ch, 0, 0, AQ_ROOM);
    autoquest_trigger_check(ch, 0, 0, AQ_MOB_FIND);

   /* TELEPORTATION CODE */
   if (!IS_NPC(ch) && world[ch->in_room].tele != NULL) {
        if (world[ch->in_room].tele->cnt > 0 &&
            world[ch->in_room].tele->time == 0) {
          /* this is a teleport countdown room */
          world[ch->in_room].tele->time = pulse + world[ch->in_room].tele->cnt;
          if (world[ch->in_room].tele->time % 10) {
                world[ch->in_room].tele->time += 10 - (world[ch->in_room].tele->time % 10);
          }
          if (world[ch->in_room].tele->time > 2400) {
                world[ch->in_room].tele->time = world[ch->in_room].tele->cnt;
                /* start of next day */
          }
        }
   }
  }
}


/* give an object to a char   */
void obj_to_char(struct obj_data * object, struct char_data * ch)
{
  if (object && ch) {
    object->next_content = ch->carrying;
    ch->carrying = object;
    object->carried_by = ch;
    object->in_room = NOWHERE;
    IS_CARRYING_W(ch) += GET_OBJ_WEIGHT(object);
    IS_CARRYING_N(ch)++;

    autoquest_trigger_check(ch, NULL, object, AQ_OBJECT);

    /* set flag for crash-save system, but not on mobs! */
    if (!IS_NPC(ch))
      SET_BIT(PLR_FLAGS(ch), PLR_CRASH);
  } else
    log("SYSERR: NULL obj (%p) or char (%p) passed to obj_to_char.", object, ch);
}


/* take an object from a char */
void obj_from_char(struct obj_data * object)
{
  struct obj_data *temp;

  if (object == NULL) {
    log("SYSERR: NULL object passed to obj_from_char.");
    return;
  }
  REMOVE_FROM_LIST(object, object->carried_by->carrying, next_content);

  /* set flag for crash-save system, but not on mobs! */
  if (!IS_NPC(object->carried_by))
    SET_BIT(PLR_FLAGS(object->carried_by), PLR_CRASH);

  IS_CARRYING_W(object->carried_by) -= GET_OBJ_WEIGHT(object);
  IS_CARRYING_N(object->carried_by)--;
  object->carried_by = NULL;
  object->next_content = NULL;
}



/* Return the effect of a piece of armor in position eq_pos */
int apply_ac(struct char_data * ch, int eq_pos)
{
  int factor, actemp;


  if (GET_EQ(ch, eq_pos) == NULL) {
    core_dump();
    return 0;
  }

  if (!(GET_OBJ_TYPE(GET_EQ(ch, eq_pos)) == ITEM_ARMOR))
    return 0;

  switch (eq_pos) {

  case WEAR_BODY:
    factor = 3;
    break;                      /* 30% */
  case WEAR_HEAD:
    factor = 2;
    break;                      /* 20% */
  case WEAR_LEGS:
    factor = 2;
    break;                      /* 20% */
  default:
    factor = 1;
    break;                      /* all others 10% */
  }
  if (factor * GET_OBJ_VAL(GET_EQ(ch, eq_pos), 0) == 1){
    return (factor * GET_OBJ_VAL(GET_EQ(ch, eq_pos), 0));
  }
  else{
    actemp = ( ((factor * GET_OBJ_VAL(GET_EQ(ch, eq_pos), 0)) * (GET_OBJ_COND(GET_EQ(ch, eq_pos))))/100 );
    return (actemp);
  }
}

int invalid_align(struct char_data *ch, struct obj_data *obj)
{
  if (IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch))
    return TRUE;
  if (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch))
    return TRUE;
  if (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch))
    return TRUE;
  return FALSE;
}

void equip_char(struct char_data * ch, struct obj_data * obj, int pos)
{
  int j;

  if (pos < 0 || pos >= NUM_WEARS) {
    core_dump();
    return;
  }

  if (GET_EQ(ch, pos)) {
    log("SYSERR: Char is already equipped: %s, %s", GET_NAME(ch),
            obj->short_description);
    return;
  }
  if (obj->carried_by) {
    log("SYSERR: EQUIP: Obj is carried_by when equip.");
    return;
  }
  if (obj->in_room != NOWHERE) {
    log("SYSERR: EQUIP: Obj is in_room when equip.");
    return;
  }
  if (((IS_OBJ_STAT(obj, ITEM_ANTI_EVIL) && IS_EVIL(ch)) ||
       (IS_OBJ_STAT(obj, ITEM_ANTI_GOOD) && IS_GOOD(ch)) ||
       (IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch)) ||
//       invalid_race(ch, obj) || invalid_class(ch, obj))
       invalid_class(ch, obj)) && (GET_LEVEL(ch) < LVL_GOD)) {
      act("You are zapped by $p and instantly let go of it.", FALSE, ch, obj, 0, TO_CHAR);
      act("$n is zapped by $p and instantly lets go of it.", FALSE, ch, obj, 0, TO_ROOM);
      obj_to_char(obj, ch);     /* changed to drop in inventory instead of
                                 * ground */
      return;
  }

  GET_EQ(ch, pos) = obj;
  obj->worn_by = ch;
  obj->worn_on = pos;

  SET_BIT(AFF_FLAGS(ch), obj->obj_flags.bitvector);

  IS_CARRYING_W(ch) += GET_OBJ_WEIGHT(obj);

  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
    GET_AC(ch) -= apply_ac(ch, pos);

  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))  /* if light is ON */
        world[ch->in_room].light++;
  } //else
    //log("SYSERR: ch->in_room = NOWHERE when equipping char %s.", GET_NAME(ch));

  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    affect_modify(ch, obj->affected[j].location,
                  obj->affected[j].modifier,
                  obj->obj_flags.bitvector, 0, 0, TRUE);

  affect_total(ch);
}



struct obj_data *unequip_char(struct char_data * ch, int pos)
{
  int j,i;
  struct obj_data *obj;
  struct affected_type *af;

  if ((pos < 0 || pos >= NUM_WEARS) || GET_EQ(ch, pos) == NULL) {
    core_dump();
    return NULL;
  }

  obj = GET_EQ(ch, pos);
  obj->worn_by = NULL;
  obj->worn_on = -1;

  IS_CARRYING_W(ch) -= GET_OBJ_WEIGHT(obj);

  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))  /* if light is ON */
        world[ch->in_room].light--;
  } //else
    //log("SYSERR: ch->in_room = NOWHERE when unequipping char %s.", GET_NAME(ch));

  GET_EQ(ch, pos) = NULL;

  REMOVE_BIT(AFF_FLAGS(ch), obj->obj_flags.bitvector);

  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR){

    for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.bitvector, 0, 0, FALSE);
  }


    for (af = ch->affected; af; af = af->next)
     affect_modify(ch, af->location, af->modifier, af->bitvector,af->bitvector2, af->bitvector3, FALSE);

    GET_AC(ch) = 100;

    for (i = 0; i < NUM_WEARS; i++) {
     if (GET_EQ(ch, i))
       GET_AC(ch) -= apply_ac(ch, i);
    }

    for (i = 0; i < NUM_WEARS; i++) {
     if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.bitvector, 0, 0, TRUE);
    }


    for (af = ch->affected; af; af = af->next)
     affect_modify(ch, af->location, af->modifier, af->bitvector,af->bitvector2, af->bitvector3, TRUE);
  }

  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    affect_modify(ch, obj->affected[j].location,
                  obj->affected[j].modifier,
                  obj->obj_flags.bitvector, 0, 0, FALSE);

  affect_total(ch);

  return (obj);
}


struct obj_data *unequip_rent_char(struct char_data * ch, int pos)
{
  int j,i;
  struct obj_data *obj;
  struct affected_type *af;

  if ((pos < 0 || pos >= NUM_WEARS) || GET_EQ(ch, pos) == NULL) {
    core_dump();
    return NULL;
  }

  obj = GET_EQ(ch, pos);
  obj->worn_by = NULL;
  obj->worned = obj->worn_on;
  obj->worn_on = -1;

 // if (GET_OBJ_TYPE(obj) == ITEM_ARMOR)
 //   GET_AC(ch) += apply_ac(ch, pos);

  if (ch->in_room != NOWHERE) {
    if (pos == WEAR_LIGHT && GET_OBJ_TYPE(obj) == ITEM_LIGHT)
      if (GET_OBJ_VAL(obj, 2))  /* if light is ON */
        world[ch->in_room].light--;
  } //else
    //log("SYSERR: ch->in_room = NOWHERE when unequipping char %s.", GET_NAME(ch));

  GET_EQ(ch, pos) = NULL;

  if (GET_OBJ_TYPE(obj) == ITEM_ARMOR){

    for (i = 0; i < NUM_WEARS; i++) {
    if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.bitvector, 0, 0, FALSE);
  }


    for (af = ch->affected; af; af = af->next)
     affect_modify(ch, af->location, af->modifier, af->bitvector,af->bitvector2, af->bitvector3, FALSE);

    GET_AC(ch) = 100;

    for (i = 0; i < NUM_WEARS; i++) {
     if (GET_EQ(ch, i))
       GET_AC(ch) -= apply_ac(ch, i);
    }

    for (i = 0; i < NUM_WEARS; i++) {
     if (GET_EQ(ch, i))
      for (j = 0; j < MAX_OBJ_AFFECT; j++)
        affect_modify(ch, GET_EQ(ch, i)->affected[j].location,
                      GET_EQ(ch, i)->affected[j].modifier,
                      GET_EQ(ch, i)->obj_flags.bitvector, 0, 0, TRUE);
    }


    for (af = ch->affected; af; af = af->next)
     affect_modify(ch, af->location, af->modifier, af->bitvector,af->bitvector2, af->bitvector3, TRUE);
  }

  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    affect_modify(ch, obj->affected[j].location,
                  obj->affected[j].modifier,
                  obj->obj_flags.bitvector, 0, 0, FALSE);

  affect_total(ch);

  return (obj);
}

int get_number(char **name)
{
  int i;
  char *ppos;
  char number[MAX_INPUT_LENGTH];

  *number = '\0';

  if ((ppos = strchr(*name, '.'))) {
    *ppos++ = '\0';
    strcpy(number, *name);
    strcpy(*name, ppos);

    for (i = 0; *(number + i); i++)
      if (!isdigit(*(number + i)))
        return 0;

    return (atoi(number));
  }
  return 1;
}



/* Search a given list for an object number, and return a ptr to that obj */
struct obj_data *get_obj_in_list_num(int num, struct obj_data * list)
{
  struct obj_data *i;

  for (i = list; i; i = i->next_content)
    if (GET_OBJ_RNUM(i) == num)
      return i;

  return NULL;
}



/* search the entire world for an object number, and return a pointer  */
struct obj_data *get_obj_num(obj_rnum nr)
{
  struct obj_data *i;

  for (i = object_list; i; i = i->next)
    if (GET_OBJ_RNUM(i) == nr)
      return i;

  return NULL;
}



/* search a room for a char, and return a pointer if found..  */
struct char_data *get_char_room(char *name, room_rnum room)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  for (i = world[room].people; i && (j <= number); i = i->next_in_room)
    if (isname(tmp, i->player.name))
      if (++j == number)
        return i;

  return NULL;
}



/* search all over the world for a char num, and return a pointer if found */
struct char_data *get_char_num(mob_rnum nr)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (GET_MOB_RNUM(i) == nr)
      return i;

  return NULL;
}



/* put an object in a room */
void obj_to_room(struct obj_data * object, room_rnum room)
{
  if (!object || room < 0 || room > top_of_world)
    log("SYSERR: Illegal value(s) passed to obj_to_room. (Room #%d/%d, obj %p)",
        room, top_of_world, object);
  else {
    object->next_content = world[room].contents;
    world[room].contents = object;
    object->in_room = room;
    object->carried_by = NULL;
    if (ROOM_FLAGGED(room, ROOM_HOUSE))
      SET_BIT(ROOM_FLAGS(room), ROOM_HOUSE_CRASH);
  }
}


/* Take an object from a room */
void obj_from_room(struct obj_data * object)
{
  struct obj_data *temp;

  if (!object || object->in_room == NOWHERE) {
    log("SYSERR: NULL object (%p) or obj not in a room (%d) passed to obj_from_room",
        object, object->in_room);
    return;
  }

  REMOVE_FROM_LIST(object, world[object->in_room].contents, next_content);

  if (ROOM_FLAGGED(object->in_room, ROOM_HOUSE))
    SET_BIT(ROOM_FLAGS(object->in_room), ROOM_HOUSE_CRASH);
  object->in_room = NOWHERE;
  object->next_content = NULL;
}


/* put an object in an object (quaint)  */
void obj_to_obj(struct obj_data * obj, struct obj_data * obj_to)
{
  struct obj_data *tmp_obj;

  if (!obj || !obj_to || obj == obj_to) {
    log("SYSERR: NULL object (%p) or same source (%p) and target (%p) obj passed to obj_to_obj.",
        obj, obj, obj_to);
    return;
  }

  obj->next_content = obj_to->contains;
  obj_to->contains = obj;
  obj->in_obj = obj_to;

  for (tmp_obj = obj->in_obj; tmp_obj->in_obj; tmp_obj = tmp_obj->in_obj)
    GET_OBJ_WEIGHT(tmp_obj) += GET_OBJ_WEIGHT(obj);

  /* top level object.  Subtract weight from inventory if necessary. */
  GET_OBJ_WEIGHT(tmp_obj) += GET_OBJ_WEIGHT(obj);
  if (tmp_obj->carried_by)
    IS_CARRYING_W(tmp_obj->carried_by) += GET_OBJ_WEIGHT(obj);
}


/* remove an object from an object */
void obj_from_obj(struct obj_data * obj)
{
  struct obj_data *temp, *obj_from;

  if (obj->in_obj == NULL) {
    log("SYSERR: (%s): trying to illegally extract obj from obj.", __FILE__);
    return;
  }
  obj_from = obj->in_obj;
  REMOVE_FROM_LIST(obj, obj_from->contains, next_content);

  /* Subtract weight from containers container */
  for (temp = obj->in_obj; temp->in_obj; temp = temp->in_obj)
    GET_OBJ_WEIGHT(temp) -= GET_OBJ_WEIGHT(obj);

  /* Subtract weight from char that carries the object */
  GET_OBJ_WEIGHT(temp) -= GET_OBJ_WEIGHT(obj);
  if (temp->carried_by)
    IS_CARRYING_W(temp->carried_by) -= GET_OBJ_WEIGHT(obj);

  obj->in_obj = NULL;
  obj->next_content = NULL;
}


/* Set all carried_by to point to new owner */
void object_list_new_owner(struct obj_data * list, struct char_data * ch)
{
  if (list) {
    object_list_new_owner(list->contains, ch);
    object_list_new_owner(list->next_content, ch);
    list->carried_by = ch;
  }
}


/* Extract an object from the world */
void extract_obj(struct obj_data * obj)
{
  struct obj_data *temp;

  if (obj->worn_by != NULL)
    if (unequip_char(obj->worn_by, obj->worn_on) != obj)
      log("SYSERR: Inconsistent worn_by and worn_on pointers!!");
  if (obj->in_room != NOWHERE)
    obj_from_room(obj);
  else if (obj->carried_by)
    obj_from_char(obj);
  else if (obj->in_obj)
    obj_from_obj(obj);

  /* Get rid of the contents of the object, as well. */
  while (obj->contains)
    extract_obj(obj->contains);

  REMOVE_FROM_LIST(obj, object_list, next);

  if (GET_OBJ_RNUM(obj) >= 0)
    (obj_index[GET_OBJ_RNUM(obj)].number)--;

  if (SCRIPT(obj))
    extract_script(SCRIPT(obj));

  free_obj(obj);
}



void update_object(struct obj_data * obj, int use)
{
  /* dont update objects with a timer trigger */
  if (!SCRIPT_CHECK(obj, OTRIG_TIMER) && (GET_OBJ_TIMER(obj) > 0))
    GET_OBJ_TIMER(obj) -= use;
  if (obj->contains)
    update_object(obj->contains, use);
  if (obj->next_content)
    update_object(obj->next_content, use);
}


void update_char_objects(struct char_data * ch)
{
  int i;

  if (GET_EQ(ch, WEAR_LIGHT) != NULL)
    if (GET_OBJ_TYPE(GET_EQ(ch, WEAR_LIGHT)) == ITEM_LIGHT)
      if (GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2) > 0) {
        i = --GET_OBJ_VAL(GET_EQ(ch, WEAR_LIGHT), 2);
        if (i == 1) {
          act("Your light begins to flicker and fade.", FALSE, ch, 0, 0, TO_CHAR);
          act("$n's light begins to flicker and fade.", FALSE, ch, 0, 0, TO_ROOM);
        } else if (i == 0) {
          act("Your light sputters out and dies.", FALSE, ch, 0, 0, TO_CHAR);
          act("$n's light sputters out and dies.", FALSE, ch, 0, 0, TO_ROOM);
          world[ch->in_room].light--;
        }
      }

  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      update_object(GET_EQ(ch, i), 2);

  if (ch->carrying)
    update_object(ch->carrying, 1);
}

void limpa_auctions(struct char_data *ch);

/* Extract a ch completely from the world, and leave his stuff behind */
void extract_char(struct char_data * ch)
{
  struct char_data *k, *temp;
  struct descriptor_data *t_desc;
  struct obj_data *obj;
  int i, freed = 0;

  if (!IS_NPC(ch) && !ch->desc) {
    for (t_desc = descriptor_list; t_desc; t_desc = t_desc->next)
      if (t_desc->original == ch)
	do_return(t_desc->character, NULL, 0, 0);
  }
  if (ch->in_room == NOWHERE) {
    log("SYSERR: NOWHERE extracting char %s. (%s, extract_char)",
	GET_NAME(ch), __FILE__);
    exit(1);
  }
  if (ch->followers || ch->master)
    die_follower(ch);

  limpa_auctions(ch);

  /* Forget snooping, if applicable */
  if (ch->desc) {
    if (ch->desc->snooping) {
      ch->desc->snooping->snoop_by = NULL;
      ch->desc->snooping = NULL;
    }
    if (ch->desc->snoop_by) {
      SEND_TO_Q("Your victim is no longer among us.\r\n",
		ch->desc->snoop_by);
      ch->desc->snoop_by->snooping = NULL;
      ch->desc->snoop_by = NULL;
    }
  }
  /* transfer objects to room, if any */
  while (ch->carrying) {
    obj = ch->carrying;
    obj_from_char(obj);
    obj_to_room(obj, ch->in_room);
  }

  /* transfer equipment to room, if any */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      obj_to_room(unequip_char(ch, i), ch->in_room);

  if (FIGHTING(ch))
    stop_fighting(ch);

  for (k = combat_list; k; k = temp) {
    temp = k->next_fighting;
    if (FIGHTING(k) == ch)
      stop_fighting(k);
  }

  char_from_room(ch);

  /* pull the char from the list */
  REMOVE_FROM_LIST(ch, character_list, next);

  if (ch->desc && ch->desc->original)
    do_return(ch, NULL, 0, 0);

  if (!IS_NPC(ch)) {
    save_char(ch, NOWHERE);
    Crash_delete_crashfile(ch);
  } else {
    if (GET_MOB_RNUM(ch) > -1)		/* if mobile */
      mob_index[GET_MOB_RNUM(ch)].number--;
    clearMemory(ch);		/* Only NPC's can have memory */
    if (SCRIPT(ch))
      extract_script(SCRIPT(ch));
    if (SCRIPT_MEM(ch))
      extract_script_mem(SCRIPT_MEM(ch));
    free_char(ch);
    freed = 1;
  }

  if (!freed && ch->desc != NULL) {
    STATE(ch->desc) = CON_MENU;
    SEND_TO_Q(MENU, ch->desc);
  } else {  /* if a player gets purged from within the game */
    if (!freed)
      free_char(ch);
  }
}

void extract_char_to_quit(struct char_data * ch)
{
  struct char_data *k, *temp;
  struct descriptor_data *t_desc;
  struct obj_data *obj;
  int i, freed = 0;

  if (!IS_NPC(ch) && !ch->desc) {
    for (t_desc = descriptor_list; t_desc; t_desc = t_desc->next)
      if (t_desc->original == ch)
	do_return(t_desc->character, NULL, 0, 0);
  }
  if (ch->in_room == NOWHERE) {
    log("SYSERR: NOWHERE extracting char %s. (%s, extract_char)",
	GET_NAME(ch), __FILE__);
    exit(1);
  }
  if (ch->followers || ch->master)
    die_follower(ch);

  limpa_auctions(ch);

  /* Forget snooping, if applicable */
  if (ch->desc) {
    if (ch->desc->snooping) {
      ch->desc->snooping->snoop_by = NULL;
      ch->desc->snooping = NULL;
    }
    if (ch->desc->snoop_by) {
      SEND_TO_Q("Your victim is no longer among us.\r\n",
		ch->desc->snoop_by);
      ch->desc->snoop_by->snooping = NULL;
      ch->desc->snoop_by = NULL;
    }
  }
  /* transfer objects to room, if any */
  while (ch->carrying) {
    obj = ch->carrying;
    obj_from_char(obj);
    obj_to_room(obj, ch->in_room);
  }

  /* transfer equipment to room, if any */
  for (i = 0; i < NUM_WEARS; i++)
    if (GET_EQ(ch, i))
      obj_to_room(unequip_char(ch, i), ch->in_room);

  if (FIGHTING(ch))
    stop_fighting(ch);

  for (k = combat_list; k; k = temp) {
    temp = k->next_fighting;
    if (FIGHTING(k) == ch)
      stop_fighting(k);
  }

  char_from_room(ch);

  /* pull the char from the list */
  REMOVE_FROM_LIST(ch, character_list, next);

  if (ch->desc && ch->desc->original)
    do_return(ch, NULL, 0, 0);

  if (!IS_NPC(ch)) {
    save_char(ch, NOWHERE);
    Crash_delete_crashfile(ch);
  } else {
    if (GET_MOB_RNUM(ch) > -1)		/* if mobile */
      mob_index[GET_MOB_RNUM(ch)].number--;
    clearMemory(ch);		/* Only NPC's can have memory */
    if (SCRIPT(ch))
      extract_script(SCRIPT(ch));
    if (SCRIPT_MEM(ch))
      extract_script_mem(SCRIPT_MEM(ch));
    free_char(ch);
    freed = 1;
  }

  if (!freed && ch->desc != NULL) {
    STATE(ch->desc) = CON_CLOSE;
  } else {  /* if a player gets purged from within the game */
    if (!freed)
      free_char(ch);
  }
}

/* ***********************************************************************
* Here follows high-level versions of some earlier routines, ie functions*
* which incorporate the actual player-data                               *.
*********************************************************************** */


struct char_data *get_player_vis(struct char_data * ch, char *name, int inroom)
{
  struct char_data *i;

  for (i = character_list; i; i = i->next)
    if (!IS_NPC(i) && (!inroom || i->in_room == ch->in_room) &&
        !str_cmp(i->player.name, name) && CAN_SEE(ch, i))
      return i;

  return NULL;
}


struct char_data *get_char_room_vis(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* JE 7/18/94 :-) :-) */
  if (!str_cmp(name, "self") || !str_cmp(name, "me"))
    return ch;

  /* 0.<name> means PC with name */
  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis(ch, tmp, 1);

  for (i = world[ch->in_room].people; i && j <= number; i = i->next_in_room)
    if (isname(tmp, i->player.name))
      if (CAN_SEE(ch, i))
        if (++j == number)
          return i;

  return NULL;
}


struct char_data *get_char_vis(struct char_data * ch, char *name)
{
  struct char_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* check the room first */
  if ((i = get_char_room_vis(ch, name)) != NULL)
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return get_player_vis(ch, tmp, 0);

  for (i = character_list; i && (j <= number); i = i->next)
    if (isname(tmp, i->player.name) && CAN_SEE(ch, i))
      if (++j == number)
        return i;

  return NULL;
}



struct obj_data *get_obj_in_list_vis(struct char_data * ch, char *name,
                                              struct obj_data * list)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  for (i = list; i && (j <= number); i = i->next_content)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i) || (GET_OBJ_TYPE(i) == ITEM_LIGHT))
        if (++j == number)
          return i;

  return NULL;
}




/* search the entire world for an object, and return a pointer  */
struct obj_data *get_obj_vis(struct char_data * ch, char *name)
{
  struct obj_data *i;
  int j = 0, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;

  /* scan items carried */
  if ((i = get_obj_in_list_vis(ch, name, ch->carrying)))
    return i;

  /* scan room */
  if ((i = get_obj_in_list_vis(ch, name, world[ch->in_room].contents)))
    return i;

  strcpy(tmp, name);
  if (!(number = get_number(&tmp)))
    return NULL;

  /* ok.. no luck yet. scan the entire obj list   */
  for (i = object_list; i && (j <= number); i = i->next)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i))
        if (++j == number)
          return i;

  return NULL;
}



struct obj_data *get_object_in_equip_vis(struct char_data * ch,
                           char *arg, struct obj_data * equipment[], int *j)
{
  for ((*j) = 0; (*j) < NUM_WEARS; (*j)++)
    if (equipment[(*j)])
      if (CAN_SEE_OBJ(ch, equipment[(*j)]))
        if (isname(arg, equipment[(*j)]->name))
          return (equipment[(*j)]);

  return NULL;
}


char *money_desc(int amount)
{
  static char buf[128];

  if (amount <= 0) {
    log("SYSERR: Try to create negative or 0 money (%d).", amount);
    return NULL;
  }
  if (amount == 1)
    strcpy(buf, "a gold coin");
  else if (amount <= 100)
    strcpy(buf, "a tiny pile of gold coins");
  else if (amount <= 200)
    strcpy(buf, "a handful of gold coins");
  else if (amount <= 750)
    strcpy(buf, "a little pile of gold coins");
  else if (amount <= 2000)
    strcpy(buf, "a small pile of gold coins");
  else if (amount <= 10000)
    strcpy(buf, "a pile of gold coins");
  else if (amount <= 50000)
    strcpy(buf, "a big pile of gold coins");
  else if (amount <= 100000)
    strcpy(buf, "a large heap of gold coins");
  else if (amount <= 200000)
    strcpy(buf, "a huge mound of gold coins");
  else if (amount <= 750000)
    strcpy(buf, "an enormous mound of gold coins");
  else if (amount <= 1500000)
    strcpy(buf, "a small mountain of gold coins");
  else if (amount <= 2500000)
    strcpy(buf, "a mountain of gold coins");
  else if (amount <= 5000000)
    strcpy(buf, "a huge mountain of gold coins");
  else if (amount <= 10000000)
    strcpy(buf, "an enormous mountain of gold coins");
  else
    strcpy(buf, "an absolutely colossal mountain of gold coins");

  return buf;
}


struct obj_data *create_money(int amount)
{
  struct obj_data *obj;
  struct extra_descr_data *new_descr;
  char buf[200];

  if (amount <= 0) {
    log("SYSERR: Try to create negative or 0 money. (%d)", amount);
    return NULL;
  }
 // leak_logging = 0;

  obj = create_obj();
  CREATE(new_descr, struct extra_descr_data, 1);

  if (amount == 1) {
    obj->name = str_dup("coin gold");
    obj->short_description = str_dup("a gold coin");
    obj->description = str_dup("One miserable gold coin is lying here.");
    new_descr->keyword = str_dup("coin gold");
    new_descr->description = str_dup("It's just one miserable little gold coin.");
  } else {
    obj->name = str_dup("coins gold");
    obj->short_description = str_dup(money_desc(amount));
    sprintf(buf, "%s is lying here.", money_desc(amount));
    obj->description = str_dup(CAP(buf));

    new_descr->keyword = str_dup("coins gold");
    if (amount < 10) {
      sprintf(buf, "There are %d coins.", amount);
      new_descr->description = str_dup(buf);
    } else if (amount < 100) {
      sprintf(buf, "There are about %d coins.", 10 * (amount / 10));
      new_descr->description = str_dup(buf);
    } else if (amount < 1000) {
      sprintf(buf, "It looks to be about %d coins.", 100 * (amount / 100));
      new_descr->description = str_dup(buf);
    } else if (amount < 100000) {
      sprintf(buf, "You guess there are, maybe, %d coins.",
              1000 * ((amount / 1000) + number(0, (amount / 1000))));
      new_descr->description = str_dup(buf);
    } else
      new_descr->description = str_dup("There are a LOT of coins.");
  }

  new_descr->next = NULL;
  obj->ex_description = new_descr;

  GET_OBJ_TYPE(obj) = ITEM_MONEY;
  GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE;
  GET_OBJ_VAL(obj, 0) = amount;
  GET_OBJ_COST(obj) = amount;
  obj->item_number = NOTHING;

 // leak_logging = 1;

  return obj;
}


/* Generic Find, designed to find any object/character                    */
/* Calling :                                                              */
/*  *arg     is the sting containing the string to be searched for.       */
/*           This string doesn't have to be a single word, the routine    */
/*           extracts the next word itself.                               */
/*  bitv..   All those bits that you want to "search through".            */
/*           Bit found will be result of the function                     */
/*  *ch      This is the person that is trying to "find"                  */
/*  **tar_ch Will be NULL if no character was found, otherwise points     */
/* **tar_obj Will be NULL if no object was found, otherwise points        */
/*                                                                        */
/* The routine returns a pointer to the next word in *arg (just like the  */
/* one_argument routine).                                                 */

int generic_find(char *arg, int bitvector, struct char_data * ch,
                     struct char_data ** tar_ch, struct obj_data ** tar_obj)
{
  int i, found;
  char name[256];

  one_argument(arg, name);

  if (!*name)
    return (0);

  *tar_ch = NULL;
  *tar_obj = NULL;

  if (IS_SET(bitvector, FIND_CHAR_ROOM)) {      /* Find person in room */
    if ((*tar_ch = get_char_room_vis(ch, name))) {
      return (FIND_CHAR_ROOM);
    }
  }
  if (IS_SET(bitvector, FIND_CHAR_WORLD)) {
    if ((*tar_ch = get_char_vis(ch, name))) {
      return (FIND_CHAR_WORLD);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_EQUIP)) {
    for (found = FALSE, i = 0; i < NUM_WEARS && !found; i++)
      if (GET_EQ(ch, i) && isname(name, GET_EQ(ch, i)->name)) {
        *tar_obj = GET_EQ(ch, i);
        found = TRUE;
      }
    if (found) {
      return (FIND_OBJ_EQUIP);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_INV)) {
    if ((*tar_obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
      return (FIND_OBJ_INV);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_ROOM)) {
    if ((*tar_obj = get_obj_in_list_vis(ch, name, world[ch->in_room].contents))) {
      return (FIND_OBJ_ROOM);
    }
  }
  if (IS_SET(bitvector, FIND_OBJ_WORLD)) {
    if ((*tar_obj = get_obj_vis(ch, name))) {
      return (FIND_OBJ_WORLD);
    }
  }
  return (0);
}


/* a function to scan for "all" or "all.x" */
int find_all_dots(char *arg)
{
  if (!strcmp(arg, "all"))
    return FIND_ALL;
  else if (!strncmp(arg, "all.", 4)) {
    strcpy(arg, arg + 4);
    return FIND_ALLDOT;
  } else
    return FIND_INDIV;
}

void make_summary(struct char_data * ch)
{
	sprintf(buf, "\r\n&b            ____________________________________________________ \r\n");
	sprintf(buf + strlen(buf), "&b           | &BYour summary:&b                                      |\r\n");
	sprintf(buf + strlen(buf), "&b           |                                                    |\r\n");
	sprintf(buf + strlen(buf), "&b           | &CLevels&b          &B:&b             &C%20s&b |\r\n", add_points(GET_LVL_SUM(ch)));
	sprintf(buf + strlen(buf), "&b           | &nExp&b             &B:&b             &n%20s&b |\r\n", add_points(GET_EXP_SUM(ch)));
	sprintf(buf + strlen(buf), "&b           | &YGold&b            &B:&b             &Y%20s&b |\r\n", add_points(GET_GOLD_SUM(ch)));
	sprintf(buf + strlen(buf), "&b           | &RDead mobs&b       &B:&b             &R%20s&b |\r\n", add_points(GET_KMS(ch)));
	sprintf(buf + strlen(buf), "&b           | &RDead players&b    &B:&b             &R%20s&b |\r\n", add_points(GET_KPS(ch)));
	sprintf(buf + strlen(buf), "&b           | &rDeads&b           &B:&b             &r%20s&b |\r\n", add_points(GET_DIED_S(ch)));
	sprintf(buf + strlen(buf), "&b           | &GPoints&b          &B:&b             &G%20s&b |\r\n", add_points(GET_POINTS_S(ch)));
	sprintf(buf + strlen(buf), "&b           | &gChanged points&b  &B:&b             &g%20s&b |\r\n", add_points(GET_POINTS_GS(ch)));
	sprintf(buf + strlen(buf), "&b           |____________________________________________________|&n\r\n");
	sprintf(buf + strlen(buf), "\r\n\r\n");
	send_to_char(buf, ch);
}
::::::::::::::
hedit.c
::::::::::::::
/************************************************************************
* hedit.c 	Hedit version 2.0 for Oasis OLC				*
* by Steve Wolfe - siv@cyberenet.net					*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "boards.h"
#include "olc.h"

/* List each help entry saved, was used for debugging. */
#if 0
#define HEDIT_LIST	1
#endif

/*------------------------------------------------------------------------*/

/*
 * External data structures.
 */
extern struct help_index_element *help_table;
extern int top_of_helpt;
extern struct descriptor_data *descriptor_list;

/*------------------------------------------------------------------------*/

/*
 * Function Prototypes
 */
void hedit_disp_extradesc_menu(struct descriptor_data *d);
void hedit_disp_exit_menu(struct descriptor_data *d);
void hedit_disp_exit_flag_menu(struct descriptor_data *d);
void hedit_disp_flag_menu(struct descriptor_data *d);
void hedit_disp_sector_menu(struct descriptor_data *d);
void hedit_disp_menu(struct descriptor_data *d);
void hedit_parse(struct descriptor_data *d, char *arg);
void hedit_setup_new(struct descriptor_data *d, char *new_key);
void hedit_setup_existing(struct descriptor_data *d, int rnum);
void hedit_save_to_disk(void);
void hedit_save_internally(struct descriptor_data *d);
void free_help(struct help_index_element *help);
int is_name(char *str, char *namelist);

/*------------------------------------------------------------------------*/

/*------------------------------------------------------------------------*\
  Utils and exported functions.
\*------------------------------------------------------------------------*/

void hedit_setup_new(struct descriptor_data *d, char *new_key)
{
  CREATE(OLC_HELP(d), struct help_index_element, 1);

  OLC_HELP(d)->keywords = str_dup(new_key);
  OLC_HELP(d)->entry = str_dup("This is an unfinished help entry.\r\n");
  hedit_disp_menu(d);
  OLC_VAL(d) = 0;
}

/*------------------------------------------------------------------------*/

void hedit_setup_existing(struct descriptor_data *d, int rnum)
{
  struct help_index_element *help;

  /*
   * Build a copy of the help entry for editing.
   */
  CREATE(help, struct help_index_element, 1);

  *help = help_table[rnum];
  /*
   * Allocate space for all strings.
   */
  help->keywords = str_dup(help_table[rnum].keywords ?
	help_table[rnum].keywords : "UNDEFINED");
  help->entry = str_dup(help_table[rnum].entry ?
	help_table[rnum].entry : "undefined\r\n");

  /*
   * Attach copy of help entry to player's descriptor.
   */
  OLC_HELP(d) = help;
  OLC_VAL(d) = 0;
  hedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

void hedit_save_internally(struct descriptor_data *d)
{
  int i, rnum;
  struct help_index_element *new_help_table;

  rnum = OLC_ZNUM(d);
  /*
   * Help entry exists exists: free and replace it.
   */
  if (rnum >= 0) {
    free_help(help_table + rnum);
    help_table[rnum] = *OLC_HELP(d);
  } else {			/* Entry doesn't exist, hafta add it. */
    CREATE(new_help_table, struct help_index_element, top_of_helpt + 2);

    /*
     * Insert new entry at the top - why not?
     */
    new_help_table[0] = *(OLC_HELP(d));

    /*
     * Count through help table.
     */
    for (i = 0; i <= top_of_helpt; i++)
      new_help_table[i + 1] = help_table[i];

    /*
     * Copy help table over to new one.
     */
    free(help_table);
    help_table = new_help_table;
    top_of_helpt++;
  }
  olc_add_to_save_list(HEDIT_PERMISSION, OLC_SAVE_HELP);
}

/*------------------------------------------------------------------------*/

void hedit_save_to_disk(void)
{
  int i;
  FILE *fp;
  struct help_index_element *help;

  sprintf(buf, "%s.new", HELP_FILE);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open help file!", BRF, LVL_BUILDER, TRUE);
    return;
  }
  for (i = 0; i <= top_of_helpt; i++) {
    help = (help_table + i);

#if defined(HEDIT_LIST)
    sprintf(buf1, "OLC: Saving help entry %d.", i);
    log(buf1);
#endif

    /*
     * Remove the '\r\n' sequences from description.
     */
    strcpy(buf1, help->entry ? help->entry : "Empty");
    strip_string(buf1);

    /*
     * Forget making a buffer, lets just write the thing now.
     */
    fprintf(fp, "%s\n%s\n#%d\n",
      help->keywords ? help->keywords : "UNDEFINED", buf1,
      help->min_level);
  }

  /*
   * Write final line and close.
   */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s", HELP_FILE);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(HEDIT_PERMISSION, OLC_SAVE_HELP);
}

/*------------------------------------------------------------------------*/

void free_help(struct help_index_element *help)
{

  if (help->keywords)
    free(help->keywords);
  if (help->entry)
    free(help->entry);
  memset(help, 0, (sizeof(struct help_index_element)));
//  free(help);
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

/*
 * The main menu.
 */
void hedit_disp_menu(struct descriptor_data *d)
{
  struct help_index_element *help;

  get_char_cols(d->character);
  help = OLC_HELP(d);

  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  "%s1%s) Keywords    : %s%s\r\n"
	  "%s2%s) Entry       :\r\n%s%s"
	  "%s3%s) Min Level   : %s%d\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  grn, nrm, yel, help->keywords,
	  grn, nrm, yel, help->entry,
	  grn, nrm, cyn, help->min_level,
	  grn, nrm
	  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = HEDIT_MAIN_MENU;
}

/**************************************************************************
  The main loop
 **************************************************************************/

void hedit_parse(struct descriptor_data *d, char *arg)
{
  int number;

  switch (OLC_MODE(d)) {
  case HEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      hedit_save_internally(d);
      sprintf(buf, "OLC: %s edits help for %s.", GET_NAME(d->character), OLC_HELP(d)->keywords);
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /*
       * Do NOT free strings! Just the help structure. 
       */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Help entry saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /*
       * Free everything up, including strings, etc.
       */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save this help entry internally? : ", d->character);
      break;
    }
    return;

  case HEDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) { /* Something has been modified. */
	send_to_char("Do you wish to save this help entry internally? : ", d->character);
	OLC_MODE(d) = HEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      send_to_char("\r\n", d->character);
      return;
    case '1':
      send_to_char("Enter keywords:-\r\n] ", d->character);
      OLC_MODE(d) = HEDIT_KEYWORDS;
      break;
    case '2':
      OLC_MODE(d) = HEDIT_ENTRY;
#if defined(CLEAR_SCREEN)
      SEND_TO_Q("\x1B[H\x1B[J", d);
#endif
      SEND_TO_Q("Enter help entry: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_HELP(d)->entry) {
	SEND_TO_Q(OLC_HELP(d)->entry, d);
	d->backstr = str_dup(OLC_HELP(d)->entry);
      }
      d->str = &OLC_HELP(d)->entry;
      d->max_str = MAX_HELP_ENTRY;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '3':
      send_to_char("Enter min level:-\r\n] ", d->character);
      OLC_MODE(d) = HEDIT_MIN_LEVEL;
      break;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      hedit_disp_menu(d);
      break;
    }
    return;

  case HEDIT_KEYWORDS:
    if (OLC_HELP(d)->keywords)
      free(OLC_HELP(d)->keywords);
    if (strlen(arg) > MAX_HELP_KEYWORDS)
      arg[MAX_HELP_KEYWORDS - 1] = '\0';
    OLC_HELP(d)->keywords = str_dup((arg && *arg) ? arg : "UNDEFINED");
    break;

  case HEDIT_ENTRY:
    /*
     * We will NEVER get here, we hope.
     */
    mudlog("SYSERR: Reached HEDIT_ENTRY case in parse_hedit", BRF, LVL_BUILDER, TRUE);
    break;

  case HEDIT_MIN_LEVEL:
    number = atoi(arg);
    if ((number < 0) || (number > LVL_IMPL))
      send_to_char("That is not a valid choice!\r\nEnter min level:-\r\n] ", d->character);
    else {
      OLC_HELP(d)->min_level = number;
      break;
    }
    return;

  default:
    /*
     * We should never get here.
     */
    mudlog("SYSERR: Reached default case in parse_hedit", BRF, LVL_BUILDER, TRUE);
    break;
  }
  /*
   * If we get this far, something has been changed.
   */
  OLC_VAL(d) = 1;
  hedit_disp_menu(d);
}

int find_help_rnum(char *keyword)
{
  extern int top_of_helpt;
  int i;

  for (i = 0; i < top_of_helpt; i++)
    if (!str_cmp(keyword, help_table[i].keywords) ||
       is_name(keyword, help_table[i].keywords))
      return i;

  return -1;
}
::::::::::::::
house.c
::::::::::::::
/* ************************************************************************
*   File: house.c                                       Part of CircleMUD *
*  Usage: Handling of player houses                                       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "house.h"
#include "constants.h"

extern struct room_data *world;
extern int top_of_world;
extern struct index_data *obj_index;

/* external functions */
struct obj_data *Obj_from_store(struct obj_file_elem object, int *location);
int Obj_to_store(struct obj_data *obj, FILE *fl, int location);

/* local globals */
struct house_control_rec house_control[MAX_HOUSES];
int num_of_houses = 0;

/* local functions */
int House_get_filename(room_vnum vnum, char *filename, size_t maxlen);
int House_load(room_vnum vnum);
int House_save(struct obj_data *obj, FILE *fp);
void House_restore_weight(struct obj_data *obj);
void House_delete_file(room_vnum vnum);
int find_house(room_vnum vnum);
void House_save_control(void);
void hcontrol_list_houses(struct char_data *ch);
void hcontrol_build_house(struct char_data *ch, char *arg);
void hcontrol_destroy_house(struct char_data *ch, char *arg);
void hcontrol_pay_house(struct char_data *ch, char *arg);
ACMD(do_hcontrol);
ACMD(do_house);


/* First, the basics: finding the filename; loading/saving objects */

/* Return a filename given a house vnum */
int House_get_filename(room_vnum vnum, char *filename, size_t maxlen)
{
  if (vnum == NOWHERE)
    return (0);

  snprintf(filename, maxlen, LIB_HOUSE"%d.house", vnum);
  return (1);
}


/* Load all objects for a house */
int House_load(room_vnum vnum)
{
  FILE *fl;
  char filename[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  room_rnum rnum;
  int i;

  if ((rnum = real_room(vnum)) == NOWHERE)
    return (0);
  if (!House_get_filename(vnum, filename, sizeof(filename)))
    return (0);
  if (!(fl = fopen(filename, "r+b")))	/* no file found */
    return (0);
  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      perror("SYSERR: Reading house file in House_load");
      fclose(fl);
      return (0);
    }
    if (!feof(fl))
      obj_to_room(Obj_from_store(object, &i), rnum);
  }

  fclose(fl);

  return (1);
}


/* Save all objects for a house (recursive; initial call must be followed
   by a call to House_restore_weight)  Assumes file is open already. */
int House_save(struct obj_data *obj, FILE *fp)
{
  struct obj_data *tmp;
  int result;

  if (obj) {
    House_save(obj->contains, fp);
    House_save(obj->next_content, fp);
    result = Obj_to_store(obj, fp, 0);
    if (!result)
      return (0);

    for (tmp = obj->in_obj; tmp; tmp = tmp->in_obj)
      GET_OBJ_WEIGHT(tmp) -= GET_OBJ_WEIGHT(obj);
  }
  return (1);
}


/* restore weight of containers after House_save has changed them for saving */
void House_restore_weight(struct obj_data *obj)
{
  if (obj) {
    House_restore_weight(obj->contains);
    House_restore_weight(obj->next_content);
    if (obj->in_obj)
      GET_OBJ_WEIGHT(obj->in_obj) += GET_OBJ_WEIGHT(obj);
  }
}


/* Save all objects in a house */
void House_crashsave(room_vnum vnum)
{
  int rnum;
  char buf[MAX_STRING_LENGTH];
  FILE *fp;

  if ((rnum = real_room(vnum)) == NOWHERE)
    return;
  if (!House_get_filename(vnum, buf, sizeof(buf)))
    return;
  if (!(fp = fopen(buf, "wb"))) {
    perror("SYSERR: Error saving house file");
    return;
  }
  if (!House_save(world[rnum].contents, fp)) {
    fclose(fp);
    return;
  }
  fclose(fp);
  House_restore_weight(world[rnum].contents);
  REMOVE_BIT(ROOM_FLAGS(rnum), ROOM_HOUSE_CRASH);
}


/* Delete a house save file */
void House_delete_file(room_vnum vnum)
{
  char filename[MAX_INPUT_LENGTH];
  FILE *fl;

  if (!House_get_filename(vnum, filename, sizeof(filename)))
    return;
  if (!(fl = fopen(filename, "rb"))) {
    if (errno != ENOENT)
      log("SYSERR: Error deleting house file #%d. (1): %s", vnum, strerror(errno));
    return;
  }
  fclose(fl);
  if (remove(filename) < 0)
    log("SYSERR: Error deleting house file #%d. (2): %s", vnum, strerror(errno));
}


/* List all objects in a house file */
void House_listrent(struct char_data *ch, room_vnum vnum)
{
  FILE *fl;
  char filename[MAX_STRING_LENGTH];
  char buf[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct obj_data *obj;
  int i;

  if (!House_get_filename(vnum, filename, sizeof(filename)))
    return;
  if (!(fl = fopen(filename, "rb"))) {
	sprintf(buf, "No objects on file for house #%d.\r\n", vnum);
    send_to_char(buf, ch);
    return;
  }
  *buf = '\0';
  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      fclose(fl);
      return;
    }
    if (!feof(fl) && (obj = Obj_from_store(object, &i)) != NULL) {
	  sprintf(buf, " [%5d] (%5dau) %s\r\n", GET_OBJ_VNUM(obj), GET_OBJ_RENT(obj), obj->short_description);
      send_to_char(buf, ch);
      free_obj(obj);
    }
  }
  fclose(fl);
}




/******************************************************************
 *  Functions for house administration (creation, deletion, etc.  *
 *****************************************************************/

int find_house(room_vnum vnum)
{
  int i;

  for (i = 0; i < num_of_houses; i++)
    if (house_control[i].vnum == vnum)
      return (i);

  return (NOWHERE);
}



/* Save the house control information */
void House_save_control(void)
{
  FILE *fl;

  if (!(fl = fopen(HCONTROL_FILE, "wb"))) {
    perror("SYSERR: Unable to open house control file.");
    return;
  }
  /* write all the house control recs in one fell swoop.  Pretty nifty, eh? */
  fwrite(house_control, sizeof(struct house_control_rec), num_of_houses, fl);

  fclose(fl);
}


/* call from boot_db - will load control recs, load objs, set atrium bits */
/* should do sanity checks on vnums & remove invalid records */
void House_boot(void)
{
  struct house_control_rec temp_house;
  room_rnum real_house, real_atrium;
  FILE *fl;

  memset((char *)house_control,0,sizeof(struct house_control_rec)*MAX_HOUSES);

  if (!(fl = fopen(HCONTROL_FILE, "rb"))) {
    if (errno == ENOENT)
      log("   House control file '%s' does not exist.", HCONTROL_FILE);
    else
      perror("SYSERR: " HCONTROL_FILE);
    return;
  }
  while (!feof(fl) && num_of_houses < MAX_HOUSES) {
    fread(&temp_house, sizeof(struct house_control_rec), 1, fl);

    if (feof(fl))
      break;

    if (get_name_by_id(temp_house.owner) == NULL)
      continue;			/* owner no longer exists -- skip */

    if ((real_house = real_room(temp_house.vnum)) == NOWHERE)
      continue;			/* this vnum doesn't exist -- skip */

    if (find_house(temp_house.vnum) != NOWHERE)
      continue;			/* this vnum is already a house -- skip */

    if ((real_atrium = real_room(temp_house.atrium)) == NOWHERE &&
    	!ROOM_FLAGGED(real_house, ROOM_DONATION))
      continue;			/* house doesn't have an atrium -- skip and isnt a donation */

    if (temp_house.exit_num < 0 || temp_house.exit_num >= NUM_OF_DIRS)
      continue;			/* invalid exit num -- skip */

    if (TOROOM(real_house, temp_house.exit_num) != real_atrium)
      continue;			/* exit num mismatch -- skip */

    house_control[num_of_houses++] = temp_house;

    SET_BIT(ROOM_FLAGS(real_house), ROOM_HOUSE | ROOM_PRIVATE);
	if(!ROOM_FLAGGED(real_house, ROOM_DONATION))
    	SET_BIT(ROOM_FLAGS(real_atrium), ROOM_ATRIUM);
    House_load(temp_house.vnum);
  }

  fclose(fl);
  House_save_control();
}



/* "House Control" functions */

const char *HCONTROL_FORMAT =
"Usage: hcontrol build <house vnum> <exit direction> <player name>\r\n"
"       hcontrol destroy <house vnum>\r\n"
"       hcontrol pay <house vnum>\r\n"
"       hcontrol show\r\n";

void hcontrol_list_houses(struct char_data *ch)
{
  int i;
  char *timestr, *temp;
  char built_on[128], last_pay[128], own_name[MAX_NAME_LENGTH + 1];

  if (!num_of_houses) {
    send_to_char("No houses have been defined.\r\n", ch);
    return;
  }
  send_to_char("Address  Atrium  Build Date  Guests  Owner        Last Paymt\r\n"
				"-------  ------  ----------  ------  ------------ ----------\r\n", ch);

  for (i = 0; i < num_of_houses; i++) {
    /* Avoid seeing <UNDEF> entries from self-deleted people. -gg 6/21/98 */
    if ((temp = get_name_by_id(house_control[i].owner)) == NULL)
      continue;

    if (house_control[i].built_on) {
      timestr = asctime(localtime(&(house_control[i].built_on)));
      *(timestr + 10) = '\0';
      strcpy(built_on, timestr);
    } else
      strcpy(built_on, "Unknown");	/* strcpy: OK (for 'strlen("Unknown") < 128') */

    if (house_control[i].last_payment) {
      timestr = asctime(localtime(&(house_control[i].last_payment)));
      *(timestr + 10) = '\0';
      strcpy(last_pay, timestr);
    } else
      strcpy(last_pay, "None");	/* strcpy: OK (for 'strlen("None") < 128') */

    /* Now we need a copy of the owner's name to capitalize. -gg 6/21/98 */
    strcpy(own_name, temp);	/* strcpy: OK (names guaranteed <= MAX_NAME_LENGTH+1) */
    sprintf(buf, "%7d %7d  %-10s    %2d    %-12s %s\r\n",
	    house_control[i].vnum, house_control[i].atrium, built_on,
	    house_control[i].num_of_guests, CAP(own_name), last_pay);
	send_to_char(buf, ch);

    House_list_guests(ch, i, TRUE);
  }
}



void hcontrol_build_house(struct char_data *ch, char *arg)
{
  char arg1[MAX_INPUT_LENGTH];
  struct house_control_rec temp_house;
  room_vnum virt_house, virt_atrium;
  room_rnum real_house, real_atrium;
  sh_int exit_num;
  long owner;

  if (num_of_houses >= MAX_HOUSES) {
    send_to_char("Max houses already defined.\r\n", ch);
    return;
  }

  /* first arg: house's vnum */
  arg = one_argument(arg, arg1);
  if (!*arg1) {
	sprintf(buf, HCONTROL_FORMAT);
    send_to_char(buf, ch);
    return;
  }
  virt_house = atoi(arg1);
  if ((real_house = real_room(virt_house)) == NOWHERE) {
    send_to_char("No such room exists.\r\n", ch);
    return;
  }
  if ((find_house(virt_house)) != NOWHERE) {
    send_to_char("House already exists.\r\n", ch);
    return;
  }

  /* second arg: direction of house's exit */
  arg = one_argument(arg, arg1);
  if (!*arg1) {
	sprintf(buf, "%s", HCONTROL_FORMAT);
	send_to_char(buf, ch);
    return;
  }
  if ((exit_num = search_block(arg1, dirs, FALSE)) < 0) {
    sprintf(buf, "'%s' is not a valid direction.\r\n", arg1);
	send_to_char(buf, ch);
    return;
  }
  if (TOROOM(real_house, exit_num) == NOWHERE) {
    sprintf(buf, "There is no exit %s from room %d.\r\n", dirs[exit_num], virt_house);
	send_to_char(buf, ch);
    return;
  }

  real_atrium = TOROOM(real_house, exit_num);
  virt_atrium = GET_ROOM_VNUM(real_atrium);

  if (TOROOM(real_atrium, rev_dir[exit_num]) != real_house) {
    send_to_char("A house's exit must be a two-way door.\r\n", ch);
    return;
  }

  /* third arg: player's name */
  one_argument(arg, arg1);
  if (!*arg1) {
	sprintf(buf, "%s", HCONTROL_FORMAT);
	send_to_char(buf, ch);
    return;
  }
  if ((owner = get_id_by_name(arg1)) < 0) {
	sprintf(buf, "Unknown player '%s'.\r\n", arg1);
	send_to_char(buf, ch);
    return;
  }

  temp_house.mode = HOUSE_PRIVATE;
  temp_house.vnum = virt_house;
  temp_house.atrium = virt_atrium;
  temp_house.exit_num = exit_num;
  temp_house.built_on = time(0);
  temp_house.last_payment = 0;
  temp_house.owner = owner;
  temp_house.num_of_guests = 0;

  house_control[num_of_houses++] = temp_house;

  SET_BIT(ROOM_FLAGS(real_house), ROOM_HOUSE | ROOM_PRIVATE);
  SET_BIT(ROOM_FLAGS(real_atrium), ROOM_ATRIUM);
  House_crashsave(virt_house);

  send_to_char("House built.  Mazel tov!\r\n", ch);
  House_save_control();
}



void hcontrol_destroy_house(struct char_data *ch, char *arg)
{
  int i, j;
  room_rnum real_atrium, real_house;

  if (!*arg) {
    sprintf(buf, "%s", HCONTROL_FORMAT);
	send_to_char(buf, ch);
    return;
  }
  if ((i = find_house(atoi(arg))) == NOWHERE) {
    send_to_char("Unknown house.\r\n", ch);
    return;
  }
  if ((real_atrium = real_room(house_control[i].atrium)) == NOWHERE)
    log("SYSERR: House %d had invalid atrium %d!", atoi(arg), house_control[i].atrium);
  else
    REMOVE_BIT(ROOM_FLAGS(real_atrium), ROOM_ATRIUM);

  if ((real_house = real_room(house_control[i].vnum)) == NOWHERE)
    log("SYSERR: House %d had invalid vnum %d!", atoi(arg), house_control[i].vnum);
  else
    REMOVE_BIT(ROOM_FLAGS(real_house), ROOM_HOUSE | ROOM_PRIVATE | ROOM_HOUSE_CRASH);

  House_delete_file(house_control[i].vnum);

  for (j = i; j < num_of_houses - 1; j++)
    house_control[j] = house_control[j + 1];

  num_of_houses--;

  send_to_char("House deleted.\r\n", ch);
  House_save_control();

  /*
   * Now, reset the ROOM_ATRIUM flag on all existing houses' atriums,
   * just in case the house we just deleted shared an atrium with another
   * house.  --JE 9/19/94
   */
  for (i = 0; i < num_of_houses; i++)
    if (!ROOM_FLAGGED(real_room(house_control[i].vnum), ROOM_DONATION) &&
    	(real_atrium = real_room(house_control[i].atrium)) != NOWHERE)
      SET_BIT(ROOM_FLAGS(real_atrium), ROOM_ATRIUM);
}


void hcontrol_pay_house(struct char_data *ch, char *arg)
{
  int i;

  if (!*arg)
  {
	sprintf(buf, "%s", HCONTROL_FORMAT);
	send_to_char(buf, ch);
  }
  else if ((i = find_house(atoi(arg))) == NOWHERE)
    send_to_char("Unknown house.\r\n", ch);
  else {
    sprintf(buf, "Payment for house %s collected by %s.", arg, GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);

    house_control[i].last_payment = time(0);
    House_save_control();
    send_to_char("Payment recorded.\r\n", ch);
  }
}


/* The hcontrol command itself, used by imms to create/destroy houses */
ACMD(do_hcontrol)
{
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];

  half_chop(argument, arg1, arg2);

  if (is_abbrev(arg1, "build"))
    hcontrol_build_house(ch, arg2);
  else if (is_abbrev(arg1, "destroy"))
    hcontrol_destroy_house(ch, arg2);
  else if (is_abbrev(arg1, "pay"))
    hcontrol_pay_house(ch, arg2);
  else if (is_abbrev(arg1, "show"))
    hcontrol_list_houses(ch);
  else
  {
	sprintf(buf, "%s", HCONTROL_FORMAT);
	send_to_char(buf, ch);
  }
}


/* The house command, used by mortal house owners to assign guests */
ACMD(do_house)
{
  char arg[MAX_INPUT_LENGTH];
  int i, j, id;

  one_argument(argument, arg);

  if (!ROOM_FLAGGED(IN_ROOM(ch), ROOM_HOUSE))
    send_to_char("You must be in your house to set guests.\r\n", ch);
  else if ((i = find_house(GET_ROOM_VNUM(IN_ROOM(ch)))) == NOWHERE)
    send_to_char("Um.. this house seems to be screwed up.\r\n", ch);
  else if (get_id_by_name(GET_NAME(ch)) != house_control[i].owner)
    send_to_char("Only the primary owner can set guests.\r\n", ch);
  else if (!*arg)
    House_list_guests(ch, i, FALSE);
  else if ((id = get_id_by_name(arg)) < 0)
    send_to_char("No such player.\r\n", ch);
  else if (id == get_id_by_name(GET_NAME(ch)))
    send_to_char("It's your house!\r\n", ch);
  else {
    for (j = 0; j < house_control[i].num_of_guests; j++)
      if (house_control[i].guests[j] == id) {
	for (; j < house_control[i].num_of_guests; j++)
	  house_control[i].guests[j] = house_control[i].guests[j + 1];
	house_control[i].num_of_guests--;
	House_save_control();
	send_to_char("Guest deleted.\r\n", ch);
	return;
      }
    if (house_control[i].num_of_guests == MAX_GUESTS) {
      send_to_char("You have too many guests.\r\n", ch);
      return;
    }
    j = house_control[i].num_of_guests++;
    house_control[i].guests[j] = id;
    House_save_control();
    send_to_char("Guest added.\r\n", ch);
  }
}



/* Misc. administrative functions */


/* crash-save all the houses */
void House_save_all(void)
{
  int i;
  room_rnum real_house;

  for (i = 0; i < num_of_houses; i++)
    if ((real_house = real_room(house_control[i].vnum)) != NOWHERE)
      if (ROOM_FLAGGED(real_house, ROOM_HOUSE_CRASH))
	House_crashsave(house_control[i].vnum);
}


/* note: arg passed must be house vnum, so there. */
int House_can_enter(struct char_data *ch, room_vnum house)
{
  int i, j;

  if (GET_LEVEL(ch) >= LVL_GRGOD || (i = find_house(house)) == NOWHERE)
    return (1);

  switch (house_control[i].mode) {
  case HOUSE_PRIVATE:
    if (get_id_by_name(GET_NAME(ch)) == house_control[i].owner)
      return (1);
    for (j = 0; j < house_control[i].num_of_guests; j++)
      if (get_id_by_name(GET_NAME(ch)) == house_control[i].guests[j])
	return (1);
  }

  return (0);
}

void House_list_guests(struct char_data *ch, int i, int quiet)
{
  int j, num_printed;
  char *temp;

  if (house_control[i].num_of_guests == 0) {
    if (!quiet)
      send_to_char("  Guests: None\r\n", ch);
    return;
  }

  send_to_char("  Guests: ", ch);

  for (num_printed = j = 0; j < house_control[i].num_of_guests; j++) {
    /* Avoid <UNDEF>. -gg 6/21/98 */
    if ((temp = get_name_by_id(house_control[i].guests[j])) == NULL)
      continue;

    num_printed++;
    sprintf(buf, "%c%s ", UPPER(*temp), temp + 1);
	send_to_char(buf, ch);
  }

  if (num_printed == 0)
    send_to_char("all dead", ch);

  send_to_char("\r\n", ch);
}

::::::::::::::
ignore.c
::::::::::::::
/*#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "interpreter.h"

struct ignore *find_ignore(struct ignore *ignore_list, char *str)
{
  while (ignore_list != NULL) {
    if (*str == *ignore_list->ignore)
      if (!strcmp(str, ignore_list->ignore))
    return ignore_list;
    ignore_list = ignore_list->next;
  }
  return NULL;
}

int is_ignoring(struct char_data *ch, struct char_data *vict)
{
  struct ignore *temp;
  char buf[127];

  sprintf(buf, "%s", GET_NAME(ch));
  temp = GET_IGNORELIST(vict);
  while (temp != NULL) {
    if (!str_cmp(buf, temp->ignore))
      return 1;
  temp = temp->next;
  }
  return 0;
}

void write_ignorelist(struct char_data *ch)
{
  FILE *file;
  char ignoref[127];
  struct ignore *ignoretemp;
  int ignorelength;

  get_filename(GET_NAME(ch), ignoref, IGNORE_FILE);
  unlink(ignoref);
  if (!GET_IGNORELIST(ch))
    return;
  file = fopen(ignoref, "wt");
  ignoretemp = GET_IGNORELIST(ch);
  while(ignoretemp) {
    ignorelength = strlen(ignoretemp->ignore);
    fprintf(file, "%d\n", ignorelength);
    fprintf(file, "%s\n", ignoretemp->ignore);
    ignoretemp = ignoretemp->next;
  }
  fclose(file);
}

void read_ignorelist(struct char_data *ch)
{
  FILE *file;
  char ignoref[127];
  struct ignore *ignoretemp2;
  char buf[127];
  int ignorelength;

  get_filename(GET_NAME(ch), ignoref, IGNORE_FILE);
  file = fopen(ignoref, "r");
  if(!file)
    return;
  CREATE(GET_IGNORELIST(ch), struct ignore, 1);
  ignoretemp2 = GET_IGNORELIST(ch);
  do {
    fscanf(file, "%d\n", &ignorelength);
    fgets(buf, ignorelength + 1, file);
    ignoretemp2->ignore = strdup(buf);
    if(!feof(file)) {
      CREATE(ignoretemp2->next, struct ignore, 1);
      ignoretemp2 = ignoretemp2->next;
    }
  } while(!feof(file));
  fclose(file);
}


*/::::::::::::::
interpreter.c
::::::::::::::
/* ************************************************************************
*   File: interpreter.c                                 Part of CircleMUD *
*  Usage: parse user commands, search for specials, call ACMD functions   *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define __INTERPRETER_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "interpreter.h"
#include "db.h"
#include "utils.h"
#include "spells.h"
#include "handler.h"
#include "mail.h"
#include "screen.h"
#include "olc.h"
#include "dg_scripts.h"
#include "winddragon.h"

extern sh_int r_mortal_start_room;
extern sh_int r_immort_start_room;
extern sh_int r_frozen_start_room;
extern sh_int r_deadly_start_room;
extern const char *class_menu;
extern const char *race_menu;
extern char *motd;
extern char *imotd;
extern char *background;
extern char *policies;
extern char *MENU;
extern char *WELC_MESSG;
extern char *START_MESSG;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct player_index_element *player_table;
extern int top_of_p_table;
extern int circle_restrict;
extern int no_specials;
extern int max_bad_pws;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct room_data *world;
extern char *pc_race_help_types[];
extern int top_of_world;
extern int selfdelete_fastwipe;

/* external functions */
void echo_on(struct descriptor_data *d);
void echo_off(struct descriptor_data *d);
void do_start(struct char_data *ch);
int parse_class(char arg);
int parse_race(char arg);
int special(struct char_data *ch, int cmd, char *arg);
int isbanned(char *hostname);
int Valid_Name(char *newname);
void oedit_parse(struct descriptor_data *d, char *arg);
void redit_parse(struct descriptor_data *d, char *arg);
void hedit_parse(struct descriptor_data *d, char *arg);
void zedit_parse(struct descriptor_data *d, char *arg);
void medit_parse(struct descriptor_data *d, char *arg);
void sedit_parse(struct descriptor_data *d, char *arg);
void aedit_parse(struct descriptor_data *d, char *arg);
void trigedit_parse(struct descriptor_data *d, char *arg);
void qedit_parse(struct descriptor_data *d, char *arg);
void read_aliases(struct char_data *ch);
void remove_player(int pfilepos);
int is_complete(int vnum);
int allowed_classes(int x, int i);
void display_classes(struct descriptor_data *d);
void write_last_command(char *arg);
int do_run(struct char_data *ch, char argument[25]);
void actualize_splskl(struct char_data *ch);
void display_races(struct descriptor_data *d);
void display_classes(struct descriptor_data *d);
void disp_abils(struct descriptor_data *d, int class);
void display_stat(struct descriptor_data *d);
void roll_real_abils(struct char_data * ch);

/* local functions */
int perform_dupe_check(struct descriptor_data *d);
struct alias *find_alias(struct alias *alias_list, char *str);
void free_alias(struct alias *a);
void perform_complex_alias(struct txt_q *input_q, char *orig, struct alias *a);
int perform_alias(struct descriptor_data *d, char *orig);
int reserved_word(char *argument);
int find_name(char *name);
int _parse_name(char *arg, char *name);
struct char_data *is_playing(char *vict_name);
void topten(struct char_data *topch) ;
void topten1(struct char_data *topch) ;
void topten2(struct char_data *topch) ;


/* prototypes for all do_x functions. */

//religiao:
ACMD(do_muir);
ACMD(do_ilmanateur);
ACMD(do_selune);
ACMD(do_helm);
ACMD(do_ohgma);
ACMD(do_tempus);
ACMD(do_bane);
ACMD(do_pandora);
ACMD(do_talos);

ACMD(do_topten);
ACMD(do_relialin);
ACMD(do_pray);
ACMD(do_action);
ACMD(do_advance);
ACMD(do_aedit);
ACMD(do_affections);
//ACMD(do_accept);
ACMD(do_aid);
ACMD(do_alias);
ACMD(do_arena);
ACMD(do_assist);
ACMD(do_at);
ACMD(do_auction);
ACMD(do_awho);
ACMD(do_ahall);
ACMD(do_backstab);
ACMD(do_ban);
ACMD(do_bash);
ACMD(do_berzerk);
ACMD(do_bid);
ACMD(do_bet);
ACMD(do_blood_ritual);
ACMD(do_cast);
ACMD(do_chaos);
ACMD(do_chown);
ACMD(do_chop);
ACMD(do_circle);
ACMD(do_clan);
//ACMD(do_challenge);
ACMD(do_color);
ACMD(do_combo);
ACMD(do_commands);
ACMD(do_compare);
ACMD(do_consider);
ACMD(do_copy);
ACMD(do_copyover);
ACMD(do_credits);
ACMD(do_date);
ACMD(do_dc);
ACMD(do_diagnose);
ACMD(do_disarm);
ACMD(do_display);
ACMD(do_drink);
ACMD(do_drown);
ACMD(do_drop);
//ACMD(do_decline);
ACMD(do_eat);
ACMD(do_echo);
ACMD(do_enter);
ACMD(do_equipment);
ACMD(do_escape);
ACMD(do_examine);
ACMD(do_exit);
ACMD(do_exits);
ACMD(do_fbi);
ACMD(do_find);
ACMD(do_flee);
ACMD(do_follow);
ACMD(do_force);
ACMD(do_gas);
ACMD(do_gecho);
ACMD(do_gmote);
ACMD(do_gen_comm);
ACMD(do_gen_door);
ACMD(do_gen_ps);
ACMD(do_gen_tog);
ACMD(do_gen_write);
ACMD(do_get);
ACMD(do_give);
ACMD(do_gold);
ACMD(do_goto);
ACMD(do_grab);
ACMD(do_group);
ACMD(do_gsay);
ACMD(do_gut);
ACMD(do_headbash);
ACMD(do_hcontrol);
ACMD(do_help);
ACMD(do_hide);
ACMD(do_hit);
ACMD(do_house);
//ACMD(do_ignore);//last
ACMD(do_info);
ACMD(do_insult);
ACMD(do_inventory);
ACMD(do_invis);
ACMD(do_kick);
ACMD(do_kickflip);
ACMD(do_kill);
ACMD(do_knockout);
ACMD(do_last);
ACMD(do_leave);
ACMD(do_levels);
ACMD(do_liblist);
ACMD(do_listen);
ACMD(do_load);
ACMD(do_look);
/* ACMD(do_move); -- interpreter.h */
ACMD(do_meditate);
ACMD(do_message);
ACMD(do_mobfix);
ACMD(do_not_here);
ACMD(do_offer);
ACMD(do_olc);
ACMD(do_order);
ACMD(do_page);
ACMD(do_pk);
//ACMD(do_peace);
ACMD(do_player);
ACMD(do_playerlink);
ACMD(do_poofset);
ACMD(do_pour);
ACMD(do_prename);
ACMD(do_purge);
ACMD(do_put);
ACMD(do_qlist);
ACMD(do_qstat);
ACMD(do_qcomm);
ACMD(do_quit);
ACMD(do_reboot);
ACMD(do_recall);
ACMD(do_recharge);
ACMD(do_remort);
ACMD(do_remove);
ACMD(do_rent);
ACMD(do_reply);
ACMD(do_report);
ACMD(do_rescue);
ACMD(do_rest);
ACMD(do_restore);
ACMD(do_return);
ACMD(do_revive);
ACMD(do_rlink);
ACMD(do_sabre);
ACMD(do_sacrifice);
ACMD(do_save);
ACMD(do_say);
ACMD(do_scan);
ACMD(do_score);
ACMD(do_seelog);
ACMD(do_send);
ACMD(do_set);
ACMD(do_show);
ACMD(do_shutdown);
ACMD(do_sit);
ACMD(do_skillset);
//ACMD(do_slang);
ACMD(do_sleep);
ACMD(do_slist);
ACMD(do_skill);
ACMD(do_sneak);
ACMD(do_snoop);
ACMD(do_spec_comm);
ACMD(do_spell);
ACMD(do_split);
ACMD(do_stand);
ACMD(do_stat);
ACMD(do_steal);
ACMD(do_style);
ACMD(do_stroke);
ACMD(do_summary);
ACMD(do_suicide);
ACMD(do_switch);
ACMD(do_syslog);
ACMD(do_tedit);
ACMD(do_teleport);
ACMD(do_tell);
ACMD(do_time);
ACMD(do_title);
ACMD(do_toggle);
ACMD(do_track);
ACMD(do_trans);
ACMD(do_transform);
ACMD(do_throw);
ACMD(do_unban);
ACMD(do_ungroup);
ACMD(do_use);
ACMD(do_users);
ACMD(do_visible);
ACMD(do_vnum);
ACMD(do_vstat);
ACMD(do_veq);
ACMD(do_wanted);
ACMD(do_warshout);
ACMD(do_wake);
ACMD(do_wear);
ACMD(do_weather);
ACMD(do_where);
ACMD(do_who);
ACMD(do_wield);
ACMD(do_wimpy);
ACMD(do_wizlock);
ACMD(do_wiznet);
ACMD(do_wizutil);
ACMD(do_write);
ACMD(do_whois);
ACMD(do_whirlwind);
ACMD(do_xname);
ACMD(do_zreset);

/* DG Script ACMD's */
ACMD(do_attach);
ACMD(do_detach);
ACMD(do_tlist);
ACMD(do_tstat);
ACMD(do_masound);
ACMD(do_mkill);
ACMD(do_mjunk);
ACMD(do_mechoaround);
ACMD(do_msend);
ACMD(do_mecho);
ACMD(do_mload);
ACMD(do_mpurge);
ACMD(do_mgoto);
ACMD(do_mat);
ACMD(do_mteleport);
ACMD(do_mforce);
ACMD(do_mexp);
ACMD(do_mgold);
ACMD(do_mhunt);
ACMD(do_mremember);
ACMD(do_mforget);
ACMD(do_mtransform);

/* Program run commands */
ACMD(do_swho);
ACMD(do_slast);
ACMD(do_grep);
ACMD(do_sps);
ACMD(do_ukill);
ACMD(do_sexec);

struct command_info *complete_cmd_info;

/* This is the Master Command List(tm).

 * You can put new commands in, take commands out, change the order
 * they appear in, etc.  You can adjust the "priority" of commands
 * simply by changing the order they appear in the command list.
 * (For example, if you want "as" to mean "assist" instead of "ask",
 * just put "assist" above "ask" in the Master Command List(tm).
 *
 * In general, utility commands such as "at" should have high priority;
 * infrequently used and dangerously destructive commands should have low
 * priority.
 */

cpp_extern const struct command_info cmd_info[] = {

    /* this must be first -- for specprocs */
   { "RESERVED"	, "RESERVED"	, 0, 0, 0, 0 },

    /* directions must come before other commands but after RESERVED */
   { "north"	, "north"	, POS_STANDING, do_move     , 0, SCMD_NORTH },
   { "east"	, "east"	, POS_STANDING, do_move     , 0, SCMD_EAST },
   { "south"	, "south"	, POS_STANDING, do_move     , 0, SCMD_SOUTH },
   { "west"	, "west"	, POS_STANDING, do_move     , 0, SCMD_WEST },
   { "up"	, "up"		, POS_STANDING, do_move     , 0, SCMD_UP },
   { "down"	, "down"	, POS_STANDING, do_move     , 0, SCMD_DOWN },

   /* Punctuation Commands */
   { "."        , "."		, POS_SLEEPING, do_gen_comm , 10, SCMD_GOSSIP },
   { "?"        , "?"		, POS_DEAD    , do_help     , 0, 0 },


   /* now, the main list */
   { "at"       , "a"		, POS_DEAD    , do_at       , LVL_ELDER, 0 },
   { "advance"  , "ad"		, POS_DEAD    , do_advance  , LVL_GOD, 0 },
   { "aedit"    , "aed"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_AEDIT },
   { "affections","aff"         , POS_DEAD    , do_affections,0, 0 },
   { "afk"      , "afk"		, POS_DEAD    , do_gen_tog  , 0, SCMD_AFK },
 //  { "accept"   , "accept"     , POS_STANDING, do_accept   , 1, 0 },
   { "aid"      , "aid"		, POS_STANDING, do_aid      , 0, 0 },
   { "alias"    , "ali"		, POS_DEAD    , do_alias    , 0, 0 },
   { "alignment"  ,"alignment"  , POS_STANDING, do_relialin , 1, 0 },
   { "assist"   , "as"		, POS_FIGHTING, do_assist   , 1, 0 },
   { "ask"      , "ask"		, POS_RESTING , do_spec_comm, 0, SCMD_ASK },
   { "auction"  , "auct"	, POS_STANDING, do_auction  , 0, 0 },
   { "autoassist","autoass"	, POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOASSIST },
   { "autoexit" , "autoex"	, POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOEXIT },
   { "autogold" , "autogo"	, POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOGOLD },
   { "autoloot" , "autolo"	, POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOLOOT },
   { "autosplit", "autosp"	, POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOSPLIT },
   { "ahall"    , "ahall"       , POS_STANDING, do_ahall    , 0, 0 },

   { "backstab" , "b"		, POS_STANDING, do_backstab , 1, 0 },
   { "ban"      , "ba"		, POS_DEAD    , do_ban      , LVL_SUPGOD, 0 },
   { "balance"  , "bal"		, POS_STANDING, do_not_here , 1, 0 },
   { "bash"     , "bash"	, POS_FIGHTING, do_bash     , 1, 0 },
   { "berzerk"  , "ber"		, POS_FIGHTING, do_berzerk  , 0, 0 },
   { "bid"      , "bid"		, POS_SLEEPING, do_bid	    , 0, 0 },
   { "bet"      , "bet"         , POS_RESTING , do_bet      , 0, 0 },
   { "boot"     , "boot"        , POS_DEAD    , do_copyover , LVL_GRGOD, 0 },
   { "brief"    , "brief"	, POS_DEAD    , do_gen_tog  , 0, SCMD_BRIEF },
   { "buy"      , "bu"		, POS_STANDING, do_not_here , 0, 0 },
   { "bug"      , "bug"		, POS_DEAD    , do_gen_write, 10, SCMD_BUG },
   { "blood"    , "bloo"	, POS_STANDING, do_blood_ritual , 1, 0 },

   { "cast"     , "c"		, POS_SITTING , do_cast     , 1, 0 },
   { "chaos"    , "chaos"	, POS_STANDING, do_chaos    , LVL_ELDER, 0 },
   { "chat"     , "cha"		, POS_SLEEPING, do_gen_comm , 10, SCMD_CHAT },
   { "check"    , "check"	, POS_STANDING, do_not_here , 1, 0 },
   { "chown"    , "chow"	, POS_STANDING, do_chown    , LVL_GOD, 0 },
   { "chop "    , "chop"	, POS_FIGHTING, do_chop     , 1, 0 },
   { "circle"   , "cir" 	, POS_FIGHTING, do_circle   , 0, 0 },
   { "clan"     , "clan"	, POS_SLEEPING, do_clan     , 1, 0 },
 //  { "challenge", "chal"	, POS_SLEEPING, do_challenge, 1, 0 },
   { "clear"    , "clear" 	, POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR },
   { "close"    , "close"	, POS_SITTING , do_gen_door , 0, SCMD_CLOSE },
   { "cls"      , "cls"		, POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR },
   { "consider" , "co"		, POS_RESTING , do_consider , 0, 0 },
   { "color"    , "color"	, POS_DEAD    , do_color    , 0, 0 },
   { "combo"    , "comb"	, POS_FIGHTING, do_combo    , 0, 0 },
   { "commands" , "comm"	, POS_DEAD    , do_commands , 0, SCMD_COMMANDS },
   { "compact"  , "comp"	, POS_DEAD    , do_gen_tog  , 0, SCMD_COMPACT },
   { "compare"  , "compar"	, POS_STANDING, do_compare  , 0, 0 },
   { "copy"     , "copy"	, POS_DEAD    , do_copy     , LVL_BUILDER, 0 },
   { "credits"  , "cred"	, POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS },
   { "crossdoors","crossd"	, POS_DEAD    , do_gen_tog  , LVL_ELDER, SCMD_CROSSDOORS },
   { "change"   , "chan"        , POS_SLEEPING, do_not_here , 1, 0 },

   { "date"     , "date"	, POS_DEAD    , do_date     , LVL_ELDER, SCMD_DATE },
//   { "decline"  , "decline"	, POS_STANDING, do_decline  , 1, 0 },
   { "dc"       , "dc"		, POS_DEAD    , do_dc       , LVL_SUPGOD, 0 },
   { "deposit"  , "depo"	, POS_STANDING, do_not_here , 1, 0 },
   { "destruction", "destruction" , POS_FIGHTING, do_talos    , 100 , 0 },
   { "diagnose" , "diag"	, POS_RESTING , do_diagnose , 0, 0 },
   { "disarm"   , "disa"	, POS_FIGHTING, do_disarm   , 0, 0 },
   { "display"  , "disp"	, POS_DEAD    , do_display  , 0, 0 },
   { "dlist"    , "dl"          , POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_DLIST },
   { "donate"   , "donate"	, POS_RESTING , do_drop     , 0, SCMD_DONATE },
   { "drink"    , "drink"	, POS_RESTING , do_drink    , 0, SCMD_DRINK },
   { "drown"    , "drown"	, POS_RESTING , do_drown    , 1, 0 },
   { "drop"     , "drop"	, POS_RESTING , do_drop     , 0, SCMD_DROP },

   { "eat"      , "eat"		, POS_RESTING , do_eat      , 0, SCMD_EAT },
   { "echo"     , "echo"	, POS_SLEEPING, do_echo     , LVL_LORD, SCMD_ECHO },
   { "emote"    , "emo"		, POS_RESTING , do_echo     , 1, SCMD_EMOTE },
   { "elist"    , "el" 		, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_ELIST },
   { "enter"    , "enter"	, POS_STANDING, do_enter    , 0, 0 },
   { "equipment", "eq"		, POS_SLEEPING, do_equipment, 0, 0 },
   { "escape"   , "esc"		, POS_FIGHTING, do_escape   , 1, 0 },
   { "exits"    , "ex"		, POS_RESTING , do_exits    , 0, 0 },
   { "examine"  , "exa"		, POS_SITTING , do_examine  , 0, 0 },

   { "fbi"      , "fbi"		, POS_DEAD    , do_fbi      , LVL_SUPGOD, 0 },
   { "find"     , "fin"		, POS_DEAD    , do_find     , LVL_GOD, 0 },
   { "finger"   , "fi"  	, POS_DEAD    , do_player   , 0, 0 },
   { "force"    , "f"		, POS_SLEEPING, do_force    , LVL_GOD, 0 },
   { "forge"    , "for"		, POS_STANDING, do_not_here , 1, 0 },
   { "fill"     , "fill"	, POS_STANDING, do_pour     , 0, SCMD_FILL },
   { "flee"     , "fl"		, POS_FIGHTING, do_flee     , 1, 0 },
   { "follow"   , "fol"		, POS_RESTING , do_follow   , 0, 0 },
   { "freedom"    , "freedom"     , POS_FIGHTING, do_selune   , 0 , 0 },
   { "freeze"   , "fr"		, POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_FREEZE },

   { "gas"      , "gas"		, POS_STANDING, do_gas      , 0, 0 },
   { "get"      , "g"		, POS_RESTING , do_get      , 0, 0 },
   { "gecho"    , "gecho"	, POS_DEAD    , do_gecho    , LVL_GOD, 0 },
   { "gemote"   , "gem"         , POS_SLEEPING, do_gen_comm , 0, SCMD_GMOTE },
   { "give"     , "gi"		, POS_RESTING , do_give     , 0, 0 },
   { "goto"     , "go"		, POS_SLEEPING, do_goto     , LVL_ELDER, 0 },
   { "gold"     , "gol"		, POS_RESTING , do_gold     , 0, 0 },
   { "gossip"   , "gos"		, POS_SLEEPING, do_gen_comm , 10, SCMD_GOSSIP },
   { "group"    , "gr"		, POS_RESTING , do_group    , 1, 0 },
   { "grab"     , "grab"	, POS_RESTING , do_grab     , 0, 0 },
   { "grats"    , "grats"	, POS_SLEEPING, do_gen_comm , 10, SCMD_GRATZ },
   { "grep"     , "gre"	        , POS_DEAD    , do_grep     , LVL_SUBIMPL, 0 },
   { "gsay"     , "gs"		, POS_SLEEPING, do_gsay     , 0, 0 },
   { "gtell"    , "gt"		, POS_SLEEPING, do_gsay     , 0, 0 },
   { "gut"    , "gut"		, POS_SLEEPING, do_gut      , 0, 0 },

   { "harakiri" , "hk"		, POS_FIGHTING, do_suicide  , 0, 0 },
   { "headbash" , "headba"	, POS_FIGHTING, do_headbash , 0, 0 },
   { "hedit"    , "hed" 	, POS_DEAD    , do_olc	    , LVL_BUILDER, SCMD_OLC_HEDIT },
   { "help"     , "h"		, POS_DEAD    , do_help     , 0, 0 },
   { "handbook" , "hand"	, POS_DEAD    , do_gen_ps   , LVL_ELDER, SCMD_HANDBOOK },
   { "hcontrol" , "hcontrol", POS_DEAD    , do_hcontrol , LVL_SUPGOD, 0 },
   { "hide"     , "hide"	, POS_RESTING , do_hide     , 1, 0 },
   { "hit"      , "hit"		, POS_FIGHTING, do_hit      , 0, SCMD_HIT },
   { "hold"     , "hold"	, POS_RESTING , do_grab     , 1, 0 },
   { "holler"   , "holler"	, POS_RESTING , do_gen_comm , 1, SCMD_HOLLER },
   { "holylight", "holylight"	, POS_DEAD    , do_gen_tog  , LVL_ELDER, SCMD_HOLYLIGHT },
   { "house"    , "house"	, POS_RESTING , do_house    , 0, 0 },
   { "honor"      , "honor"       , POS_FIGHTING, do_muir     , 0 , 0 },
   { "humility"   , "humility"    , POS_FIGHTING, do_ilmanateur ,50 ,0 },

   { "inventory", "i"		, POS_DEAD    , do_inventory, 0, 0 },
   { "idea"     , "idea"	, POS_DEAD    , do_gen_write, 10, SCMD_IDEA },
   { "identify"   , "identify"    , POS_FIGHTING, do_ohgma    , 0 , 0 },
   //( "ignore"   , "ignor"       , POS_DEAD    , do_ignore   , LVL_ELDER, 0 },//last
   { "imotd"    , "im"		, POS_DEAD    , do_gen_ps   , LVL_ELDER, SCMD_IMOTD },
   { "immlist"  , "imm"		, POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST },
   { "info"     , "in"		, POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO },
   { "insult"   , "insult"	, POS_RESTING , do_insult   , 0, 0 },
   { "invis"    , "invis"	, POS_DEAD    , do_invis    , LVL_ELDER, 0 },

   { "junk"     , "j"		, POS_RESTING , do_drop     , 0, SCMD_JUNK },
   { "join"	, "join"	, POS_STANDING, do_not_here , 0, 0},

   { "kill"     , "ki"		, POS_FIGHTING, do_kill     , 0, 0 },
   { "kick"     , "kick"	, POS_FIGHTING, do_kick     , 1, 0 },
   { "kickflip" , "kickflip"	, POS_FIGHTING, do_kickflip , 1, 0 },
   { "knockout" , "knock"	, POS_STANDING, do_knockout , 1, 0 },

   { "look"     , "l"		, POS_RESTING , do_look     , 0, SCMD_LOOK },
   { "law"        , "law"         , POS_STANDING, do_helm     , 100 , 0 },
   { "last"     , "last"	, POS_DEAD    , do_last     , LVL_GOD, 0 },
   { "leave"    , "leave"	, POS_STANDING, do_leave    , 0, 0 },
   { "levels"   , "lev"		, POS_DEAD    , do_levels   , 0, 0 },
   { "list"     , "list"	, POS_STANDING, do_not_here , 0, 0 },
   { "listen"   , "liste"	, POS_STANDING, do_listen   , 0, 0 },
   { "llist"    , "ll" 		, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_LLIST },
   { "lock"     , "lo"		, POS_SITTING , do_gen_door , 0, SCMD_LOCK },
   { "load"     , "lock"	, POS_DEAD    , do_load     , LVL_GOD, 0},

   { "map"		,"map"		, POS_DEAD    , do_gen_tog  , 0, SCMD_MAP },
   { "meta"     , "met" 	, POS_RESTING , do_not_here , 0, 0 },
   { "mobfix"   , "mf"		, POS_DEAD    , do_mobfix   , LVL_BUILDER, 0 },
   { "motd"     , "m"		, POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD },
   { "mail"     , "mail"	, POS_STANDING, do_not_here , 1, 0 },
   { "medit"    , "med"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_MEDIT},
   { "meditate" , "medit"	, POS_RESTING , do_meditate , 1, 0 },
   { "message"  , "mess"        , POS_DEAD    , do_message  , LVL_ELDER , 0 },
   { "mlist"    , "ml"		, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_MLIST },
   { "mount"    , "mou" 	, POS_RESTING , do_not_here , 0, 0 },
   { "mute"     , "mu"		, POS_DEAD    , do_wizutil  , LVL_DEMIGOD, SCMD_SQUELCH },
   { "murder"   , "murder"	, POS_FIGHTING, do_hit      , 0, SCMD_MURDER },

   { "newbie"   , "newb"	, POS_SLEEPING, do_gen_comm , 0, SCMD_NEWBIE },
   { "news"     , "n"		, POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS },
   { "noauction", "noauct"	, POS_DEAD    , do_gen_tog  , 0, SCMD_NOAUCTION },
   { "nochat"   , "nocha"	, POS_DEAD    , do_gen_tog  , 0, SCMD_NOCHAT },
   { "nogossip" , "nogos"	, POS_DEAD    , do_gen_tog  , 0, SCMD_NOGOSSIP },
   { "nograts"  , "nograts"	, POS_DEAD    , do_gen_tog  , 0, SCMD_NOGRATZ },
   { "nohassle" , "nohass"	, POS_DEAD    , do_gen_tog  , LVL_ELDER, SCMD_NOHASSLE },
   { "nonewbie" , "nonewb"	, POS_DEAD    , do_gen_tog  , 0, SCMD_NONEWBIE },
   { "norepeat" , "norep"	, POS_DEAD    , do_gen_tog  , 0, SCMD_NOREPEAT },
   { "noreply"  , "norepl"	, POS_DEAD    , do_gen_tog  , 1, SCMD_NOREPLY },
   { "noshout"  , "noshout"	, POS_SLEEPING, do_gen_tog  , 1, SCMD_DEAF },
   { "nosummon" , "nosum"	, POS_DEAD    , do_gen_tog  , 1, SCMD_NOSUMMON },
   { "notell"   , "notell"	, POS_DEAD    , do_gen_tog  , 1, SCMD_NOTELL },
   { "notitle"  , "notitle"	, POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_NOTITLE },
   { "nowiz"    , "nowiz"	, POS_DEAD    , do_gen_tog  , LVL_ELDER, SCMD_NOWIZ },

   { "order"    , "o"		, POS_RESTING , do_order    , 1, 0 },
   { "oedit"    , "oed"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_OEDIT},
   { "offer"    , "offer"	, POS_STANDING, do_not_here , 1, 0 },
   { "olc"      , "olc"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SAVEINFO },
   { "olist"    , "oli" 	, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_OLIST },
   { "open"     , "open"	, POS_SITTING , do_gen_door , 0, SCMD_OPEN },
   { "oppresion"  , "oppresion"   , POS_FIGHTING, do_bane     , 50 , 0 },

   { "put"      , "p"		, POS_RESTING , do_put      , 0, 0 },
   { "page"     , "pa"		, POS_DEAD    , do_page     , LVL_GOD, 0 },
   { "pardon"   , "pard"	, POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_PARDON },
   { "pick"     , "pick"	, POS_STANDING, do_gen_door , 1, SCMD_PICK },
   { "pk"	, "pk"		, POS_STANDING, do_pk	    , 0, 0 },
//   { "peace"    , "peace"       , POS_STANDING, do_peace    , 0, 0 },
   { "playerlink", "playerlink"	, POS_DEAD    , do_playerlink, LVL_MJGOD, 0 },
   { "policy"   , "pol"		, POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES },
   { "poofin"   , "poofin"	, POS_DEAD    , do_poofset  , LVL_ELDER, SCMD_POOFIN },
   { "poofout"  , "poofout"	, POS_DEAD    , do_poofset  , LVL_ELDER, SCMD_POOFOUT },
   { "pour"     , "pour"	, POS_STANDING, do_pour     , 0, SCMD_POUR },
   { "pray"	, "pray"	, POS_STANDING, do_pray	    , 0 , 0 }, 
   { "prename"  , "prenam"	, POS_DEAD    , do_prename  , 0, 0 },
   { "prompt"   , "pr"		, POS_DEAD    , do_display  , 0, 0 },
   { "purge"    , "purge"	, POS_DEAD    , do_purge    , LVL_DEMIGOD, 0 },

   { "quaff"    , "q"		, POS_RESTING , do_use      , 0, SCMD_QUAFF },
   { "qecho"    , "qecho"	, POS_DEAD    , do_qcomm    , LVL_DEMIGOD, SCMD_QECHO },
   { "qedit"	, "qedit"	, POS_DEAD    , do_olc	    , LVL_BUILDER, SCMD_OLC_QEDIT},
   { "qlist"	, "qlist"	, POS_DEAD    , do_qlist    , LVL_BUILDER, 0},
   { "qsay"     , "qs"		, POS_RESTING , do_qcomm    , 0, SCMD_QSAY },
   { "qstat"	, "qstat"	, POS_DEAD    , do_qstat    , LVL_BUILDER, 0},
   { "quest"    , "quest"	, POS_DEAD    , do_gen_tog  , 0, SCMD_QUEST },
   { "qui"      , "qui"		, POS_DEAD    , do_quit     , 0, 0 },
   { "quit"     , "quit"	, POS_DEAD    , do_quit     , 0, SCMD_QUIT },

   { "reply"    , "r"		, POS_SLEEPING, do_reply    , 0, 0 },
   { "rest"     , "re"		, POS_RESTING , do_rest     , 0, 0 },
   { "read"     , "read"	, POS_RESTING , do_look     , 0, SCMD_READ },
   { "recite"   , "rec"		, POS_RESTING , do_use      , 0, SCMD_RECITE },
   { "reborn"   , "reborn"      , POS_STANDING, do_not_here , 1, 0 },
   { "recall"   , "reca"	, POS_STANDING, do_recall   , 0, 0 },
   { "receive"  , "receive"	, POS_STANDING, do_not_here , 1, 0 },
   { "recharge" , "recharge", POS_STANDING, do_recharge , 1, 0 },
   { "redit"    , "red"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_REDIT},
   { "religion"  ,"religion"  , POS_STANDING, do_relialin , 1, 0 },
   { "reload"   , "rel"		, POS_DEAD    , do_reboot   , LVL_MJGOD, 0 },
   { "remove"   , "rem"		, POS_RESTING , do_remove   , 0, 0 },
   { "remort"   , "remort"	, POS_STANDING, do_remort   , 1, 0 },
   { "rent"     , "rent"	, POS_STANDING, do_not_here , 1, 0 },
   { "repair"   , "repa" 	, POS_RESTING , do_not_here , 0, 0 },
   { "report"   , "repo"	, POS_SLEEPING, do_report   , 0, 0 },
   { "reroll"   , "reroll"	, POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL },
   { "rescue"   , "rescue"	, POS_FIGHTING, do_rescue   , 1, 0 },
   { "restore"  , "restore"	, POS_DEAD    , do_restore  , LVL_GOD, 0 },
   { "return"   , "return"	, POS_DEAD    , do_return   , 0, 0 },
   { "revive"   , "rev"		, POS_STANDING, do_revive   , 1, 0 },
   { "rlink"    , "rlink"	, POS_DEAD    , do_rlink    , LVL_BUILDER, 0 },
   { "rlist"    , "rl"		, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_RLIST },
//   { "roomflags", "roomfl"	, POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_ROOMFLAGS },

   { "sabre"    , "sab"		, POS_FIGHTING, do_sabre    , 0, 0 },
   { "sacrifice", "sac"		, POS_STANDING, do_sacrifice, 0, 0 },
   { "say"      , "s"		, POS_RESTING , do_say      , 0, 0 },
   { "'"        , "s"		, POS_RESTING , do_say      , 0, 0 },
   { "save"     , "sa"		, POS_SLEEPING, do_save     , 0, 0 },
   { "score"    , "sc"		, POS_DEAD    , do_score    , 0, 0 },
   { "scan"     , "sca"		, POS_STANDING, do_scan     , 0, 0 },
   { "sedit"    , "sed"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_SEDIT},
   { "seduction"  , "seduction"   , POS_FIGHTING, do_pandora  , 50 , 0 },
   { "seelog"   , "see"		, POS_DEAD    , do_seelog   , LVL_GOD, 0 },
   { "sell"     , "sell"	, POS_STANDING, do_not_here , 0, 0 },
   { "send"     , "send"	, POS_SLEEPING, do_send     , LVL_GOD, 0 },
   { "set"      , "set"		, POS_DEAD    , do_set      , LVL_GOD, 0 },
   { "sexec"    , "sexec"       , POS_DEAD    , do_sexec    , 0, 0 },
   { "shout"    , "sh"		, POS_RESTING , do_gen_comm , 0, SCMD_SHOUT },
   { "show"     , "show"	, POS_DEAD    , do_show     , LVL_LORD, 0 },
   { "shutdow"  , "shutdow"	, POS_DEAD    , do_shutdown , LVL_SUBIMPL, 0 },
   { "shutdown" , "shutdown"	, POS_DEAD    , do_shutdown , LVL_IMPL, SCMD_SHUTDOWN },
   { "sip"      , "sip"		, POS_RESTING , do_drink    , 0, SCMD_SIP },
   { "sit"      , "sit"		, POS_RESTING , do_sit      , 0, 0 },
   { "skills"   , "sk"		, POS_DEAD    , do_skill    , 0, 0 },
   { "skillset" , "skillset"	, POS_SLEEPING, do_skillset , LVL_SUPGOD, 0 },
  // ( "slang"    , "slang"       , POS_FIGHTING, do_slang    , 1, 0 },
   { "slast"    , "slas"	, POS_DEAD    , do_slast    , LVL_SUBIMPL, 0 },
   { "sleep"    , "sleep"	, POS_SLEEPING, do_sleep    , 0, 0 },
   { "slist"    , "sli"		, POS_DEAD    , do_slist    , 0, 0 },
   { "slowns"   , "slowns"	, POS_DEAD    , do_gen_tog  , LVL_IMPL, SCMD_SLOWNS },
   { "sneak"    , "sn"		, POS_STANDING, do_sneak    , 1, 0 },
   { "snoop"    , "snoop"	, POS_DEAD    , do_snoop    , LVL_LORD, 0 },
   { "socials"  , "soc"		, POS_DEAD    , do_commands , 0, SCMD_SOCIALS },
   { "spells"   , "sp"		, POS_DEAD    , do_spell    , 0, 0 },
   { "split"    , "split"	, POS_SITTING , do_split    , 1, 0 },
   { "sps"      , "sps"	        , POS_DEAD    , do_sps      , LVL_SUBIMPL, 0 },
   { "stand"    , "st"		, POS_RESTING , do_stand    , 0, 0 },
   { "stat"     , "stat"	, POS_DEAD    , do_stat     , LVL_ELDER, 0 },
   { "steal"    , "ste"		, POS_STANDING, do_steal    , 1, 0 },
   { "style"    , "sty"		, POS_STANDING, do_style    , 1, 0 },
   { "stroke"   , "stro"	, POS_FIGHTING, do_stroke   , 1, 0 },
   { "summary"  , "sum"		, POS_DEAD    , do_summary  , 1, 0 },
   { "switch"   , "swit"	, POS_DEAD    , do_switch   , LVL_ELDER, 0 },
   { "swho"     , "swh"	        , POS_DEAD    , do_swho     , LVL_SUBIMPL, 0 },
   { "syslog"   , "sys"		, POS_DEAD    , do_syslog   , LVL_ELDER, 0 },

   { "tedit"    , "ted"		, POS_DEAD    , do_tedit    , LVL_GOD, 0 },
   { "tell"     , "t"		, POS_DEAD    , do_tell     , 0, 0 },
   { "take"     , "take"	, POS_RESTING , do_get      , 0, 0 },
   { "taste"    , "taste"	, POS_RESTING , do_eat      , 0, SCMD_TASTE },
   { "teleport" , "tele"	, POS_DEAD    , do_teleport , LVL_GOD, 0 },
   { "thaw"     , "thaw"	, POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_THAW },
   { "title"    , "ti"		, POS_DEAD    , do_title    , 0, 0 },
   { "time"     , "time"	, POS_DEAD    , do_time     , 0, 0 },
   { "toggle"   , "tog"		, POS_DEAD    , do_toggle   , 0, 0 },
   { "track"    , "tr"		, POS_STANDING, do_track    , 0, 0 },
   { "transfer" , "trans"	, POS_SLEEPING, do_trans    , LVL_GOD, 0 },
   { "transform", "transform"   , POS_STANDING, do_transform, 0, 0 },
   { "trigedit" , "trig"	, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_TRIGEDIT},
   { "typo"     , "typo"	, POS_DEAD    , do_gen_write, 10, SCMD_TYPO },
   { "throw"    , "throw"       , POS_SLEEPING, do_throw     , 0, 0 },
   { "topten"   , "topten"      ,  POS_DEAD    , do_topten   , 0, 0},

   { "ukill"    , "ukil"        , POS_DEAD    , do_ukill    , LVL_SUBIMPL, 0 },
   { "unlock"   , "un"		, POS_SITTING , do_gen_door , 0, SCMD_UNLOCK },
   { "unban"    , "unban"       , POS_DEAD    , do_unban    , LVL_SUPGOD, 0 },
   { "ungroup"  , "ungr"	, POS_DEAD    , do_ungroup  , 0, 0 },
   { "unaffect" , "unaff"	, POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_UNAFFECT },
   { "unmount"  ,  "unm" 	, POS_RESTING , do_not_here , 0, 0 },
   { "uptime"   , "upt"		, POS_DEAD    , do_date     , LVL_ELDER, SCMD_UPTIME },
   { "use"      , "use"		, POS_SITTING , do_use      , 1, SCMD_USE },
   { "users"    , "users"	, POS_DEAD    , do_users    , LVL_ELDER, 0 },

   { "value"    , "val"		, POS_STANDING, do_not_here , 0, 0 },
   { "version"  , "version"	, POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION },
   { "visible"  , "vis"		, POS_RESTING , do_visible  , 1, 0 },
   { "vlist"    , "vl" 		, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_VLIST },
   { "vnum"     , "vnum"	, POS_DEAD    , do_vnum     , LVL_BUILDER, 0 },
   { "vstat"    , "vstat"	, POS_DEAD    , do_vstat    , LVL_BUILDER, 0 },
   { "vwear"    , "vwear"	, POS_DEAD    , do_veq      , LVL_BUILDER, 0 },

//   { "wanted"	, "wan"		, POS_DEAD    , do_wanted   , 0, 0 },
   { "war"	, "war"		, POS_STANDING, do_arena    , 0, 0 },
   { "wardome"  , "wardome"     , POS_STANDING, do_not_here , 1, 0 },
   { "warrior"   , "warrior"       , POS_FIGHTING, do_tempus,0,0 },
   { "warwho"	, "warw"	, POS_DEAD    , do_awho     , 0, 0 },
   { "warshout" , "wars"	, POS_FIGHTING, do_warshout , 0, 0 },
   { "wake"     , "wa"		, POS_SLEEPING, do_wake     , 0, 0 },
   { "wdprotocol","wdprot"	, POS_DEAD    , do_gen_tog  , 0, SCMD_WDPROTOCOL },
   { "wear"     , "wea"		, POS_RESTING , do_wear     , 0, 0 },
   { "weather"  , "weather"	, POS_RESTING , do_weather  , 0, 0 },
   { "who"      , "wh"		, POS_DEAD    , do_who      , 0, 0 },
   { "whois"    , "whois"       , POS_DEAD    , do_whois    , 0, 0 },
   { "where"    , "where"	, POS_RESTING , do_where    , 1, 0 },
   { "whisper"  , "whisp"	, POS_RESTING , do_spec_comm, 10, SCMD_WHISPER },
   { "whoami"   , "whoami"      , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI },
   { "wield"    , "wi"		, POS_RESTING , do_wield    , 0, 0 },
   { "wimpy"    , "wimp"	, POS_DEAD    , do_wimpy    , 0, 0 },
   { "withdraw" , "withdraw"	, POS_STANDING, do_not_here , 1, 0 },
   { "wiznet"   , "wiz"		, POS_DEAD    , do_wiznet   , LVL_ELDER, 0 },
   { ";"        , "wiz"		, POS_DEAD    , do_wiznet   , LVL_ELDER, 0 },
   { "wizhelp"  , "wizhelp"	, POS_SLEEPING, do_commands , LVL_ELDER, SCMD_WIZHELP },
   { "wizlist"  , "wizlist"	, POS_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST },
   { "wizlock"  , "wizlock"	, POS_DEAD    , do_wizlock  , LVL_MJGOD, 0 },
   { "write"    , "wr"		, POS_STANDING, do_write    , 5, 0 },
   { "whirlwind", "whirl"	, POS_FIGHTING, do_whirlwind, 1, 0 },

   { "xname"    , "xn"		, POS_DEAD    , do_xname    , LVL_SUPGOD, 0 },

   { "zedit"    , "zed"		, POS_DEAD    , do_olc      , LVL_BUILDER, SCMD_OLC_ZEDIT},
   { "zlist"    , "zl"		, POS_DEAD    , do_liblist  , LVL_BUILDER, SCMD_ZLIST },
   { "zreset"   , "zreset"	, POS_DEAD    , do_zreset   , LVL_BUILDER, 0 },


   /* DG trigger commands */
//   { "attach"   , "attach"	, POS_DEAD    , do_attach   , LVL_IMPL, 0 },
//   { "detach"   , "detach"	, POS_DEAD    , do_detach   , LVL_IMPL, 0 },
   { "tlist"    , "tlist"	, POS_DEAD    , do_tlist    , LVL_BUILDER, 0 },
   { "tstat"    , "tstat"	, POS_DEAD    , do_tstat    , LVL_BUILDER, 0 },
   { "masound"  , "masound"	, POS_DEAD    , do_masound  , 0, 0 },
   { "mkill"    , "mkill"	, POS_STANDING, do_mkill    , 0, 0 },
   { "mjunk"    , "mjunk"	, POS_SITTING , do_mjunk    , 0, 0 },
   { "mecho"    , "mecho"	, POS_DEAD    , do_mecho    , 0, 0 },
   { "mechoaround","mechoaround", POS_DEAD    , do_mechoaround, 0, 0 },
   { "msend"    , "msend"	, POS_DEAD    , do_msend    , 0, 0 },
   { "mload"    , "mload"	, POS_DEAD    , do_mload    , 0, 0 },
   { "mpurge"   , "mpurge"	, POS_DEAD    , do_mpurge    , 0, 0 },
   { "mgoto"    , "mgoto"	, POS_DEAD    , do_mgoto    , 0, 0 },
   { "mat"      , "mat"		, POS_DEAD    , do_mat      , 0, 0 },
   { "mteleport", "mteleport"	, POS_DEAD    , do_mteleport, 0, 0 },
   { "mforce"   , "mforce"	, POS_DEAD    , do_mforce   , 0, 0 },
   { "mexp"     , "mexp"	, POS_DEAD    , do_mexp     , 0, 0 },
   { "mgold"    , "mgold"	, POS_DEAD    , do_mgold    , 0, 0 },
   { "mhunt"    , "mhunt"	, POS_DEAD    , do_mhunt    , 0, 0 },
   { "mremember", "mremember"	, POS_DEAD    , do_mremember, 0, 0 },
   { "mforget"  , "mforget"	, POS_DEAD    , do_mforget  , 0, 0 },
   { "mtransform","mtransform"	, POS_DEAD    , do_mtransform, 0, 0 },

   { "\n",	"zzzzzzz",	0, 0, 0, 0 } };	/* this must be last */

const char *fill[] =
{
  "in",
  "from",
  "with",
  "the",
  "on",
  "at",
  "to",
  "\n"
};

const char *reserved[] =
{
  "a",
  "an",
  "self",
  "me",
  "all",
  "room",
  "someone",
  "something",
  "\n"
};

/*
 * This is the actual command interpreter called from game_loop() in comm.c
 * It makes sure you are the proper level and position to execute the command,
 * then calls the appropriate function.
 */
void command_interpreter(struct char_data *ch, char *argument)
{
  int cmd, length;
  char *line;

  REMOVE_BIT(AFF_FLAGS(ch), AFF_HIDE);
  REMOVE_BIT(AFF_FLAGS(ch), AFF_GAS);
  REMOVE_BIT(PLR_FLAGS(ch), PLR_MEDITATE);

  /* just drop to next line for hitting CR */
  skip_spaces(&argument);
  if (!*argument)
    return;

//  processar o speedwalk aki
  for (cmd = 0; *complete_cmd_info[cmd].command != '\n'; cmd++){
     if((!IS_MOVE(cmd)) && !(PLR_FLAGGED(ch, PLR_FROZEN) && GET_LEVEL(ch) < LVL_IMPL) && (do_run(ch, argument))){
         return;
     }
  }

  /*
   * special case to handle one-character, non-alphanumeric commands;
   * requested by many people so "'hi" or ";godnet test" is possible.
   * Patch sent by Eric Green and Stefan Wasilewski.
   */
  if (!isalpha(*argument)) {
    arg[0] = argument[0];
    arg[1] = '\0';
    line = argument + 1;
  } else
    line = any_one_arg(argument, arg);

  if ((GET_LEVEL(ch)<LVL_IMMORT) &&
      (command_wtrigger(ch, arg, line) ||
       command_mtrigger(ch, arg, line) ||
       command_otrigger(ch, arg, line)))
    return; /* command trigger took over */

  /* otherwise, find the command */
  for (length = strlen(arg), cmd = 0; *complete_cmd_info[cmd].command != '\n'; cmd++)
    if (!strncmp(complete_cmd_info[cmd].command, arg, length))
      if (GET_LEVEL(ch) >= complete_cmd_info[cmd].minimum_level){
        /* New crash test system -Petrus*/
        sprintf(buf, "(LAST COMMAND) %s: \"%s\" - (%d) - %s -\r\n", GET_NAME(ch), argument,
	        GET_ROOM_VNUM(ch->in_room), world[ch->in_room].name);
        write_last_command(buf);
        break;
      }
  if (*complete_cmd_info[cmd].command == '\n') {
    switch (number(1,14)) {
      case  1: send_to_char("Huh?!?\r\n", ch); break;
      case  2: send_to_char("I can't understand you...\r\n", ch); break;
      case  3: send_to_char("What are you trying to do?\r\n", ch); break;
      case  4: send_to_char("Are you drunk?\r\n", ch); break;
      case  5: send_to_char("Your keyboard must be broken...\r\n", ch); break;
      case  6: send_to_char("Que?!?\r\n", ch); break;
      case  7: send_to_char("What are you trying to do?!?\r\n", ch); break;
      case  8: send_to_char("Try typing HELP to see the most common commands.\r\n", ch); break;
      case  9: send_to_char("Ha?!?\r\n", ch); break;
      case 10: send_to_char("ZzZzZzZz...\r\n", ch); break;
      case 11: send_to_char("Type COMMANDS to see the commands avaiable.\r\n", ch); break;
      case 12: send_to_char("Are you playing with the keyboard?\r\n", ch); break;
      case 13: send_to_char("Verify your mind and try again...\r\n", ch); break;
      case 14: send_to_char("Don't you know how to command these shit? Type HELP.\r\n", ch); break;
    }
  }

  else if (PLR_FLAGGED(ch, PLR_FROZEN) && GET_LEVEL(ch) < LVL_IMPL)
    send_to_char("You try, but the mind-numbing cold prevents you...\r\n", ch);
//  else if (PRF_FLAGGED(ch, PRF_AFK))
//    send_to_char("Try turning your AFK flag off first.\r\n", ch);
  else if (complete_cmd_info[cmd].command_pointer == NULL)
    send_to_char("Sorry, that command hasn't been implemented yet.\r\n", ch);
  else if (IS_NPC(ch) && complete_cmd_info[cmd].minimum_level >= LVL_IMMORT)
    send_to_char("You can't use immortal commands while switched.\r\n", ch);
  else if (GET_POS(ch) < complete_cmd_info[cmd].minimum_position)
    switch (GET_POS(ch)) {
    case POS_DEAD:
      send_to_char("Lie still; you are DEAD!!! :-(\r\n", ch);
      break;
    case POS_INCAP:
    case POS_MORTALLYW:
      send_to_char("You are in a pretty bad shape, unable to do anything!\r\n", ch);
      break;
    case POS_STUNNED:
      send_to_char("All you can do right now is think about the stars!\r\n", ch);
      break;
    case POS_SLEEPING:
      send_to_char("In your dreams, or what?\r\n", ch);
      break;
    case POS_RESTING:
      send_to_char("Nah... You feel too relaxed to do that..\r\n", ch);
      break;
    case POS_SITTING:
      send_to_char("Maybe you should get on your feet first?\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("No way!  You're fighting for your life!\r\n", ch);
      break;
  } else if (no_specials || !special(ch, cmd, line))
    ((*complete_cmd_info[cmd].command_pointer) (ch, line, cmd, complete_cmd_info[cmd].subcmd));

}

/**************************************************************************
 * Routines to handle aliasing                                             *
  **************************************************************************/


struct alias *find_alias(struct alias *alias_list, char *str)
{
  while (alias_list != NULL) {
    if (*str == *alias_list->alias)     /* hey, every little bit counts :-) */
      if (!strcmp(str, alias_list->alias))
        return alias_list;

    alias_list = alias_list->next;
  }

  return NULL;
}


void free_alias(struct alias *a)
{
  if (a->alias)
    free(a->alias);
  if (a->replacement)
    free(a->replacement);
  free(a);
}


/* The interface to the outside world: do_alias */
ACMD(do_alias)
{
  char *repl;
  struct alias *a, *temp;

  if (IS_NPC(ch))
    return;

  repl = any_one_arg(argument, arg);

  if (!*arg) {                  /* no argument specified -- list currently defined aliases */
    send_to_char("Currently defined aliases:\r\n", ch);
    if ((a = GET_ALIASES(ch)) == NULL)
      send_to_char(" None.\r\n", ch);
    else {
      while (a != NULL) {
        sprintf(buf, "%15s: %s\r\n", a->alias, a->replacement);
        send_to_char(buf, ch);
        a = a->next;
      }
    }
  } else {                      /* otherwise, add or remove aliases */
    /* is this an alias we've already defined? */
    if ((a = find_alias(GET_ALIASES(ch), arg)) != NULL) {
      REMOVE_FROM_LIST(a, GET_ALIASES(ch), next);
      free_alias(a);
    }
    /* if no replacement string is specified, assume we want to delete */
    if (!*repl) {
      if (a == NULL)
        send_to_char("No such alias.\r\n", ch);
      else
        send_to_char("Alias deleted.\r\n", ch);
    } else {                    /* otherwise, either add or redefine an alias */
      if (!str_cmp(arg, "alias")) {
        send_to_char("You can't alias 'alias'.\r\n", ch);
        return;
      }
      CREATE(a, struct alias, 1);
      a->alias = str_dup(arg);
      delete_doubledollar(repl);
      a->replacement = str_dup(repl);
      if (strchr(repl, ALIAS_SEP_CHAR) || strchr(repl, ALIAS_VAR_CHAR))
        a->type = ALIAS_COMPLEX;
      else
        a->type = ALIAS_SIMPLE;
      a->next = GET_ALIASES(ch);
      GET_ALIASES(ch) = a;
      send_to_char("Alias added.\r\n", ch);
    }
  }
}

/*
 * Valid numeric replacements are only $1 .. $9 (makes parsing a little
 * easier, and it's not that much of a limitation anyway.)  Also valid
 * is "$*", which stands for the entire original line after the alias.
 * ";" is used to delimit commands.
 */
#define NUM_TOKENS       9

void perform_complex_alias(struct txt_q *input_q, char *orig, struct alias *a)
{
  struct txt_q temp_queue;
  char *tokens[NUM_TOKENS], *temp, *write_point;
  int num_of_tokens = 0, num;

  /* First, parse the original string */
  temp = strtok(strcpy(buf2, orig), " ");
  while (temp != NULL && num_of_tokens < NUM_TOKENS) {
    tokens[num_of_tokens++] = temp;
    temp = strtok(NULL, " ");
  }

  /* initialize */
  write_point = buf;
  temp_queue.head = temp_queue.tail = NULL;

  /* now parse the alias */
  for (temp = a->replacement; *temp; temp++) {
    if (*temp == ALIAS_SEP_CHAR) {
      *write_point = '\0';
      buf[MAX_INPUT_LENGTH - 1] = '\0';
      write_to_q(buf, &temp_queue, 1);
      write_point = buf;
    } else if (*temp == ALIAS_VAR_CHAR) {
      temp++;
      if ((num = *temp - '1') < num_of_tokens && num >= 0) {
        strcpy(write_point, tokens[num]);
        write_point += strlen(tokens[num]);
      } else if (*temp == ALIAS_GLOB_CHAR) {
        strcpy(write_point, orig);
        write_point += strlen(orig);
      } else if ((*(write_point++) = *temp) == '$')     /* redouble $ for act safety */
        *(write_point++) = '$';
    } else
      *(write_point++) = *temp;
  }

  *write_point = '\0';
  buf[MAX_INPUT_LENGTH - 1] = '\0';
  write_to_q(buf, &temp_queue, 1);

  /* push our temp_queue on to the _front_ of the input queue */
  if (input_q->head == NULL)
    *input_q = temp_queue;
  else {
    temp_queue.tail->next = input_q->head;
    input_q->head = temp_queue.head;
  }
}


/*
 * Given a character and a string, perform alias replacement on it.
 *
 * Return values:
 *   0: String was modified in place; call command_interpreter immediately.
 *   1: String was _not_ modified in place; rather, the expanded aliases
 *      have been placed at the front of the character's input queue.
 */
int perform_alias(struct descriptor_data *d, char *orig)
{
  char first_arg[MAX_INPUT_LENGTH], *ptr;
  struct alias *a, *tmp;

  /* Mobs don't have alaises. */
  if (IS_NPC(d->character))
    return 0;

  /* bail out immediately if the guy doesn't have any aliases */
  if ((tmp = GET_ALIASES(d->character)) == NULL)
    return 0;

  /* find the alias we're supposed to match */
  ptr = any_one_arg(orig, first_arg);

  /* bail out if it's null */
  if (!*first_arg)
    return 0;

  /* if the first arg is not an alias, return without doing anything */
  if ((a = find_alias(tmp, first_arg)) == NULL)
    return 0;

  if (a->type == ALIAS_SIMPLE) {
    strcpy(orig, a->replacement);
    return 0;
  } else {
    perform_complex_alias(&d->input, ptr, a);
    return 1;
  }
}



/***************************************************************************
 * Various other parsing utilities                                         *
 **************************************************************************/

/*
 * searches an array of strings for a target string.  "exact" can be
 * 0 or non-0, depending on whether or not the match must be exact for
 * it to be returned.  Returns -1 if not found; 0..n otherwise.  Array
 * must be terminated with a '\n' so it knows to stop searching.
 */
int search_block(char *arg, const char **list, int exact)
{
  int i, l;

  /* Make into lower case, and get length of string */
  for (l = 0; *(arg + l); l++)
    *(arg + l) = LOWER(*(arg + l));

  if (exact) {
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strcmp(arg, *(list + i)))
        return (i);
  } else {
    if (!l)
      l = 1;                    /* Avoid "" to match the first available
                                 * string */
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strncmp(arg, *(list + i), l))
        return (i);
  }

  return -1;
}


/*
 * This function does the same thing as search_block, but it
 * uses strcasecmp.    */
int search_block_case(char *arg, char **list, bool exact)
{
  int i, l;

  /* Make into lower case, and get length of string */
  for (l = 0; *(arg + l); l++)
    *(arg + l) = LOWER(*(arg + l));

  if (exact) {
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strcasecmp(arg, *(list + i)))
	return (i);
  } else {
    if (!l)
      l = 1;			/* Avoid "" to match the first available
				 * string */
    for (i = 0; **(list + i) != '\n'; i++)
      if (!strncasecmp(arg, *(list + i), l))
	return (i);
  }

  return -1;
}


int is_number(const char *str)
{
  if (!str || !*str)	/* Test for NULL pointer or string. */
    return FALSE;

  if (*str == '-')	/* -'s in front are valid. */
    str++;

  while (*str)
    if (!isdigit(*(str++)))
      return FALSE;

  return TRUE;
}

/*
 * Function to skip over the leading spaces of a string.
 */
void skip_spaces(char **string)
{
  for (; **string && isspace(**string); (*string)++);
}


/*
 * Given a string, change all instances of double dollar signs ($$) to
 * single dollar signs ($).  When strings come in, all $'s are changed
 * to $$'s to avoid having users be able to crash the system if the
 * inputted string is eventually sent to act().  If you are using user
 * input to produce screen output AND YOU ARE SURE IT WILL NOT BE SENT
 * THROUGH THE act() FUNCTION (i.e., do_gecho, do_title, but NOT do_say),
 * you can call delete_doubledollar() to make the output look correct.
 *
 * Modifies the string in-place.
 */
char *delete_doubledollar(char *string)
{
  char *read, *write;

  /* If the string has no dollar signs, return immediately */
  if ((write = strchr(string, '$')) == NULL)
    return string;

  /* Start from the location of the first dollar sign */
  read = write;


  while (*read)   /* Until we reach the end of the string... */
    if ((*(write++) = *(read++)) == '$') /* copy one char */
      if (*read == '$')
        read++; /* skip if we saw 2 $'s in a row */

  *write = '\0';

  return string;
}


int fill_word(char *argument)
{
  return (search_block(argument, fill, TRUE) >= 0);
}


int reserved_word(char *argument)
{
  return (search_block(argument, reserved, TRUE) >= 0);
}


/*
 * copy the first non-fill-word, space-delimited argument of 'argument'
 * to 'first_arg'; return a pointer to the remainder of the string.
 */
char *one_argument(char *argument, char *first_arg)
{
  char *begin = first_arg;

  if (!argument) {
    log("SYSERR: one_argument received a NULL pointer!");
    *first_arg = '\0';
    return NULL;
  }

  do {
    skip_spaces(&argument);

    first_arg = begin;
    while (*argument && !isspace(*argument)) {
      *(first_arg++) = LOWER(*argument);
      argument++;
    }

    *first_arg = '\0';
  } while (fill_word(begin));

  return argument;
}


/*
 * one_word is like one_argument, except that words in quotes ("") are
 * considered one word.
 */
char *one_word(char *argument, char *first_arg)
{
  char *begin = first_arg;

  do {
    skip_spaces(&argument);

    first_arg = begin;

    if (*argument == '\"') {
      argument++;
      while (*argument && *argument != '\"') {
        *(first_arg++) = LOWER(*argument);
        argument++;
      }
      argument++;
    } else {
      while (*argument && !isspace(*argument)) {
        *(first_arg++) = LOWER(*argument);
        argument++;
      }
    }

    *first_arg = '\0';
  } while (fill_word(begin));

  return argument;
}


/* same as one_argument except that it doesn't ignore fill words */
char *any_one_arg(char *argument, char *first_arg)
{
  skip_spaces(&argument);

  while (*argument && !isspace(*argument)) {
    *(first_arg++) = LOWER(*argument);
    argument++;
  }

  *first_arg = '\0';

  return argument;
}


/*
 * Same as one_argument except that it takes two args and returns the rest;
 * ignores fill words
 */
char *two_arguments(char *argument, char *first_arg, char *second_arg)
{
  return one_argument(one_argument(argument, first_arg), second_arg); /* :-) */
}



/*
 * determine if a given string is an abbreviation of another
 * (now works symmetrically -- JE 7/25/94)
 *
 * that was dumb.  it shouldn't be symmetrical.  JE 5/1/95
 *
 * returnss 1 if arg1 is an abbreviation of arg2
 */
int is_abbrev(const char *arg1, const char *arg2)
{
  if (!*arg1)
    return 0;

  for (; *arg1 && *arg2; arg1++, arg2++)
    if (LOWER(*arg1) != LOWER(*arg2))
      return 0;

  if (!*arg1)
    return 1;
  else
    return 0;
}



/* return first space-delimited token in arg1; remainder of string in arg2 */
void half_chop(char *string, char *arg1, char *arg2)
{
  char *temp;

  temp = any_one_arg(string, arg1);
  skip_spaces(&temp);
  strcpy(arg2, temp);
}



/* Used in specprocs, mostly.  (Exactly) matches "command" to cmd number */
int find_command(const char *command)
{
  int cmd;

  for (cmd = 0; *complete_cmd_info[cmd].command != '\n'; cmd++)
    if (!strcmp(complete_cmd_info[cmd].command, command))
      return cmd;

  return -1;
}


int special(struct char_data *ch, int cmd, char *arg)
{
  struct obj_data *i;
  struct char_data *k;
  int j;

  /* special in room? */
  if (GET_ROOM_SPEC(ch->in_room) != NULL)
    if (GET_ROOM_SPEC(ch->in_room) (ch, world + ch->in_room, cmd, arg))
      return 1;

  /* special in equipment list? */
  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j) && GET_OBJ_SPEC(GET_EQ(ch, j)) != NULL)
      if (GET_OBJ_SPEC(GET_EQ(ch, j)) (ch, GET_EQ(ch, j), cmd, arg))
        return 1;

  /* special in inventory? */
  for (i = ch->carrying; i; i = i->next_content)
    if (GET_OBJ_SPEC(i) != NULL)
      if (GET_OBJ_SPEC(i) (ch, i, cmd, arg))
        return 1;

  /* special in mobile present? */
  for (k = world[ch->in_room].people; k; k = k->next_in_room)
    if (GET_MOB_SPEC(k) != NULL)
      if (GET_MOB_SPEC(k) (ch, k, cmd, arg))
        return 1;

  /* special in object present? */
  for (i = world[ch->in_room].contents; i; i = i->next_content)
    if (GET_OBJ_SPEC(i) != NULL)
      if (GET_OBJ_SPEC(i) (ch, i, cmd, arg))
        return 1;

  return 0;
}



/* *************************************************************************
*  Stuff for controlling the non-playing sockets (get name, pwd etc)       *
************************************************************************* */


/* locate entry in p_table with entry->name == name. -1 mrks failed search */
int find_name(char *name)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++) {
    if (!str_cmp((player_table + i)->name, name))
      return i;
  }

  return -1;
}


int _parse_name(char *arg, char *name)
{
  int i;

  /* skip whitespaces */
  for (; isspace(*arg); arg++);

  for (i = 0; (*name = *arg); arg++, i++, name++)
    if (!isalpha(*arg))
      return 1;

  if (!i)
    return 1;

  return 0;
}


#define RECON           1
#define USURP           2
#define UNSWITCH        3

/*
 * XXX: Make immortals 'return' instead of being disconnected when switched
 *      into person returns.  This function seems a bit over-extended too.
 */
int perform_dupe_check(struct descriptor_data *d)
{
  struct descriptor_data *k, *next_k;
  struct char_data *target = NULL, *ch, *next_ch;
  int mode = 0;

  int id = GET_IDNUM(d->character);

  /*
   * Now that this descriptor has successfully logged in, disconnect all
   * other descriptors controlling a character with the same ID number.
   */

  for (k = descriptor_list; k; k = next_k) {
    next_k = k->next;

    if (k == d)
      continue;

    if (k->original && (GET_IDNUM(k->original) == id)) {    /* switched char */
      SEND_TO_Q("\r\nMultiple login detected -- disconnecting.\r\n", k);
      STATE(k) = CON_CLOSE;
      if (!target) {
        target = k->original;
        mode = UNSWITCH;
      }
      if (k->character)
        k->character->desc = NULL;
      k->character = NULL;
      k->original = NULL;
    } else if (k->character && (GET_IDNUM(k->character) == id)) {
      if (!target && STATE(k) == CON_PLAYING) {
        SEND_TO_Q("\r\nThis body has been usurped!\r\n", k);
        target = k->character;
        mode = USURP;
      }
      k->character->desc = NULL;
      k->character = NULL;
      k->original = NULL;
      SEND_TO_Q("\r\nMultiple login detected -- disconnecting.\r\n", k);
      STATE(k) = CON_CLOSE;
    }
  }

 /*
  * now, go through the character list, deleting all characters that
  * are not already marked for deletion from the above step (i.e., in the
  * CON_HANGUP state), and have not already been selected as a target for
  * switching into.  In addition, if we haven't already found a target,
  * choose one if one is available (while still deleting the other
  * duplicates, though theoretically none should be able to exist).
  */

  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    if (IS_NPC(ch))
      continue;
    if (GET_IDNUM(ch) != id)
      continue;

    /* ignore chars with descriptors (already handled by above step) */
    if (ch->desc)
      continue;

    /* don't extract the target char we've found one already */
    if (ch == target)
      continue;

    /* we don't already have a target and found a candidate for switching */
    if (!target) {
      target = ch;
      mode = RECON;
      continue;
    }

    /* we've found a duplicate - blow him away, dumping his eq in limbo. */
    if (ch->in_room != NOWHERE)
      char_from_room(ch);
    char_to_room(ch, 1);
    extract_char(ch);
  }

  /* no target for swicthing into was found - allow login to continue */
  if (!target)
    return 0;

  /* Okay, we've found a target.  Connect d to target. */
  free_char(d->character); /* get rid of the old char */
  d->character = target;
  d->character->desc = d;
  d->original = NULL;
  d->character->char_specials.timer = 0;
  REMOVE_BIT(PLR_FLAGS(d->character), PLR_MAILING | PLR_WRITING);
  STATE(d) = CON_PLAYING;

  switch (mode) {
  case RECON:
    SEND_TO_Q("Reconnecting.\r\n", d);
    act("$n has reconnected.", TRUE, d->character, 0, 0, TO_ROOM);
    sprintf(buf, "%s [%s] has reconnected.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  case USURP:
    SEND_TO_Q("You take over your own body, already in use!\r\n", d);
    act("$n suddenly keels over in pain, surrounded by a white aura...\r\n"
        "$n's body has been taken over by a new spirit!",
        TRUE, d->character, 0, 0, TO_ROOM);
    sprintf(buf, "%s has re-logged in ... disconnecting old socket.",
            GET_NAME(d->character));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  case UNSWITCH:
    SEND_TO_Q("Reconnecting to unswitched char.", d);
    sprintf(buf, "%s [%s] has reconnected.", GET_NAME(d->character), d->host);
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);
    break;
  }

  return 1;
}

sh_int race_class[][NUM_CLASSES] = {
//  SO  CL  TH  WA  NE  PA  NI  RA  PS  WR  BA  SH
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //HUMA
   { 1,  1,  1,  0,  1,  0,  0,  1,  1,  1,  0,  0 }, //DROW
   { 1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0 }, //DWAR
   { 1,  1,  1,  1,  0,  0,  0,  1,  1,  0,  0,  1 }, //ELF
   { 0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  1,  1 }, //OGRE
   { 0,  0,  0,  1,  1,  0,  0,  0,  0,  0,  1,  1 }, //ORC
   { 1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  1 }, //TROL
   { 1,  1,  0,  0,  1,  0,  1,  0,  1,  1,  0,  0 }, //GITH
   { 0,  1,  1,  0,  0,  0,  0,  1,  1,  0,  0,  0 }, //GNOM
   { 0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1 }, //LIZA
   { 0,  1,  1,  0,  0,  0,  1,  0,  0,  1,  0,  0 }, //SEA
   { 0,  0,  1,  1,  1,  0,  1,  0,  0,  0,  0,  0 }, //GORA
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //DUNE
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //ANCI
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Nau
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Hig
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Hil
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Bug
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Cav
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Lic
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Tin
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Dra
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }, //Hse
   { 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1 }  //Arc
};

int allowed_classes(int x, int i)
{
	if(race_class[x][i])
    	  	return (TRUE);

    return (FALSE);
}

/* load the player, put them in the right room - used by copyover_recover too */
int enter_player_game (struct descriptor_data *d)
{
    extern sh_int r_mortal_start_room;
    extern sh_int r_immort_start_room;
    extern sh_int r_frozen_start_room;
    int i;

    sh_int load_room;
    int load_result;

    reset_char(d->character);

    if (PLR_FLAGGED(d->character, PLR_INVSTART))
        GET_INVIS_LEV(d->character) = GET_LEVEL(d->character);

    if ((load_result = Crash_load(d->character)))
        d->character->in_room = NOWHERE;

    read_aliases(d->character);
    GET_ID(d->character) = GET_IDNUM(d->character);
    save_char(d->character, NOWHERE);

    d->character->next = character_list;
    character_list = d->character;

      load_room = GET_LOADROOM(d->character);

      for(i=0;i<NUM_ROOMS;i++)
       if (load_room == to_fly_rooms[i]){
        load_room = NOWHERE;
       }

      if (load_room == NOWHERE) {
        if (GET_LEVEL(d->character) >= LVL_ELDER) {
          load_room = r_immort_start_room;
        } else {
          load_room = r_mortal_start_room;
        }
      } else {
        load_room = real_room(load_room);
      }

    if (PLR_FLAGGED(d->character, PLR_FROZEN))
        load_room = r_frozen_start_room;

    if (PLR_FLAGGED(d->character, PLR_DEAD))
        load_room = r_deadly_start_room;

    char_to_room(d->character, load_room);

    return load_result;
}


/* deal with newcomers and other non-playing sockets */
void nanny(struct descriptor_data *d, char *arg)
{
  char buf[128];
  int player_i, load_result;
  char tmp_name[MAX_INPUT_LENGTH];

  skip_spaces(&arg);

  switch (STATE(d)) {

  /*. OLC states .*/
  case CON_HEDIT:
    hedit_parse(d, arg);
    break;
  case CON_OEDIT:
    oedit_parse(d, arg);
    break;
  case CON_REDIT:
    redit_parse(d, arg);
    break;
  case CON_ZEDIT:
    zedit_parse(d, arg);
    break;
  case CON_MEDIT:
    medit_parse(d, arg);
    break;
  case CON_SEDIT:
    sedit_parse(d, arg);
    break;
  case CON_AEDIT:
    aedit_parse(d, arg);
    break;
  case CON_TRIGEDIT:
    trigedit_parse(d, arg);
    break;
  case CON_QEDIT:
    qedit_parse(d, arg);
    break;
  /*. End of OLC states .*/

  case CON_GET_NAME:            /* wait for input of name */
    if (d->character == NULL) {
      CREATE(d->character, struct char_data, 1);
      clear_char(d->character);
      CREATE(d->character->player_specials, struct player_special_data, 1);
      d->character->desc = d;
    }
    if (!*arg)
      STATE(d) = CON_CLOSE;
    else {
      if ((_parse_name(arg, tmp_name)) || strlen(tmp_name) < 2 ||
          strlen(tmp_name) > MAX_NAME_LENGTH || !Valid_Name(tmp_name) ||
          fill_word(strcpy(buf, tmp_name)) || reserved_word(buf)) {
        SEND_TO_Q("Invalid name, please try another.\r\n"
                  "Name: ", d);
        return;
      }
      if ((player_i = load_char(tmp_name, d->character)) > -1) {
        GET_PFILEPOS(d->character) = player_i;

        if (PLR_FLAGGED(d->character, PLR_DELETED)) {

	  /* make sure old files are removed so the new player doesn't get
	     the deleted player's equipment (this should probably be a
	     stock behavior)
	  */
	  if((player_i = find_name(tmp_name)) >= 0)
	    remove_player(player_i);

          /* We get a false positive from the original deleted character. */
          free_char(d->character);
          d->character = NULL;
          /* Check for multiple creations... */
          if (!Valid_Name(tmp_name)) {
            SEND_TO_Q("Invalid name, please try another.\r\nName: ", d);
            return;
          }
          CREATE(d->character, struct char_data, 1);
          clear_char(d->character);
          CREATE(d->character->player_specials, struct player_special_data, 1);
          d->character->desc = d;
          CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
          strcpy(d->character->player.name, CAP(tmp_name));
          GET_PFILEPOS(d->character) = player_i;
          sprintf(buf, "Did I get that right, %s (Y/N)? ", tmp_name);
          SEND_TO_Q(buf, d);
          STATE(d) = CON_NAME_CNFRM;
        } else {
          /* undo it just in case they are set */
          REMOVE_BIT(PLR_FLAGS(d->character),
                     PLR_WRITING | PLR_MAILING | PLR_CRYO);

          SEND_TO_Q("Password: ", d);
          echo_off(d);
          d->idle_tics = 0;
          STATE(d) = CON_PASSWORD;
        }
      } else {
        /* player unknown -- make new character */

        /* Check for multiple creations of a character. */
        if (!Valid_Name(tmp_name)) {
          SEND_TO_Q("Invalid name, please try another.\r\nName: ", d);
          return;
        }
        CREATE(d->character->player.name, char, strlen(tmp_name) + 1);
        strcpy(d->character->player.name, CAP(tmp_name));

        sprintf(buf, "Did I get that right, %s (Y/N)? ", tmp_name);
        SEND_TO_Q(buf, d);
        STATE(d) = CON_NAME_CNFRM;
      }
    }
    break;
  case CON_NAME_CNFRM:          /* wait for conf. of new name    */
    if (UPPER(*arg) == 'Y') {
      if (isbanned(d->host) >= BAN_NEW) {
        sprintf(buf, "Request for new char %s denied from [%s] (siteban)",
                GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_GOD, TRUE);
        SEND_TO_Q("Sorry, new characters are not allowed from your site!\r\n", d);
        STATE(d) = CON_CLOSE;
        return;
      }
      if (circle_restrict) {
        SEND_TO_Q("Sorry, new players can't be created at the moment.\r\n", d);
        sprintf(buf, "Request for new char %s denied from [%s] (wizlock)",
                GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_GOD, TRUE);
        STATE(d) = CON_CLOSE;
        return;
      }
      SEND_TO_Q("New character.\r\n", d);
      sprintf(buf, "Give me a password for %s: ", GET_NAME(d->character));
      SEND_TO_Q(buf, d);
      echo_off(d);
      STATE(d) = CON_NEWPASSWD;
    } else if (*arg == 'n' || *arg == 'N') {
      SEND_TO_Q("Okay, what IS it, then? ", d);
      free(d->character->player.name);
      d->character->player.name = NULL;
      STATE(d) = CON_GET_NAME;
    } else {
      SEND_TO_Q("Please type Yes or No: ", d);
    }
    break;
  case CON_PASSWORD:            /* get pwd for known player      */
    /*
     * To really prevent duping correctly, the player's record should
     * be reloaded from disk at this point (after the password has been
     * typed).  However I'm afraid that trying to load a character over
     * an already loaded character is going to cause some problem down the
     * road that I can't see at the moment.  So to compensate, I'm going to
     * (1) add a 15 or 20-second time limit for entering a password, and (2)
     * re-add the code to cut off duplicates when a player quits.  JE 6 Feb 96
     */

    echo_on(d);    /* turn echo back on */

    if (!*arg)
      STATE(d) = CON_CLOSE;
    else {
      if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
        sprintf(buf, "Bad PW: %s [%s]", GET_NAME(d->character), d->host);
        mudlog(buf, BRF, LVL_GOD, TRUE);
        GET_BAD_PWS(d->character)++;
        save_char(d->character, NOWHERE);
        if (++(d->bad_pws) >= max_bad_pws) {    /* 3 strikes and you're out. */
          SEND_TO_Q("Wrong password... disconnecting.\r\n", d);
          STATE(d) = CON_CLOSE;
        } else {
          SEND_TO_Q("Wrong password.\r\nPassword: ", d);
          echo_off(d);
        }
        return;
      }

      /* Password was correct. */
      load_result = GET_BAD_PWS(d->character);
      GET_BAD_PWS(d->character) = 0;
      d->bad_pws = 0;

      if (isbanned(d->host) == BAN_SELECT &&
          !PLR_FLAGGED(d->character, PLR_SITEOK)) {
        SEND_TO_Q("Sorry, this char has not been cleared for login from your site!\r\n", d);
        STATE(d) = CON_CLOSE;
        sprintf(buf, "Connection attempt for %s denied from %s",
                GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_GOD, TRUE);
        return;
      }
      if (GET_LEVEL(d->character) < circle_restrict) {
        SEND_TO_Q("The game is temporarily restricted.. try again later.\r\n", d);
        STATE(d) = CON_CLOSE;
        sprintf(buf, "Request for login denied for %s [%s] (wizlock)",
                GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_GOD, TRUE);
        return;
      }
      /* check and make sure no other copies of this player are logged in */
      if (perform_dupe_check(d))
        return;

      if (GET_LEVEL(d->character) >= LVL_ELDER)
        SEND_TO_Q(imotd, d);
      else
        SEND_TO_Q(motd, d);

      sprintf(buf, "%s [%s] has connected.", GET_NAME(d->character), d->host);
      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE);

      if (load_result) {
        sprintf(buf, "\r\n\r\n\007\007\007"
                "%s%d LOGIN FAILURE%s SINCE LAST SUCCESSFUL LOGIN.%s\r\n",
                CCRED(d->character, C_SPR), load_result,
                (load_result > 1) ? "S" : "", CCNRM(d->character, C_SPR));
        SEND_TO_Q(buf, d);
        GET_BAD_PWS(d->character) = 0;
      }
      SEND_TO_Q("\r\n\n&n*** PRESS RETURN *** ", d);
      STATE(d) = CON_RMOTD;
    }
    break;

  case CON_NEWPASSWD:
  case CON_CHPWD_GETNEW:
    if (!*arg || strlen(arg) > MAX_PWD_LENGTH || strlen(arg) < 3 ||
        !str_cmp(arg, GET_NAME(d->character))) {
      SEND_TO_Q("\r\nIllegal password.\r\n", d);
      SEND_TO_Q("Password: ", d);
      return;
    }
    strncpy(GET_PASSWD(d->character), CRYPT(arg, GET_NAME(d->character)), MAX_PWD_LENGTH);
    *(GET_PASSWD(d->character) + MAX_PWD_LENGTH) = '\0';

    SEND_TO_Q("\r\nPlease retype password: ", d);
    if (STATE(d) == CON_NEWPASSWD)
      STATE(d) = CON_CNFPASSWD;
    else
      STATE(d) = CON_CHPWD_VRFY;

    break;

  case CON_CNFPASSWD:
  case CON_CHPWD_VRFY:
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character),
                MAX_PWD_LENGTH)) {
      SEND_TO_Q("\r\nPasswords don't match... start over.\r\n", d);
      SEND_TO_Q("Password: ", d);
      if (STATE(d) == CON_CNFPASSWD)
        STATE(d) = CON_NEWPASSWD;
      else
        STATE(d) = CON_CHPWD_GETNEW;
      return;
    }
    echo_on(d);

    if (STATE(d) == CON_CNFPASSWD) {
      SEND_TO_Q("ANSI terminal is a terminal with color suport.\r\n"
		"Normal Terminal is a terminal with no color suport.\r\n"
		"\r\n"
		"You only have color suport when you use a MUD client...\r\n"
		"If you aren't using a MUD client select the Normal Terminal.\r\n"
		"\r\n"
		"IMPORTANT: You can change this using the color command on the game.\r\n"
      		"\r\n"
      		"Select 'a' for a ANSI Terminal or 'n' for a Normal Terminal.\r\n"
                "You use a ANSI Terminal or a Normal Terminal? ", d);
      STATE(d) = CON_TERMINAL;
    } else {
      echo_on(d);
      SEND_TO_Q("\r\nDone.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    }

    break;

  case CON_TERMINAL:          /* query terminal of new user         */
    switch (*arg) {
    case 'a':
    case 'A':
      SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_1);
      SET_BIT(PRF_FLAGS(d->character), PRF_COLOR_2);
      break;
    case 'n':
    case 'N':
      break;
    default:
      SEND_TO_Q("\r\n"
      		"That is not a choice...\r\n"
                "Select 'a' to ANSI or 'n' to Normal Terminal.\r\n"
                "You are using a ANSI Terminal or a Normal Terminal? ", d);
      return;
    }
    SEND_TO_Q("\r\nWhat is your sex (M/F)? ", d);
    STATE(d) = CON_QSEX;
    break;

  case CON_QSEX:                /* query sex of new user         */
    switch (*arg) {
    case 'm':
    case 'M':
      d->character->player.sex = SEX_MALE;
      break;
    case 'f':
    case 'F':
      d->character->player.sex = SEX_FEMALE;
      break;
    default:
      SEND_TO_Q("\r\n"
      		"That is not a sex..\r\n"
                "What IS your sex? ", d);
      return;
    }

    display_races(d);
    SEND_TO_Q("\r\nOption: ", d);
    STATE(d) = CON_QRACE;
    break;

  case CON_QRACE:
    load_result = parse_race(*arg);
    if (load_result == RACE_UNDEFINED ) {
      SEND_TO_Q("\r\nThat's not a valid option.\r\nOption: ", d);
      return;
    }

    if(load_result > 11)
    {
     SEND_TO_Q("\r\nThis is a very advanced race. Choose another.\r\nOption: ", d);
     return ;

    } else
      GET_RACE(d->character) = load_result;

    SEND_TO_Q("\r\n", d);
    do_help(d->character, pc_race_help_types[(int)load_result], 0, 0);
    SEND_TO_Q("&WDo you accept this race(&wy&W/&wn&W)? &w", d);
    STATE(d) = CON_QCONFIRMRACE;
    break;

  case CON_QCONFIRMRACE:

    switch (*arg) {

    case 'y':
    case 'Y':
      display_classes(d);
      SEND_TO_Q("\r\nOption: ", d);
      STATE(d) = CON_QCLASS;
      break;
    default:
      display_races(d);
      SEND_TO_Q("\r\nOption: ", d);
      STATE(d) = CON_QRACE;
      break;
    }
    break;


  case CON_QCLASS:
    load_result = parse_class(*arg);

    if (*arg == '-') {
      display_races(d);
      SEND_TO_Q("\r\nOption: ", d);
      STATE(d) = CON_QRACE;
      return;
    }

    if (load_result == CLASS_UNDEFINED ||
     !allowed_classes(GET_RACE(d->character), load_result)) {
      SEND_TO_Q("\r\nThat's not a valid option.\r\nOption: ", d);
      return;
    }
    GET_CLASS(d->character) = load_result;
    roll_real_abils(d->character);
    SEND_TO_Q("\r\n", d);
    display_stat(d);
    SEND_TO_Q("\r\n", d);
    disp_abils(d, load_result);
    SEND_TO_Q("&WDo you accept this character(&wy&W/&wn&W)? &w", d);
    STATE(d) = CON_QCONFIRMCLAS;
    break;

  case CON_QCONFIRMCLAS:

    switch (*arg) {
      case 'y':
      case 'Y':
        if (GET_PFILEPOS(d->character) < 0)
          GET_PFILEPOS(d->character) = create_entry(GET_NAME(d->character));

//        if(number(1,75) == 34)
//        GET_RACE(d->character) =  GET_RACE(d->character) + 12 ;

        init_char(d->character);
        save_char(d->character, NOWHERE);
        save_player_index();
        SEND_TO_Q(motd, d);
        SEND_TO_Q("\r\n\n&n*** PRESS RETURN *** ", d);
        STATE(d) = CON_RMOTD;
        sprintf(buf, "%s [%s] new player.", GET_NAME(d->character), d->host);
        mudlog(buf, NRM, LVL_IMMORT, TRUE);
        break;
      default:
        display_classes(d);
        SEND_TO_Q("\r\nOption: ", d);
        STATE(d) = CON_QCLASS;
	return;
//        break;
    }
   break;

  case CON_RMOTD:               /* read CR after printing motd   */
    SEND_TO_Q(MENU, d);
    STATE(d) = CON_MENU;
    break;

  case CON_SUMMARY:
    SEND_TO_Q(MENU, d);
    STATE(d) = CON_MENU;
    break;

  case CON_MENU:                /* get selection from main menu  */
    switch (*arg) {
    case '0':
      SEND_TO_Q("\r\n\r\nA strange voice whispers, 'The WarDome will wait your return...'\r\n\r\nWARDOME.FUGSPBR.ORG 2022 !!!\r\n\r\n", d);
      SEND_TO_Q("VISIT THE WARDOME MUD LIST IN http://www2.fugspbr.org/mailman/listinfo/wardome .\r\n\r\n", d);
      STATE(d) = CON_CLOSE;
      break;

    case '1': // join in

      load_result = enter_player_game(d);
      act("$n is dropped from a vortex of light and enters in the WarDome.", TRUE, d->character, 0, 0, TO_ROOM);

      STATE(d) = CON_PLAYING;
      if (!GET_LEVEL(d->character)) {
        do_start(d->character);
	SET_BIT(PRF_FLAGS(d->character), PRF_INFO_START);
	save_char(d->character, NOWHERE);
        send_to_char(START_MESSG, d->character);
      }
      look_at_room(d->character, 0);
      if (has_mail(GET_IDNUM(d->character)))
        send_to_char("&yYou have &Ymail&y waiting.&n\r\n", d->character);
      if (is_complete(GET_QUEST(d->character))) {
        send_to_char("&CYour current quest are already completed. Try another.&n\r\n", d->character);
	GET_QUEST(d->character) = -1;
      }
      actualize_splskl(d->character);
      save_char(d->character, NOWHERE);
        if (load_result == 2) {   /* rented items lost */
        send_to_char("\r\n\007You could not afford your rent!\r\n"
          "Your possesions have been donated to the Salvation Army!\r\n",
                     d->character);
      }
      d->has_prompt = 0;
      topten(d->character);
      topten1(d->character);
      topten2(d->character);
      break;

    case '2':  // read rules
      page_string(d, policies, 0);
      STATE(d) = CON_RMOTD;
      break;

    case '3': // quest of the week
      page_string(d, background, 0);
      STATE(d) = CON_RMOTD;
      break;

    case '4': // change password
      SEND_TO_Q("\r\nEnter your old password: ", d);
      echo_off(d);
      STATE(d) = CON_CHPWD_GETOLD;
      break;

    case '5': // enter description
        STATE(d) = CON_RMOTD;
        break ;

      if (d->character->player.description) {
        SEND_TO_Q("Current description:\r\n", d);
        SEND_TO_Q(d->character->player.description, d);
        /*
         * Don't free this now... so that the old description gets loaded
         * as the current buffer in the editor.  Do setup the ABORT buffer
         * here, however.
         *
         * free(d->character->player.description);
         * d->character->player.description = NULL;
         */
        d->backstr = str_dup(d->character->player.description);
      }
      SEND_TO_Q("Enter the new text you'd like others to see when they look at you.\r\n", d);
      SEND_TO_Q("(/s saves /h for help)\r\n", d);
      d->str = &d->character->player.description;
      d->max_str = EXDSCR_LENGTH;
      STATE(d) = CON_EXDESC;
      break;

    case '6': // enter whoisdescription
      if (d->character->player.whoisdesc) {
        SEND_TO_Q("Current text description:\r\n", d);
        SEND_TO_Q(d->character->player.whoisdesc, d);
        /*
         * Don't free this now... so that the old description gets loaded
         * as the current buffer in the editor.  Do setup the ABORT buffer
         * here, however.
         *
         * free(d->character->player.description);
         * d->character->player.description = NULL;
         */
        d->backstr = str_dup(d->character->player.whoisdesc);
      }
      SEND_TO_Q("Enter the new text you'd like others to see when they ask for you in a player command.\r\n", d);
      SEND_TO_Q("(/s saves /h for help)\r\n", d);
      d->str = &d->character->player.whoisdesc;
      d->max_str = EXDSCR_LENGTH;
      STATE(d) = CON_EXDESC;
      break;

    case '7': // summary
      make_summary(d->character);
      STATE(d) = CON_SUMMARY;
      break;

    case '8': // delete
      SEND_TO_Q("\r\nEnter your password for verification: ", d);
      echo_off(d);
      STATE(d) = CON_DELCNF1;
      break;

    default: // error
      SEND_TO_Q("\r\nThat's not a menu choice!\r\n", d);
      SEND_TO_Q(MENU, d);
      break;
    }

    break;

  case CON_CHPWD_GETOLD:
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
      echo_on(d);
      SEND_TO_Q("\r\nIncorrect password.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    } else {
      SEND_TO_Q("\r\nEnter a new password: ", d);
      STATE(d) = CON_CHPWD_GETNEW;
    }
    return;

  case CON_DELCNF1:
    echo_on(d);
    if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
      SEND_TO_Q("\r\nIncorrect password.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    } else {
      SEND_TO_Q("\r\nYOU ARE ABOUT TO DELETE THIS CHARACTER PERMANENTLY.\r\n"
                "ARE YOU ABSOLUTELY SURE?\r\n\r\n"
                "Please type \"yes\" to confirm: ", d);
      STATE(d) = CON_DELCNF2;
    }
    break;

  case CON_DELCNF2:
    if (!strcmp(arg, "yes") || !strcmp(arg, "YES")) {
      if (PLR_FLAGGED(d->character, PLR_FROZEN)) {
        SEND_TO_Q("You try to kill yourself, but the ice stops you.\r\n", d);
        SEND_TO_Q("Character not deleted.\r\n\r\n", d);
        STATE(d) = CON_CLOSE;
        return;
      }
      if (GET_LEVEL(d->character) < LVL_GRGOD)
        SET_BIT(PLR_FLAGS(d->character), PLR_DELETED);
      save_char(d->character, NOWHERE);
      Crash_delete_file(GET_NAME(d->character));

      /* If the selfdelete_fastwipe flag is set (in config.c), remove all
	 the player's immediately
      */
      if(selfdelete_fastwipe)
	if((player_i = find_name(GET_NAME(d->character))) >= 0) {
	  SET_BIT(player_table[player_i].flags, PINDEX_SELFDELETE);
	  remove_player(player_i);
	}

      sprintf(buf, "Character '%s' deleted!\r\n"
              "Goodbye.\r\n", GET_NAME(d->character));
      SEND_TO_Q(buf, d);
      sprintf(buf, "%s (lev %d) has self-deleted.", GET_NAME(d->character),
              GET_LEVEL(d->character));
      mudlog(buf, NRM, LVL_GOD, TRUE);
      STATE(d) = CON_CLOSE;
      return;
    } else {
      SEND_TO_Q("\r\nCharacter not deleted.\r\n", d);
      SEND_TO_Q(MENU, d);
      STATE(d) = CON_MENU;
    }
    break;

/*      Taken care of in game_loop()
  case CON_CLOSE:
    close_socket(d);
    break;
*/

  default:
    log("SYSERR: Nanny: illegal state of con'ness (%d) for '%s'; closing connection.",
        STATE(d), d->character ? GET_NAME(d->character) : "<unknown>");
    STATE(d) = CON_DISCONNECT;  /* Safest to do. */
    break;
  }
}

struct char_data *is_playing(char *vict_name)
{
  extern struct descriptor_data *descriptor_list;
  struct descriptor_data *i, *next_i;

  for (i = descriptor_list; i; i = next_i) {
    next_i = i->next;
    if(i->connected == CON_PLAYING && !str_cmp(i->character->player.name, vict_name))
      return (i->character);
  }
  return (NULL);
}



::::::::::::::
limits.c
::::::::::::::
/* ************************************************************************
*   File: limits.c                                      Part of CircleMUD *
*  Usage: limits & gain funcs for HMV, exp, hunger/thirst, idle time      *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "spells.h"
#include "comm.h"
#include "db.h"
#include "handler.h"
#include "dg_scripts.h"
#include "buffer.h"

extern struct char_data *character_list;
extern struct obj_data *object_list;
extern struct room_data *world;
extern int max_exp_gain;
extern int max_exp_loss;
extern int idle_rent_time;
extern int idle_max_level;
extern int idle_void;
extern int use_autowiz;
extern int min_wizlist_lev;
extern int free_rent;
extern int trans_aff[][10];

int destransformar(struct char_data *ch, int trans);

int godmana[9] = {0,0,0,0,0,0,0,0,0};
int maxgodmana[9] ={100,200,100,150,0,100,200,200,200 } ; 
int godpower[9] = {50,200,25,100,0,55,200,200,20} ;

/* local functions */
int graf(int age, int p0, int p1, int p2, int p3, int p4, int p5, int p6);
void check_autowiz(struct char_data * ch);


void Crash_rentsave(struct char_data *ch, int cost);
int level_exp(int remort, int level);
char *title_male(int chclass, int level);
char *title_female(int chclass, int level);
void update_char_objects(struct char_data * ch);        /* handler.c */

/* When age < 15 return the value p0 */
/* When age in 15..29 calculate the line between p1 & p2 */
/* When age in 30..44 calculate the line between p2 & p3 */
/* When age in 45..59 calculate the line between p3 & p4 */
/* When age in 60..79 calculate the line between p4 & p5 */
/* When age >= 80 return the value p6 */
int graf(int age, int p0, int p1, int p2, int p3, int p4, int p5, int p6)
{

  if (age < 15)
    return (p0);                /* < 15   */
  else if (age <= 29)
    return (int) (p1 + (((age - 15) * (p2 - p1)) / 15));        /* 15..29 */
  else if (age <= 44)
    return (int) (p2 + (((age - 30) * (p3 - p2)) / 15));        /* 30..44 */
  else if (age <= 59)
    return (int) (p3 + (((age - 45) * (p4 - p3)) / 15));        /* 45..59 */
  else if (age <= 79)
    return (int) (p4 + (((age - 60) * (p5 - p4)) / 20));        /* 60..79 */
  else
    return (p6);                /* >= 80 */
}


/*
 * The hit_limit, mana_limit, and move_limit functions are gone.  They
 * added an unnecessary level of complexity to the internal structure,
 * weren't particularly useful, and led to some annoying bugs.  From the
 * players' point of view, the only difference the removal of these
 * functions will make is that a character's age will now only affect
 * the HMV gain per tick, and _not_ the HMV maximums.
 */

/* manapoint gain pr. game hour */
int mana_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch)) {
    /* Neat and fast */
    gain = GET_LEVEL(ch);
  } else {
    gain = (GET_MAX_MANA(ch)*0.035) + (GET_WIS(ch)/2);;

    /* Class calculations */

    /* Skill/Spell calculations */

    /* Position calculations    */
    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      gain += (gain / 2);
      break;
    case POS_RESTING:
      gain += (gain / 3);       /* Divide by 3 */
      break;
    case POS_SITTING:
      gain += (gain / 4);       /* Divide by 4 */
      break;
    }

  if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain /= 4;
  }
  if(gain <= 1)
    gain = 3;

  if (PLR_FLAGGED(ch, PLR_MEDITATE))
      gain *= 2;
      
  if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_GOOD_REGEN))
    gain += (gain * 0.125); 
        
  if (!IS_NPC(ch) && GET_MAX_MANA(ch) == GET_MANA(ch) && GET_SKILL(ch, SKILL_VITALIZE_MANA) > number(1, 101) && !AFF2_FLAGGED(ch, AFF2_TRANSFORM)) {
    improve_skill(ch, SKILL_VITALIZE_MANA);
    gain += (gain * 0.2);
    GET_MOVE(ch) -= GET_MOVE(ch)*0.025;
  }  

  if (AFF_FLAGGED(ch, AFF_POISON))
    gain /= 4;

  if(PLR_FLAGGED(ch, PLR_DEAD) || IS_SET(ROOM_FLAGS(ch->in_room), ROOM_NO_REGEN_MANA) || AFF2_FLAGGED(ch, AFF2_TRANSFORM))
    gain = 0;
    
  if(GET_RACE(ch) == RACE_TINKER || (GET_RACE(ch) == RACE_DRACONIAN && number(1,12) == 3))
   gain = gain * 1.3 ;

  return (gain);
}


/* Hitpoint gain pr. game hour */
int hit_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch)) {
    /* Neat and fast */
    gain = (GET_LEVEL(ch)*2) + (GET_CON(ch)/2);
  } else {
    gain = (GET_MAX_HIT(ch)*0.04) + (GET_CON(ch)/2);

    /* Class/Level calculations */

    /* Skill/Spell calculations */

    /* Position calculations    */

    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      gain += (gain / 2);       /* Divide by 2 */
      break;
    case POS_RESTING:
      gain += (gain / 4);       /* Divide by 4 */
      break;
    case POS_SITTING:
      gain += (gain / 8);       /* Divide by 8 */
      break;
    }

    if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain /= 4;
  }
  if(gain <= 1)
    gain = 3;
    
  if (AFF_FLAGGED(ch, AFF_REGEN))
    gain *= 1.5;
    
  if (IS_SET(ROOM_FLAGS(ch->in_room), ROOM_GOOD_REGEN))
    gain += (gain * 0.25); 

  if (!IS_NPC(ch) && GET_MAX_HIT(ch) == GET_HIT(ch) && GET_SKILL(ch, SKILL_VITALIZE_HEALTH) > number(1, 101) && !AFF2_FLAGGED(ch, AFF2_TRANSFORM)) {
    improve_skill(ch, SKILL_VITALIZE_HEALTH);
    gain += (gain * 0.2);
    GET_MOVE(ch) -= GET_MOVE(ch)*0.025;
  }

  if (AFF_FLAGGED(ch, AFF_POISON))
    gain /= 4;

  if(PLR_FLAGGED(ch, PLR_DEAD) || IS_SET(ROOM_FLAGS(ch->in_room), ROOM_NO_REGEN_HIT) ||
  	(GET_POS(ch) == POS_FIGHTING) || AFF2_FLAGGED(ch, AFF2_TRANSFORM))
    gain = 0;

  if(GET_RACE(ch) == RACE_CAVE_TROLL || (GET_RACE(ch) == RACE_DRACONIAN && number(1,12) == 
3))  gain = gain * 1.4 ;
          
  return (gain);
}



/* move gain pr. game hour */
int move_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch)) {
    /* Neat and fast */
    gain = (GET_LEVEL(ch)*2)+(GET_DEX(ch)/2);
  } else {
    gain = (GET_MAX_MOVE(ch)*0.035) +(GET_DEX(ch)/2);

    /* Position calculations    */
    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      gain += (gain / 2);       /* Divide by 2 */
      break;
    case POS_RESTING:
      gain += (gain / 4);       /* Divide by 4 */
      break;
    case POS_SITTING:
      gain += (gain / 8);       /* Divide by 8 */
      break;
    }

    if ((GET_COND(ch, FULL) == 0) || (GET_COND(ch, THIRST) == 0))
      gain /= 4;
  }
  if(gain <= 1)
    gain = 3;
    
  if (AFF_FLAGGED(ch, AFF_POISON))
    gain /= 4;

  if(PLR_FLAGGED(ch, PLR_DEAD) || AFF2_FLAGGED(ch, AFF2_TRANSFORM))
    gain = 0;

  if(GET_RACE(ch) == RACE_BUGBEAR || (GET_RACE(ch) == RACE_DRACONIAN && number(1,12) == 3))
   gain = gain * 1.5 ;

  if(AFF2_FLAGGED(ch, AFF2_TRANSFORM))
    if(GET_MOVE(ch) < 1)
	destransformar(ch, GET_TRANS(ch));
    
  return (gain);
}
#define COST			8

int mental_gain(struct char_data * ch)
{
  int gain = 0;
  int custo[] = {-50,-5,-10,-20,-30,-40,-50} ; // custo por tick
                     // adicionado por Luigi para corrigir o bug dos transforms
                   
  if(!IS_NPC(ch)) {
    gain = (GET_WIS(ch)/6)+1;

    if (!PLR_FLAGGED(ch, PLR_MEDITATE))
        gain = 0;

    if(AFF2_FLAGGED(ch, AFF2_TRANSFORM)) {
      //  gain = trans_aff[GET_TRANS(ch)][COST]; 
        gain = custo[GET_TRANS(ch)] ; // substitui a linha anterior
        if(GET_MENTAL(ch)+gain < 1) {
	    destransformar(ch, GET_TRANS(ch));
	    gain = 0;
        }
    }
  }

  return (gain);
}

void mental_update(void)
{
  struct char_data *i, *next_char;

  for (i = character_list; i; i = next_char) {
    next_char = i->next;
    if(!i)  return;	
    if (GET_POS(i) >= POS_STUNNED)
      GET_MENTAL(i) = MIN(GET_MENTAL(i) + mental_gain(i), GET_MAX_MENTAL(i));
    if (GET_POS(i) < POS_INCAP)
      update_pos(i);  
  }
}

int breath_gain(struct char_data * ch)
{
  int gain;

  if (IS_NPC(ch)) {
    gain = 0;
  } else {
    gain = GET_CON(ch) / 2;
  }
  
    /* Position calculations    */
    switch (GET_POS(ch)) {
    case POS_SLEEPING:
      gain += (gain / 2);       /* Divide by 2 */
      break;
    case POS_RESTING:
      gain += (gain / 4);       /* Divide by 4 */
      break;
    case POS_SITTING:
      gain += (gain / 8);       /* Divide by 8 */
      break;
    case POS_FIGHTING:
      gain -= (gain / 2);       /* Divide by 2 */
      break;
    }

  if (AFF_FLAGGED(ch, AFF_POISON))
    gain /= 4;

  if(PLR_FLAGGED(ch, PLR_DEAD))
    gain = 0;
    
  return (gain);
}

void set_title(struct char_data *ch, char *title)
{
  if (title == NULL) {
    if (GET_SEX(ch) == SEX_FEMALE)
      title = title_female(GET_CLASS(ch), GET_LEVEL(ch));
    else
      title = title_male(GET_CLASS(ch), GET_LEVEL(ch));
  }

  if (strlen(title) > MAX_TITLE_LENGTH)
    title[MAX_TITLE_LENGTH] = '\0';

  if (GET_TITLE(ch) != NULL)
    free(GET_TITLE(ch));

  GET_TITLE(ch) = str_dup(title);
}

void set_prename(struct char_data * ch, char *title)
{
  if (title == NULL)
    title = NULL;

//  if (strlen(title) > MAX_TITLE_LENGTH)
//    title[MAX_TITLE_LENGTH] = '\0';

  if (GET_PRENAME(ch) != NULL)
    free(GET_PRENAME(ch));

  if(title != NULL)
    GET_PRENAME(ch) = str_dup(title);
  else
    GET_PRENAME(ch) = title;
}

void check_autowiz(struct char_data * ch)
{
#ifndef CIRCLE_UNIX
  return;
#else
  char buf[100];

  if (use_autowiz && GET_LEVEL(ch) >= LVL_IMMORT) {
    sprintf(buf, "nice ../bin/autowiz %d %s %d %s %d &", min_wizlist_lev,
            WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
    mudlog("Initiating autowiz.", CMP, LVL_IMMORT, FALSE);
    system(buf);
  }
#endif /* CIRCLE_UNIX */
}

void gain_exp(struct char_data * ch, int gain)
{
  int is_altered = FALSE;
  int num_levels = 0;
  char buf[128];

  if (!IS_NPC(ch) && ((GET_LEVEL(ch) < 1 || GET_LEVEL(ch) >= LVL_IMMORT)))
    return;

  if (IS_NPC(ch)) {
    GET_EXP(ch) += gain;
    return;
  }

  if (gain > 0) {
    gain = MIN(max_exp_gain, gain);	/* put a cap on the max gain per kill */
    GET_EXP(ch) += gain;
    GET_EXP_SUM(ch) += gain;
    while (GET_LEVEL(ch) < LVL_IMMORT &&
	GET_EXP(ch) >= level_exp(GET_REMORT(ch), GET_LEVEL(ch) + 1)) {
      GET_LEVEL(ch) += 1;
      num_levels++;
      advance_level(ch);
      is_altered = TRUE;
    }

    if (is_altered) {
      sprintf(buf, "%s advanced %d level%s to level %d.",
		GET_NAME(ch), num_levels, num_levels == 1 ? "" : "s",
		GET_LEVEL(ch));
      mudlog(buf, BRF, 201, TRUE);
      if (num_levels == 1)
        send_to_char("\007\007&WYou rise a level!&n\r\n", ch);
      else {
	sprintf(buf, "\007\007&wYou rise &m%d &wlevels!&n\r\n", num_levels);
	send_to_char(buf, ch);
      }
      set_title(ch, NULL);
      check_autowiz(ch);
    }
  } else if (gain < 0) {
    gain = MAX(-max_exp_loss, gain);	/* Cap max exp lost per death */
    GET_EXP(ch) += gain;
    GET_EXP_SUM(ch) += gain;
    if (GET_EXP(ch) < 0)
      GET_EXP(ch) = 0;
  }
}


void gain_exp_regardless(struct char_data * ch, int gain)
{
  GET_EXP(ch) += gain;

  if (!IS_NPC(ch)) {
    while(gain--) {
      GET_LEVEL(ch) += 1;
      advance_level(ch);
    }
      set_title(ch, NULL);
      check_autowiz(ch);
  }
}

void gain_condition(struct char_data * ch, int condition, int value)
{
  bool intoxicated;

  if (IS_NPC(ch) || GET_COND(ch, condition) == -1)      /* No change */
    return;

  intoxicated = (GET_COND(ch, DRUNK) > 0);

  GET_COND(ch, condition) += value;

  GET_COND(ch, condition) = MAX(0, GET_COND(ch, condition));
  GET_COND(ch, condition) = MIN(24, GET_COND(ch, condition));

  if (GET_COND(ch, condition) || PLR_FLAGGED(ch, PLR_WRITING))
    return;

  switch (condition) {
  case FULL:
    send_to_char("&wYou are hungry.&n\r\n", ch);
    return;
  case THIRST:
    send_to_char("&wYou are thirsty.&n\r\n", ch);
    return;
  case DRUNK:
    if (intoxicated)
      send_to_char("You are now sober.\r\n", ch);
    return;
  default:
    break;
  }

}

void check_idling(struct char_data * ch)
{
  if (++(ch->char_specials.timer) > idle_void) {
    if (GET_WAS_IN(ch) == NOWHERE && ch->in_room != NOWHERE) {
      GET_WAS_IN(ch) = ch->in_room;
      if (FIGHTING(ch)) {
        stop_fighting(FIGHTING(ch));
        stop_fighting(ch);
      }
      act("$n disappears into the void.", TRUE, ch, 0, 0, TO_ROOM);
      send_to_char("You have been idle, and are pulled into a void.\r\n", ch);
      save_char(ch, NOWHERE);
      Crash_crashsave(ch);
      char_from_room(ch);
      char_to_room(ch, 1);
    } else if (ch->char_specials.timer > idle_rent_time) {
      if (ch->in_room != NOWHERE)
        char_from_room(ch);
      char_to_room(ch, 3);
      if (ch->desc) {
        STATE(ch->desc) = CON_DISCONNECT;
        /*
         * For the 'if (d->character)' test in close_socket().
         * -gg 3/1/98 (Happy anniversary.)
         */
        ch->desc->character = NULL;
        ch->desc = NULL;
      }
      if (free_rent)
        Crash_rentsave(ch, 0);

      sprintf(buf, "%s force-rented and extracted (idle).", GET_NAME(ch));
      mudlog(buf, CMP, LVL_GOD, TRUE);
      extract_char(ch);
    }
  }
}

void gods_update(void)
{
  struct char_data *i, *next_char;
  int x;
  for (i = character_list; i; i = next_char) {
    next_char = i->next;
    
    x = GET_RELIGION(i) ;
    if (!i) return;
    
    if((x>0) && (x != 5) && ((GET_LEVEL(i) > 100) || (GET_REMORT(i) > 0)) 
    && (GET_LEVEL(i) < 201))
     godmana[x-1] = MIN(godmana[x-1]+1, maxgodmana[x-1]) ;
  }
}




void hmm_update(void)
{
  struct char_data *i, *next_char;

  for (i = character_list; i; i = next_char) {
    next_char = i->next;

    if (!i) return;

    if (GET_POS(i) >= POS_STUNNED) {
      GET_MOVE(i) = MIN(GET_MOVE(i) + move_gain(i), GET_MAX_MOVE(i));
      GET_HIT(i) = MIN(GET_HIT(i) + hit_gain(i), GET_MAX_HIT(i));
      GET_MANA(i) = MIN(GET_MANA(i) + mana_gain(i), GET_MAX_MANA(i));
    }
    if (GET_POS(i) < POS_INCAP)
      update_pos(i);  
  }
}

/* Update PCs, NPCs, and objects */
void point_update(void)
{
  struct char_data *i, *next_char;
  struct obj_data *j, *next_thing, *jj, *next_thing2;
  char crashbuf[256];

  /* characters */
  for (i = character_list; i; i = next_char) {
    next_char = i->next;

    if (!i) return;

    gain_condition(i, FULL, -1);
    gain_condition(i, DRUNK, -1);
    gain_condition(i, THIRST, -1);
        
    if (GET_POS(i) >= POS_STUNNED) {
      if (AFF_FLAGGED(i, AFF_POISON))
        if (damage(i, i, 2, SPELL_POISON) == -1)
          continue;     /* Oops, they died. -gg 6/24/98 */
      if (GET_POS(i) <= POS_STUNNED)
        update_pos(i);
    } else if (GET_POS(i) == POS_INCAP) {
      if (damage(i, i, 1, TYPE_SUFFERING) == -1)
        continue;
    } else if (GET_POS(i) == POS_MORTALLYW) {
      if (damage(i, i, 2, TYPE_SUFFERING) == -1)
        continue;
    }
    if (!IS_NPC(i)) {
      update_char_objects(i);
      if (GET_LEVEL(i) < idle_max_level)
        check_idling(i);
    }
  }

  /* objects */
  for (j = object_list; j; j = next_thing) {
	  next_thing = j->next;       /* Next in object list */

	  if (!j)
		  return;

	  /* If this is a corpse */
	  if (IS_CORPSE(j)) {
		  /* timer count down */
		  if (GET_OBJ_TIMER(j) > 0)
			  GET_OBJ_TIMER(j)--;

		  if (!GET_OBJ_TIMER(j)) {

        if (j->carried_by)
          act("$p decays in your hands.", FALSE, j->carried_by, j, 0, TO_CHAR);
        else if ((j->in_room != NOWHERE) && (world[j->in_room].people)) {
          act("A quivering horde of maggots consumes $p.",
              TRUE, world[j->in_room].people, j, 0, TO_ROOM);
          act("A quivering horde of maggots consumes $p.",
              TRUE, world[j->in_room].people, j, 0, TO_CHAR);
        }
        for (jj = j->contains; jj; jj = next_thing2) {
			next_thing2 = jj->next_content;       /* Next in inventory */
			obj_from_obj(jj);
			
			if (!jj || !j)
				break;

			if (j->in_obj)
				obj_to_obj(jj, j->in_obj);
			else if (j->carried_by)
				obj_to_room(jj, j->carried_by->in_room);
			else if (j->in_room != NOWHERE)
				obj_to_room(jj, j->in_room);
			else { // Aqui o bixo cai..
				sprintf(crashbuf, "Objeto-Crash: %s", j->short_description);
				mudlog(crashbuf, CMP, LVL_IMMORT, FALSE);
				core_dump();
			}
        }
        extract_obj(j);
      }
    }
    /* If the timer is set, count it down and at 0, try the trigger */
    /* note to .rej hand-patchers: make this last in your point-update() */
    else if (GET_OBJ_TIMER(j)>0) {
      GET_OBJ_TIMER(j)--; 
      if (!GET_OBJ_TIMER(j))
        timer_otrigger(j);
    }
  }
}
::::::::::::::
magic.c
::::::::::::::
/* ************************************************************************
*   File: magic.c                                       Part of CircleMUD *
*  Usage: low-level functions for magic; spell template code              *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "spells.h"
#include "handler.h"
#include "db.h"
#include "dg_scripts.h"

extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *obj_index;

extern struct descriptor_data *descriptor_list;
extern struct zone_data *zone_table;

extern int mini_mud;
extern int pk_allowed;
extern char *spell_wear_off_msg[];
extern struct default_mobile_stats *mob_defaults;
extern struct apply_mod_defaults *apmd;

int saving_throws(int class_num, int type, int level); /* class.c */
void clearMemory(struct char_data * ch);
void weight_change_object(struct obj_data * obj, int weight);
void add_follower(struct char_data * ch, struct char_data * leader);
extern struct spell_info_type spell_info[];
int can_pk(struct char_data * ch, struct char_data * vt);
int check_wanted(struct char_data * ch);

/* local functions */
int mag_materials(struct char_data * ch, int item0, int item1, int item2,
int extract, int verbose);
void perform_mag_groups(int level, struct char_data * ch, struct char_data *
tch, int spellnum, int savetype);
int mag_savingthrow(struct char_data * ch, int type);
void affect_update(void);

/*
* Saving throws are now in class.c (bpl13)
*/

int mag_savingthrow(struct char_data * ch, int type)
{
  int save;

  /* negative apply_saving_throw values make saving throws better! */

  if (IS_NPC(ch)) /* NPCs use warrior tables according to some book */
    save = saving_throws(CLASS_WARRIOR, type, (int) GET_LEVEL(ch));
  else
    save = saving_throws((int) GET_CLASS(ch), type, (int) GET_LEVEL(ch));

  save += GET_SAVE(ch, type);

  /* throwing a 0 is always a failure */
  if (MAX(1, save) <  number(95, 200))
    return TRUE;
  else
    return FALSE;
}



/* affect_update: called from comm.c (causes spells to wear off) */
void affect_update(void)
{
  struct affected_type *af, *next;
  struct char_data *i;
  extern struct raff_node *raff_list;
  struct raff_node *raff, *next_raff, *temp;

  for (i = character_list; i; i = i->next)
    for (af = i->affected; af; af = next) {
      next = af->next;
      if(af->duration > 22)
        af->duration = 22;
      else if (af->duration >= 1)
        af->duration--;
      else if (af->duration == -1)      /* No action */
        af->duration = -1;      /* GODs only! unlimited */
      else {
        if ((af->type > 0) && (af->type <= MAX_SPELLS))
          if (!af->next || (af->next->type != af->type) ||
              (af->next->duration > 0))
            if (*spell_wear_off_msg[af->type]) {
              send_to_char(spell_wear_off_msg[af->type], i);
              send_to_char("\r\n", i);
              if (af->bitvector == AFF_TANGLED)
                act("$n is free of the vines that bind.",TRUE,i,0,0,TO_ROOM);
            }
        affect_remove(i, af);
      }
    }
	/* update the room affections */
	for (raff = raff_list; raff; raff = next_raff) {
		next_raff = raff->next;

		raff->timer--;

		if (raff->timer <= 0) {
			/* this room affection has expired */
			send_to_room(spell_wear_off_msg[raff->spell],
				raff->room);
			send_to_room("\r\n", raff->room);

			/* remove the affection */
			REMOVE_BIT(world[(int)raff->room].room_affections,
				raff->affection);
			REMOVE_FROM_LIST(raff, raff_list, next)
			free(raff);
		}
	}
}


/*
*  mag_materials:
*  Checks for up to 3 vnums (spell reagents) in the player's inventory.
*
* No spells implemented in Circle 3.0 use mag_materials, but you can use
* it to implement your own spells which require ingredients (i.e., some
* heal spell which requires a rare herb or some such.)
*/
int mag_materials(struct char_data * ch, int item0, int item1, int item2,
                      int extract, int verbose)
{
  struct obj_data *tobj;
  struct obj_data *obj0 = NULL, *obj1 = NULL, *obj2 = NULL;

  for (tobj = ch->carrying; tobj; tobj = tobj->next_content) {
    if ((item0 > 0) && (GET_OBJ_VNUM(tobj) == item0)) {
      obj0 = tobj;
      item0 = -1;
    } else if ((item1 > 0) && (GET_OBJ_VNUM(tobj) == item1)) {
      obj1 = tobj;
      item1 = -1;
    } else if ((item2 > 0) && (GET_OBJ_VNUM(tobj) == item2)) {
      obj2 = tobj;
      item2 = -1;
    }
  }
  if ((item0 > 0) || (item1 > 0) || (item2 > 0)) {
    if (verbose) {
      switch (number(0, 2)) {
      case 0:
        send_to_char("A wart sprouts on your nose.\r\n", ch);
        break;
      case 1:
        send_to_char("Your hair falls out in clumps.\r\n", ch);
        break;
      case 2:
        send_to_char("A huge corn develops on your big toe.\r\n", ch);
        break;
      }
    }
    return (FALSE);
  }
  if (extract) {
    if (item0 < 0) {
      obj_from_char(obj0);
      extract_obj(obj0);
    }
    if (item1 < 0) {
      obj_from_char(obj1);
      extract_obj(obj1);
    }
    if (item2 < 0) {
      obj_from_char(obj2);
      extract_obj(obj2);
    }
  }
  if (verbose) {
    send_to_char("A puff of smoke rises from your pack.\r\n", ch);
    act("A puff of smoke rises from $n's pack.", TRUE, ch, NULL, NULL,
TO_ROOM);
  }
  return (TRUE);
}




/*
* Every spell that does damage comes through here.  This calculates the
* amount of damage, adds in any modifiers, determines what the saves are,
* tests for save and calls damage().
*
* -1 = dead, otherwise the amount of damage done.
*/
int mag_damage(int level, struct char_data * ch, struct char_data * victim,
                     int spellnum, int savetype)
{
  int dam = 0;

  if (victim == NULL || ch == NULL)
    return 0;

  if(!IS_NPC(ch) && !IS_NPC(victim)){
    if(!can_pk(ch, victim)){
      send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n",
ch);
      return 0;
    }
  }

  switch (spellnum) {

    /* MAGIAS - CLERIC */

  case SPELL_BLADEBARRIER:
    if (IS_CLERIC(ch))
      dam = dice(15, 4); /* 37.5 */
    else
      dam = dice(5, 4); /* 12.5 */
    break;

  case SPELL_LIGHTNING_SPIT:
    dam = dice(1, 8)+2; /* 6.5 */
    break;

  case SPELL_FROST_SPIT:
    dam = dice(3, 8)+3; /* 15 */
    break;

  case SPELL_FIRE_SPIT:
    dam = dice(4, 6)+10; /* 24 */
    break;

  case SPELL_GAS_SPIT:
    dam = dice(8, 5)+6; /* 30 */
    break;

  case SPELL_ACID_SPIT:
    dam = dice(10, 4)+12; /* 37 */
    break;

  case SPELL_DISPEL_EVIL:
    dam = dice(30, 18); /* 285 */
    if (IS_EVIL(ch)) {
      victim = ch;
      dam = GET_HIT(ch) - 1;
    } else if (!(IS_EVIL(victim))) {
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
      dam = 0;
      return 0;
    }
    break;

  case SPELL_DISPEL_GOOD:
    dam = dice(30, 18); /* 285 */
    if (IS_GOOD(ch)) {
      victim = ch;
      dam = GET_HIT(ch) - 1;
    } else if (!(IS_GOOD(victim))) {
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
      dam = 0;
      return 0;
    }
    break;

  case SPELL_DISPEL_NEUTRAL:
    dam = dice(30, 18); /* 285 */
    if (!(IS_GOOD(ch) || IS_EVIL(ch))) {
      victim = ch;
      dam = GET_HIT(ch) - 1;
    } else if (IS_GOOD(victim) || IS_EVIL(victim)) {
      act("The gods protect $N.", FALSE, ch, 0, victim, TO_CHAR);
      dam = 0;
      return 0;
    }
    break;

  case SPELL_PSIONIC_BLAST:
    dam = dice(15, 18);
    if (number(0, 50) == number(0, 60))
      GET_POS(victim) = POS_SITTING;
    break;

    /* MAGIAS - RANGER */

  case SPELL_ACIDARROW:
    if (IS_RANGER(ch))
      dam = dice(20, 15);
    else
      dam = dice(4, 4);
    break;

  case SPELL_FLAMEARROW:
    if (IS_RANGER(ch))
      dam = dice(30, 15);
    else
      dam = dice(16, 4);
    break;

    /* MAGIAS - NECROMANCER */

  case SPELL_DEATH_RIPPLE:
    dam = dice(12, 15);
    break;

  case SPELL_DEATH_WAVE:
    dam = dice(32, 25);
    break;

  case SPELL_DEATH_FINGER:
      if(FIGHTING(victim) != ch) {
        send_to_char("The finger of death will only help you if the victim attacks you.\r\n",ch);
        return 0;
      }
      if(((GET_HIT(victim) * 100) / GET_MAX_HIT(victim))  >  11) {
        send_to_char("Your victim must be less than 11 percent healthy.\r\n", ch);
        return 0;
      }
      GET_HIT(victim) = 1;
      dam = 1000;
    break;

  case SPELL_SIPHON_LIFE:
      dam = dice(26, 25); /* 338 */
      if(AFF_FLAGGED(victim, AFF_SANCTUARY))
        GET_HIT(ch)= MIN(GET_HIT(ch) + (dam/2), GET_MAX_HIT(ch));
      else
        GET_HIT(ch)= MIN(GET_HIT(ch) + dam, GET_MAX_HIT(ch));
      break;

    /* MAGIAS - PALADIN */

  case SPELL_HOLY_MACE:
    dam = dice(20, 25); /* 260 */
    break;

  case SPELL_HOLY_SHOUT:
    dam = dice(23, 25); /* 299 */
    break;

  case SPELL_HOLY_WORD:
   dam = dice(31, 20); /* 325.5 */
   break;

  case SPELL_HOLY_BOLT:
   dam = dice(27, 25); /* 351 */
   break ;

    /* MAGIAS - GERAL */

  case SPELL_CREATE_LIGHT:
    dam = dice(2, 6);
    break;

  case SPELL_PHANTOM_FLAME:
    dam = dice(9, 4);
    break;

  case SPELL_CREATE_FLAMES:
    dam = dice(12, 6);
    break;

  case SPELL_MAGIC_MISSILE:
    dam = dice(27, 4);
    break;

  case SPELL_WINGED_KNIFE:
    dam = dice(15, 12);
    break;

  case SPELL_CORPOR_TREMBLING:
    dam = dice(10, 20);
    break;

  case SPELL_CHILL_TOUCH:
    dam = dice(12, 20);
    break;

  case SPELL_EGO_WHIP:
    dam = dice(18, 18);
    break;

  case SPELL_BURNING_HANDS:
    dam = dice(20, 20);
    break;

  case SPELL_GHASTLY_TOUCH:
    dam = dice(27, 15);
    break;

  case SPELL_PROJECT_FORCE:
    dam = dice(27, 27);
    break;

  case SPELL_VOLCANO:
    dam = dice(27, 20);
    break;

  case SPELL_SHOCKING_GRASP:
    dam = dice(30, 20);
    break;

  case SPELL_WRENCH:
    dam = dice(22, 30);
    break;

  case SPELL_COLOR_SPRAY:
    dam = dice(27, 30);
    break;

  case SPELL_BALISTIC_ATTACK:
    dam = dice(30, 30);
    break;

  case SPELL_SHILLELAGH:
    dam = dice(48, 18);
    break;

  case SPELL_LIGHTNING_BOLT:
    dam = dice(30, 30);
    break;

  case SPELL_VAMPIRIC_TOUCH:
    dam = dice(36, 25);
    break;

  case SPELL_ICE_HEART:
    dam = dice(40, 20);
    break;

  case SPELL_ICEBOLT:
    dam = dice(31, 30);
    break;

  case SPELL_MAGICAL_STONE:
    dam = dice(48, 20);
    break;

  case SPELL_DETONATE:
    dam = dice(33, 30);
    break;

  case SPELL_GLACIAL_CONE:
    dam = dice(35, 30);
    break;

  case SPELL_FIREBOLT:
    dam = dice(36, 30);
    break;

  case SPELL_PSYCHIC_RAY:
    dam = dice(40, 30);
    break;

  case SPELL_POLTEIRGEIST:
    dam = dice(48, 25);
    break;

  case SPELL_HARM:
    dam = dice(40, 30);
    break;

  case SPELL_PRISMATIC_SPHERE:
    dam = dice(42, 30);
    break;

  case SPELL_MOLEC_AGITATION:
    dam = dice(41, 30);
    break;

  case SPELL_DELAYED_FIREBALL:
    if (IS_WARLOCK(ch))
      dam = dice(48, 32);
    else
      dam = dice(45, 32);
    break;

    /* MAGIAS DE AREA - GERAL */

  case SPELL_METEOR_SHOWER:
    dam = dice(4, 4);
    break;

  case SPELL_MINUTE_METEOR:
    dam = dice(8, 12);
    break;

  case SPELL_GREASE:
    dam = dice(18, 4);
    break;

  case SPELL_CROMATIC_ORB:
    dam = dice(10, 20);
    break;

  case SPELL_CALL_LIGHTNING:
    dam = dice(12, 18);
    break;

  case SPELL_AREA_LIGHTNING:
    dam = dice(15, 20);
    break;

  case SPELL_SKULL_TRAP:
    dam = dice(22, 15);
    break;

  case SPELL_EARTHQUAKE:
    dam = dice(20, 18);
    break;

  case SPELL_ELETRICSTORM:
    dam = dice(20, 25);
    break;

  case SPELL_ICESTORM:
    dam = dice(27, 25);
    break;

  case SPELL_GEYSER:
    dam = dice(32, 20);
    break;

  case SPELL_FIRESTORM:
    dam = dice(33, 25);
    break;

  case SPELL_METEORSTORM:
    dam = dice(37, 25);
    break;

  case SPELL_COMMAND:
    dam = dice(44, 25);
    break;

  case SPELL_BLIZZARD:
    dam = dice(37, 30);
    break;

  case SPELL_ARMAGEDDOM:
    dam = dice(40, 25);
    break;

  case SPELL_END_WORLD:
    if (IS_NECROMANCER(ch))
      dam = dice(40, 32);
    else
      dam = dice(40, 25);
    break;

  case SPELL_FIREBALL:
    if (IS_MAGIC_USER(ch) || IS_WARLOCK(ch))
      dam = dice(48, 30);
    else
      dam = dice(44, 30);
    break;

  case SPELL_ULTIMA:
   dam = dice(100,30) ;
   break;

  case SPELL_SUMMON_BAHAMUT:
   dam = dice(80, 30) ;
   break;

  case SPELL_TALOS:
   dam = dice(50,35);
   break ;   

  }  /* switch(spellnum) */

  /* divide damage by two if victim makes his saving throw */
  if (mag_savingthrow(victim, savetype))
    dam /= 2;

  /* and finally, inflict the damage */

dam = dam * GET_INT(ch) / 9 ; // dano tb depende da int do cara

if(GET_RACE(ch) == RACE_LICH || (GET_RACE(ch) == RACE_DRACONIAN &&
number(1,12) == 3))
  dam = dam * 1.2 ;

  return (GET_POS(ch) > POS_DEAD ? damage(ch, victim, dam, spellnum) : 0);
}


/*
* Every spell that does an affect comes through here.  This determines
* the effect, whether it is added or replacement, whether it is legal or
* not, etc.
*
* affect_join(vict, aff, add_dur, avg_dur, add_mod, avg_mod)
*/

#define MAX_SPELL_AFFECTS 6     /* change if more needed */

void mag_affects(int level, struct char_data * ch, struct char_data *
victim, int spellnum, int savetype)
{
  struct affected_type af[MAX_SPELL_AFFECTS];
  bool accum_affect = FALSE, accum_duration = FALSE;
  const char *to_vict = NULL, *to_room = NULL;
  int i;

  if (victim == NULL || ch == NULL)
    return;

  for (i = 0; i < MAX_SPELL_AFFECTS; i++) {
    af[i].type = spellnum;
    af[i].bitvector = 0;
    af[i].bitvector2 = 0;
    af[i].bitvector3 = 0;
    af[i].modifier = 0;
    af[i].location = APPLY_NONE;
  }

  switch (spellnum) {

  case SPELL_CHILL_TOUCH:
    af[0].location = APPLY_STR;
    if (mag_savingthrow(victim, savetype))
      af[0].duration = 1;
    else
      af[0].duration = 4;
    af[0].modifier = -2;
    accum_duration = TRUE;
    to_vict = "You feel your strength wither!";
    break;


  case SPELL_BARKSKIN :
    af[0].location = APPLY_AC;
    af[0].modifier = -30;
    af[0].duration = 5;
    to_vict = "You get a hard barkskin.";
    break;


  case SPELL_GHASTLY_TOUCH:
    af[0].location = APPLY_STR;
    if (mag_savingthrow(victim, savetype))
      af[0].duration = 2;
    else
      af[0].duration = 6;
    af[0].modifier = -3;
    accum_duration = TRUE;
    to_vict = "You feel your strength wither!";
    break;

  case SPELL_VAMPIRIC_TOUCH:
    af[0].location = APPLY_STR;
    if (mag_savingthrow(victim, savetype))
      af[0].duration = 3;
    else
      af[0].duration = 8;
    af[0].modifier = -4;
    accum_duration = TRUE;
    to_vict = "You feel your strength wither!";
    break;

  
  case SPELL_MUIR: // religiao
    af[0].duration = 5;
    af[0].bitvector2 = AFF2_MUIR1;
    to_vict = "You got the basic power of Muir.";
    break;

  case SPELL_ILMANATEUR: // religiao
    af[0].duration = 3;
    af[0].bitvector2 = AFF2_ILMANATEUR1;
    to_vict = "You got the basic power of Ilmanateur.";
    break;

  case SPELL_SELUNE: // religiao
    af[0].duration = 8;
    af[0].bitvector2 = AFF2_SELUNE;
    to_vict = "You got the basic power of Selune.";
    break;

  case SPELL_ARMOR:
    if(affected_by_spell(victim, SPELL_ENHANCED_ARMOR))
    {
      send_to_char("You still protected with enhanced armor.\r\n", ch);
      return;
    }
    af[0].location = APPLY_AC;
    af[0].modifier = -10-(GET_LEVEL(ch)/10);
    af[0].duration = 12;
    accum_duration = TRUE;
    to_vict = "You feel someone protecting you.";
    break;

  case SPELL_BLESS:
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 1+(GET_LEVEL(ch)/35);
    af[0].duration = 6;

    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -1;
    af[1].duration = 6;

    accum_duration = TRUE;
    to_vict = "You feel righteous.";
    break;

  case SPELL_BRAVERY:
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 10;
    af[0].duration = 1;

    af[1].location = APPLY_DAMROLL;
    af[1].modifier = 10;
    af[1].duration = 1;

    accum_duration = FALSE;
    to_vict = "You find the heaven bravery.";
    break;

  case SPELL_CONCENTRATION:
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 4;
    af[0].duration = 4;

    accum_duration = FALSE;
    to_vict = "You start to concentrate better in your attacks.";
    break;

  case SPELL_CONVICTION:
    af[0].location = APPLY_DAMROLL;
    af[0].modifier = 4;
    af[0].duration = 4;

    accum_duration = FALSE;
    to_vict = "You start to attack more convicted.";
    break;

  case SPELL_AURA_SIGHT:
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 1;
    af[0].duration = 8;

    af[1].location = APPLY_SAVING_SPELL;
    af[1].modifier = -1;
    af[1].duration = 8;

    accum_duration = TRUE;
    to_vict = "You feel an aura helping you.";
    break;

  case SPELL_BODY_WEAPONRY:
    af[0].location = APPLY_HITROLL;
    af[0].modifier = 3;
    af[0].duration = 5;

    accum_duration = TRUE;
    to_vict = "You feel your body turning a weaponry machine!!";
    break;

  case SPELL_BODY_EQUILIBRIUM:
    af[0].location = APPLY_DAMROLL;
    af[0].modifier = 3;
    af[0].duration = 5;

    accum_duration = TRUE;
    to_vict = "You feel yourself balanced!";
    break;

  case SPELL_COMBAT_MIND:
    af[0].location = APPLY_DAMROLL;
    af[0].modifier = 2;
    af[0].duration = 6;

    af[1].location = APPLY_HITROLL;
    af[1].modifier = 2;
    af[1].duration = 6;

    accum_duration = TRUE;
    to_vict = "You feel your battle concentration rising";
    break;

  case SPELL_ANTIMAGIC_SHELL:
    af[0].location = APPLY_SAVING_SPELL;
    af[0].modifier = -15;
    af[0].duration = 5;

    accum_duration = TRUE;
    to_vict = "You feel your magic resistance increasing.";
    break;

  case SPELL_MINOR_GLOBE:
    af[0].location = APPLY_AC;
    af[0].modifier = -10;
    af[0].duration = 4;

    af[1].location = APPLY_DAMROLL;
    af[1].modifier = +2;
    af[1].duration = 4;

    af[2].location = APPLY_HITROLL;
    af[2].modifier = +2;
    af[2].duration = 4;

    af[3].location = APPLY_SAVING_SPELL;
    af[3].modifier = -2;
    af[3].duration = 4;

    accum_duration = TRUE;
    to_vict = "You feel a globe protecting you.";
    break;

  case SPELL_BLINDNESS:
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || ((GET_LEVEL(victim) <
GET_LEVEL(ch)) && (number(20, 60) < number(30, 80)))) {
      send_to_char("You fail.\r\n", ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_HITROLL;
    af[0].modifier = -4-(GET_HITROLL(victim)/4);
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 40;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;

    to_room = "$n seems to be blinded!";
    to_vict = "You have been blinded!";
    break;

  case SPELL_FEEL_LIGHT:
    if (MOB_FLAGGED(victim,MOB_NOBLIND) || ((GET_LEVEL(victim) <
GET_LEVEL(ch)) && (number(25, 50) < number(40, 65)))) {
      send_to_char("You misfire.\r\n", ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_HITROLL;
    af[0].modifier = -3-(GET_HITROLL(victim)/3);
    af[0].duration = 2;
    af[0].bitvector = AFF_BLIND;

    af[1].location = APPLY_AC;
    af[1].modifier = 30;
    af[1].duration = 2;
    af[1].bitvector = AFF_BLIND;

    to_room = "$n seems to feel the light in his eyes!";
    to_vict = "You have been blinded by the light in your eyes!";
    break;

  case SPELL_CURSE:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_HITROLL;
    af[0].duration = 1 + (GET_LEVEL(ch) / 6);
    af[0].modifier = -1;
    af[0].bitvector = AFF_CURSE;

    af[1].location = APPLY_DAMROLL;
    af[1].duration = 1 + (GET_LEVEL(ch) / 6);
    af[1].modifier = -1;
    af[1].bitvector = AFF_CURSE;

    accum_duration = TRUE;
    accum_affect = FALSE;
    to_room = "$n briefly glows red!";
    to_vict = "You feel very uncomfortable.";
    break;
    break;

  case SPELL_DETECT_ALIGN:
    af[0].duration = 12;
    af[0].bitvector = AFF_DETECT_ALIGN;
    accum_duration = TRUE;
    to_vict = "Your eyes tingle.";
    to_room = "$n's eyes tingle.";
    break;

  case SPELL_DETECT_INVIS:
    af[0].duration = 12;
    af[0].bitvector = AFF_DETECT_INVIS;
    accum_duration = TRUE;
    to_vict = "Your eyes tingle.";
    to_room = "$n's eyes tingle.";
    break;

  case SPELL_DETECT_MAGIC:
    af[0].duration = 12;
    af[0].bitvector = AFF_DETECT_MAGIC;
    accum_duration = TRUE;
    to_vict = "Your eyes tingle.";
    to_room = "$n's eyes tingle.";
    break;

  case SPELL_INFRAVISION:
    af[0].duration = 12;
    af[0].bitvector = AFF_INFRAVISION;
    accum_duration = TRUE;
    to_vict = "Your eyes glow red.";
    to_room = "$n's eyes glow red.";
    break;

  case SPELL_INVISIBLE:
    if (!victim)
      victim = ch;

    af[0].duration = 10;
    af[0].modifier = -40;
    af[0].location = APPLY_AC;
    af[0].bitvector = AFF_INVISIBLE;
    accum_duration = TRUE;
    to_vict = "You vanish.";
    to_room = "$n slowly fades out of existence.";
    break;

  case SPELL_SUP_INVISIBLE:
    if (!victim)
      victim = ch;

    af[0].duration = 20;
    af[0].modifier = -60;
    af[0].location = APPLY_AC;
    af[0].bitvector = AFF_INVISIBLE;
    accum_duration = TRUE;
    to_vict = "You vanish.";
    to_room = "$n slowly fades out of existence.";
    break;

  case SPELL_POISON:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_STR;
    af[0].duration = GET_LEVEL(ch)/4;
    af[0].modifier = -2;
    af[0].bitvector = AFF_POISON;
    to_vict = "You feel very sick.";
    to_room = "$n gets violently ill!";
    break;

  case SPELL_PROT_FROM_EVIL:
    af[0].duration = 6;
    af[0].bitvector = AFF_PROTECT_EVIL;
    accum_duration = TRUE;
    to_vict = "You feel invulnerable!";
    break;

  case SPELL_SANCTUARY:
    af[0].duration = 4;
    af[0].bitvector = AFF_SANCTUARY;

    accum_duration = TRUE;
    to_vict = "A white aura momentarily surrounds you.";
    to_room = "$n is surrounded by a white aura.";
    break;

  case SPELL_SLEEP:
    if (!pk_allowed && !IS_NPC(ch) && !IS_NPC(victim))
      return;
    if (MOB_FLAGGED(victim, MOB_NOSLEEP))
      return;
    if (mag_savingthrow(victim, savetype))
      return;
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].duration = 2 + (GET_LEVEL(ch) / 10);
    af[0].bitvector = AFF_SLEEP;

    if (GET_POS(victim) > POS_SLEEPING) {
      act("You feel very sleepy...  Zzzz......", FALSE, victim, 0, 0, TO_CHAR);
      act("$n goes to sleep.", TRUE, victim, 0, 0, TO_ROOM);
      GET_POS(victim) = POS_SLEEPING;
    }
    break;

  case SPELL_STRENGTH:
    if (GET_ADD(victim) == 100)
      return;

    af[0].location = APPLY_STR;
    af[0].duration = (GET_LEVEL(ch) / 20) + 4;
    af[0].modifier = 1 + (level > 18);
    accum_duration = TRUE;
    accum_affect = TRUE;
    to_vict = "You feel stronger!";
    to_room = "$n feels stronger!";
    break;

  case SPELL_MAJOR_GLOBE:
    af[0].location = APPLY_INT;
    af[0].modifier = +1;
    af[0].duration = 2;
    accum_duration = FALSE;

    af[1].location = APPLY_WIS;
    af[1].modifier = +1;
    af[1].duration = 2;
    accum_duration = FALSE;

    af[2].location = APPLY_CON;
    af[2].modifier = +1;
    af[2].duration = 2;
    accum_duration = FALSE;

    af[3].location = APPLY_DEX;
    af[3].modifier = +1;
    af[3].duration = 2;
    accum_duration = FALSE;

    to_vict = "You feel a great globe rising around your body.";
    break;

  case SPELL_ENHANCED_STRENGTH:
    if (GET_ADD(victim) == 100)
      return;

    af[0].location = APPLY_STR;
    af[0].duration = 8;
    af[0].modifier = +4;
    accum_duration = TRUE;
    accum_affect = TRUE;
    to_vict = "You feel stronger!";
    to_room = "$n feels stronger!";
    break;

  case SPELL_SENSE_LIFE:
    to_vict = "Your feel your awareness improve.";
    af[0].duration = 9;
    af[0].bitvector = AFF_SENSE_LIFE;
    accum_duration = TRUE;
    break;

  case SPELL_CLAIRAUDIENCE:
    to_vict = "Your vents hear with clairaudience now!";
    af[0].duration = 6;
    af[0].bitvector = AFF_SENSE_LIFE;
    accum_duration = TRUE;
    break;

  case SPELL_CLAIRVOYANCE:
    af[0].duration = 6;
    af[0].bitvector = AFF_DETECT_INVIS;
    accum_duration = TRUE;
    to_vict = "Your eyes foresee with clairvoyance now!";
    break;

  case SPELL_WATERWALK:
    af[0].duration = 16;
    af[0].bitvector = AFF_WATERWALK;
    accum_duration = TRUE;
    to_vict = "You feel webbing between your toes.";
    break;

  case SPELL_HASTE:
    af[0].duration = 4;
    af[0].bitvector = AFF_HASTE;

    accum_duration = FALSE;
    to_vict = "Your adrenaline is gushing!";
    to_room = "$n starts to movement faster.";
    break;

  case SPELL_MANA_SHIELD:
    af[0].duration = 4;
    af[0].bitvector = AFF_MANA_SHIELD;

    accum_duration = FALSE;
    to_vict = "You create a great aura of energy wich surrounds you.";
    to_room = "$n creates a great aura of energy around $m.";
    break;

  case SPELL_DAMNED_CURSE:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_HITROLL;
    af[0].duration = 1 + (GET_LEVEL(ch) / 24);
    af[0].modifier = -10 - (GET_LEVEL(ch) / 45);
    af[0].bitvector = AFF_DAMNED_CURSE;

    af[1].location = APPLY_DAMROLL;
    af[1].duration = 1 + (GET_LEVEL(ch) / 24);
    af[1].modifier = -10 - (GET_LEVEL(ch) / 45);
    af[1].bitvector = AFF_DAMNED_CURSE;

    accum_duration = TRUE;
    accum_affect = FALSE;
    to_room = "$n starts to shivers and suffer!";
    to_vict = "You feel a great pain all around your body!";
    break;

  case SPELL_PESTILENCE:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_HITROLL;
    af[0].duration = 1 + (GET_LEVEL(ch) / 16);
    af[0].modifier = -16 - (GET_LEVEL(ch) / 35);
    af[0].bitvector = AFF_DAMNED_CURSE;

    af[1].location = APPLY_DAMROLL;
    af[1].duration = 1 + (GET_LEVEL(ch) / 24);
    af[1].modifier = -16 - (GET_LEVEL(ch) / 35);
    af[1].bitvector = AFF_DAMNED_CURSE;

    accum_duration = TRUE;
    accum_affect = FALSE;
    to_room = "$n suffers stricken with nuisance!";
    to_vict = "You feel to be infected with nuisance!";
    break;

  case SPELL_PETRIFY:

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }


   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

    af[0].duration = 2;
    af[0].bitvector = AFF_HOLDED;

    accum_duration = FALSE;
    to_vict = "All of your muscles turns stone.";
    to_room = "$n turns a great stone.";
    break;

  case SPELL_GOD_PACT:
    if (!(IS_GOOD(ch))) {
      send_to_char("You are much evil to make a pact with God!\r\n", ch);
      return;
    }

   if(AFF_FLAGGED(ch, AFF_SATAN))
   {
    send_to_char("You are protected by SATAN already!!!!!\r\n", ch) ;
    return ;
   }

    af[0].duration = 1+(GET_LEVEL(ch)/60);
    af[0].bitvector = AFF_GOD;

    accum_duration = TRUE;
    to_vict = "A yellow aura momentarily surrounds you.";
    to_room = "$n is surrounded by a yellow aura.";
    break;

  case SPELL_SATAN_PACT:
    if (!(IS_EVIL(ch))) {
      send_to_char("You are much good to make a pact with Satan!\r\n", ch);
      return;
    }

    if(AFF_FLAGGED(ch, AFF_GOD))
    {
     send_to_char("You are protected by GOD already!!!!!\r\n", ch);
     return ;
   }

    af[0].duration = 1+(GET_LEVEL(ch)/60);
    af[0].bitvector = AFF_SATAN;

    accum_duration = TRUE;
    to_vict = "A red aura momentarily surrounds you.";
    to_room = "$n is surrounded by a red aura.";
    break;

  case SPELL_MENTAL_RAGE:

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }


    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].duration = 1;
    af[0].bitvector = AFF_HOLDED;

    accum_duration = FALSE;
    to_vict = "A flash of light obscures $n's vision and paralyse them.";
    to_room = "$n stops on the time...";
    break;

  case SPELL_HOLD_PERSON:

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

   if (mag_savingthrow(victim, savetype))
   {
      send_to_char(NOEFFECT, ch);
      return;
   }

    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].duration = 1;
    af[0].bitvector = AFF_HOLDED;

    accum_duration = FALSE;
    to_vict = "All of your movements become motionless.";
    to_room = "$n stops all $m movements like a stone.";
    break;

  case SPELL_FLY:
    af[0].duration = 3 + level / 15;
    af[0].bitvector = AFF_FLY;
    accum_duration = TRUE;
    to_vict = "Your feet rise the floor.";
    to_room = "$n feet rise the floor.";
    break;

  case SPELL_VULCAN:
    af[0].location = APPLY_DAMROLL;
    af[0].duration = 1;
    af[0].modifier = 1 + (GET_LEVEL(ch)/18);
    accum_duration = FALSE;
    to_vict = "You feel you are thirst of blood.";
    to_room = "You see $n are thirsty of blood.";
    break;

  case SPELL_ENTANGLE:
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    if (ROOM_FLAGGED(IN_ROOM(ch),ROOM_INDOORS)) {
      act("You feel something pounding up into the floor beneath you.",
          FALSE, victim, 0, 0, TO_CHAR);
      act("You hear a pounding under the floor below $n.", TRUE, victim,
          0, 0, TO_ROOM);
      return;
    }
    if (MOB_FLAGGED(victim,MOB_NOENTANGLE) || (number(1, 60) > number(30, 70)))/*mag_savingthrow(victim, savetype))*/ {
      act("Vines grow from the ground to entangle you, but you shrug them off.",
          FALSE, victim, 0, 0, TO_CHAR);
      act("Vines from the ground try to entangle $n, but can't get a grip.",
          TRUE, victim, 0, 0, TO_ROOM);
      return;
    }
    af[0].duration = 1;
   /* if (GET_LEVEL(ch) < GET_LEVEL(victim))
    af[0].duration -= 1;*/
    af[0].bitvector = AFF_TANGLED;
    to_vict = "Vines suddenly grow up from the ground and entangle you!";
    to_room = "Vines grow up from the ground and thoroughly entangle $n.";

    if (GET_POS(ch) > POS_STUNNED) {
      if (!(FIGHTING(ch)))
        set_fighting(ch, victim);

      if (IS_NPC(ch) && IS_NPC(victim) && victim->master &&
          !number(0, 10) && IS_AFFECTED(victim, AFF_CHARM) &&
          (victim->master->in_room == ch->in_room)) {
        if (FIGHTING(ch))
          stop_fighting(ch);
        hit(ch, victim->master, TYPE_UNDEFINED);
        return;
      }
    }
    if (GET_POS(victim) > POS_STUNNED && !FIGHTING(victim)) {
      set_fighting(victim, ch);
      if (MOB_FLAGGED(victim, MOB_MEMORY) && !IS_NPC(ch) &&
          (GET_LEVEL(ch) < LVL_IMMORT))
        remember(victim, ch);
    }
    break;

   case SPELL_FIRESHIELD:
    af[0].duration  = 4;
    af[0].bitvector = AFF_FIRESHIELD;
    accum_duration  = FALSE;
    to_vict = "You start glowing red.";
    to_room = "$n is surrounded by a glowing red aura.";
    break;

  case SPELL_ADRENALINE:
    af[0].duration = 1 + level / 35;
    af[0].bitvector = AFF_REGEN;
    accum_duration = FALSE;
    to_vict = "Your feel your regeneration power rising.";
    to_room = "$n starts to regenerate his body.";
    break;

  case SPELL_FORCE_SHIELD:
    af[0].location = APPLY_AC;
    af[0].modifier = -30-(GET_LEVEL(ch)/20);
    af[0].duration = 10;
    accum_duration = TRUE;
    to_vict = "You feel a force barrier protecting you.";
    break;

  case SPELL_ENHANCED_ARMOR:
    if(!affected_by_spell(victim, SPELL_ARMOR))
    {
      af[0].location = APPLY_AC;
      af[0].modifier = -5-(GET_LEVEL(ch)/10);
      af[0].duration = 20;
      accum_duration = FALSE;
      to_vict = "You feel your protections rising.";
    } else {
	  affect_from_char(victim, SPELL_ARMOR);
      af[0].location = APPLY_AC;
      af[0].modifier = -40;
      af[0].duration = 20;
      accum_duration = FALSE;
      to_vict = "You feel someone protecting you.";
    }
    break;

  case SPELL_SLOW:

    if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
    return;
   }

    af[0].location = APPLY_HITROLL;
    af[0].modifier = -10;
    af[0].duration = 3;
    af[0].bitvector2 = AFF2_SLOW;
    accum_duration = FALSE;
    to_vict = "You feel your power lost.";
    break;

  case SPELL_THOUGHT_SHIELD:
    af[0].location = APPLY_AC;
    af[0].modifier = -10;
    af[0].duration = 4;
    accum_duration = FALSE;
    to_vict = "A shield of thought is making protection around you.";
    break;

case SPELL_BIOFEEDBACK:
    af[0].location = APPLY_AC;
    af[0].modifier = -15;
    af[0].duration = 6;
    accum_duration = FALSE;
    to_vict = "You feel more armored.";
    break;

case SPELL_MENTAL_BARRIER:
    af[0].location = APPLY_AC;
    af[0].modifier = -12;
    af[0].duration = 8;
    accum_duration = FALSE;
    to_vict = "You feel a mental barrier protecting you.";
    break;

case SPELL_INERTIAL_BARRIER:
    af[0].location = APPLY_AC;
    af[0].modifier = -18;
    af[0].duration = 12;
    accum_duration = FALSE;
    to_vict = "You feel an inertial barrier protecting you.";
    break;

case SPELL_CELL_ADJUSTMENT:
    af[0].location = APPLY_AC;
    af[0].modifier = -25;
    af[0].duration = 15;
    accum_duration = FALSE;
    to_vict = "You adjust your cell and feel more guarded.";
    break;

case SPELL_IRON_SKIN:
    if(affected_by_spell(victim, SPELL_PLATINUM_SKIN) ||
    	affected_by_spell(victim, SPELL_DIAMOND_SKIN))
    {
    	send_to_char("Your skin has already changed.\r\n", victim);
    	return;
    }
    af[0].location = APPLY_AC;
    af[0].modifier = -25;
    af[0].duration = 15;
    accum_duration = FALSE;
    to_vict = "You feel your skin turning iron.";
    break;

case SPELL_PLATINUM_SKIN:
    if(!affected_by_spell(victim, SPELL_IRON_SKIN))
    {
    	send_to_char("You need to turn in iron your skin first.\r\n", victim);
    	return;
    }
    affect_from_char(victim, SPELL_IRON_SKIN);
    af[0].location = APPLY_AC;
    af[0].modifier = -35;
    af[0].duration = 15;
    accum_duration = FALSE;
    to_vict = "You feel your skin turning platinum.";
    break;

case SPELL_DIAMOND_SKIN:
    if(!affected_by_spell(victim, SPELL_PLATINUM_SKIN))
    {
    	send_to_char("You need to turn in platinum your skin first.\r\n",
victim);
    	return;
    }
    affect_from_char(victim, SPELL_PLATINUM_SKIN);
    af[0].location = APPLY_AC;
    af[0].modifier = -45;
    af[0].duration = 15;
    accum_duration = FALSE;
    to_vict = "You feel your skin turning diamond.";
    break;

case SPELL_HOLY_SHIELD:
    af[0].location = APPLY_AC;
    af[0].modifier = -35;
    af[0].duration = 5;
    accum_duration = FALSE;
    to_vict = "You feel the Holy Shield protecting you.";
    break;

  case SPELL_PARADI_CHRYSALIS:
    if (number(20, 30) < number(20, 30))
    {
    	af[0].location = APPLY_AC;
    	af[0].modifier = -25;
    	af[0].duration = 5;
    	af[1].location = APPLY_SAVING_SPELL;
    	af[1].modifier = -5;
    	af[1].duration = 5;
    	accum_duration = FALSE;
    	to_vict = "You pray for some protection and receive a part of it!";
    }
    if (number(20, 30) > number(20, 30))
    {
    	af[0].location = APPLY_AC;
    	af[0].modifier = -45;
    	af[0].duration = 5;
    	af[1].location = APPLY_SAVING_SPELL;
    	af[1].modifier = -2;
    	af[1].duration = 5;
    	accum_duration = FALSE;
    	to_vict = "You pray for some protection and receive a part of it!";
    }
    if (number(20, 30) == number(20, 30))
    {
    	af[0].location = APPLY_AC;
    	af[0].modifier = -70;
    	af[0].duration = 7;
    	af[1].location = APPLY_SAVING_SPELL;
    	af[1].modifier = -7;
    	af[1].duration = 7;
    	accum_duration = FALSE;
    	to_vict = "You pray for some protection and receive the Paradise Chrysalis!!!";
    }
    break;

  case SPELL_ABUTILON:
    if (number(20, 30) < number(20, 30))
    {
    	af[0].location = APPLY_DAMROLL;
    	af[0].modifier = 5;
    	af[0].duration = 5;
    	af[1].location = APPLY_HITROLL;
    	af[1].modifier = 2;
    	af[1].duration = 5;
    	accum_duration = FALSE;
    	to_vict = "You receive the abutilon of your God!";
    }
    if (number(20, 30) > number(20, 30))
    {
    	af[0].location = APPLY_DAMROLL;
    	af[0].modifier = 2;
    	af[0].duration = 5;
    	af[1].location = APPLY_HITROLL;
    	af[1].modifier = 5;
    	af[1].duration = 5;
    	accum_duration = FALSE;
    	to_vict = "You receive the a abutilon of your God!";
    }
    if (number(20, 30) == number(20, 30))
    {
    	af[0].location = APPLY_DAMROLL;
    	af[0].modifier = 7;
    	af[0].duration = 7;
    	af[1].location = APPLY_HITROLL;
    	af[1].modifier = 7;
    	af[1].duration = 7;
    	accum_duration = FALSE;
    	to_vict = "Your God recompensates you with all abutilon of heaven!!!";
    }
    break;

  case SPELL_FRIENDS:
    af[0].location = APPLY_CHA;
    af[0].modifier = +1;
    af[0].duration = 10;
    accum_duration = FALSE;
    to_vict = "You feel your charism rising.";
    break;

case SPELL_EMPATHY:
    af[0].location = APPLY_CHA;
    af[0].modifier = +1;
    af[0].duration = 6;
    accum_duration = FALSE;
    to_vict = "You feel more charismatic now.";
    break;

case SPELL_INTEL_FORTRESS:
    af[0].location = APPLY_WIS;
    af[0].modifier = +3;
    af[0].duration = 4;
    accum_duration = FALSE;
    to_vict = "You feel your wisdom increasing";
    break;

case SPELL_ADREN_CONTROL:
    af[0].location = APPLY_DEX;
    af[0].modifier = +3;
    af[0].duration = 4;
    accum_duration = FALSE;
    to_vict = "You feel your dexterity rising";
    break;

case SPELL_DUMBNESS:
    af[0].location = APPLY_INT;
    if (mag_savingthrow(victim, savetype))
      af[0].duration = 1;
    else
      af[0].duration = 4;
    af[0].modifier = -3;
    accum_duration = TRUE;
    to_vict = "You feel dumber somehow.";
    break;

  case SPELL_PAIN:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_DAMROLL;
    af[0].duration = 1;
    af[0].modifier = -1;

    accum_duration = FALSE;
    accum_affect = TRUE;
    to_room = "$n feels a violent grief about $m body!";
    to_vict = "You feel a violent grief taking control of your body!";
    break;

  case SPELL_DISPLACEMENT:
    if (mag_savingthrow(victim, savetype)) {
      send_to_char(NOEFFECT, ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    af[0].location = APPLY_HITROLL;
    af[0].duration = 1;
    af[0].modifier = -2;

    accum_duration = FALSE;
    accum_affect = TRUE;
    to_room = "$n feels a strange displacement!";
    to_vict = "You feel a uncomfortable displacement!";
    break;

  case SPELL_PHANTOM_ARMOR:
    af[0].location = APPLY_AC;
    af[0].duration = 3;
    af[0].modifier = -30;
    accum_duration = FALSE;
    to_vict = "The spirits on the undead come forth to protect you!";
    to_room = "$n is surrounded by a hoard of phantoms.";
    break;

  case SPELL_FLESH_ARMOR:
    af[0].location = APPLY_AC;
    af[0].duration = 5;
    af[0].modifier = -25;
    accum_duration = FALSE;
    to_vict = "A strange flesh coat starts to protect you!";
    to_room = "$n is wraped by a flesh coat.";
    break;

  case SPELL_SACRIFICE:
    af[0].location = APPLY_WIS;
    af[0].duration = 6;
    af[0].modifier = -1;

    af[1].location = APPLY_INT;
    af[1].duration = 6;
    af[1].modifier = -1;

    af[2].location = APPLY_DEX;
    af[2].duration = 6;
    af[2].modifier = -1;

    af[3].location = APPLY_CON;
    af[3].duration = 6;
    af[3].modifier = -1;

    af[4].location = APPLY_CHA;
    af[4].duration = 6;
    af[4].modifier = -1;

    af[5].location = APPLY_STR;
    af[5].duration = 6;
    af[5].modifier = 5;

    accum_duration = FALSE;
    to_vict = "You sacrifice yourself and become stronger";
    to_room = "$n makes a sacrifice and become stronger.";
    break;

  case SPELL_SPECTRAL_WINGS:
    af[0].duration = 18;
    af[0].bitvector = AFF_FLY;
    to_vict = "You sprout a pair of spectral wings and rise from the ground!";
    to_room = "$n sprouts a pair of spectral wings and rises from the ground.";
    break;

  case SPELL_HOLY_FURY:
    af[0].bitvector = AFF_HASTE;
    af[0].duration = 6;
    accum_duration = FALSE;
    accum_affect = FALSE;
    to_vict = "You feel like you can take on an army!";
    to_room = "$n gets a strange furious scowl on $m face and speeds up.";
    break;

  case SPELL_CHAMPION_STRENGTH:
    if (GET_ADD(victim) != 100) {
      af[0].location = APPLY_STR;
      af[0].duration = 5;
      af[0].modifier = +3;
    }
    af[1].location = APPLY_DAMROLL;
    af[1].duration = 5;
    af[1].modifier = +3;
    accum_duration = FALSE;
    accum_affect = FALSE;
    to_vict = "You feel like you have the strength of a champion!";
    break;

  case SPELL_TERROR:
   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

    WAIT_STATE(victim, PULSE_VIOLENCE * 10); // pequeno tempo para recuperar-se do susto.
    af[0].duration = 1; // para recuperar-se do trauma demora um pouco mais.
    af[0].bitvector2 = AFF2_TERROR;
    to_room = "$n has fear in the eyes!";
    to_vict = "You are panicky!!";
     break;

  case SPELL_AVERSION:

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }

    WAIT_STATE(victim, PULSE_VIOLENCE * 10); // pequeno tempo para recuperar-se do susto.
    af[0].duration = 1; // para recuperar-se do trauma demora um pouco mais.
    af[0].bitvector2 = AFF2_TERROR;
    to_room = "$n causes an aversion in this place!";
    to_vict = "You feel the fear taking control of your body!";
      break;

  case SPELL_CONFUSION:

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char("Weak, too weak\r\n", ch);
      return;
   }

   if (mag_savingthrow(victim, savetype))
   {
    send_to_char(NOEFFECT, ch);
      return;
   }


    WAIT_STATE(victim, PULSE_VIOLENCE * 10); // pequeno tempo para recuperar-se do susto.
    af[0].duration = 1; // para recuperar-se do trauma demora um pouco mais.
    af[0].bitvector2 = AFF2_TERROR;
    to_room = "$n gestures and everyone in this place looks confused!";
    to_vict = "You feel confused and cannot control your body!!!";
      break;

  case SPELL_ENGULFING_DARKNESS:
    af[0].location = APPLY_AC;
    af[0].modifier = 10;
    af[0].duration = 5;
    to_room = "$n is surrended by a wicked aura!";
    to_vict = "Darkness engulfs your body!";
    break;

  case SPELL_BANSHEE_AURA:
    af[0].duration = 5;
    af[0].bitvector2 = AFF2_BANSHEE;
    to_vict = "URGH!!! Your blood boils!";
    break;

  case SPELL_BLINK:
    af[0].duration = 7;
    af[0].bitvector2 = AFF2_BLINK;
    to_vict = "You don't feel any different.";
    to_room = "You see $n shift a few feet away.";
    break;

case SPELL_DEATHDANCE:
    af[0].duration = 9;
    af[0].bitvector2 = AFF2_DEATHDANCE;
    to_vict = "You feel your life take on a whole new meaning....";
    to_room = "A wave of death dances forth from $n";
    break;

  case SPELL_MARTIAL_TRANCE:
    af[0].duration = 1;
    af[0].bitvector = AFF_REGEN;
    accum_duration = FALSE;
    to_vict = "You start doing a martial trance";
    to_room = "$n starts doing a strange trance";
    break;

  case SPELL_PROT_FIRE:
    af[0].duration = 10 + level;
    af[0].bitvector2 = AFF2_PROT_FIRE;
    accum_duration = FALSE;
    to_vict = "You feel a shell of insulation form around your body.";
    break;

case SPELL_WRAITHFORM:
    af[0].duration = 8;
    af[0].bitvector2 = AFF2_PASSDOOR;
    to_vict = "You turn translucent!";
    to_room = "$n turns translucent!";
    break;
  }

  /*
   * If this is a mob that has this affect set in its mob file, do not
   * perform the affect.  This prevents people from un-sancting mobs
   * by sancting them and waiting for it to fade, for example.
   */
  if (IS_NPC(victim) && !affected_by_spell(victim, spellnum))
    for (i = 0; i < MAX_SPELL_AFFECTS; i++)
      if (AFF_FLAGGED(victim, af[i].bitvector) || AFF2_FLAGGED(victim,
af[i].bitvector2)
          || AFF3_FLAGGED(victim, af[i].bitvector3)) {
        send_to_char(NOEFFECT, ch);
        return;
      }

  /*
   * If the victim is already affected by this spell, and the spell does
   * not have an accumulative effect, then fail the spell.
   */
  if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect))
{
    send_to_char(NOEFFECT, ch);
    return;
  }

  for (i = 0; i < MAX_SPELL_AFFECTS; i++)
    if (af[i].bitvector || af[i].bitvector2 || af[i].bitvector3 ||
(af[i].location != APPLY_NONE))
      affect_join(victim, af+i, accum_duration, FALSE, accum_affect, FALSE);

  if (to_vict != NULL)
    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
  if (to_room != NULL)
    act(to_room, TRUE, victim, 0, ch, TO_ROOM);
}


/*
* This function is used to provide services to mag_groups.  This function
* is the one you should change to add new group spells.
*/

void perform_mag_groups(int level, struct char_data * ch,
                        struct char_data * tch, int spellnum, int savetype)
{
  switch (spellnum) {
    case SPELL_GROUP_HEAL:
    mag_points(level, ch, tch, SPELL_HEAL, savetype);
    break;
  case SPELL_GROUP_ARMOR:
    mag_affects(level, ch, tch, SPELL_ARMOR, savetype);
    break;
  case SPELL_GROUP_RECALL:
    spell_recall(level, ch, tch, NULL);
    break;
  case SPELL_GROUP_FLY:
    mag_affects(level, ch, tch, SPELL_FLY, savetype);
    break;
  case SPELL_GROUP_BLESS:
    mag_affects(level, ch, tch, SPELL_BLESS, savetype);
    break;
  }
}


/*
* Every spell that affects the group should run through here
* perform_mag_groups contains the switch statement to send us to the right
* magic.
*
* group spells affect everyone grouped with the caster who is in the room,
* caster last.
*
* To add new group spells, you shouldn't have to change anything in
* mag_groups -- just add a new case to perform_mag_groups.
*/


void mag_groups(int level, struct char_data * ch, int spellnum, int
savetype)
{
  struct char_data *tch, *k;
  struct follow_type *f, *f_next;

  if (ch == NULL)
    return;

  if (!AFF_FLAGGED(ch, AFF_GROUP))
    return;
  if (ch->master != NULL)
    k = ch->master;
  else
    k = ch;
  for (f = k->followers; f; f = f_next) {
    f_next = f->next;
    tch = f->follower;
    if (tch->in_room != ch->in_room)
      continue;
    if (!AFF_FLAGGED(tch, AFF_GROUP))
      continue;
    if (AFF2_FLAGGED(tch, AFF2_TRANSFORM))
      continue;
    if (ch == tch)
      continue;
    perform_mag_groups(level, ch, tch, spellnum, savetype);
  }

  if ((k != ch) && AFF_FLAGGED(k, AFF_GROUP))
    perform_mag_groups(level, ch, k, spellnum, savetype);

  perform_mag_groups(level, ch, ch, spellnum, savetype);
}


/*
* mass spells affect every creature in the room except the caster.
*
* No spells of this class currently implemented as of Circle 3.0.
*/

void mag_masses(int level, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *tch_next;

  for (tch = world[ch->in_room].people; tch; tch = tch_next) {
    tch_next = tch->next_in_room;
    if (tch == ch)
      continue;

    switch (spellnum) {
    }
  }
}


/*
* Every spell that affects an area (room) runs through here.  These are
* generally offensive spells.  This calls mag_damage to do the actual
* damage -- all spells listed here must also have a case in mag_damage()
* in order for them to work.
*
*  area spells have limited targets within the room.
*/

void mag_areas(int level, struct char_data * ch, int spellnum, int savetype)
{
  struct char_data *tch, *next_tch;
  const char *to_char = NULL, *to_room = NULL;
  int i;
  int num = 0 ;

  if (ch == NULL)
    return;

  /*
   * to add spells to this fn, just add the message here plus an entry
   * in mag_damage for the damaging part of the spell.
   */
  switch (spellnum) {
  case SPELL_EARTHQUAKE:
    to_char = "You gesture and the earth begins to shake all around you!";
    to_room ="$n gracefully gestures and the earth begins to shake violently!";
    break;
  case SPELL_END_WORLD:
    to_char = "You gesture and a explosion disintegrate and reintegrate the room!";
    to_room ="$n gracefully gestures and the room suddenly disappear and appear!";
    break;
  case SPELL_ICESTORM:
    to_char = "You throw a ice tempest on the room!";
    to_room ="$n throws a ice tempest on the room!";
    break;
  case SPELL_METEORSTORM:
    to_char = "You throw a meteor storm on the room!";
    to_room ="$n throws a meteor storm on the room!";
    break;
  case SPELL_FIRESTORM:
    to_char = "You gesture and a fire storm makes the room burn!";
    to_room ="$n makes strange gestures and a fire storm hit the room!";
    break;
  case SPELL_ELETRICSTORM:
    to_char = "You gesture and a eletric storm makes the room burn!";
    to_room ="$n makes strange gestures and a eletric storm hit the room!";
    break;
  case SPELL_MINUTE_METEOR:
    to_char = "You gesture and a lot of meteor falls in the room!";
    to_room ="$n makes strange gestures and a lot of Meteor falls in the room!";
    break;
  case SPELL_CALL_LIGHTNING:
    to_room ="$n calls all the lightning power of the air in the room!";
    to_char ="You call the lightning power in the room.";
    break;
  case SPELL_GREASE:
    to_char = "You gesture and 'KABUMM' explode the Grease.";
    to_room ="$n makes strange gestures and 'KABUM' explode the Grease.";
    break;
  case SPELL_CROMATIC_ORB:
    to_char = "You gesture and makes a incredible cromatic orb.";
    to_room ="$n makes strange gestures and makes a incredible cromatic orb.";
    break;
  case SPELL_AREA_LIGHTNING:
    to_char = "You gesture and call down lights in this place.";
    to_room ="$n makes strange gestures and get call down lights in this place.";
    break;
  case SPELL_SKULL_TRAP:
    to_char = "You gesture and throw a powerful skull which explodes.";
    to_room ="$n throws a strange skull in the center of the room which explodes.";
    break;
case SPELL_METEOR_SHOWER:
    to_char = "You call the iron meteors with your magic!";
    to_room = "$n glows and the rain of iron meteors comes suddenly!";
    break;
  case SPELL_BLADEBARRIER:
    to_room ="$n laughs and attempts to put up a BLADE BARRIER!";
    to_char ="You concentrate on swords.  Swords. SWORDS!!!";
    break;
  case SPELL_COMMAND:
    to_room ="$n commands and throw against all fire stones!";
    to_char ="You glow and command a rain of fire stone against all.";
    break;
  case SPELL_GEYSER:
    to_room ="$n glows and creates a greate fire EFFLORESCENSE!";
    to_char ="You concentrate and create a fire EFFLORESCENSE!!!";
    break;
  case SPELL_ARMAGEDDOM:
    to_room ="$n laughs and call down the strength of armageddom to the room!";
    to_char ="You laugh and call down the armageddom to the place!";
    break;
  case SPELL_BLIZZARD:
    to_room ="$n conjures a great number of SNOW BLOCKS falling in the  room!!";
    to_char ="You concentrate a conjure SNOW BLOCKS to fall in the room!";
    break;
  case SPELL_FIREBALL:
    to_room ="With all his power, $n explodes a FIREBALL against all! BUMMM!";
    to_char ="You utter the power of a FIREBALL which explodes BUMMM!!!";
    break;
  case SPELL_HOLY_SHOUT:
    to_char = "The world shook as you issue holy shout!";
    to_room = "$n opens the holy bible and said the holy word!";
    break;
  case SPELL_DEATH_RIPPLE:
    to_char = "Your lips utters the hymn of death!";
    to_room = "$n utters the word of DEATH!";
    break;
  case SPELL_DEATH_WAVE:
    to_char = "You sing the hymn of death!";
    to_room = "$n shouts the words of DEATH! Deadly wave destroys all life!";
  break;
  case SPELL_SUMMON_BAHAMUT:
    to_char = "You summon the dragon king to purge the land with a GIGA FLARE!";
    to_room ="$n gracefully gestures and the dragon king purges the land with its GIGA FLARE!";
  break;
  case SPELL_TALOS:
    to_char = "You sing the hymn of TALOS!";
    to_room = "$n shouts the words of TALOS!!";
    break ;
  }

  if (to_char != NULL)
    act(to_char, FALSE, ch, 0, 0, TO_CHAR);
  if (to_room != NULL)
    act(to_room, FALSE, ch, 0, 0, TO_ROOM);


  for (tch = world[ch->in_room].people; tch; tch = next_tch) {
    next_tch = tch->next_in_room;

    /*
     * The skips: 1: the caster
     *            2: immortals
     *            3: if no pk on this mud, skips over all players
     *            4: pets (charmed NPCs)
     * players can only hit players in CRIMEOK rooms 4) players can only hit
     * charmed mobs in CRIMEOK rooms
     */

    if (tch == ch)
      continue;
    if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
      continue;
    if (!pk_allowed && !IS_NPC(ch) && !IS_NPC(tch))
      continue;
    if (!IS_NPC(ch) && IS_NPC(tch) && AFF_FLAGGED(tch, AFF_CHARM))
      continue;
    i = (GET_LEVEL(tch) - GET_LEVEL(ch));
    if (!IS_NPC(ch) && !IS_NPC(tch))
      if (!(ROOM_FLAGGED(ch->in_room, ROOM_ARENA) &&
ROOM_FLAGGED(tch->in_room, ROOM_ARENA)))
        if (!(i < PK_MIN_LEVEL && i > -PK_MIN_LEVEL))
          if (check_wanted(tch) && (!FIGHTING(tch)))
            continue;

    if(GET_RACE(tch) == RACE_ANCI_DROW || (GET_RACE(tch) == RACE_DRACONIAN && number(1,12)
== 3))
    {
     send_to_char("Spell innefective\r\n" ,ch) ;
     send_to_char("Spell innefective\r\n" ,tch) ;
     continue ;
    }

   if(num > 3) return ; // soh acerta 3 mobs no maximo.

    num++ ; // numero de mobs afetados por magia de area
    /* Doesn't matter if they die here so we don't check. -gg 6/24/98 */
    mag_damage(GET_LEVEL(ch), ch, tch, spellnum, 1);
  }
}


/*
*  Every spell which summons/gates/conjours a mob comes through here.
*
*  None of these spells are currently implemented in Circle 3.0; these
*  were taken as examples from the JediMUD code.  Summons can be used
*  for spells like clone, ariel servant, etc.
*
* 10/15/97 (gg) - Implemented Animate Dead and Clone.
*/

/*
* These use act(), don't put the \r\n.
*/
const char *mag_summon_msgs[] = {
  "\r\n",
  "$n makes a strange magical gesture; you feel a strong breeze!",
  "$n animates a corpse!",
  "$N appears from a cloud of thick blue smoke!",
  "$N appears from a cloud of thick green smoke!",
  "$N appears from a cloud of thick red smoke!",
  "$N disappears in a thick black cloud!"
  "As $n makes a strange magical gesture, you feel a strong breeze.",
  "As $n makes a strange magical gesture, you feel a searing heat.",
  "As $n makes a strange magical gesture, you feel a sudden chill.",
  "As $n makes a strange magical gesture, you feel the dust swirl.",
  "$n magically divides!",
  "$n animates a corpse!",
  "$n magically creates a golem!",
  "$n creates a illusion!",
  "$n makes magical gestures and open the earth!",
  "$n creates a powerful black bear!"
};

/*
* Keep the \r\n because these use send_to_char.
*/
const char *mag_summon_fail_msgs[] = {
  "\r\n",
  "There are no such creatures.\r\n",
  "Uh oh...\r\n",
  "Oh dear.\r\n",
  "Oh shit!\r\n",
  "The elements resist!\r\n",
  "You failed.\r\n",
  "There is no corpse!\r\n"
};

/* These mobiles do not exist. */
#define MOB_MONSUM_I            130
#define MOB_MONSUM_II           140
#define MOB_MONSUM_III          150
#define MOB_GATE_I              160
#define MOB_GATE_II             170
#define MOB_GATE_III            180

/* Defined mobiles. */
#define MOB_ELEMENTAL_BASE      20      /* Only one for now. */
#define MOB_CLONE               10
#define MOB_ZOMBIE              11
#define MOB_GOLEM               15
#define MOB_ILLUSION            16
#define MOB_AERIALSERVANT       19

void mag_summons(int level, struct char_data * ch, struct obj_data * obj,
                      int spellnum, int savetype)
{
  struct char_data *mob = NULL;
  struct obj_data *tobj, *next_obj;
  int   pfail = 0, msg = 0, fmsg = 0, mob_num = 0,
        num = 1, handle_corpse = FALSE, i;

  if (ch == NULL)
    return;

  switch (spellnum) {
  case SPELL_CLONE:
    msg = 10;
    fmsg = number(2, 6);        /* Random fail message. */
    mob_num = MOB_CLONE;
    pfail = 50; /* 50% failure, should be based on something later. */
    break;

  case SPELL_CALL_BEAR :
   msg = 15 ;
   fmsg = 3 ;
   mob_num = 43 ; // white bear, by Luigi.
   pfail = 25 ;
   break ;

  case SPELL_HELM : // religion
   msg = 15 ;
   fmsg = 3 ;
   mob_num = 444 ; // by Luigi.
   pfail = 0 ;
   break ;

  case SPELL_ANIMATE_DEAD:
    if (obj == NULL || !IS_CORPSE(obj)) {
      act(mag_summon_fail_msgs[7], FALSE, ch, 0, 0, TO_CHAR);
      return;
    }
    handle_corpse = TRUE;
    msg = 11;
    fmsg = number(2, 6);        /* Random fail message. */
    mob_num = MOB_ZOMBIE;
    pfail = 10; /* 10% failure, should vary in the future. */
    break;

  case SPELL_GOLEM:
    msg = 12;
    fmsg = number(2, 6);        /* Random fail message. */
    mob_num = MOB_GOLEM;
    pfail = 50; /* 50% failure, should be based on something later. */
    break;

  case SPELL_ILLUSION:
    msg = 13;
    fmsg = number(2, 6);        /* Random fail message. */
    mob_num = MOB_ILLUSION;
    pfail = 50; /* 50% failure, should be based on something later. */
    break;

  case SPELL_ELEMENTAL:
    msg = 14;
    fmsg = number(2, 6);        /* Random fail message. */
    mob_num = MOB_ELEMENTAL_BASE;
    pfail = 50; /* 50% failure, should be based on something later. */
    break;

  default:
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM)) {
    send_to_char("You are too giddy to have any followers!\r\n", ch);
    return;
  }
  if (number(0, 101) < pfail) {
    send_to_char(mag_summon_fail_msgs[fmsg], ch);
    return;
  }
  if (!allow_follower(ch, 5)) {
    send_to_char("You can't have any more followers.\n\r", ch);
    return;
  }
  for (i = 0; i < num; i++) {
    if (!(mob = read_mobile(mob_num, VIRTUAL))) {
      send_to_char("You don't quite remember how to make that creature.\r\n", ch);
      return;
    }
    char_to_room(mob, ch->in_room);
    IS_CARRYING_W(mob) = 0;
    IS_CARRYING_N(mob) = 0;
    SET_BIT(AFF_FLAGS(mob), AFF_CHARM);
    if (spellnum == SPELL_CLONE) {      /* Don't mess up the proto with strcpy. */
      mob->player.name = str_dup(GET_NAME(ch));
      mob->player.short_descr = str_dup(GET_NAME(ch));
      GET_MAX_HIT(mob) = GET_MAX_HIT(ch);
      GET_HIT(mob) = GET_MAX_HIT(ch);
      GET_DAMROLL(mob) = GET_DAMROLL(ch);
      GET_HITROLL(mob) = GET_HITROLL(ch);
      GET_LEVEL(mob) = GET_LEVEL(ch);
      GET_EXP(mob) = 0;
      GET_MANA(ch) = 0;
      GET_GOLD(mob) = 0;
      GET_CLASS(mob) = -1;
    } else if (spellnum == SPELL_GOLEM) {      /* Don't mess up the proto
with strcpy. */
      GET_MAX_HIT(mob) = GET_LEVEL(ch)*10;
      GET_HIT(mob) = GET_MAX_HIT(mob);
      GET_AC(mob) = GET_AC(ch);
      GET_DAMROLL(mob) = GET_LEVEL(ch)/6;
      GET_HITROLL(mob) = GET_LEVEL(ch)/6;
      GET_LEVEL(mob) = GET_LEVEL(ch);
      GET_EXP(mob) = 0;
      GET_GOLD(mob) = 0;
      GET_CLASS(mob) = -1;
    } else if (spellnum == SPELL_ANIMATE_DEAD) {      /* Don't mess up the
proto with strcpy. */
      GET_MAX_HIT(mob) = GET_LEVEL(ch)*3;
      GET_HIT(mob) = GET_MAX_HIT(mob);
      GET_AC(mob) = GET_AC(ch)/5;
      GET_DAMROLL(mob) = GET_LEVEL(ch)/19.5;
      GET_HITROLL(mob) = GET_LEVEL(ch)/19.5;
      GET_LEVEL(mob) = GET_LEVEL(ch);
      GET_EXP(mob) = 0;
      GET_GOLD(mob) = 0;
      GET_CLASS(mob) = -1;
    } else if (spellnum == SPELL_ILLUSION) {      /* Don't mess up the proto
with strcpy. */
      mob->player.name = str_dup(GET_NAME(ch));
      mob->player.short_descr = str_dup(GET_NAME(ch));
      sprintf(buf, "&y%s&c%s &y%s&y is standing here.\r\n", (GET_PRENAME(ch)
!= NULL ? GET_PRENAME(ch) : ""), GET_NAME(ch), GET_TITLE(ch));
      mob->player.long_descr = str_dup(buf);
      GET_EXP(mob) = 0;
      GET_GOLD(mob) = 0;
      GET_CLASS(mob) = -1;
      REMOVE_BIT(AFF_FLAGS(mob), AFF_CHARM);
      send_to_char("You create a illusion of yourself.\r\n", ch);
    } else if (spellnum == SPELL_ELEMENTAL) {      /* Don't mess up the
proto with strcpy. */
      GET_MAX_HIT(mob) = GET_LEVEL(ch)*7;
      GET_HIT(mob) = GET_MAX_HIT(mob);
      GET_AC(mob) = GET_AC(ch)/3;
      GET_DAMROLL(mob) = GET_LEVEL(ch)/15;
      GET_HITROLL(mob) = GET_LEVEL(ch)/15;
      GET_LEVEL(mob) = GET_LEVEL(ch);
      GET_EXP(mob) = 0;
      GET_GOLD(mob) = 0;
      GET_CLASS(mob) = -1;
    }
    act(mag_summon_msgs[msg], FALSE, ch, 0, mob, TO_ROOM);
    load_mtrigger(mob);
    if (spellnum != SPELL_ILLUSION)
      add_follower(mob, ch);
  }
  if (handle_corpse) {
    for (tobj = obj->contains; tobj; tobj = next_obj) {
      next_obj = tobj->next_content;
      obj_from_obj(tobj);
      obj_to_char(tobj, mob);
    }
    extract_obj(obj);
  }
}


void mag_points(int level, struct char_data * ch, struct char_data * victim,
                     int spellnum, int savetype)
{
  int hit = 0;
  int move = 0;
  int mana = 0;

  if (victim == NULL)
    return;

  switch (spellnum) {
  case SPELL_CURE_LIGHT:
    hit = dice(2, 10);
    send_to_char("You feel better.\r\n", victim);
    break;
  case SPELL_CURE_CRITIC:
    hit = dice(7, 10);
    send_to_char("You feel a lot better!\r\n", victim);
    break;
  case SPELL_CURE_SERIOUS:
    hit = dice(12, 10);
    send_to_char("You feel much better!\r\n", victim);
    break;
  case SPELL_HEAL:
    hit = dice(20, 10);
    send_to_char("A warm feeling floods your body.\r\n", victim);
    break;
  case SPELL_REGENERATION:
    hit = dice(25, 20);
    send_to_char("You feel in your body the goddly power...\r\n", victim);
    break;
  case SPELL_REVITALIZE:
    hit = dice(16, 10);
    send_to_char("You feel your health revitalizing!\r\n", victim);
    break;
  case SPELL_LAY_ON_HANDS:
    hit = level;
    send_to_char("You receive the godly mercy and feel better!\r\n",
victim);
    break;

  case SPELL_ENERGY_DRAIN:
    if(!IS_NPC(victim)) {
      if ((GET_HIT(victim) < (GET_MAX_HIT(victim)/6)) || (number(20, 60) <
number(20, 80))) {
       act("$N's will resists your drain!", FALSE, ch, 0, victim, TO_CHAR);
       return;
      }
     } else {
      if ((number(20, 40) < number(25, 50)) || GET_HIT(victim) <
(GET_MAX_HIT(victim)/6)) {
       act("$N's will resists your drain!", FALSE, ch, 0, victim, TO_CHAR);
       return;
      }
     }

      GET_HIT(ch) += (GET_HIT(victim)/6);
      if (GET_HIT(ch) > GET_MAX_HIT(ch)) {
        GET_HIT(ch) = GET_MAX_HIT(ch);
      }
      GET_HIT(victim) -= (GET_HIT(victim)/6);

    send_to_char("You feel a less of health!\r\n", victim);
    send_to_char("You feel your health revitalized!\r\n", ch);

    break;

  case SPELL_LIFE_DRAINING:
    if (GET_HIT(victim) < 70) {
      send_to_char("The victim do not have life to drain!\r\n", ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    GET_HIT(ch) = GET_HIT(ch) + dice(6, 12);
    if (GET_HIT(ch) > GET_MAX_HIT(ch)) {
      GET_HIT(ch) = GET_MAX_HIT(ch);
    }
    GET_HIT(victim) = GET_HIT(victim) - dice(6, 12);

    send_to_char("You feel someone draining your life!\r\n", victim);
    send_to_char("You drain some life!\r\n", ch);
    break;

  case SPELL_LEND_HEALTH:
    if (GET_HIT(victim) < 100) {
      send_to_char("The victim do not have health to lend!\r\n", ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    GET_HIT(ch) = GET_HIT(ch) + dice(10, 12);
    if (GET_HIT(ch) > GET_MAX_HIT(ch)) {
      GET_HIT(ch) = GET_MAX_HIT(ch);
    }
    GET_HIT(victim) = GET_HIT(victim) - dice(10, 12);

    send_to_char("You feel someone lending your health!\r\n", victim);
    send_to_char("You lend the health of someone!\r\n", ch);
    break;

  case SPELL_PSYCHIC_DRAIN:
    if (GET_HIT(victim) < 70) {
      send_to_char("The mana of the victim is not sufficient to you drain!\r\n", ch);
      return;
    }
    if(!IS_NPC(ch) && !IS_NPC(victim)){
      if(!can_pk(ch, victim)){
        send_to_char("&WYou can not &Rkill &Wyour opponent right now.&n\r\n", ch);
        return;
      }
    }
    GET_MANA(ch) = GET_MANA(ch) + dice(8, 12);
    if (GET_MANA(ch) > GET_MAX_MANA(ch)) {
      GET_MANA(ch) = GET_MAX_MANA(ch);
    }
    GET_MANA(victim) = GET_MANA(victim) - dice(8, 12);

    send_to_char("You feel someone lending your health!\r\n", victim);
    send_to_char("You lend the health of someone!\r\n", ch);
    break;

  case SPELL_RESTORE_MANA:
    mana = GET_LEVEL(victim) + dice(8, 10);
    send_to_char("Your magic power has been restored.\r\n", victim);
    break;
  case SPELL_REFRESH:
    move = GET_MAX_MOVE(victim) / 5;
    send_to_char("You feel less tired.\r\n", victim);
    break;
  case SPELL_SATANIC_CURE:
    hit = 175 + dice(5, 10);
    send_to_char("You feel in your body the power of satan...\r\n", victim);
    break;
  }

  if(GET_RACE(ch) == RACE_ARCHONS || (GET_RACE(ch) == RACE_DRACONIAN &&
number(1,12) == 3))
   hit = hit * 1.2 ;

  GET_HIT(victim) = MIN(GET_MAX_HIT(victim), GET_HIT(victim) + hit);
  GET_MOVE(victim) = MIN(GET_MAX_MOVE(victim), GET_MOVE(victim) + move);
  GET_MANA(victim) = MIN(GET_MAX_MANA(victim), GET_MANA(victim) + mana);
  update_pos(victim);
}


void mag_unaffects(int level, struct char_data * ch, struct char_data *
victim,
                        int spellnum, int type)
{
  int spell = 0;
  const char *to_vict = NULL, *to_room = NULL;

  if (victim == NULL)
    return;

  switch (spellnum) {
  case SPELL_CURE_BLIND:
  case SPELL_HEAL:
    spell = SPELL_BLINDNESS;
    to_vict = "Your vision returns!";
    to_room = "There's a momentary gleam in $n's eyes.";
    break;
  case SPELL_REMOVE_POISON:
    spell = SPELL_POISON;
    to_vict = "A warm feeling runs through your body!";
    to_room = "$n looks better.";
    break;
  case SPELL_REMOVE_CURSE:
    spell = SPELL_CURSE;
    to_vict = "You don't feel so unlucky.";
    break;
  default:
    log("SYSERR: unknown spellnum %d passed to mag_unaffects.", spellnum);
    return;
  }

  if (!affected_by_spell(victim, spell) && spellnum != SPELL_HEAL) {
    send_to_char(NOEFFECT, ch);
    return;
  }

  affect_from_char(victim, spell);
  if (to_vict != NULL)
    act(to_vict, FALSE, victim, 0, ch, TO_CHAR);
  if (to_room != NULL)
    act(to_room, TRUE, victim, 0, ch, TO_ROOM);

}


void mag_alter_objs(int level, struct char_data * ch, struct obj_data * obj,
                         int spellnum, int savetype)
{
  const char *to_char = NULL, *to_room = NULL;

  if (obj == NULL)
    return;

  switch (spellnum) {
    case SPELL_BLESS:
      if (!IS_OBJ_STAT(obj, ITEM_BLESS) &&
          (GET_OBJ_WEIGHT(obj) <= 5 * GET_LEVEL(ch))) {
        SET_BIT(GET_OBJ_EXTRA(obj), ITEM_BLESS);
        to_char = "$p glows briefly.";
      }
      break;
    case SPELL_CURSE:
      if (!IS_OBJ_STAT(obj, ITEM_NODROP)) {
        SET_BIT(GET_OBJ_EXTRA(obj), ITEM_NODROP);
        if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
          GET_OBJ_VAL(obj, 2)--;
        to_char = "$p briefly glows red.";
      }
      break;
    case SPELL_INVISIBLE:
      if (!IS_OBJ_STAT(obj, ITEM_NOINVIS | ITEM_INVISIBLE)) {
        SET_BIT(obj->obj_flags.extra_flags, ITEM_INVISIBLE);
        to_char = "$p vanishes.";
      }
      break;
    case SPELL_POISON:
      if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && !GET_OBJ_VAL(obj, 3)) {
      GET_OBJ_VAL(obj, 3) = 1;
      to_char = "$p steams briefly.";
      }
      break;
    case SPELL_REMOVE_CURSE:
      if (IS_OBJ_STAT(obj, ITEM_NODROP)) {
        REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_NODROP);
        if (GET_OBJ_TYPE(obj) == ITEM_WEAPON)
          GET_OBJ_VAL(obj, 2)++;
        to_char = "$p briefly glows blue.";
      }
      break;
    case SPELL_REMOVE_POISON:
      if (((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOUNTAIN) ||
         (GET_OBJ_TYPE(obj) == ITEM_FOOD)) && GET_OBJ_VAL(obj, 3)) {
        GET_OBJ_VAL(obj, 3) = 0;
        to_char = "$p steams briefly.";
      }
      break;
  }

  if (to_char == NULL)
    send_to_char(NOEFFECT, ch);
  else
    act(to_char, TRUE, ch, obj, 0, TO_CHAR);

  if (to_room != NULL)
    act(to_room, TRUE, ch, obj, 0, TO_ROOM);
  else if (to_char != NULL)
    act(to_char, TRUE, ch, obj, 0, TO_ROOM);

}



void mag_creations(int level, struct char_data * ch, int spellnum)
{
  struct obj_data *tobj;
  int z;

  if (ch == NULL)
    return;
  level = MAX(MIN(level, LVL_IMPL), 1);

  switch (spellnum) {
  case SPELL_CREATE_FOOD:
    z = 3009;
    break;
  default:
    send_to_char("Spell unimplemented, it would seem.\r\n", ch);
    return;
  }

  if (!(tobj = read_object(z, VIRTUAL))) {
    send_to_char("I seem to have goofed.\r\n", ch);
    log("SYSERR: spell_creations, spell %d, obj %d: obj not found",
            spellnum, z);
    return;
  }

  obj_to_char(tobj, ch);
  act("$n creates $p.", FALSE, ch, tobj, 0, TO_ROOM);
  act("You create $p.", FALSE, ch, tobj, 0, TO_CHAR);
  load_otrigger(tobj);
}

void mag_room(int level, struct char_data * ch, int spellnum)
{
	long aff; /* what affection */
	int ticks; /* how many ticks this spell lasts */
	char *to_char = NULL;
	char *to_room = NULL;
	struct raff_node *raff;

	extern struct raff_node *raff_list;

	aff = ticks =0;

	if (ch == NULL)
		return;
	level = MAX(MIN(level, LVL_IMPL), 1);

	switch (spellnum) {
	case SPELL_WALL_OF_FOG:
		to_char = "You create a fog out of nowhere.";
		to_room = "$n creates a fog out of nowhere.";
		aff = RAFF_FOG;
		ticks = 1; /* this spell lasts one tick */
		break;
	case SPELL_FIREWALL:
		to_char = "You create a firewall.";
		to_room = "$n creates a firewall.";
		aff = RAFF_FIREWALL;
		ticks = 1; /* this spell lasts one tick */
		break;
	case SPELL_ICEWALL:
		to_char = "You create a icewall.";
		to_room = "$n creates a icewall.";
		aff = RAFF_ICEWALL;
		ticks = 1; /* this spell lasts one tick */
		break;
	default:
		sprintf(buf, "SYSERR: unknown spellnum %d passed to mag_unaffects",
spellnum);
		log(buf);
		break;
	}

	/* create, initialize, and link a room-affection node */
	CREATE(raff, struct raff_node, 1);
	raff->room = ch->in_room;
	raff->timer = ticks;
	raff->affection = aff;
	raff->spell = spellnum;
	raff->next = raff_list;
	raff_list = raff;

	/* set the affection */
	SET_BIT(ROOM_AFFECTIONS(raff->room), aff);

	if (to_char == NULL)
		send_to_char(NOEFFECT, ch);
	else
		act(to_char, TRUE, ch, 0, 0, TO_CHAR);

	if (to_room != NULL)
		act(to_room, TRUE, ch, 0, 0, TO_ROOM);
	else if (to_char != NULL)
		act(to_char, TRUE, ch, 0, 0, TO_ROOM);
}


::::::::::::::
mail.c
::::::::::::::
/* ************************************************************************
*   File: mail.c                                        Part of CircleMUD *
*  Usage: Internal funcs and player spec-procs of mud-mail system         *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/******* MUD MAIL SYSTEM MAIN FILE ***************************************

Written by Jeremy Elson (jelson@cs.jhu.edu)

*************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "db.h"
#include "interpreter.h"
#include "handler.h"
#include "mail.h"

void postmaster_send_mail(struct char_data * ch, struct char_data *mailman,
                          int cmd, char *arg);
void postmaster_check_mail(struct char_data * ch, struct char_data *mailman,
                          int cmd, char *arg);
void postmaster_receive_mail(struct char_data * ch, struct char_data *mailman,
                          int cmd, char *arg);
SPECIAL(postmaster);

extern struct room_data *world;
extern struct index_data *mob_index;
extern int no_mail;
extern struct player_index_element *player_table;
extern int top_of_p_table;
int find_name(char *name);

mail_index_type *mail_index = NULL;     /* list of recs in the mail file  */
position_list_type *free_list = NULL;   /* list of free positions in file */
long file_end_pos = 0;                  /* length of file */

/* local functions */
void push_free_list(long pos);
long pop_free_list(void);
mail_index_type *find_char_in_index(long searchee);
void write_to_file(void *buf, int size, long filepos);
void read_from_file(void *buf, int size, long filepos);
void index_mail(long id_to_index, long pos);

/* -------------------------------------------------------------------------- */

/*
 * void push_free_list(long #1)
 * #1 - What byte offset into the file the block resides.
 *
 * Net effect is to store a list of free blocks in the mail file in a linked
 * list.  This is called when people receive their messages and at startup
 * when the list is created.
 */
void push_free_list(long pos)
{
  position_list_type *new_pos;

  CREATE(new_pos, position_list_type, 1);
  new_pos->position = pos;
  new_pos->next = free_list;
  free_list = new_pos;
}


/*
 * long pop_free_list(none)
 * Returns the offset of a free block in the mail file.
 *
 * Typically used whenever a person mails a message.  The blocks are not
 * guaranteed to be sequential or in any order at all.
 */
long pop_free_list(void)
{
  position_list_type *old_pos;
  long return_value;

  /*
   * If we don't have any free blocks, we append to the file.
   */
  if ((old_pos = free_list) == NULL)
    return file_end_pos;

  /* Save the offset of the free block. */
  return_value = free_list->position;
  /* Remove this block from the free list. */
  free_list = old_pos->next;
  /* Get rid of the memory the node took. */
  free(old_pos);
  /* Give back the free offset. */
  return return_value;
}


/*
 * main_index_type *find_char_in_index(long #1)
 * #1 - The idnum of the person to look for.
 * Returns a pointer to the mail block found.
 *
 * Finds the first mail block for a specific person based on id number.
 */
mail_index_type *find_char_in_index(long searchee)
{
  mail_index_type *tmp;

  if (searchee < 0) {
    log("SYSERR: Mail system -- non fatal error #1 (searchee == %ld).", searchee);
    return NULL;
  }
  for (tmp = mail_index; (tmp && tmp->recipient != searchee); tmp = tmp->next);

  return tmp;
}


/*
 * void write_to_file(void * #1, int #2, long #3)
 * #1 - A pointer to the data to write, usually the 'block' record.
 * #2 - How much to write (because we'll write NUL terminated strings.)
 * #3 - What offset (block position) in the file to write to.
 *
 * Writes a mail block back into the database at the given location.
 */
void write_to_file(void *buf, int size, long filepos)
{
  FILE *mail_file;

  if (filepos % BLOCK_SIZE) {
    log("SYSERR: Mail system -- fatal error #2!!! (invalid file position %ld)", filepos);
    no_mail = TRUE;
    return;
  }
  if (!(mail_file = fopen(MAIL_FILE, "r+b"))) {
    log("SYSERR: Unable to open mail file '%s'.", MAIL_FILE);
    no_mail = TRUE;
    return;
  }
  fseek(mail_file, filepos, SEEK_SET);
  fwrite(buf, size, 1, mail_file);

  /* find end of file */
  fseek(mail_file, 0L, SEEK_END);
  file_end_pos = ftell(mail_file);
  fclose(mail_file);
  return;
}


/*
 * void read_from_file(void * #1, int #2, long #3)
 * #1 - A pointer to where we should store the data read.
 * #2 - How large the block we're reading is.
 * #3 - What position in the file to read.
 *
 * This reads a block from the mail database file.
 */
void read_from_file(void *buf, int size, long filepos)
{
  FILE *mail_file;

  if (filepos % BLOCK_SIZE) {
    log("SYSERR: Mail system -- fatal error #3!!! (invalid filepos read %ld)", filepos);
    no_mail = TRUE;
    return;
  }
  if (!(mail_file = fopen(MAIL_FILE, "r+b"))) {
    log("SYSERR: Unable to open mail file '%s'.", MAIL_FILE);
    no_mail = TRUE;
    return;
  }

  fseek(mail_file, filepos, SEEK_SET);
  fread(buf, size, 1, mail_file);
  fclose(mail_file);
  return;
}


void index_mail(long id_to_index, long pos)
{
  mail_index_type *new_index;
  position_list_type *new_position;

  if (id_to_index < 0) {
    log("SYSERR: Mail system -- non-fatal error #4. (id_to_index == %ld)", id_to_index);
    return;
  }
  if (!(new_index = find_char_in_index(id_to_index))) {
    /* name not already in index.. add it */
    CREATE(new_index, mail_index_type, 1);
    new_index->recipient = id_to_index;
    new_index->list_start = NULL;

    /* add to front of list */
    new_index->next = mail_index;
    mail_index = new_index;
  }
  /* now, add this position to front of position list */
  CREATE(new_position, position_list_type, 1);
  new_position->position = pos;
  new_position->next = new_index->list_start;
  new_index->list_start = new_position;
}


/*
 * int scan_file(none)
 * Returns false if mail file is corrupted or true if everything correct.
 *
 * This is called once during boot-up.  It scans through the mail file
 * and indexes all entries currently in the mail file.
 */
int scan_file(void)
{
  FILE *mail_file;
  header_block_type next_block;
  int total_messages = 0, block_num = 0;

  if (!(mail_file = fopen(MAIL_FILE, "r"))) {
    log("Mail file non-existant... creating new file.");
    touch(MAIL_FILE);
    return 1;
  }
  while (fread(&next_block, sizeof(header_block_type), 1, mail_file)) {
    if (next_block.block_type == HEADER_BLOCK) {
      index_mail(next_block.header_data.to, block_num * BLOCK_SIZE);
      total_messages++;
    } else if (next_block.block_type == DELETED_BLOCK)
      push_free_list(block_num * BLOCK_SIZE);
    block_num++;
  }

  file_end_pos = ftell(mail_file);
  fclose(mail_file);
  log("   %ld bytes read.", file_end_pos);
  if (file_end_pos % BLOCK_SIZE) {
    log("SYSERR: Error booting mail system -- Mail file corrupt!");
    log("SYSERR: Mail disabled!");
    return 0;
  }
  log("   Mail file read -- %d messages.", total_messages);
  return 1;
}                               /* end of scan_file */


/*
 * int has_mail(long #1)
 * #1 - id number of the person to check for mail.
 * Returns true or false.
 *
 * A simple little function which tells you if the guy has mail or not.
 */
int has_mail(long recipient)
{
  return (find_char_in_index(recipient) != NULL);
}


/*
 * void store_mail(long #1, long #2, char * #3)
 * #1 - id number of the person to mail to.
 * #2 - id number of the person the mail is from.
 * #3 - The actual message to send.
 *
 * call store_mail to store mail.  (hard, huh? :-) )  Pass 3 arguments:
 * who the mail is to (long), who it's from (long), and a pointer to the
 * actual message text (char *).
 */
void store_mail(long to, long from, char *message_pointer)
{
  header_block_type header;
  data_block_type data;
  long last_address, target_address;
  char *msg_txt = message_pointer;
  int bytes_written = 0;
  int total_length = strlen(message_pointer);
  
  if ((sizeof(header_block_type) != sizeof(data_block_type)) ||
      (sizeof(header_block_type) != BLOCK_SIZE)) {
    core_dump();
    return;
  }

  if (from < 0 || to < 0 || !*message_pointer) {
    log("SYSERR: Mail system -- non-fatal error #5. (from == %ld, to == %ld)", from, to);
    return;
  }
  memset((char *) &header, 0, sizeof(header));  /* clear the record */
  header.block_type = HEADER_BLOCK;
  header.header_data.next_block = LAST_BLOCK;
  header.header_data.from = from;
  header.header_data.to = to;
  header.header_data.mail_time = time(0);
  strncpy(header.txt, msg_txt, HEADER_BLOCK_DATASIZE);
  header.txt[HEADER_BLOCK_DATASIZE] = '\0';

  target_address = pop_free_list();     /* find next free block */
  index_mail(to, target_address);       /* add it to mail index in memory */
  write_to_file(&header, BLOCK_SIZE, target_address);

  if (strlen(msg_txt) <= HEADER_BLOCK_DATASIZE)
    return;                     /* that was the whole message */

  bytes_written = HEADER_BLOCK_DATASIZE;
  msg_txt += HEADER_BLOCK_DATASIZE;     /* move pointer to next bit of text */

  /*
   * find the next block address, then rewrite the header to reflect where
   * the next block is.
   */
  last_address = target_address;
  target_address = pop_free_list();
  header.header_data.next_block = target_address;
  write_to_file(&header, BLOCK_SIZE, last_address);

  /* now write the current data block */
  memset((char *) &data, 0, sizeof(data));      /* clear the record */
  data.block_type = LAST_BLOCK;
  strncpy(data.txt, msg_txt, DATA_BLOCK_DATASIZE);
  data.txt[DATA_BLOCK_DATASIZE] = '\0';
  write_to_file(&data, BLOCK_SIZE, target_address);
  bytes_written += strlen(data.txt);
  msg_txt += strlen(data.txt);

  /*
   * if, after 1 header block and 1 data block there is STILL part of the
   * message left to write to the file, keep writing the new data blocks and
   * rewriting the old data blocks to reflect where the next block is.  Yes,
   * this is kind of a hack, but if the block size is big enough it won't
   * matter anyway.  Hopefully, MUD players won't pour their life stories out
   * into the Mud Mail System anyway.
   * 
   * Note that the block_type data field in data blocks is either a number >=0,
   * meaning a link to the next block, or LAST_BLOCK flag (-2) meaning the
   * last block in the current message.  This works much like DOS' FAT.
   */
  while (bytes_written < total_length) {
    last_address = target_address;
    target_address = pop_free_list();

    /* rewrite the previous block to link it to the next */
    data.block_type = target_address;
    write_to_file(&data, BLOCK_SIZE, last_address);

    /* now write the next block, assuming it's the last.  */
    data.block_type = LAST_BLOCK;
    strncpy(data.txt, msg_txt, DATA_BLOCK_DATASIZE);
    data.txt[DATA_BLOCK_DATASIZE] = '\0';
    write_to_file(&data, BLOCK_SIZE, target_address);

    bytes_written += strlen(data.txt);
    msg_txt += strlen(data.txt);
  }
}                               /* store mail */


/*
 * char *read_delete(long #1)
 * #1 - The id number of the person we're checking mail for.
 * Returns the message text of the mail received.
 *
 * Retrieves one messsage for a player. The mail is then discarded from
 * the file and the mail index.
 */
char *read_delete(long recipient)
{
  header_block_type header;
  data_block_type data;
  mail_index_type *mail_pointer, *prev_mail;
  position_list_type *position_pointer;
  long mail_address, following_block;
  char *message, *tmstr, buf[200];
  char *from, *to;
  size_t string_size;

  if (recipient < 0) {
    log("SYSERR: Mail system -- non-fatal error #6. (recipient: %ld)", recipient);
    return NULL;
  }
  if (!(mail_pointer = find_char_in_index(recipient))) {
    log("SYSERR: Mail system -- post office spec_proc error?  Error #7. (invalid character in index)");
    return NULL;
  }
  if (!(position_pointer = mail_pointer->list_start)) {
    log("SYSERR: Mail system -- non-fatal error #8. (invalid position pointer %p)", position_pointer);
    return NULL;
  }
  if (!(position_pointer->next)) {      /* just 1 entry in list. */
    mail_address = position_pointer->position;
    free(position_pointer);

    /* now free up the actual name entry */
    if (mail_index == mail_pointer) {   /* name is 1st in list */
      mail_index = mail_pointer->next;
      free(mail_pointer);
    } else {
      /* find entry before the one we're going to del */
      for (prev_mail = mail_index;
           prev_mail->next != mail_pointer;
           prev_mail = prev_mail->next);
      prev_mail->next = mail_pointer->next;
      free(mail_pointer);
    }
  } else {
    /* move to next-to-last record */
    while (position_pointer->next->next)
      position_pointer = position_pointer->next;
    mail_address = position_pointer->next->position;
    free(position_pointer->next);
    position_pointer->next = NULL;
  }

  /* ok, now lets do some readin'! */
  read_from_file(&header, BLOCK_SIZE, mail_address);

  if (header.block_type != HEADER_BLOCK) {
    log("SYSERR: Oh dear. (Header block %ld != %d)", header.block_type, HEADER_BLOCK);
    no_mail = TRUE;
    log("SYSERR: Mail system disabled!  -- Error #9. (Invalid header block.)");
    return NULL;
  }
  tmstr = asctime(localtime(&header.header_data.mail_time));
  *(tmstr + strlen(tmstr) - 1) = '\0';

  from = get_name_by_id(header.header_data.from);
  to = get_name_by_id(recipient);

  sprintf(buf, " * * * * Wardome Mail System * * * *\r\n"
          "Date: %s\r\n"
          "  To: %s\r\n"
          "From: %s\r\n\r\n", tmstr, to ? to : "Unknown",
          from ? from : "Unknown");

  string_size = (sizeof(char) * (strlen(buf) + strlen(header.txt) + 1));
  CREATE(message, char, string_size);
  strcpy(message, buf);
  strcat(message, header.txt);
  message[string_size - 1] = '\0';
  following_block = header.header_data.next_block;

  /* mark the block as deleted */
  header.block_type = DELETED_BLOCK;
  write_to_file(&header, BLOCK_SIZE, mail_address);
  push_free_list(mail_address);

  while (following_block != LAST_BLOCK) {
    read_from_file(&data, BLOCK_SIZE, following_block);

    string_size = (sizeof(char) * (strlen(message) + strlen(data.txt) + 1));
    RECREATE(message, char, string_size);
    strcat(message, data.txt);
    message[string_size - 1] = '\0';
    mail_address = following_block;
    following_block = data.block_type;
    data.block_type = DELETED_BLOCK;
    write_to_file(&data, BLOCK_SIZE, mail_address);
    push_free_list(mail_address);
  }

  return message;
}


/****************************************************************
* Below is the spec_proc for a postmaster using the above       *
* routines.  Written by Jeremy Elson (jelson@server.cs.jhu.edu) *
****************************************************************/

SPECIAL(postmaster)
{
  if (!ch->desc || IS_NPC(ch))
    return 0;                   /* so mobs don't get caught here */

  if (!(CMD_IS("mail") || CMD_IS("check") || CMD_IS("receive")))
    return 0;

  if (no_mail) {
    send_to_char("Sorry, the mail system is having technical difficulties.\r\n", ch);
    return 0;
  }

  if (CMD_IS("mail")) {
    postmaster_send_mail(ch, (struct char_data *)me, cmd, argument);
    return 1;
  } else if (CMD_IS("check")) {
    postmaster_check_mail(ch, (struct char_data *)me, cmd, argument);
    return 1;
  } else if (CMD_IS("receive")) {
    postmaster_receive_mail(ch, (struct char_data *)me, cmd, argument);
    return 1;
  } else
    return 0;
}


void postmaster_send_mail(struct char_data * ch, struct char_data *mailman,
                          int cmd, char *arg)
{
  long recipient = 0;
  char buf[256];

  if (GET_LEVEL(ch) < MIN_MAIL_LEVEL) {
    sprintf(buf, "$n tells you, 'Sorry, you have to be level %d to send mail!'",
            MIN_MAIL_LEVEL);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  one_argument(arg, buf);

  if (!*buf) {                  /* you'll get no argument from me! */
    act("$n tells you, 'You need to specify an addressee! <all> <imms> <player name>'",
        FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  if (GET_GOLD(ch) < STAMP_PRICE) {
    sprintf(buf, "$n tells you, 'A stamp costs %d coins.'\r\n"
            "$n tells you, '...which I see you can't afford.'", STAMP_PRICE);
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }

  if ((recipient = get_id_by_name(buf)) < 0) {
    act("$n tells you, 'No one by that name is registered here!'",
        FALSE, mailman, 0, ch, TO_VICT);
    return;
  }

  act("$n starts to write some mail.", TRUE, ch, 0, 0, TO_ROOM);
  sprintf(buf, "$n tells you, 'I'll take %d coins for the stamp.'\r\n"
       "$n tells you, 'Write your message, (/s saves /h for help)'",
          STAMP_PRICE);

  act(buf, FALSE, mailman, 0, ch, TO_VICT);
  GET_GOLD(ch) -= STAMP_PRICE;
  SET_BIT(PLR_FLAGS(ch), PLR_MAILING | PLR_WRITING);

  ch->desc->mail_to = recipient;

  CREATE(ch->desc->str, char *, 1);

  *(ch->desc->str) = NULL;
  ch->desc->max_str = MAX_MAIL_SIZE;
}


void postmaster_check_mail(struct char_data * ch, struct char_data *mailman,
                          int cmd, char *arg)
{
  char buf[256];

  if (has_mail(GET_IDNUM(ch)))
    sprintf(buf, "$n tells you, 'You have mail waiting.'");
  else
    sprintf(buf, "$n tells you, 'Sorry, you don't have any mail waiting.'");
  act(buf, FALSE, mailman, 0, ch, TO_VICT);
}


void postmaster_receive_mail(struct char_data * ch, struct char_data *mailman,
                          int cmd, char *arg)
{
  char buf[256];
  struct obj_data *obj;

  if (!has_mail(GET_IDNUM(ch))) {
    sprintf(buf, "$n tells you, 'Sorry, you don't have any mail waiting.'");
    act(buf, FALSE, mailman, 0, ch, TO_VICT);
    return;
  }
  while (has_mail(GET_IDNUM(ch))) {
    obj = create_obj();
    obj->item_number = NOTHING;
    obj->name = str_dup("mail paper letter");
    obj->short_description = str_dup("a piece of mail");
    obj->description = str_dup("Someone has left a piece of mail here.");

    GET_OBJ_TYPE(obj) = ITEM_NOTE;
    GET_OBJ_WEAR(obj) = ITEM_WEAR_TAKE | ITEM_WEAR_HOLD;
    GET_OBJ_WEIGHT(obj) = 1;
    GET_OBJ_COST(obj) = 30;
    GET_OBJ_RENT(obj) = 10;
    obj->action_description = read_delete(GET_IDNUM(ch));

    if (obj->action_description == NULL)
      obj->action_description =
        str_dup("Mail system error - please report.  Error #11.\r\n");

    obj_to_char(obj, ch);

    act("$n gives you a piece of mail.", FALSE, mailman, 0, ch, TO_VICT);
    act("$N gives $n a piece of mail.", FALSE, ch, 0, mailman, TO_ROOM);
  }
}
::::::::::::::
medit.c
::::::::::::::
/************************************************************************
 * OasisOLC - medit.c						v1.5	*
 * Copyright 1996 Harvey Gilpin.					*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "spells.h"
#include "utils.h"
#include "db.h"
#include "shop.h"
#include "olc.h"
#include "handler.h"
#include "dg_olc.h"

/*
 * Set this to 1 for debugging logs in medit_save_internally.
 */
#if 0
#define DEBUG
#endif

/*
 * Set this to 1 as a last resort to save mobiles.
 */
#if 0
#define I_CRASH
#endif

/*-------------------------------------------------------------------*/

/*
 * External variable declarations.
 */
extern struct index_data *mob_index;
extern struct char_data *mob_proto;
extern struct char_data *character_list;
extern int top_of_mobt;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern struct player_special_data dummy_mob;
extern struct attack_hit_type attack_hit_text[];
extern const char *action_bits[];
extern const char *affected_bits[];
extern const char *position_types[];
extern const char *genders[];
extern const char *class_types[];
extern const char *race_types[];
extern int top_shop;
extern struct shop_data *shop_index;
extern struct descriptor_data *descriptor_list;
#if defined(OASIS_MPROG)
extern const char *mobprog_types[];
#endif
void quest_save_to_file(FILE * fp, struct char_data *mob);

/*-------------------------------------------------------------------*/

/*
 * Handy internal macros.
 */

#define GET_NDD(mob) ((mob)->mob_specials.damnodice)
#define GET_SDD(mob) ((mob)->mob_specials.damsizedice)
#define GET_ALIAS(mob) ((mob)->player.name)
#define GET_SDESC(mob) ((mob)->player.short_descr)
#define GET_LDESC(mob) ((mob)->player.long_descr)
#define GET_DDESC(mob) ((mob)->player.description)
#define GET_ATTACK(mob) ((mob)->mob_specials.attack_type)
#define S_KEEPER(shop) ((shop)->keeper)
#define GET_ATTACK1(mob)  ((mob)->mob_specials.attack1)
#define GET_ATTACK2(mob)  ((mob)->mob_specials.attack2)
#define GET_ATTACK3(mob)  ((mob)->mob_specials.attack3)
#if defined(OASIS_MPROG)
#define GET_MPROG(mob)		(mob_index[(mob)->nr].mobprogs)
#define GET_MPROG_TYPE(mob)	(mob_index[(mob)->nr].progtypes)
#endif

/*-------------------------------------------------------------------*/

/*
 * Function prototypes.
 */
void medit_parse(struct descriptor_data *d, char *arg);
void medit_disp_menu(struct descriptor_data *d);
void medit_setup_new(struct descriptor_data *d);
void medit_setup_existing(struct descriptor_data *d, int rmob_num);
void medit_save_internally(struct descriptor_data *d);
void medit_save_to_disk(int zone_num);
void init_mobile(struct char_data *mob);
void copy_mobile(struct char_data *tmob, struct char_data *fmob);
void medit_disp_positions(struct descriptor_data *d);
void medit_disp_mob_flags(struct descriptor_data *d);
void medit_disp_aff_flags(struct descriptor_data *d);
void medit_disp_attack_types(struct descriptor_data *d);
void medit_disp_class(struct descriptor_data *d);
void medit_disp_race(struct descriptor_data *d); 
#if defined(OASIS_MPROG)
void medit_disp_mprog(struct descriptor_data *d);
void medit_change_mprog(struct descriptor_data *d);
const char *medit_get_mprog_type(struct mob_prog_data *mprog);
#endif

/*-------------------------------------------------------------------*\
  utility functions 
\*-------------------------------------------------------------------*/

/*
 * Free a mobile structure that has been edited.
 * Take care of existing mobiles and their mob_proto!
 */

void medit_free_mobile(struct char_data *mob)
{
  int i;
  /*
   * Non-prototyped mobile.  Also known as new mobiles.
   */
  if (!mob)
    return;
  else if (GET_MOB_RNUM(mob) == -1) {
    if (mob->player.name)
      free(mob->player.name);
    if (mob->player.title)
      free(mob->player.title);
    if (mob->player.short_descr)
      free(mob->player.short_descr);
    if (mob->player.long_descr)
      free(mob->player.long_descr);
    if (mob->player.description)
      free(mob->player.description);
  } else if ((i = GET_MOB_RNUM(mob)) > -1) {	/* Prototyped mobile. */
    if (mob->player.name && mob->player.name != mob_proto[i].player.name)
      free(mob->player.name);
    if (mob->player.title && mob->player.title != mob_proto[i].player.title)
      free(mob->player.title);
    if (mob->player.short_descr && mob->player.short_descr != mob_proto[i].player.short_descr)
      free(mob->player.short_descr);
    if (mob->player.long_descr && mob->player.long_descr != mob_proto[i].player.long_descr)
      free(mob->player.long_descr);
    if (mob->player.description && mob->player.description != mob_proto[i].player.description)
      free(mob->player.description);
  }
  while (mob->affected)
    affect_remove(mob, mob->affected);

  free(mob);
}

void medit_setup_new(struct descriptor_data *d)
{
  struct char_data *mob;

  /*
   * Allocate a scratch mobile structure.  
   */
  CREATE(mob, struct char_data, 1);

  init_mobile(mob);

  GET_MOB_RNUM(mob) = -1;
  /*
   * Set up some default strings.
   */
  GET_ALIAS(mob) = str_dup("mob unfinished");
  GET_SDESC(mob) = str_dup("the unfinished mob");
  GET_LDESC(mob) = str_dup("An unfinished mob stands here.\r\n");
  GET_DDESC(mob) = str_dup("It looks unfinished.\r\n");
#if defined(OASIS_MPROG)
  OLC_MPROGL(d) = NULL;
  OLC_MPROG(d) = NULL;
#endif

  OLC_MOB(d) = mob;
  OLC_VAL(d) = 0;  /* Has changed flag. (It hasn't so far, we just made it.) */
  OLC_ITEM_TYPE(d) = MOB_TRIGGER;

  medit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

void medit_setup_existing(struct descriptor_data *d, int rmob_num)
{
  struct char_data *mob;
#if defined(OASIS_MPROG)
  MPROG_DATA *temp;
  MPROG_DATA *head;
#endif

  /*
   * Allocate a scratch mobile structure. 
   */
  CREATE(mob, struct char_data, 1);

  copy_mobile(mob, mob_proto + rmob_num);

#if defined(OASIS_MPROG)
  /*
   * I think there needs to be a brace from the if statement to the #endif
   * according to the way the original patch was indented.  If this crashes,
   * try it with the braces and report to greerga@van.ml.org on if that works.
   */
  if (GET_MPROG(mob))
    CREATE(OLC_MPROGL(d), MPROG_DATA, 1);
  head = OLC_MPROGL(d);
  for (temp = GET_MPROG(mob); temp;temp = temp->next) {
    OLC_MPROGL(d)->type = temp->type;
    OLC_MPROGL(d)->arglist = str_dup(temp->arglist);
    OLC_MPROGL(d)->comlist = str_dup(temp->comlist);
    if (temp->next) {
      CREATE(OLC_MPROGL(d)->next, MPROG_DATA, 1);
      OLC_MPROGL(d) = OLC_MPROGL(d)->next;
    }
  }
  OLC_MPROGL(d) = head;
  OLC_MPROG(d) = OLC_MPROGL(d);
#endif

  OLC_MOB(d) = mob;
  OLC_ITEM_TYPE(d) = MOB_TRIGGER;
  dg_olc_script_copy(d);
  medit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

/*
 * Copy one mob struct to another.
 */
void copy_mobile(struct char_data *tmob, struct char_data *fmob)
{
  struct trig_proto_list *proto, *fproto;

  /*
   * Free up any used strings.
   */
  if (GET_ALIAS(tmob))
    free(GET_ALIAS(tmob));
  if (GET_SDESC(tmob))
    free(GET_SDESC(tmob));
  if (GET_LDESC(tmob))
    free(GET_LDESC(tmob));
  if (GET_DDESC(tmob))
    free(GET_DDESC(tmob));

  /* delete the old script list */
  proto = tmob->proto_script;
  while (proto) {
    fproto = proto;
    proto = proto->next;
    free(fproto);
  }

  /*
   * Copy mob over.
   */
  *tmob = *fmob;

  /*
   * Reallocate strings.
   */
  GET_ALIAS(tmob) = str_dup((GET_ALIAS(fmob) && *GET_ALIAS(fmob)) ? GET_ALIAS(fmob) : "undefined");
  GET_SDESC(tmob) = str_dup((GET_SDESC(fmob) && *GET_SDESC(fmob)) ? GET_SDESC(fmob) : "undefined");
  GET_LDESC(tmob) = str_dup((GET_LDESC(fmob) && *GET_LDESC(fmob)) ? GET_LDESC(fmob) : "undefined");
  GET_DDESC(tmob) = str_dup((GET_DDESC(fmob) && *GET_DDESC(fmob)) ? GET_DDESC(fmob) : "undefined");

  /* copy the new script list */
  if (fmob->proto_script) {
    fproto = fmob->proto_script;
    CREATE(proto, struct trig_proto_list, 1);
    tmob->proto_script = proto;
    do {
      proto->vnum = fproto->vnum;
      fproto = fproto->next;
      if (fproto) { 
        CREATE(proto->next, struct trig_proto_list, 1);
        proto = proto->next;
      }
    } while (fproto);
  }
}

/*-------------------------------------------------------------------*/

/*
 * Ideally, this function should be in db.c, but I'll put it here for
 * portability.
 */
void init_mobile(struct char_data *mob)
{
  clear_char(mob);

  GET_HIT(mob) = GET_MANA(mob) = 1;
  GET_MAX_MANA(mob) = GET_MAX_MOVE(mob) = 100;
  GET_NDD(mob) = GET_SDD(mob) = 1;
  GET_WEIGHT(mob) = 200;
  GET_HEIGHT(mob) = 198;

  mob->real_abils.str = mob->real_abils.intel = mob->real_abils.wis = 11;
  mob->real_abils.dex = mob->real_abils.con = mob->real_abils.cha = 11;
  mob->aff_abils = mob->real_abils;

  SET_BIT(MOB_FLAGS(mob), MOB_ISNPC);
  mob->player_specials = &dummy_mob;
}

/*-------------------------------------------------------------------*/

#define ZCMD zone_table[zone].cmd[cmd_no]

/*
 * Save new/edited mob to memory.
 */
void medit_save_internally(struct descriptor_data *d)
{
  int rmob_num, found = 0, new_mob_num = 0, zone, cmd_no, shop;
  struct char_data *new_proto;
  struct index_data *new_index;
  struct char_data *live_mob;
  struct descriptor_data *dsc;

  /* put the script into proper position */
  OLC_MOB(d)->proto_script = OLC_SCRIPT(d);

  /*
   * Mob exists? Just update it.
   */
  if ((rmob_num = real_mobile(OLC_NUM(d))) != -1) {
    OLC_MOB(d)->proto_script = OLC_SCRIPT(d);
    copy_mobile((mob_proto + rmob_num), OLC_MOB(d));
    /*
     * Update live mobiles.
     */
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (IS_MOB(live_mob) && GET_MOB_RNUM(live_mob) == rmob_num) {
        /*
	 * Only really need to update the strings, since these can
	 * cause protection faults.  The rest can wait till a reset/reboot.
	 */
	GET_ALIAS(live_mob) = GET_ALIAS(mob_proto + rmob_num);
	GET_SDESC(live_mob) = GET_SDESC(mob_proto + rmob_num);
	GET_LDESC(live_mob) = GET_LDESC(mob_proto + rmob_num);
	GET_DDESC(live_mob) = GET_DDESC(mob_proto + rmob_num);
      }
  }
  /*
   * Mob does not exist, we have to add it.
   */
  else {
#if defined(DEBUG)
    fprintf(stderr, "top_of_mobt: %d, new top_of_mobt: %d\n", top_of_mobt, top_of_mobt + 1);
#endif

    CREATE(new_proto, struct char_data, top_of_mobt + 2);
    CREATE(new_index, struct index_data, top_of_mobt + 2);

    for (rmob_num = 0; rmob_num <= top_of_mobt; rmob_num++) {
      if (!found) {		/* Is this the place? */
/*	if ((rmob_num > top_of_mobt) || (mob_index[rmob_num].vnum > OLC_NUM(d))) {*/
	if (mob_index[rmob_num].vnum > OLC_NUM(d)) {
	  /*
	   * Yep, stick it here.
	   */
	  found = TRUE;
#if defined(DEBUG)
	  fprintf(stderr, "Inserted: rmob_num: %d\n", rmob_num);
#endif
	  new_index[rmob_num].vnum = OLC_NUM(d);
	  new_index[rmob_num].number = 0;
	  new_index[rmob_num].func = NULL;
	  new_mob_num = rmob_num;
	  GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
	  copy_mobile((new_proto + rmob_num), OLC_MOB(d));
	  /*
	   * Copy the mob that should be here on top.
	   */
	  new_index[rmob_num + 1] = mob_index[rmob_num];
	  new_proto[rmob_num + 1] = mob_proto[rmob_num];
	  GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
	} else {	/* Nope, copy over as normal. */
	  new_index[rmob_num] = mob_index[rmob_num];
	  new_proto[rmob_num] = mob_proto[rmob_num];
	}
      } else { /* We've already found it, copy the rest over. */
	new_index[rmob_num + 1] = mob_index[rmob_num];
	new_proto[rmob_num + 1] = mob_proto[rmob_num];
	GET_MOB_RNUM(new_proto + rmob_num + 1) = rmob_num + 1;
      }
    }
#if defined(DEBUG)
    fprintf(stderr, "rmob_num: %d, top_of_mobt: %d, array size: 0-%d (%d)\n",
		rmob_num, top_of_mobt, top_of_mobt + 1, top_of_mobt + 2);
#endif
    if (!found) { /* Still not found, must add it to the top of the table. */
#if defined(DEBUG)
      fprintf(stderr, "Append.\n");
#endif
      new_index[rmob_num].vnum = OLC_NUM(d);
      new_index[rmob_num].number = 0;
      new_index[rmob_num].func = NULL;
      new_mob_num = rmob_num;
      GET_MOB_RNUM(OLC_MOB(d)) = rmob_num;
      copy_mobile((new_proto + rmob_num), OLC_MOB(d));
    }
    /*
     * Replace tables.
     */
#if defined(DEBUG)
    fprintf(stderr, "Attempted free.\n");
#endif
#if !defined(I_CRASH)
    free(mob_index);
    free(mob_proto);
#endif
    mob_index = new_index;
    mob_proto = new_proto;
    top_of_mobt++;
#if defined(DEBUG)
    fprintf(stderr, "Free ok.\n");
#endif

    /*
     * Update live mobile rnums.
     */
    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
      if (GET_MOB_RNUM(live_mob) > new_mob_num)
	GET_MOB_RNUM(live_mob)++;

    /*
     * Update zone table.
     */
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
	if (ZCMD.command == 'M')
	  if (ZCMD.arg1 >= new_mob_num)
	    ZCMD.arg1++;

    /*
     * Update shop keepers.
     */
    if (shop_index)
      for (shop = 0; shop <= top_shop; shop++)
 	if (SHOP_KEEPER(shop) >= new_mob_num)
	  SHOP_KEEPER(shop)++;

    /*
     * Update keepers in shops being edited and other mobs being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT) {
	if (S_KEEPER(OLC_SHOP(dsc)) >= new_mob_num)
	  S_KEEPER(OLC_SHOP(dsc))++;
      } else if (dsc->connected == CON_MEDIT) {
	if (GET_MOB_RNUM(OLC_MOB(dsc)) >= new_mob_num)
	  GET_MOB_RNUM(OLC_MOB(dsc))++;
      }
  }

#if defined(OASIS_MPROG)
  GET_MPROG(OLC_MOB(d)) = OLC_MPROGL(d);
  GET_MPROG_TYPE(OLC_MOB(d)) = (OLC_MPROGL(d) ? OLC_MPROGL(d)->type : 0);
  while (OLC_MPROGL(d)) {
    GET_MPROG_TYPE(OLC_MOB(d)) |= OLC_MPROGL(d)->type;
    OLC_MPROGL(d) = OLC_MPROGL(d)->next;
  }
#endif

  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_MOB);
}

/*-------------------------------------------------------------------*/

/*
 * Save ALL mobiles for a zone to their .mob file, mobs are all 
 * saved in Extended format, regardless of whether they have any
 * extended fields.  Thanks to Sammy for ideas on this bit of code.
 */
void medit_save_to_disk(int zone_num)
{
  int i, rmob_num, zone, top;
  FILE *mob_file;
  char fname[64];
  struct char_data *mob;
#if defined(OASIS_MPROG)
  MPROG_DATA *mob_prog = NULL;
#endif

  zone = zone_table[zone_num].number;
  top = zone_table[zone_num].top;

  sprintf(fname, "%s/%d.new", MOB_PREFIX, zone);
  if (!(mob_file = fopen(fname, "w"))) {
    mudlog("SYSERR: OLC: Cannot open mob file!", BRF, LVL_BUILDER, TRUE);
    return;
  }

  /*
   * Seach the database for mobs in this zone and save them.
   */
  for (i = zone * 100; i <= top; i++) {
    if ((rmob_num = real_mobile(i)) != -1) {
      if (fprintf(mob_file, "#%d\n", i) < 0) {
	mudlog("SYSERR: OLC: Cannot write mob file!\r\n", BRF, LVL_BUILDER, TRUE);
	fclose(mob_file);
	return;
      }
      mob = (mob_proto + rmob_num);

      /*
       * Clean up strings.
       */
      strcpy(buf1, (GET_LDESC(mob) && *GET_LDESC(mob)) ? GET_LDESC(mob) : "undefined");
      strip_string(buf1);
      strcpy(buf2, (GET_DDESC(mob) && *GET_DDESC(mob)) ? GET_DDESC(mob) : "undefined");
      strip_string(buf2);

      fprintf(mob_file, "%s~\n"
			"%s~\n"
			"%s~\n"
			"%s~\n"
			"%ld %ld %d E\n"
			"%d %d %d %dd%d+%d %dd%d+%d\n"
			"%d %d %d\n"
			"%d %d %d %d %d\n",
	      (GET_ALIAS(mob) && *GET_ALIAS(mob)) ? GET_ALIAS(mob) : "undefined",
	      (GET_SDESC(mob) && *GET_SDESC(mob)) ? GET_SDESC(mob) : "undefined",
	      buf1, buf2, MOB_FLAGS(mob), AFF_FLAGS(mob), GET_ALIGNMENT(mob),
	      GET_LEVEL(mob), 20 - GET_HITROLL(mob), /* Hitroll -> THAC0 */
	      GET_AC(mob) / 10, GET_HIT(mob), GET_MANA(mob), GET_MOVE(mob),
	      GET_NDD(mob), GET_SDD(mob), GET_DAMROLL(mob), GET_GOLD(mob),
	      GET_EXP(mob), GET_REMORT(mob), GET_POS(mob), GET_DEFAULT_POS(mob), GET_SEX(mob),
	      GET_CLASS(mob), GET_RACE(mob));

      /*
       * Deal with Extra stats in case they are there.
       */
      if (GET_ATTACK(mob) != 0)
	fprintf(mob_file, "BareHandAttack: %d\n", GET_ATTACK(mob));
      if (GET_STR(mob) != 11)
	fprintf(mob_file, "Str: %d\n", GET_STR(mob));
      if (GET_ADD(mob) != 0)
	fprintf(mob_file, "StrAdd: %d\n", GET_ADD(mob));
      if (GET_DEX(mob) != 11)
	fprintf(mob_file, "Dex: %d\n", GET_DEX(mob));
      if (GET_INT(mob) != 11)
	fprintf(mob_file, "Int: %d\n", GET_INT(mob));
      if (GET_WIS(mob) != 11)
	fprintf(mob_file, "Wis: %d\n", GET_WIS(mob));
      if (GET_CON(mob) != 11)
	fprintf(mob_file, "Con: %d\n", GET_CON(mob));
      if (GET_CHA(mob) != 11)
	fprintf(mob_file, "Cha: %d\n", GET_CHA(mob));
      if(GET_ATTACK1(mob) != 0)
        fprintf(mob_file, "Att2: %d\n", GET_ATTACK1(mob));
      if(GET_ATTACK2(mob) != 0)
        fprintf(mob_file, "Att3: %d\n", GET_ATTACK2(mob));
      if(GET_ATTACK3(mob) != 0)
        fprintf(mob_file, "Att4: %d\n", GET_ATTACK3(mob));
      /*
       * XXX: Add E-mob handlers here.
       */

      fprintf(mob_file, "E\n");

      script_save_to_disk(mob_file, mob, MOB_TRIGGER);
      quest_save_to_file(mob_file, mob);
      
#if defined(OASIS_MPROG)
      /*
       * Write out the MobProgs.
       */
      mob_prog = GET_MPROG(mob);
      while(mob_prog) {
	strcpy(buf1, mob_prog->arglist);
	strip_string(buf1);
	strcpy(buf2, mob_prog->comlist);
	strip_string(buf2);
	fprintf(mob_file, "%s %s~\n%s", medit_get_mprog_type(mob_prog),
					buf1, buf2);
	mob_prog = mob_prog->next;
	fprintf(mob_file, "~\n%s", (!mob_prog ? "|\n" : ""));
      }
#endif
    }
  }
  fprintf(mob_file, "$\n");
  fclose(mob_file);
  sprintf(buf2, "%s/%d.mob", MOB_PREFIX, zone);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(fname, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_MOB);
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

/*
 * Display positions. (sitting, standing, etc)
 */
void medit_disp_positions(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; *position_types[i] != '\n'; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, position_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter position number : ", d->character);
}

/*-------------------------------------------------------------------*/

#if defined(OASIS_MPROG)
/*
 * Get the type of MobProg.
 */
const char *medit_get_mprog_type(struct mob_prog_data *mprog)
{
  switch (mprog->type) {
  case IN_FILE_PROG:	return ">in_file_prog";
  case ACT_PROG:	return ">act_prog";
  case SPEECH_PROG:	return ">speech_prog";
  case RAND_PROG:	return ">rand_prog";
  case FIGHT_PROG:	return ">fight_prog";
  case HITPRCNT_PROG:	return ">hitprcnt_prog";
  case DEATH_PROG:	return ">death_prog";
  case ENTRY_PROG:	return ">entry_prog";
  case GREET_PROG:	return ">greet_prog";
  case ALL_GREET_PROG:	return ">all_greet_prog";
  case GIVE_PROG:	return ">give_prog";
  case BRIBE_PROG:	return ">bribe_prog";
  }
  return ">ERROR_PROG";
}

/*-------------------------------------------------------------------*/

/*
 * Display the MobProgs.
 */
void medit_disp_mprog(struct descriptor_data *d)
{
  struct mob_prog_data *mprog = OLC_MPROGL(d);

  OLC_MTOTAL(d) = 1;

#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  while (mprog) {
    sprintf(buf, "%d) %s %s\r\n", OLC_MTOTAL(d), medit_get_mprog_type(mprog),
		(mprog->arglist ? mprog->arglist : "NONE"));
    send_to_char(buf, d->character);
    OLC_MTOTAL(d)++;
    mprog = mprog->next;
  }
  sprintf(buf,  "%d) Create New Mob Prog\r\n"
		"%d) Purge Mob Prog\r\n"
		"Enter number to edit [0 to exit]:  ",
		OLC_MTOTAL(d), OLC_MTOTAL(d) + 1);
  send_to_char(buf, d->character);
  OLC_MODE(d) = MEDIT_MPROG;
}

/*-------------------------------------------------------------------*/

/*
 * Change the MobProgs.
 */
void medit_change_mprog(struct descriptor_data *d)
{
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  sprintf(buf,  "1) Type: %s\r\n"
		"2) Args: %s\r\n"
		"3) Commands:\r\n%s\r\n\r\n"
		"Enter number to edit [0 to exit]: ",
	medit_get_mprog_type(OLC_MPROG(d)),
	(OLC_MPROG(d)->arglist ? OLC_MPROG(d)->arglist: "NONE"),
	(OLC_MPROG(d)->comlist ? OLC_MPROG(d)->comlist : "NONE"));

  send_to_char(buf, d->character);
  OLC_MODE(d) = MEDIT_CHANGE_MPROG;
}

/*-------------------------------------------------------------------*/

/*
 * Change the MobProg type.
 */
void medit_disp_mprog_types(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif

  for (i = 0; i < NUM_PROGS-1; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, mobprog_types[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter mob prog type : ", d->character);
  OLC_MODE(d) = MEDIT_MPROG_TYPE;
}
#endif

/*-------------------------------------------------------------------*/
void medit_disp_class(struct descriptor_data *d)
{
  int i;
      
  get_char_cols(d->character);
    
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  for (i = -1; i < NUM_CLASSES; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, class_types[i+1]);
    send_to_char(buf, d->character);
  }      
  send_to_char("Enter new Class : ", d->character);
}

/*------------------------------------------------------------------*/
void medit_disp_race(struct descriptor_data *d)
{      
  int i;
        
  get_char_cols(d->character);
  
#if defined(CLEAR_SCREEN)
  send_to_char("^[[H^[[J", d->character);
#endif
  for (i = -1; i < NUM_RACES; i++) { 
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, race_types[i+1]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter new Race : ", d->character);
}

/*-------------------------------------------------------------------*/

/*
 * Display the gender of the mobile.
 */
void medit_disp_sex(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_GENDERS; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, genders[i]);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter gender number : ", d->character);
}

/*-------------------------------------------------------------------*/

/*
 * Display attack types menu.
 */
void medit_disp_attack_types(struct descriptor_data *d)
{
  int i;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_ATTACK_TYPES; i++) {
    sprintf(buf, "%s%2d%s) %s\r\n", grn, i, nrm, attack_hit_text[i].singular);
    send_to_char(buf, d->character);
  }
  send_to_char("Enter attack type : ", d->character);
}

/*-------------------------------------------------------------------*/

/*
 * Display mob-flags menu.
 */
void medit_disp_mob_flags(struct descriptor_data *d)
{
  int i, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_MOB_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, action_bits[i],
		!(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(MOB_FLAGS(OLC_MOB(d)), action_bits, buf1);
  sprintf(buf, "\r\nCurrent flags : %s%s%s\r\nEnter mob flags (0 to quit) : ",
		  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*-------------------------------------------------------------------*/

/*
 * Display affection flags menu.
 */
void medit_disp_aff_flags(struct descriptor_data *d)
{
  int i, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_AFF_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits[i],
			!(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(AFF_FLAGS(OLC_MOB(d)), affected_bits, buf1);
  sprintf(buf, "\r\nCurrent flags   : %s%s%s\r\nEnter aff flags (0 to quit) : ",
			  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*-------------------------------------------------------------------*/

/*
 * Display main menu.
 */
void medit_disp_menu(struct descriptor_data *d)
{
  struct char_data *mob;

  mob = OLC_MOB(d);
  get_char_cols(d->character);

  sprintf(buf,
#if defined(CLEAR_SCREEN)
"[H[J"
#endif
	  "-- Mob Number:  [%s%d%s]\r\n"
	  "%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
	  "%s3%s) S-Desc: %s%s\r\n"
	  "%s4%s) L-Desc:-\r\n%s%s"
	  "%s5%s) D-Desc:-\r\n%s%s"
     "%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]\r\n"
     "%s8%s) Hitroll:     [%s%4d%s],  %s9%s) Damroll:      [%s%4d%s]\r\n"
     "%sA%s) NumDamDice:  [%s%4d%s],  %sB%s) SizeDamDice:  [%s%4d%s]\r\n"
	  "%sC%s) Num HP Dice: [%s%4d%s],  %sD%s) Size HP Dice: [%s%4d%s],  %sE%s) HP Bonus: [%s%5d%s]\r\n"
	  "%sF%s) Armor Class: [%s%4d%s],  %sG%s) Exp:     [%s%9d%s],  %sH%s) Gold:  [%s%8d%s]\r\n",

	  cyn, OLC_NUM(d), nrm,
	  grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
	  grn, nrm, yel, GET_ALIAS(mob),
	  grn, nrm, yel, GET_SDESC(mob),
	  grn, nrm, yel, GET_LDESC(mob),
	  grn, nrm, yel, GET_DDESC(mob),
	  grn, nrm, cyn, GET_LEVEL(mob), nrm,
	  grn, nrm, cyn, GET_ALIGNMENT(mob), nrm,
	  grn, nrm, cyn, GET_HITROLL(mob), nrm,
	  grn, nrm, cyn, GET_DAMROLL(mob), nrm,
	  grn, nrm, cyn, GET_NDD(mob), nrm,
	  grn, nrm, cyn, GET_SDD(mob), nrm,
	  grn, nrm, cyn, GET_HIT(mob), nrm,
	  grn, nrm, cyn, GET_MANA(mob), nrm,
	  grn, nrm, cyn, GET_MOVE(mob), nrm,
	  grn, nrm, cyn, GET_AC(mob), nrm,
	  grn, nrm, cyn, GET_EXP(mob), nrm,
	  grn, nrm, cyn, GET_GOLD(mob), nrm
	  );
  send_to_char(buf, d->character);

  sprintbit(MOB_FLAGS(mob), action_bits, buf1);
  sprintbit(AFF_FLAGS(mob), affected_bits, buf2);
  sprintf(buf,
	  "%sI%s) Position  : %s%s\r\n"
	  "%sJ%s) Default   : %s%s\r\n"
	  "%sK%s) Attack    : %s%s\r\n"
          "%sL%s) Attack-2  : %s%d\r\n"
          "%sM%s) Attack-3  : %s%d\r\n"
          "%sN%s) Attack-4  : %s%d\r\n"
	  "%sO%s) NPC Flags : %s%s\r\n"
	  "%sP%s) AFF Flags : %s%s\r\n"
#if defined(OASIS_MPROG)
	  "%sR%s) Mob Progs : %s%s\r\n"
#endif
          "%sS%s) Script    : %s%s\r\n"
          "%sT%s) Remort    : %s%2d%s\r\n"          
          "%sU%s) NPC Class : %s%s\r\n"
          "%sV%s) NPC Race  : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  grn, nrm, yel, position_types[(int)GET_POS(mob)],
	  grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
	  grn, nrm, yel, attack_hit_text[GET_ATTACK(mob)].singular,
          grn, nrm, yel, GET_ATTACK1(mob),
          grn, nrm, yel, GET_ATTACK2(mob),
          grn, nrm, yel, GET_ATTACK3(mob),
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2,
#if defined(OASIS_MPROG)
	  grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
#endif
          grn, nrm, cyn, mob->proto_script?"Set.":"Not Set.",
          grn, nrm, cyn, GET_REMORT(mob), nrm,
          grn, nrm, cyn, class_types[(int)(GET_CLASS(mob) + 1)],
          grn, nrm, cyn, race_types[(int)(GET_RACE(mob) + 1)],
	  grn, nrm
	  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = MEDIT_MAIN_MENU;
}

/************************************************************************
 *			The GARGANTAUN event handler			*
 ************************************************************************/

void medit_parse(struct descriptor_data *d, char *arg)
{
  int i;

  if (OLC_MODE(d) > MEDIT_NUMERICAL_RESPONSE) {
    if (!*arg || (!isdigit(arg[0]) && ((*arg == '-') && (!isdigit(arg[1]))))) {
      send_to_char("Field must be numerical, try again : ", d->character);
      return;
    }
  }
  switch (OLC_MODE(d)) {
/*-------------------------------------------------------------------*/
  case MEDIT_CONFIRM_SAVESTRING:
    /*
     * Ensure mob has MOB_ISNPC set or things will go pair shaped.
     */
    SET_BIT(MOB_FLAGS(OLC_MOB(d)), MOB_ISNPC);
    switch (*arg) {
    case 'y':
    case 'Y':
      /*
       * Save the mob in memory and to disk.
       */
      send_to_char("Saving mobile to memory.\r\n", d->character);
      medit_save_internally(d);
      sprintf(buf, "OLC: %s edits mob %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /* FALL THROUGH */
    case 'n':
    case 'N':
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save the mobile? : ", d->character);
      return;
    }
    break;

/*-------------------------------------------------------------------*/
  case MEDIT_MAIN_MENU:
    i = 0;
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {	/* Anything been changed? */
	send_to_char("Do you wish to save the changes to the mobile? (y/n) : ", d->character);
	OLC_MODE(d) = MEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      OLC_MODE(d) = MEDIT_SEX;
      medit_disp_sex(d);
      return;
    case '2':
      OLC_MODE(d) = MEDIT_ALIAS;
      i--;
      break;
    case '3':
      OLC_MODE(d) = MEDIT_S_DESC;
      i--;
      break;
    case '4':
      OLC_MODE(d) = MEDIT_L_DESC;
      i--;
      break;
    case '5':
      OLC_MODE(d) = MEDIT_D_DESC;
      SEND_TO_Q("Enter mob description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_MOB(d)->player.description) {
	SEND_TO_Q(OLC_MOB(d)->player.description, d);
	d->backstr = str_dup(OLC_MOB(d)->player.description);
      }
      d->str = &OLC_MOB(d)->player.description;
      d->max_str = MAX_MOB_DESC;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      return;
    case '6':
      OLC_MODE(d) = MEDIT_LEVEL;
      i++;
      break;
    case '7':
      OLC_MODE(d) = MEDIT_ALIGNMENT;
      i++;
      break;
    case '8':
      OLC_MODE(d) = MEDIT_HITROLL;
      i++;
      break;
    case '9':
      OLC_MODE(d) = MEDIT_DAMROLL;
      i++;
      break;
    case 'a':
    case 'A':
      OLC_MODE(d) = MEDIT_NDD;
      i++;
      break;
    case 'b':
    case 'B':
      OLC_MODE(d) = MEDIT_SDD;
      i++;
      break;
    case 'c':
    case 'C':
      OLC_MODE(d) = MEDIT_NUM_HP_DICE;
      i++;
      break;
    case 'd':
    case 'D':
      OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
      i++;
      break;
    case 'e':
    case 'E':
      OLC_MODE(d) = MEDIT_ADD_HP;
      i++;
      break;
    case 'f':
    case 'F':
      OLC_MODE(d) = MEDIT_AC;
      i++;
      break;
    case 'g':
    case 'G':
      OLC_MODE(d) = MEDIT_EXP;
      i++;
      break;
    case 'h':
    case 'H':
      OLC_MODE(d) = MEDIT_GOLD;
      i++;
      break;
    case 'i':
    case 'I':
      OLC_MODE(d) = MEDIT_POS;
      medit_disp_positions(d);
      return;
    case 'j':
    case 'J':
      OLC_MODE(d) = MEDIT_DEFAULT_POS;
      medit_disp_positions(d);
      return;
    case 'k':
    case 'K':
      OLC_MODE(d) = MEDIT_ATTACK;
      medit_disp_attack_types(d);
      return;
    case 'l':
    case 'L':
      OLC_MODE(d) = MEDIT_ATTACK1;
      i++;
      break;
    case 'm':
    case 'M':
      OLC_MODE(d) = MEDIT_ATTACK2;
      i++;
      break;
    case 'n':
    case 'N':
     OLC_MODE(d) = MEDIT_ATTACK3;
      i++;
      break;
    case 'o':
    case 'O':
      OLC_MODE(d) = MEDIT_NPC_FLAGS;
      medit_disp_mob_flags(d);
      return;
    case 'p':
    case 'P':
      OLC_MODE(d) = MEDIT_AFF_FLAGS;
      medit_disp_aff_flags(d);
      return;
#if defined(OASIS_MPROG)
    case 'r':
    case 'R':
      OLC_MODE(d) = MEDIT_MPROG;
      medit_disp_mprog(d);
      return;
#endif
    case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
    case 't':
    case 'T':      
      OLC_MODE(d) = MEDIT_REMORT;
      i++;
      break;   
    case 'u':
    case 'U':
      OLC_MODE(d) = MEDIT_CLASS;
      medit_disp_class(d);
      return;
    case 'v':
    case 'V':
      OLC_MODE(d) = MEDIT_RACE;
      medit_disp_race(d);
      return;  
    default:
      medit_disp_menu(d);
      return;
    }
    if (i != 0) {
      send_to_char(i == 1 ? "\r\nEnter new value : " :
		   i == -1 ? "\r\nEnter new text :\r\n] " :
			"\r\nOops...:\r\n", d->character);
      return;
    }
    break;

/*-------------------------------------------------------------------*/
  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;
/*-------------------------------------------------------------------*/
  case MEDIT_ALIAS:
    if (GET_ALIAS(OLC_MOB(d)))
      free(GET_ALIAS(OLC_MOB(d)));
    GET_ALIAS(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
    break;
/*-------------------------------------------------------------------*/
  case MEDIT_S_DESC:
    if (GET_SDESC(OLC_MOB(d)))
      free(GET_SDESC(OLC_MOB(d)));
    GET_SDESC(OLC_MOB(d)) = str_dup((arg && *arg) ? arg : "undefined");
    break;
/*-------------------------------------------------------------------*/
  case MEDIT_L_DESC:
    if (GET_LDESC(OLC_MOB(d)))
      free(GET_LDESC(OLC_MOB(d)));
    if (arg && *arg) {
      strcpy(buf, arg);
      strcat(buf, "\r\n");
      GET_LDESC(OLC_MOB(d)) = str_dup(buf);
    } else
      GET_LDESC(OLC_MOB(d)) = str_dup("undefined");

    break;
/*-------------------------------------------------------------------*/
  case MEDIT_D_DESC:
    /*
     * We should never get here.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached D_DESC case!",
			BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
/*-------------------------------------------------------------------*/
#if defined(OASIS_MPROG)
  case MEDIT_MPROG_COMLIST:
    /*
     * We should never get here, but if we do, bail out.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached MPROG_COMLIST case!",
			BRF, LVL_BUILDER, TRUE);
    break;
#endif
/*-------------------------------------------------------------------*/
  case MEDIT_NPC_FLAGS:
    if ((i = atoi(arg)) == 0)
      break;
    else if (!((i < 0) || (i > NUM_MOB_FLAGS)))
      TOGGLE_BIT(MOB_FLAGS(OLC_MOB(d)), 1 << (i - 1));
    medit_disp_mob_flags(d);
    return;
/*-------------------------------------------------------------------*/
  case MEDIT_AFF_FLAGS:
    if ((i = atoi(arg)) == 0)
      break;
    else if (!((i < 0) || (i > NUM_AFF_FLAGS)))
      TOGGLE_BIT(AFF_FLAGS(OLC_MOB(d)), 1 << (i - 1));
    medit_disp_aff_flags(d);
    return;
/*-------------------------------------------------------------------*/
#if defined(OASIS_MPROG)
  case MEDIT_MPROG:
    if ((i = atoi(arg)) == 0)
      medit_disp_menu(d);
    else if (i == OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      CREATE(temp, struct mob_prog_data, 1);
      temp->next = OLC_MPROGL(d);
      temp->type = -1;
      temp->arglist = NULL;
      temp->comlist = NULL;
      OLC_MPROG(d) = temp;
      OLC_MPROGL(d) = temp;
      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
      medit_change_mprog (d);
    } else if (i < OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      int x = 1;
      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
        x++;
      OLC_MPROG(d) = temp;
      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
      medit_change_mprog (d);
    } else if (i == OLC_MTOTAL(d) + 1) {
      send_to_char("Which mob prog do you want to purge? ", d->character);
      OLC_MODE(d) = MEDIT_PURGE_MPROG;
    } else
      medit_disp_menu(d);
    return;

  case MEDIT_PURGE_MPROG:
    if ((i = atoi(arg)) > 0 && i < OLC_MTOTAL(d)) {
      struct mob_prog_data *temp;
      int x = 1;

      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
	x++;
      OLC_MPROG(d) = temp;
      REMOVE_FROM_LIST(OLC_MPROG(d), OLC_MPROGL(d), next);
      free(OLC_MPROG(d)->arglist);
      free(OLC_MPROG(d)->comlist);
      free(OLC_MPROG(d));
      OLC_MPROG(d) = NULL;
      OLC_VAL(d) = 1;
    }
    medit_disp_mprog(d);
    return;

  case MEDIT_CHANGE_MPROG: {
    if ((i = atoi(arg)) == 1)
      medit_disp_mprog_types(d);
    else if (i == 2) {
      send_to_char ("Enter new arg list: ", d->character);
      OLC_MODE(d) = MEDIT_MPROG_ARGS;
    } else if (i == 3) {
      send_to_char("Enter new mob prog commands:\r\n", d->character);
      /*
       * Pass control to modify.c for typing.
       */
      OLC_MODE(d) = MEDIT_MPROG_COMLIST;
      d->backstr = NULL;
      if (OLC_MPROG(d)->comlist) {
        SEND_TO_Q(OLC_MPROG(d)->comlist, d);
        d->backstr = str_dup(OLC_MPROG(d)->comlist);
      }
      d->str = &OLC_MPROG(d)->comlist;
      d->max_str = MAX_STRING_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
    } else
      medit_disp_mprog(d);
    return;
#endif

/*-------------------------------------------------------------------*/

/*
 * Numerical responses.
 */

#if defined(OASIS_MPROG)
/*
  David Klasinc suggests for MEDIT_MPROG_TYPE:
    switch (atoi(arg)) {
      case 0: OLC_MPROG(d)->type = 0; break;
      case 1: OLC_MPROG(d)->type = 1; break;
      case 2: OLC_MPROG(d)->type = 2; break;
      case 3: OLC_MPROG(d)->type = 4; break;
      case 4: OLC_MPROG(d)->type = 8; break;
      case 5: OLC_MPROG(d)->type = 16; break;
      case 6: OLC_MPROG(d)->type = 32; break;
      case 7: OLC_MPROG(d)->type = 64; break;
      case 8: OLC_MPROG(d)->type = 128; break;
      case 9: OLC_MPROG(d)->type = 256; break;
      case 10: OLC_MPROG(d)->type = 512; break;
      case 11: OLC_MPROG(d)->type = 1024; break;
      default: OLC_MPROG(d)->type = -1; break;
    }
*/

  case MEDIT_MPROG_TYPE:
    OLC_MPROG(d)->type = (1 << MAX(0, MIN(atoi(arg), NUM_PROGS - 1)));
    OLC_VAL(d) = 1;
    medit_change_mprog(d);
    return;

  case MEDIT_MPROG_ARGS:
    OLC_MPROG(d)->arglist = str_dup(arg);
    OLC_VAL(d) = 1;
    medit_change_mprog(d);
    return;
#endif

  case MEDIT_SEX:
    GET_SEX(OLC_MOB(d)) = MAX(0, MIN(NUM_GENDERS - 1, atoi(arg)));
    break;

  case MEDIT_HITROLL:
    GET_HITROLL(OLC_MOB(d)) = MAX(0, MIN(5000, atoi(arg)));
    break;

  case MEDIT_DAMROLL:
    GET_DAMROLL(OLC_MOB(d)) = MAX(0, MIN(5000, atoi(arg)));
    break;

  case MEDIT_NDD:
    GET_NDD(OLC_MOB(d)) = MAX(0, MIN(100, atoi(arg)));
    break;

  case MEDIT_SDD:
    GET_SDD(OLC_MOB(d)) = MAX(0, MIN(300, atoi(arg)));
    break;

  case MEDIT_NUM_HP_DICE:
    GET_HIT(OLC_MOB(d)) = MAX(0, MIN(30, atoi(arg)));
    break;

  case MEDIT_SIZE_HP_DICE:
    GET_MANA(OLC_MOB(d)) = MAX(0, MIN(1000, atoi(arg)));
    break;

  case MEDIT_ADD_HP:
    GET_MOVE(OLC_MOB(d)) = MAX(0, MIN(500000, atoi(arg)));
    break;

  case MEDIT_AC:
    GET_AC(OLC_MOB(d)) = MAX(-1500, MIN(100, atoi(arg)));
    break;

  case MEDIT_EXP:
    GET_EXP(OLC_MOB(d)) = MAX(0, atoi(arg));
    break;

  case MEDIT_GOLD:
    GET_GOLD(OLC_MOB(d)) = MAX(0, atoi(arg));
    break;

  case MEDIT_POS:
    GET_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS - 1, atoi(arg)));
    break;

  case MEDIT_DEFAULT_POS:
    GET_DEFAULT_POS(OLC_MOB(d)) = MAX(0, MIN(NUM_POSITIONS - 1, atoi(arg)));
    break;

  case MEDIT_ATTACK:
    GET_ATTACK(OLC_MOB(d)) = MAX(0, MIN(NUM_ATTACK_TYPES - 1, atoi(arg)));
    break;

  case MEDIT_LEVEL:
    GET_LEVEL(OLC_MOB(d)) = MAX(1, MIN(200, atoi(arg)));
    break;
    
  case MEDIT_REMORT:
    GET_REMORT(OLC_MOB(d)) = MAX(0, MIN(12, atoi(arg)));
    break;   
  
  case MEDIT_CLASS:
    GET_CLASS(OLC_MOB(d)) = MAX(-1, MIN(NUM_CLASSES - 1, atoi(arg)));
    break;   
    
  case MEDIT_RACE:
    GET_RACE(OLC_MOB(d)) = MAX(-1, MIN(NUM_RACES - 1, atoi(arg)));
    break;  

  case MEDIT_ALIGNMENT:
    GET_ALIGNMENT(OLC_MOB(d)) = MAX(-1000, MIN(1000, atoi(arg)));
    break;

  case MEDIT_ATTACK1:
    GET_ATTACK1(OLC_MOB(d)) = MAX(0, MIN(100, atoi(arg)));
    break;

  case MEDIT_ATTACK2:
    GET_ATTACK2(OLC_MOB(d)) = MAX(0, MIN(100, atoi(arg)));
    break;

  case MEDIT_ATTACK3:
    GET_ATTACK3(OLC_MOB(d)) = MAX(0, MIN(100, atoi(arg)));
    break;
/*-------------------------------------------------------------------*/
  default:
    /*
     * We should never get here.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: medit_parse(): Reached default case!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }
/*-------------------------------------------------------------------*/

/*
 * END OF CASE 
 * If we get here, we have probably changed something, and now want to
 * return to main menu.  Use OLC_VAL as a 'has changed' flag  
 */

  OLC_VAL(d) = 1;
  medit_disp_menu(d);
}
::::::::::::::
mob_int.c
::::::::::::::
/* ************************************************************************
*   File: mob_int.c                                     Part of CircleMUD *
*  Usage: Combat system                                                   *
*									  *
*  Acoes de mobs para serem altamente eficazes				  *
*									  *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "handler.h"
#include "interpreter.h"
#include "spells.h"

extern struct room_data *world;
struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];

ACMD(do_bash);    
ACMD(do_kick);  
ACMD(do_stroke);  
ACMD(do_combo);   
ACMD(do_sabre);  
ACMD(do_circle);  
ACMD(do_disarm); 
ACMD(do_berzerk); 
ACMD(do_headbash);

struct mob_fight {
   int skill;
   void (*fazer_skill)
           (struct char_data *ch, char * argument, int cmd, int subcmd);
};

const struct mob_fight ataque[] = {
   { SPELL_BLINDNESS		,	0},
   { SPELL_BURNING_HANDS	,	0},
   { SPELL_CALL_LIGHTNING	,	0},
   { SPELL_CHILL_TOUCH   	,	0},
   { SPELL_COLOR_SPRAY   	,	0},
   { SPELL_CURSE         	,	0},
   { SPELL_ENERGY_DRAIN  	,	0},
   { SPELL_FIREBALL      	,	0},
   { SPELL_HARM          	,	0},
   { SPELL_LIGHTNING_BOLT	,	0},
   { SPELL_MAGIC_MISSILE 	,	0},
   { SPELL_POISON        	,	0},
   { SPELL_SHOCKING_GRASP	,	0},
   { SPELL_DISPEL_GOOD   	,	0},
   { SPELL_DAMNED_CURSE  	,	0},
   { SPELL_ENTANGLE      	,	0},
   { SKILL_BASH           	,	do_bash},
   { SKILL_KICK              	,	do_kick},
   { SKILL_STROKE            	,	do_stroke},
   { SKILL_COMBO             	,	do_combo},
   { SKILL_SABRE             	,	do_sabre},
   { SKILL_DISARM            	,	do_disarm},
   { SKILL_BERZERK           	,	do_berzerk},
   { SKILL_HEADBASH          	,	do_headbash},

};

#define MAX_MOB_AB			24

int ver_melhor(struct char_data *ch, int ataque)
{
  bool x = FALSE;
  int class;
  int levelch;
  int minlevel;
  
  class = GET_CLASS(ch);
  levelch = GET_LEVEL(ch);
  minlevel = spell_info[ataque].min_level[class];
  if (minlevel < 202)
      if (minlevel < levelch)
	         x = TRUE;

  return (x);
}

void mob_ia(struct char_data *ch)
{               
  int i;
  sh_int z;
  sh_int possiveis[MAX_MOB_AB];
  int num_ab;
 
  update_pos(ch);
   
  if(!IS_NPC(ch))
    return;

  if(GET_POS(ch) < POS_FIGHTING || GET_CLASS(ch) < 0)
    return;

  /* evitar loops infinitos */
 /* for (i = 1; i < MAX_SKILLS+1; i++)
    for(z = 0; z <= MAX_MOB_AB; z++) {
      if (i == ataque[z].skill)
	 b = TRUE;
    }*/
  
  num_ab = 0;
  for(z = 0; z <= MAX_MOB_AB - 1; z++) 
      if ( ver_melhor(ch, ataque[z].skill)){
	 possiveis[num_ab] = z;
	 num_ab++;
      }
 
  if(num_ab == 0)
    return;
  
 /* do {
  	x = number(0, MAX_MOB_AB);
  } while (!ver_melhor(ch, ataque[x].skill));*/
  
  i = number(0, num_ab - 1);
    
  if(ataque[possiveis[i]].skill > MAX_SPELLS)
    ((*ataque[possiveis[i]].fazer_skill) (ch, GET_NAME(FIGHTING(ch)), 0, 0));
  else
    call_magic(ch, FIGHTING(ch), 0, ataque[possiveis[i]].skill, GET_LEVEL(ch), CAST_SPELL);
}

/*
 mudar calculo
*/
int alvo_better(struct char_data *ch)
{
 int x;
 x =  GET_DAMROLL(ch);
 if(GET_EQ(ch, WEAR_WIELD)) 
    x += dice(GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 1), GET_OBJ_VAL(GET_EQ(ch, WEAR_WIELD), 2));

 return (MAX(x,1));
}

int contar_briga(struct char_data *ch)
{
  struct char_data *tch;
  int x = 0;

   for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
	if(FIGHTING(tch) == ch)
		x++;

   return (x);
}

struct char_data *melhor_alvo(struct char_data *ch)
{
   struct char_data *tch;
   struct char_data *vict = NULL;
   int menor = 0 ;
   int maior;
   int cont = 1 ;
      

   for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room)
  {
        if(FIGHTING(tch) == ch) 
       {
          if(!IS_NPC(tch)) cont = 2 ; 
          maior = alvo_better(tch) * cont;
          if(maior > menor) 
          {
            menor = maior;
            vict = tch;
          }
         cont = 1 ;
       }
   }
   return (vict);
}

::::::::::::::
mobact.c
::::::::::::::
/* ************************************************************************
*   File: mobact.c                                      Part of CircleMUD *
*  Usage: Functions for generating intelligent (?) behavior in mobiles    *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "spells.h"
#include "buffer.h"

/* external structs */
extern struct char_data *character_list;
extern struct index_data *mob_index;
extern struct room_data *world;
extern struct str_app_type str_app[];
extern int no_specials;


ACMD(do_get);

/* local functions */
void mobile_activity(void);
void clearMemory(struct char_data * ch);

#define MOB_AGGR_TO_ALIGN (MOB_AGGR_EVIL | MOB_AGGR_NEUTRAL | MOB_AGGR_GOOD)

#define IS_SELUNE(ch) AFF2_FLAGGED(ch, AFF2_SELUNE) 

void mobile_activity(void)
{
  struct char_data *ch, *next_ch, *vict;
  struct obj_data *obj, *best_obj;
  int door, found, max;
  memory_rec *names;

  for (ch = character_list; ch; ch = next_ch) {
    next_ch = ch->next;

    if(!ch) return;
    if (!IS_MOB(ch))
      continue;

    /* Examine call for special procedure */
    if (MOB_FLAGGED(ch, MOB_SPEC) && !no_specials) {
      if (mob_index[GET_MOB_RNUM(ch)].func == NULL) {
        log("SYSERR: %s (#%d): Attempting to call non-existing mob function.",
                GET_NAME(ch), GET_MOB_VNUM(ch));
        REMOVE_BIT(MOB_FLAGS(ch), MOB_SPEC);
      } else {
        /* XXX: Need to see if they can handle NULL instead of "". */
        if ((mob_index[GET_MOB_RNUM(ch)].func) (ch, ch, 0, ""))
          continue;             /* go to next char */
      }
    }

    /* If the mob has no specproc, do the default actions */
    if (FIGHTING(ch) || !AWAKE(ch))
      continue;

    /* Scavenger (picking up objects) */
    if (MOB_FLAGGED(ch, MOB_SCAVENGER) && !FIGHTING(ch) && AWAKE(ch))
      if (world[ch->in_room].contents && !number(0, 10)) {
        max = 1;
        best_obj = NULL;
        for (obj = world[ch->in_room].contents; obj; obj = obj->next_content)
          if (CAN_GET_OBJ(ch, obj) && GET_OBJ_COST(obj) > max) {
            best_obj = obj;
            max = GET_OBJ_COST(obj);
          }
        if (best_obj != NULL) {
/*          obj_from_room(best_obj);
          obj_to_char(best_obj, ch);
          act("$n gets $p.", FALSE, ch, best_obj, 0, TO_ROOM); */
          do_get(ch, best_obj->name, 0, 0);
        }
      }

    /* Mob Movement */
    if (!MOB_FLAGGED(ch, MOB_SENTINEL) && (GET_POS(ch) == POS_STANDING) &&
        ((door = number(0, 18)) < NUM_OF_DIRS) && CAN_GO(ch, door) &&
        !ROOM_FLAGGED(EXIT(ch, door)->to_room, ROOM_NOMOB | ROOM_DEATH) &&
        (!MOB_FLAGGED(ch, MOB_STAY_ZONE) ||
         (world[EXIT(ch, door)->to_room].zone == world[ch->in_room].zone))) {
      perform_move(ch, door, 1);
    }

    /* Aggressive Mobs */
    if (MOB_FLAGGED(ch, MOB_AGGRESSIVE | MOB_AGGR_TO_ALIGN)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room) {
        if (IS_NPC(vict) || !CAN_SEE(ch, vict) || PRF_FLAGGED(vict, PRF_NOHASSLE))
          continue;
        if(GET_RACE(vict) == RACE_DUNEDAIN || (GET_RACE(vict) == RACE_DRACONIAN && 
number(1,12) == 3))  continue ; 
        if(IS_SELUNE(vict))
         continue ;
        if (MOB_FLAGGED(ch, MOB_WIMPY) && AWAKE(vict))
          continue;
        if (!MOB_FLAGGED(ch, MOB_AGGR_TO_ALIGN) ||
            (MOB_FLAGGED(ch, MOB_AGGR_EVIL) && IS_EVIL(vict)) ||
            (MOB_FLAGGED(ch, MOB_AGGR_NEUTRAL) && IS_NEUTRAL(vict)) ||
            (MOB_FLAGGED(ch, MOB_AGGR_GOOD) && IS_GOOD(vict))) {
          hit(ch, vict, TYPE_UNDEFINED);
          found = TRUE;
        }
      }
    }

    /* Mob Memory */
    if (MOB_FLAGGED(ch, MOB_MEMORY) && MEMORY(ch)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room) {
        if (IS_NPC(vict) || !CAN_SEE(ch, vict) || PRF_FLAGGED(vict, PRF_NOHASSLE))
          continue;
        for (names = MEMORY(ch); names && !found; names = names->next)
          if (names->id == GET_IDNUM(vict)) {
            found = TRUE;
            act("'Hey!  You're the fiend that attacked me!!!', exclaims $n.",
                FALSE, ch, 0, 0, TO_ROOM);
            hit(ch, vict, TYPE_UNDEFINED);
          }
      }
    }

    /* Helper Mobs */
    if (MOB_FLAGGED(ch, MOB_HELPER)) {
      found = FALSE;
      for (vict = world[ch->in_room].people; vict && !found; vict = vict->next_in_room)
        if (ch != vict && IS_NPC(vict) && FIGHTING(vict) &&
            !IS_NPC(FIGHTING(vict)) && ch != FIGHTING(vict)) {
          act("$n jumps to the aid of $N!", FALSE, ch, 0, vict, TO_ROOM);
          hit(ch, FIGHTING(vict), TYPE_UNDEFINED);
          found = TRUE;
        }
    }
    /* Add new mobile actions here */

  }                             /* end for() */
}



/* Mob Memory Routines */

/* make ch remember victim */
void remember(struct char_data * ch, struct char_data * victim)
{
  memory_rec *tmp;
  bool present = FALSE;

  if (!IS_NPC(ch) || IS_NPC(victim) || PRF_FLAGGED(victim, PRF_NOHASSLE))
    return;

  for (tmp = MEMORY(ch); tmp && !present; tmp = tmp->next)
    if (tmp->id == GET_IDNUM(victim))
      present = TRUE;

  if (!present) {
    CREATE(tmp, memory_rec, 1);
    tmp->next = MEMORY(ch);
    tmp->id = GET_IDNUM(victim);
    MEMORY(ch) = tmp;
  }
}


/* make ch forget victim */
void forget(struct char_data * ch, struct char_data * victim)
{
  memory_rec *curr, *prev = NULL;

  if (!(curr = MEMORY(ch)))
    return;

  while (curr && curr->id != GET_IDNUM(victim)) {
    prev = curr;
    curr = curr->next;
  }

  if (!curr)
    return;                     /* person wasn't there at all. */

  if (curr == MEMORY(ch))
    MEMORY(ch) = curr->next;
  else
    prev->next = curr->next;

  free(curr);
}


/* erase ch's memory */
void clearMemory(struct char_data * ch)
{
  memory_rec *curr, *next;

  curr = MEMORY(ch);

  while (curr) {
    next = curr->next;
    free(curr);
    curr = next;
  }

  MEMORY(ch) = NULL;
}
::::::::::::::
modify.c
::::::::::::::
/**************************************************************************
*   File: modify.c                                      Part of CircleMUD *
*  Usage: Run-time modification of game variables                         *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
**************************************************************************/

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "comm.h"
#include "spells.h"
#include "mail.h"
#include "boards.h"
#include "olc.h"

void show_string(struct descriptor_data *d, char *input);

extern char *spells[];
extern char *MENU;
char *stripcr(char *dest, const char *src);
void qedit_disp_menu(struct descriptor_data *d);

/* local functions */
void string_add(struct descriptor_data *d, char *str);
ACMD(do_skillset);
char *next_page(char *str);
int count_pages(char *str);
void paginate_string(char *str, struct descriptor_data *d);

/*
 * Action modes for parse_action().
 */
#define PARSE_FORMAT            0
#define PARSE_REPLACE           1
#define PARSE_HELP              2
#define PARSE_DELETE            3
#define PARSE_INSERT            4
#define PARSE_LIST_NORM         5
#define PARSE_LIST_NUM          6
#define PARSE_EDIT              7

const char *string_fields[] =
{
  "name",
  "short",
  "long",
  "description",
  "title",
  "delete-description",
  "\n"
};

/*
 * Maximum length for text field x+1
 */
int length[] =
{
  15,
  60,
  256,
  240,
  60
};


/*************************************
 * Modification of malloc'ed strings.*
 *************************************/

/*
 * Handle some editor commands.
 */
void parse_action(int command, char *string, struct descriptor_data *d)
{
  int indent = 0, rep_all = 0, flags = 0, total_len, replaced;
  int j = 0;
  int i, line_low, line_high;
  char *s, *t, temp;

  switch (command) {
  case PARSE_HELP:
    sprintf(buf,
          "Editor command formats: /<letter>\r\n\r\n"
          "/a         -  aborts editor\r\n"
          "/c         -  clears buffer\r\n"
          "/d#        -  deletes a line #\r\n"
          "/e# <text> -  changes the line at # with <text>\r\n"
          "/f         -  formats text\r\n"
          "/fi        -  indented formatting of text\r\n"
          "/h         -  list text editor commands\r\n"
          "/i# <text> -  inserts <text> before line #\r\n"
          "/l         -  lists buffer\r\n"
          "/n         -  lists buffer with line numbers\r\n"
          "/r 'a' 'b' -  replace 1st occurance of text <a> in buffer with text <b>\r\n"
          "/ra 'a' 'b'-  replace all occurances of text <a> within buffer with text <b>\r\n"
          "              usage: /r[a] 'pattern' 'replacement'\r\n"
          "/s         -  saves text\r\n");
    SEND_TO_Q(buf, d);
    break;
  case PARSE_FORMAT:
    while (isalpha(string[j]) && j < 2) {
      switch (string[j]) {
      case 'i':
      if (!indent) {
        indent = TRUE;
        flags += FORMAT_INDENT;
      }
      break;
      default:
      break;
      }
      j++;
    }
    format_text(d->str, flags, d, d->max_str);
    sprintf(buf, "Text formatted with%s indent.\r\n", (indent ? "" : "out"));
    SEND_TO_Q(buf, d);
    break;
  case PARSE_REPLACE:
    while (isalpha(string[j]) && j < 2) {
      switch (string[j]) {
      case 'a':
      if (!indent)
        rep_all = 1;
      break;
      default:
      break;
      }
      j++;
    }
    if ((s = strtok(string, "'")) == NULL) {
      SEND_TO_Q("Invalid format.\r\n", d);
      return;
    } else if ((s = strtok(NULL, "'")) == NULL) {
      SEND_TO_Q("Target string must be enclosed in single quotes.\r\n", d);
      return;
    } else if ((t = strtok(NULL, "'")) == NULL) {
      SEND_TO_Q("No replacement string.\r\n", d);
      return;
    } else if ((t = strtok(NULL, "'")) == NULL) {
      SEND_TO_Q("Replacement string must be enclosed in single quotes.\r\n", d);
      return;
    } else if ((total_len = ((strlen(t) - strlen(s)) + strlen(*d->str))) <= d->max_str) {
      if ((replaced = replace_str(d->str, s, t, rep_all, d->max_str)) > 0) {
      sprintf(buf, "Replaced %d occurance%sof '%s' with '%s'.\r\n", replaced,
                ((replaced != 1) ? "s " : " "), s, t);
      SEND_TO_Q(buf, d);
      } else if (replaced == 0) {
      sprintf(buf, "String '%s' not found.\r\n", s);
      SEND_TO_Q(buf, d);
      } else
      SEND_TO_Q("ERROR: Replacement string causes buffer overflow, aborted replace.\r\n", d);
    } else
      SEND_TO_Q("Not enough space left in buffer.\r\n", d);
    break;
  case PARSE_DELETE:
    switch (sscanf(string, " %d - %d ", &line_low, &line_high)) {
    case 0:
      SEND_TO_Q("You must specify a line number or range to delete.\r\n", d);
      return;
    case 1:
      line_high = line_low;
      break;
    case 2:
      if (line_high < line_low) {
      SEND_TO_Q("That range is invalid.\r\n", d);
      return;
      }
      break;
    }

    i = 1;
    total_len = 1;
    if ((s = *d->str) == NULL) {
      SEND_TO_Q("Buffer is empty.\r\n", d);
      return;
    } else if (line_low > 0) {
      while (s && (i < line_low))
      if ((s = strchr(s, '\n')) != NULL) {
        i++;
        s++;
      }
      if ((i < line_low) || (s == NULL)) {
      SEND_TO_Q("Line(s) out of range; not deleting.\r\n", d);
      return;
      }
      t = s;
      while (s && (i < line_high))
      if ((s = strchr(s, '\n')) != NULL) {
        i++;
        total_len++;
        s++;
      }
      if ((s) && ((s = strchr(s, '\n')) != NULL)) {
      s++;
      while (*s != '\0')
        *(t++) = *(s++);
      } else
      total_len--;
      *t = '\0';
      RECREATE(*d->str, char, strlen(*d->str) + 3);
      sprintf(buf, "%d line%sdeleted.\r\n", total_len,
            ((total_len != 1) ? "s " : " "));
      SEND_TO_Q(buf, d);
    } else {
      SEND_TO_Q("Invalid line numbers to delete must be higher than 0.\r\n", d);
      return;
    }
    break;
  case PARSE_LIST_NORM:
    /*
     * Note: Rv's buf, buf1, buf2, and arg variables are defined to 32k so
     * they are probly ok for what to do here.
     */
    *buf = '\0';
    if (*string != '\0')
      switch (sscanf(string, " %d - %d ", &line_low, &line_high)) {
      case 0:
      line_low = 1;
      line_high = 999999;
      break;
      case 1:
      line_high = line_low;
      break;
    } else {
      line_low = 1;
      line_high = 999999;
    }

    if (line_low < 1) {
      SEND_TO_Q("Line numbers must be greater than 0.\r\n", d);
      return;
    } else if (line_high < line_low) {
      SEND_TO_Q("That range is invalid.\r\n", d);
      return;
    }
    *buf = '\0';
    if ((line_high < 999999) || (line_low > 1))
      sprintf(buf, "Current buffer range [%d - %d]:\r\n", line_low, line_high);
    i = 1;
    total_len = 0;
    s = *d->str;
    while (s && (i < line_low))
      if ((s = strchr(s, '\n')) != NULL) {
      i++;
      s++;
      }
    if ((i < line_low) || (s == NULL)) {
      SEND_TO_Q("Line(s) out of range; no buffer listing.\r\n", d);
      return;
    }
    t = s;
    while (s && (i <= line_high))
      if ((s = strchr(s, '\n')) != NULL) {
      i++;
      total_len++;
      s++;
      }
    if (s) {
      temp = *s;
      *s = '\0';
      strcat(buf, t);
      *s = temp;
    } else
      strcat(buf, t);
    /*
     * This is kind of annoying...but some people like it.
     */
#if 0
    sprintf(buf, "%s\r\n%d line%sshown.\r\n", buf, total_len,
      ((total_len != 1)?"s ":" "));
#endif
    SEND_TO_Q(buf, d);
//    page_string(d, buf, TRUE);
    break;
  case PARSE_LIST_NUM:
    /*
     * Note: Rv's buf, buf1, buf2, and arg variables are defined to 32k so
     * they are probly ok for what to do here.
     */
    *buf = '\0';
    if (*string != '\0')
      switch (sscanf(string, " %d - %d ", &line_low, &line_high)) {
      case 0:
      line_low = 1;
      line_high = 999999;
      break;
      case 1:
      line_high = line_low;
      break;
    } else {
      line_low = 1;
      line_high = 999999;
    }

    if (line_low < 1) {
      SEND_TO_Q("Line numbers must be greater than 0.\r\n", d);
      return;
    }
    if (line_high < line_low) {
      SEND_TO_Q("That range is invalid.\r\n", d);
      return;
    }
    *buf = '\0';
    i = 1;
    total_len = 0;
    s = *d->str;
    while (s && (i < line_low))
      if ((s = strchr(s, '\n')) != NULL) {
      i++;
      s++;
      }
    if ((i < line_low) || (s == NULL)) {
      SEND_TO_Q("Line(s) out of range; no buffer listing.\r\n", d);
      return;
    }
    t = s;
    while (s && (i <= line_high))
      if ((s = strchr(s, '\n')) != NULL) {
      i++;
      total_len++;
      s++;
      temp = *s;
      *s = '\0';
      sprintf(buf, "%s%4d:\r\n", buf, (i - 1));
      strcat(buf, t);
      *s = temp;
      t = s;
      }
    if (s && t) {
      temp = *s;
      *s = '\0';
      strcat(buf, t);
      *s = temp;
    } else if (t)
      strcat(buf, t);
    /*
     * This is kind of annoying .. seeing as the lines are numbered.
     */
#if 0
     sprintf(buf, "%s\r\n%d numbered line%slisted.\r\n", buf, total_len,
      ((total_len != 1)?"s ":" "));
#endif
    SEND_TO_Q(buf, d);
//    page_string(d, buf, TRUE);
    break;

  case PARSE_INSERT:
    half_chop(string, buf, buf2);
    if (*buf == '\0') {
      SEND_TO_Q("You must specify a line number before which to insert text.\r\n", d);
      return;
    }
    line_low = atoi(buf);
    strcat(buf2, "\r\n");

    i = 1;
    *buf = '\0';
    if ((s = *d->str) == NULL) {
      SEND_TO_Q("Buffer is empty, nowhere to insert.\r\n", d);
      return;
    }
    if (line_low > 0) {
      while (s && (i < line_low))
      if ((s = strchr(s, '\n')) != NULL) {
        i++;
        s++;
      }
      if ((i < line_low) || (s == NULL)) {
        SEND_TO_Q("Line number out of range; insert aborted.\r\n", d);
        return;
      }
      temp = *s;
      *s = '\0';
      if ((strlen(*d->str) + strlen(buf2) + strlen(s + 1) + 3) > d->max_str) {
        *s = temp;
        SEND_TO_Q("Insert text pushes buffer over maximum size, insert aborted.\r\n", d);
        return;
      }
      if (*d->str && (**d->str != '\0'))
      strcat(buf, *d->str);
      *s = temp;
      strcat(buf, buf2);
      if (s && (*s != '\0'))
      strcat(buf, s);
      RECREATE(*d->str, char, strlen(buf) + 3);
      strcpy(*d->str, buf);
      SEND_TO_Q("Line inserted.\r\n", d);
    } else {
      SEND_TO_Q("Line number must be higher than 0.\r\n", d);
      return;
    }
    break;

  case PARSE_EDIT:
    half_chop(string, buf, buf2);
    if (*buf == '\0') {
      SEND_TO_Q("You must specify a line number at which to change text.\r\n", d);
      return;
    }
    line_low = atoi(buf);
    strcat(buf2, "\r\n");

    i = 1;
    *buf = '\0';
    if ((s = *d->str) == NULL) {
      SEND_TO_Q("Buffer is empty, nothing to change.\r\n", d);
      return;
    }
    if (line_low > 0) {
      /*
       * Loop through the text counting \\n characters until we get to the line/
       */
      while (s && (i < line_low))
      if ((s = strchr(s, '\n')) != NULL) {
        i++;
        s++;
      }
      /*
       * Make sure that there was a THAT line in the text.
       */
      if ((i < line_low) || (s == NULL)) {
      SEND_TO_Q("Line number out of range; change aborted.\r\n", d);
      return;
      }
      /*
       * If s is the same as *d->str that means I'm at the beginning of the
       * message text and I don't need to put that into the changed buffer.
       */
      if (s != *d->str) {
      /*
       * First things first .. we get this part into the buffer.
       */
      temp = *s;
      *s = '\0';
      /*
       * Put the first 'good' half of the text into storage.
       */
      strcat(buf, *d->str);
      *s = temp;
      }
      /*
       * Put the new 'good' line into place.
       */
      strcat(buf, buf2);
      if ((s = strchr(s, '\n')) != NULL) {
      /*
       * This means that we are at the END of the line, we want out of
       * there, but we want s to point to the beginning of the line
       * AFTER the line we want edited
       */
      s++;
      /*
       * Now put the last 'good' half of buffer into storage.
       */
      strcat(buf, s);
      }
      /*
       * Check for buffer overflow.
       */
      if (strlen(buf) > d->max_str) {
      SEND_TO_Q("Change causes new length to exceed buffer maximum size, aborted.\r\n", d);
      return;
      }
      /*
       * Change the size of the REAL buffer to fit the new text.
       */
      RECREATE(*d->str, char, strlen(buf) + 3);
      strcpy(*d->str, buf);
      SEND_TO_Q("Line changed.\r\n", d);
    } else {
      SEND_TO_Q("Line number must be higher than 0.\r\n", d);
      return;
    }
    break;
  default:
    SEND_TO_Q("Invalid option.\r\n", d);
    mudlog("SYSERR: invalid command passed to parse_action", BRF, LVL_IMPL, TRUE);
    return;
  }
}

/*
 * Add user input to the 'current' string (as defined by d->str).
 */
  void string_add(struct descriptor_data *d, char *str)
  {
  FILE *fl;
  int terminator = 0, action = 0;
  int i = 2, j = 0;
  char actions[MAX_INPUT_LENGTH];
  extern char *MENU;
  extern struct message_data mess_info;
  extern void write_message_to_file(void);
  /*
   * Determine if this is the terminal string, and truncate if so.
   * Changed to only accept '@' at the beginning of line - J. Elson 1/17/94
   * Changed to accept '/<letter>' style editing commands - instead
   *   of solitary '@' to end. - M. Scott 10/15/96
   */

    delete_doubledollar(str);

#if 0
  /*
   * Removed old handling of '@' character, put #if 1 to re-enable it.
   */
    if ((terminator = (*str == '@')))
      *str = '\0';
#endif

  if ((action = (*str == '/'))) {
    while (str[i] != '\0') {
      actions[j] = str[i];
      i++;
      j++;
    }
    actions[j] = '\0';
    *str = '\0';
    switch (str[1]) {
    case 'a':
      terminator = 2;         /* Working on an abort message, */
      break;
    case 'c':
      if (*(d->str)) {
//      really_free(*d->str);
      free(*d->str);
      *(d->str) = NULL;
      SEND_TO_Q("Current buffer cleared.\r\n", d);
      } else
      SEND_TO_Q("Current buffer empty.\r\n", d);
      break;
    case 'd':
      parse_action(PARSE_DELETE, actions, d);
      break;
    case 'e':
      parse_action(PARSE_EDIT, actions, d);
      break;
    case 'f':
      if (*(d->str))
      parse_action(PARSE_FORMAT, actions, d);
      else
      SEND_TO_Q("Current buffer empty.\r\n", d);
      break;
    case 'i':
      if (*(d->str))
      parse_action(PARSE_INSERT, actions, d);
      else
      SEND_TO_Q("Current buffer empty.\r\n", d);
      break;
    case 'h':
      parse_action(PARSE_HELP, actions, d);
      break;
    case 'l':
      if (*d->str)
      parse_action(PARSE_LIST_NORM, actions, d);
      else
      SEND_TO_Q("Current buffer empty.\r\n", d);
      break;
    case 'n':
      if (*d->str)
      parse_action(PARSE_LIST_NUM, actions, d);
      else
      SEND_TO_Q("Current buffer empty.\r\n", d);
      break;
    case 'r':
      parse_action(PARSE_REPLACE, actions, d);
      break;
    case 's':
      terminator = 1;
      *str = '\0';
      break;
    default:
      SEND_TO_Q("Invalid option.\r\n", d);
      break;
    }
  }

    if (!(*d->str)) {
      if (strlen(str) > d->max_str) {
        send_to_char("String too long - Truncated.\r\n",
                   d->character);
        *(str + d->max_str) = '\0';
      /*
       * Changed this to NOT abort out.. just give warning.
       * terminator = 1;
       */
      }
      CREATE(*d->str, char, strlen(str) + 3);
      strcpy(*d->str, str);
    } else {
      if (strlen(str) + strlen(*d->str) > d->max_str) {
	      send_to_char("String too long, limit reached on message. Last line ignored.\r\n",
	                 d->character);
	      terminator = 1;

      } else {
/*      if (!(*d->str = (char *) realloc(*d->str, strlen(*d->str) +
                                       strlen(str) + 3))) {
       	perror("SYSERR: string_add");
        exit(1);*/
        RECREATE(*d->str, char, strlen(*d->str)+strlen(str)+3);
//      }
      strcat(*d->str, str);
      }
    }
    if (terminator) {
    /*
     * OLC Edits
     */
    extern void oedit_disp_menu(struct descriptor_data *d);
    extern void oedit_disp_extradesc_menu(struct descriptor_data *d);
    extern void redit_disp_menu(struct descriptor_data *d);
    extern void redit_disp_extradesc_menu(struct descriptor_data *d);
    extern void redit_disp_exit_menu(struct descriptor_data *d);
    extern void medit_disp_menu(struct descriptor_data *d);
    extern void hedit_disp_menu(struct descriptor_data *d);
    extern void trigedit_disp_menu(struct descriptor_data *d);

#if defined(OASIS_MPROG)
    extern void medit_change_mprog(struct descriptor_data *d);

    if (STATE(d) == CON_MEDIT) {
      switch (OLC_MODE(d)) {
      case MEDIT_D_DESC:
      medit_disp_menu(d);
      break;
      case MEDIT_MPROG_COMLIST:
      medit_change_mprog(d);
      break;
      }
    }
#endif

    /*
     * Here we check for the abort option and reset the pointers.
     */
    if ((terminator == 2) &&
      ((STATE(d) == CON_REDIT) ||
       (STATE(d) == CON_HEDIT) ||
       (STATE(d) == CON_MEDIT) ||
       (STATE(d) == CON_OEDIT) ||
       (STATE(d) == CON_TRIGEDIT) ||
       (STATE(d) == CON_EXDESC)||
       (STATE(d) == CON_TEXTED) ||
       (STATE(d) == CON_QEDIT))) {

        free(*d->str);
      if (d->backstr) {
      *d->str = d->backstr;
      } else
      *d->str = NULL;
      d->backstr = NULL;
      d->str = NULL;
      }
    /*
     * This fix causes the editor to NULL out empty messages -- M. Scott
     * Fixed to fix the fix for empty fixed messages. -- gg
     */
    else if ((d->str) && (*d->str) && (**d->str == '\0')) {
      free(*d->str);
      *d->str = NULL;
    }
    if (STATE(d) == CON_MEDIT)
      medit_disp_menu(d);
    if (STATE(d) == CON_TRIGEDIT)
      trigedit_disp_menu(d);

    if (STATE(d) == CON_OEDIT) {
      switch (OLC_MODE(d)) {
      case OEDIT_ACTDESC:
      oedit_disp_menu(d);
      break;
      case OEDIT_EXTRADESC_DESCRIPTION:
      oedit_disp_extradesc_menu(d);
      break;
      }
    } else if (STATE(d) == CON_HEDIT) {
      hedit_disp_menu(d);
    } else if (STATE(d) == CON_REDIT) {
      switch (OLC_MODE(d)) {
      case REDIT_DESC:
      redit_disp_menu(d);
      break;
      case REDIT_EXIT_DESCRIPTION:
      redit_disp_exit_menu(d);
      break;
      case REDIT_EXTRADESC_DESCRIPTION:
      redit_disp_extradesc_menu(d);
      break;
      }
    } else if (STATE(d) == CON_QEDIT) {
      switch (OLC_MODE(d)) {
      case QEDIT_INFO:
      qedit_disp_menu(d);
      break;
      case QEDIT_ENDING:
      qedit_disp_menu(d);
      break;
      }
    } else if (!d->connected && (PLR_FLAGGED(d->character, PLR_MAILING))) {
      if ((terminator == 1) && *d->str) {
      store_mail(d->mail_to, GET_IDNUM(d->character), *d->str);
      SEND_TO_Q("Message sent!\r\n", d);
      } else
      SEND_TO_Q("Mail aborted.\r\n", d);
      d->mail_to = 0;
      free(*d->str);
      free(d->str);
     } else if (!d->connected && (PLR_FLAGGED(d->character, PLR_MESSAGING))) {
      if ((terminator == 1) && *d->str) {
      strcpy(mess_info.writer, GET_NAME(d->character));
      strcpy(mess_info.message, *d->str);
      mess_info.time = time(0);
      write_message_to_file();
      d->mail_to = 0;
      free(*d->str);
      free(d->str);
      SEND_TO_Q("Message posted!\r\n", d);
      }if (!IS_NPC(d->character))
        REMOVE_BIT(PLR_FLAGS(d->character), PLR_MESSAGING | PLR_WRITING);
    } else if (d->mail_to >= BOARD_MAGIC) {
        Board_save_board(d->mail_to - BOARD_MAGIC);
      SEND_TO_Q("Post not aborted, use REMOVE <post #>.\r\n", d);
        d->mail_to = 0;
    } else if (STATE(d) == CON_EXDESC) {
      if (terminator != 1)
      SEND_TO_Q("Description aborted.\r\n", d);
        SEND_TO_Q(MENU, d);
        d->connected = CON_MENU;
    } else if (STATE(d) == CON_TEXTED) {
	if (terminator == 1) {
	   if (!(fl = fopen((char *)d->storage, "w"))) {
	      sprintf(buf, "SYSERR: Can't write file '%s'.", d->storage);
	      mudlog(buf, CMP, LVL_OLC_FULL, TRUE);
	   }
	   else {
	      if (*d->str) {
		 fputs(stripcr(buf1, *d->str), fl);
	      }
	      fclose(fl);
	      sprintf(buf, "OLC: %s saves '%s'.", GET_NAME(d->character),
 		      d->storage);
 	      mudlog(buf, CMP, LVL_OLC_FULL, TRUE);
 	      SEND_TO_Q("Saved.\r\n", d);
	      STATE(d) = CON_PLAYING;
 	   }
        } else if(terminator == 2){
		SEND_TO_Q("Text edition aborted.\r\n", d);
        	STATE(d) = CON_PLAYING;
        }
    } else if (!d->connected && d->character && !IS_NPC(d->character)) {
      if (terminator == 1) {
      if (strlen(*d->str) == 0) {
        free(*d->str);
        *d->str = NULL;
      }
    } else {
      free(*d->str);
      if (d->backstr)
        *d->str = d->backstr;
      else
        *d->str = NULL;
      d->backstr = NULL;
      SEND_TO_Q("Message aborted.\r\n", d);
      }
     }
    if (d->character && !IS_NPC(d->character))
      REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING | PLR_MAILING);
    if (d->backstr)
      free(d->backstr);
    d->backstr = NULL;
    d->str = NULL;
  } else if (!action)
      strcat(*d->str, "\r\n");

  }


/* **********************************************************************
*  Modification of character skills                                     *
********************************************************************** */

ACMD(do_skillset)
{
  struct char_data *vict;
  char name[MAX_INPUT_LENGTH], buf2[128];
  char buf[MAX_INPUT_LENGTH], help[MAX_STRING_LENGTH];
  int skill, value, i, qend;

  argument = one_argument(argument, name);

  /*
   * No arguments. print an informative text.
   */
  if (!*name) {
    send_to_char("Syntax: skillset <name> '<skill>' <value>\r\n", ch);
    strcpy(help, "Skill being one of the following:\r\n");
    for (i = 0; *spells[i] != '\n'; i++) {
      if (*spells[i] == '!')
        continue;
      sprintf(help + strlen(help), "%18s", spells[i]);
      if (i % 4 == 3) {
        strcat(help, "\r\n");
        send_to_char(help, ch);
        *help = '\0';
      }
    }
    if (*help)
      send_to_char(help, ch);
    send_to_char("\r\n", ch);
    return;
  }
  if (!(vict = get_char_vis(ch, name))) {
    send_to_char(NOPERSON, ch);
    return;
  }
  skip_spaces(&argument);

  /* If there is no chars in argument */
  if (!*argument) {
    send_to_char("Skill name expected.\r\n", ch);
    return;
  }
  if (*argument != '\'') {
    send_to_char("Skill must be enclosed in: ''\r\n", ch);
    return;
  }
  /* Locate the last quote && lowercase the magic words (if any) */

  for (qend = 1; *(argument + qend) && (*(argument + qend) != '\''); qend++)
    *(argument + qend) = LOWER(*(argument + qend));

  if (*(argument + qend) != '\'') {
    send_to_char("Skill must be enclosed in: ''\r\n", ch);
    return;
  }
  strcpy(help, (argument + 1));
  help[qend - 1] = '\0';
  if ((skill = find_skill_num(help)) <= 0) {
    send_to_char("Unrecognized skill.\r\n", ch);
    return;
  }
  argument += qend + 1;         /* skip to next parameter */
  argument = one_argument(argument, buf);

  if (!*buf) {
    send_to_char("Learned value expected.\r\n", ch);
    return;
  }
  value = atoi(buf);
  if (value < 0) {
    send_to_char("Minimum value for learned is 0.\r\n", ch);
    return;
  }
  if (value > 100) {
    send_to_char("Max value for learned is 100.\r\n", ch);
    return;
  }
  if (IS_NPC(vict)) {
    send_to_char("You can't set NPC skills.\r\n", ch);
    return;
  }
  sprintf(buf2, "(GC) %s changed %s's %s to %d.", GET_NAME(ch), GET_NAME(vict),
          spells[skill], value);
  mudlog(buf2, BRF, LVL_MJGOD, TRUE);

  SET_SKILL(vict, skill, value);

  sprintf(buf2, "You change %s's %s to %d.\r\n", GET_NAME(vict),
          spells[skill], value);
  send_to_char(buf2, ch);
}

/*********************************************************************
* New Pagination Code
* Michael Buselli submitted the following code for an enhanced pager
* for CircleMUD.  All functions below are his.  --JE 8 Mar 96
*
*********************************************************************/

#define PAGE_LENGTH     22
#define PAGE_WIDTH      80

/* Traverse down the string until the begining of the next page has been
 * reached.  Return NULL if this is the last page of the string.
 */
char *next_page(char *str)
{
  int col = 1, line = 1, spec_code = FALSE;

  for (;; str++) {
    /* If end of string, return NULL. */
    if (*str == '\0')
      return (NULL);

    /* If we're at the start of the next page, return this fact. */
    else if (line > PAGE_LENGTH)
      return (str);

    /* Check for the begining of an ANSI color code block. */
    else if (*str == '\x1B' && !spec_code)
      spec_code = TRUE;

    /* Check for the end of an ANSI color code block. */
    else if (*str == 'm' && spec_code)
      spec_code = FALSE;

    /* Check for everything else. */
    else if (!spec_code) {
      /* Carriage return puts us in column one. */
      if (*str == '\r')
	col = 1;
      /* Newline puts us on the next line. */
      else if (*str == '\n')
	line++;

      /* We need to check here and see if we are over the page width,
       * and if so, compensate by going to the begining of the next line.
       */
      else if (col++ > PAGE_WIDTH) {
	col = 1;
	line++;
      }
    }
  }
}


/* Function that returns the number of pages in the string. */
int count_pages(char *str)
{
  int pages;

  for (pages = 1; (str = next_page(str)); pages++);
  return (pages);
}


/* This function assigns all the pointers for showstr_vector for the
 * page_string function, after showstr_vector has been allocated and
 * showstr_count set.
 */
void paginate_string(char *str, struct descriptor_data *d)
{
  int i;

  if (d->showstr_count)
    *(d->showstr_vector) = str;

  for (i = 1; i < d->showstr_count && str; i++)
    str = d->showstr_vector[i] = next_page(str);

  d->showstr_page = 0;
}


/* The call that gets the paging ball rolling... */
void page_string(struct descriptor_data *d, char *str, int keep_internal)
{
  char actbuf[MAX_INPUT_LENGTH] = "";

  if (!d)
    return;

  if (!str || !*str)
    return;

  d->showstr_count = count_pages(str);
  CREATE(d->showstr_vector, char *, d->showstr_count);

  if (keep_internal) {
    d->showstr_head = strdup(str);
    paginate_string(d->showstr_head, d);
  } else
    paginate_string(str, d);

  show_string(d, actbuf);
}


/* The call that displays the next page. */
void show_string(struct descriptor_data *d, char *input)
{
  char buffer[MAX_STRING_LENGTH], buf[MAX_INPUT_LENGTH], texto[MAX_INPUT_LENGTH];
  int diff;

  any_one_arg(input, buf);

  /* Q is for quit. :) */
  if (LOWER(*buf) == 'q') {
    free(d->showstr_vector);
    d->showstr_vector = NULL;
    d->showstr_count = 0;
    if (d->showstr_head) {
      free(d->showstr_head);
      d->showstr_head = NULL;
    }
    return;
  }
  /* R is for refresh, so back up one page internally so we can display
   * it again.
   */
  else if (LOWER(*buf) == 'r')
    d->showstr_page = MAX(0, d->showstr_page - 1);

  /* B is for back, so back up two pages internally so we can display the
   * correct page here.
   */
  else if (LOWER(*buf) == 'b')
    d->showstr_page = MAX(0, d->showstr_page - 2);

  else if (*buf) {
    send_to_char("&WValid commands while paging are &RRETURN&W, &RQ&W, &RR&W and &RB&W.&n\r\n", d->character);
    return;
  }
  /* If we're displaying the last page, just send it to the character, and
   * then free up the space we used.
   */
  if (d->showstr_page + 1 >= d->showstr_count) {
    sprintf(texto, "%s", d->showstr_vector[d->showstr_page]);
	send_to_char(texto, d->character);
    free(d->showstr_vector);
    d->showstr_vector = NULL;
    d->showstr_count = 0;
    if (d->showstr_head) {
      free(d->showstr_head);
      d->showstr_head = NULL;
    }
  }
  /* Or if we have more to show.... */
  else {
    diff = d->showstr_vector[d->showstr_page + 1] - d->showstr_vector[d->showstr_page];
    if (diff > MAX_STRING_LENGTH - 3) /* 3=\r\n\0 */
      diff = MAX_STRING_LENGTH - 3;
    strncpy(buffer, d->showstr_vector[d->showstr_page], diff);	/* strncpy: OK (size truncated above) */
    /*
     * Fix for prompt overwriting last line in compact mode submitted by
     * Peter Ajamian <peter@pajamian.dhs.org> on 04/21/2001
     */
    if (buffer[diff - 2] == '\r' && buffer[diff - 1]=='\n')
      buffer[diff] = '\0';
    else if (buffer[diff - 2] == '\n' && buffer[diff - 1] == '\r')
      /* This is backwards.  Fix it. */
      strcpy(buffer + diff - 2, "\r\n");	/* strcpy: OK (size checked) */
    else if (buffer[diff - 1] == '\r' || buffer[diff - 1] == '\n')
      /* Just one of \r\n.  Overwrite it. */
      strcpy(buffer + diff - 1, "\r\n");	/* strcpy: OK (size checked) */
    else
      /* Tack \r\n onto the end to fix bug with prompt overwriting last line. */
      strcpy(buffer + diff, "\r\n");	/* strcpy: OK (size checked) */
	strcpy(texto, buffer);
    send_to_char(texto, d->character);
    d->showstr_page++;
  }
}

void smash_tilde(char *string)
{
  /*
   * Erase any ~'s inserted by people in the editor.  This prevents anyone
   * using online creation from causing parse errors in the world files.
   * Derived from an idea by Sammy <samedi@dhc.net> (who happens to like
   * his tildes thank you very much.), -gg 2/20/98
   */
	char *str = string;
    while ((str = strchr(str, '~')) != NULL)
      *str = ' ';
}

/* temp func -Petrus */
void write_last_command(char *arg)
{
  FILE *fp;

  if (!(fp = fopen("../log/.lastcommand", "wb"))) {
    return;
  }

  fputs(arg, fp);
  fputc('\n', fp);

  fclose(fp);
}
::::::::::::::
objsave.c
::::::::::::::
/* ************************************************************************
*   File: objsave.c                                     Part of CircleMUD *
*  Usage: loading/saving player objects for rent and crash-save           *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/*
 * AutoEQ by Burkhard Knopf <burkhard.knopf@informatik.tu-clausthal.de>
 */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "spells.h"
#include "buffer.h"

/* these factors should be unique integers */
#define RENT_FACTOR 	1
#define CRYO_FACTOR 	4

#define LOC_INVENTORY	0
#define MAX_BAG_ROWS	5

extern struct room_data *world;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
extern struct player_index_element *player_table;
extern int top_of_p_table;
extern int rent_file_timeout, crash_file_timeout;
extern int free_rent;
extern int min_rent_cost;
extern int max_obj_save;	/* change in config.c */

/* Extern functions */
ACMD(do_action);
ACMD(do_tell);
SPECIAL(receptionist);
SPECIAL(cryogenicist);
int invalid_class(struct char_data *ch, struct obj_data *obj);

/* local functions */
void Crash_extract_norent_eq(struct char_data *ch);
void auto_equip(struct char_data *ch, struct obj_data *obj, int location);
int Crash_offer_rent(struct char_data * ch, struct char_data * receptionist, int display, int factor);
int Crash_report_unrentables(struct char_data * ch, struct char_data * recep, struct obj_data * obj);
void Crash_report_rent(struct char_data * ch, struct char_data * recep, struct obj_data * obj, long *cost, long *nitems, int display, int factor);
struct obj_data *Obj_from_store(struct obj_file_elem object, int *location);
int Obj_to_store(struct obj_data * obj, FILE * fl, int location);
void update_obj_file(void);
int Crash_write_rentcode(struct char_data * ch, FILE * fl, struct rent_info * rent);
int gen_receptionist(struct char_data * ch, struct char_data * recep, int cmd, char *arg, int mode);
int Crash_save(struct obj_data * obj, FILE * fp, int location);
void Crash_rent_deadline(struct char_data * ch, struct char_data * recep, long cost);
void Crash_restore_weight(struct obj_data * obj);
void Crash_extract_objs(struct obj_data * obj);
int Crash_is_unrentable(struct obj_data * obj);
void Crash_extract_norents(struct obj_data * obj);
void Crash_extract_expensive(struct obj_data * obj);
void Crash_calculate_rent(struct obj_data * obj, int *cost);
void Crash_rentsave(struct char_data * ch, int cost);
void Crash_cryosave(struct char_data * ch, int cost);


struct obj_data *Obj_from_store(struct obj_file_elem object, int *location)
{
  struct obj_data *obj;
  int j;

  *location = 0;
  if (real_object(object.item_number) >= 0) {
    obj = read_object(object.item_number, VIRTUAL);
#if USE_AUTOEQ
    *location = object.location;
#endif
    GET_OBJ_VAL(obj, 0) = object.value[0];
    GET_OBJ_VAL(obj, 1) = object.value[1];
    GET_OBJ_VAL(obj, 2) = object.value[2];
    GET_OBJ_VAL(obj, 3) = object.value[3];
    GET_OBJ_EXTRA(obj) = object.extra_flags;
    GET_OBJ_WEIGHT(obj) = object.weight;
    GET_OBJ_TIMER(obj) = object.timer;
    obj->obj_flags.bitvector = object.bitvector;
    GET_OBJ_COND(obj) = object.cond;
    
    for (j = 0; j < MAX_OBJ_AFFECT; j++)
      obj->affected[j] = object.affected[j];

    return (obj);
  } else
    return (NULL);
}



int Obj_to_store(struct obj_data * obj, FILE * fl, int location)
{
  int j;
  struct obj_file_elem object;

  object.item_number = GET_OBJ_VNUM(obj);
#if USE_AUTOEQ
  object.location = location;
#endif
  object.value[0] = GET_OBJ_VAL(obj, 0);
  object.value[1] = GET_OBJ_VAL(obj, 1);
  object.value[2] = GET_OBJ_VAL(obj, 2);
  object.value[3] = GET_OBJ_VAL(obj, 3);
  object.extra_flags = GET_OBJ_EXTRA(obj);
  object.weight = GET_OBJ_WEIGHT(obj);
  object.timer = GET_OBJ_TIMER(obj);
  object.bitvector = obj->obj_flags.bitvector;
  object.cond = GET_OBJ_COND(obj);
  
  for (j = 0; j < MAX_OBJ_AFFECT; j++)
    object.affected[j] = obj->affected[j];

  if (fwrite(&object, sizeof(struct obj_file_elem), 1, fl) < 1) {
    perror("SYSERR: error writing object in Obj_to_store");
    return (0);
  }
  return (1);
}

void auto_equip(struct char_data *ch, struct obj_data *obj, int location)
{
  int j;

  /* Lots of checks... */
  if (location > 0) {	/* Was wearing it. */
    switch (j = (location - 1)) {
    case WEAR_LIGHT:
      break;
    case WEAR_FINGER_R:
    case WEAR_FINGER_L:
      if (!CAN_WEAR(obj, ITEM_WEAR_FINGER)) /* not fitting :( */
        location = LOC_INVENTORY;
      break;
    case WEAR_NECK_1:
    case WEAR_NECK_2:
      if (!CAN_WEAR(obj, ITEM_WEAR_NECK))
        location = LOC_INVENTORY;
      break;
    case WEAR_BODY:
      if (!CAN_WEAR(obj, ITEM_WEAR_BODY))
        location = LOC_INVENTORY;
      break;
    case WEAR_HEAD:
      if (!CAN_WEAR(obj, ITEM_WEAR_HEAD))
        location = LOC_INVENTORY;
      break;
    case WEAR_LEGS:
      if (!CAN_WEAR(obj, ITEM_WEAR_LEGS))
        location = LOC_INVENTORY;
      break;
    case WEAR_FEET:
      if (!CAN_WEAR(obj, ITEM_WEAR_FEET))
        location = LOC_INVENTORY;
      break;
    case WEAR_HANDS:
      if (!CAN_WEAR(obj, ITEM_WEAR_HANDS))
        location = LOC_INVENTORY;
      break;
    case WEAR_ARMS:
      if (!CAN_WEAR(obj, ITEM_WEAR_ARMS))
        location = LOC_INVENTORY;
      break;
    case WEAR_SHIELD:
      if (!CAN_WEAR(obj, ITEM_WEAR_SHIELD))
        location = LOC_INVENTORY;
      break;
    case WEAR_ABOUT:
      if (!CAN_WEAR(obj, ITEM_WEAR_ABOUT))
        location = LOC_INVENTORY;
      break;
    case WEAR_WAIST:
      if (!CAN_WEAR(obj, ITEM_WEAR_WAIST))
        location = LOC_INVENTORY;
      break;
    case WEAR_WRIST_R:
    case WEAR_WRIST_L:
      if (!CAN_WEAR(obj, ITEM_WEAR_WRIST))
        location = LOC_INVENTORY;
      break;
    case WEAR_WIELD:
      if (!CAN_WEAR(obj, ITEM_WEAR_WIELD))
        location = LOC_INVENTORY;
      break;
    case WEAR_HOLD:
      if (!CAN_WEAR(obj, ITEM_WEAR_HOLD))
         location = LOC_INVENTORY;
      break;
    case WEAR_DWIELD:
      if (!CAN_WEAR(obj, ITEM_WEAR_WIELD))
         location = LOC_INVENTORY;
      break;
    case WEAR_EAR_R:
    case WEAR_EAR_L:
      if (!CAN_WEAR(obj, ITEM_WEAR_EAR))
        location = LOC_INVENTORY;
      break;
    case WEAR_FACE:
      if (!CAN_WEAR(obj, ITEM_WEAR_FACE))
        location = LOC_INVENTORY;
      break;
    case WEAR_FLOAT:
      break;
    default:
      location = LOC_INVENTORY;
    }

    if (location > 0) {	    /* Wearable. */
      if (!GET_EQ(ch,j)) {
	/*
	 * Check the characters's alignment to prevent them from being
	 * zapped through the auto-equipping.
         */
         if (invalid_align(ch, obj) || invalid_class(ch, obj))
          location = LOC_INVENTORY;
        else
          equip_char(ch, obj, j);
      } else {	/* Oops, saved a player with double equipment? */
        char aeq[128];
        sprintf(aeq, "SYSERR: autoeq: '%s' already equipped in position %d.", GET_NAME(ch), location);
        mudlog(aeq, BRF, LVL_IMMORT, TRUE);
        location = LOC_INVENTORY;
      }
    }
  }
  if (location <= 0)	/* Inventory */
    obj_to_char(obj, ch);
}


int Crash_delete_file(char *name)
{
  char filename[50];
  FILE *fl;

  if (!get_filename(name, filename, CRASH_FILE))
    return (0);
  if (!(fl = fopen(filename, "rb"))) {
    if (errno != ENOENT)	/* if it fails but NOT because of no file */
      log("SYSERR: deleting crash file %s (1): %s", filename, strerror(errno));
    return (0);
  }
  fclose(fl);

  /* if it fails, NOT because of no file */
  if (remove(filename) < 0 && errno != ENOENT)
    log("SYSERR: deleting crash file %s (2): %s", filename, strerror(errno));

  return (1);
}


int Crash_delete_crashfile(struct char_data * ch)
{
  char fname[MAX_INPUT_LENGTH];
  struct rent_info rent;
  FILE *fl;

  if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
    return (0);
  if (!(fl = fopen(fname, "rb"))) {
    if (errno != ENOENT)	/* if it fails, NOT because of no file */
      log("SYSERR: checking for crash file %s (3): %s", fname, strerror(errno));
    return (0);
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  fclose(fl);

  if (rent.rentcode == RENT_CRASH)
    Crash_delete_file(GET_NAME(ch));

  return (1);
}


int Crash_clean_file(char *name)
{
  char fname[MAX_STRING_LENGTH], filetype[20];
  struct rent_info rent;
  FILE *fl;

  if (!get_filename(name, fname, CRASH_FILE))
    return (0);
  /*
   * open for write so that permission problems will be flagged now, at boot
   * time.
   */
  if (!(fl = fopen(fname, "r+b"))) {
    if (errno != ENOENT)	/* if it fails, NOT because of no file */
      log("SYSERR: OPENING OBJECT FILE %s (4): %s", fname, strerror(errno));
    return (0);
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  fclose(fl);

  if ((rent.rentcode == RENT_CRASH) ||
      (rent.rentcode == RENT_FORCED) || (rent.rentcode == RENT_TIMEDOUT)) {
    if (rent.time < time(0) - (crash_file_timeout * SECS_PER_REAL_DAY)) {
      Crash_delete_file(name);
      switch (rent.rentcode) {
      case RENT_CRASH:
	strcpy(filetype, "crash");
	break;
      case RENT_FORCED:
	strcpy(filetype, "forced rent");
	break;
      case RENT_TIMEDOUT:
	strcpy(filetype, "idlesave");
	break;
      default:
	strcpy(filetype, "UNKNOWN!");
	break;
      }
      log("    Deleting %s's %s file.", name, filetype);
      return (1);
    }
    /* Must retrieve rented items w/in 30 days */
  } else if (rent.rentcode == RENT_RENTED)
    if (rent.time < time(0) - (rent_file_timeout * SECS_PER_REAL_DAY)) {
      Crash_delete_file(name);
      log("    Deleting %s's rent file.", name);
      return (1);
    }
  return (0);
}



void update_obj_file(void)
{
  int i;

  for (i = 0; i <= top_of_p_table; i++)
    if (*player_table[i].name)
      Crash_clean_file(player_table[i].name);
}



void Crash_listrent(struct char_data * ch, char *name)
{
  FILE *fl;
  char fname[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct obj_data *obj;
  struct rent_info rent;

  if (!get_filename(name, fname, CRASH_FILE))
    return;
  if (!(fl = fopen(fname, "rb"))) {
    sprintf(buf, "%s has no rent file.\r\n", name);
    send_to_char(buf, ch);
    return;
  }
  sprintf(buf, "%s\r\n", fname);
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  switch (rent.rentcode) {
  case RENT_RENTED:
    strcat(buf, "Rent\r\n");
    break;
  case RENT_CRASH:
    strcat(buf, "Crash\r\n");
    break;
  case RENT_CRYO:
    strcat(buf, "Cryo\r\n");
    break;
  case RENT_TIMEDOUT:
  case RENT_FORCED:
    strcat(buf, "TimedOut\r\n");
    break;
  default:
    strcat(buf, "Undef\r\n");
    break;
  }
  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      fclose(fl);
      return;
    }
    if (!feof(fl))
      if (real_object(object.item_number) > -1) {
	obj = read_object(object.item_number, VIRTUAL);
#if USE_AUTOEQ
	sprintf(buf + strlen(buf), " [%5d] (%9dau) <%2d> %-20s\r\n",
		object.item_number, GET_OBJ_COST(obj),
		object.location, obj->short_description);
#else
	sprintf(buf + strlen(buf), " [%5d] (%9dau) %-20s\r\n",
		object.item_number, GET_OBJ_COST(obj),
		obj->short_description);
#endif
	extract_obj(obj);
	if (strlen(buf) > MAX_STRING_LENGTH - 80) {
	  strcat(buf, "** Excessive rent listing. **\r\n");
	  break;
	}
      }
  }
  send_to_char(buf, ch);
  fclose(fl);
}



int Crash_write_rentcode(struct char_data * ch, FILE * fl, struct rent_info * rent)
{
  if (fwrite(rent, sizeof(struct rent_info), 1, fl) < 1) {
    perror("SYSERR: writing rent code");
    return (0);
  }
  return (1);
}



/*
 * Return values:
 *  0 - successful load, keep char in rent room.
 *  1 - load failure or load of crash items -- put char in temple.
 *  2 - rented equipment lost (no $)
 */
int Crash_load(struct char_data * ch)
{
  FILE *fl;
  char fname[MAX_STRING_LENGTH];
  struct obj_file_elem object;
  struct rent_info rent;
  int cost, orig_rent_code, num_objs = 0, j;
  float num_of_days;
  /* AutoEQ addition. */
  struct obj_data *obj, *obj2, *cont_row[MAX_BAG_ROWS];
  int location;

  /* Empty all of the container lists (you never know ...) */
  for (j = 0; j < MAX_BAG_ROWS; j++)
    cont_row[j] = NULL;

  if (!get_filename(GET_NAME(ch), fname, CRASH_FILE))
    return (1);
  if (!(fl = fopen(fname, "r+b"))) {
    if (errno != ENOENT) {	/* if it fails, NOT because of no file */
      log("SYSERR: READING OBJECT FILE %s (5): %s", fname, strerror(errno));
      send_to_char("\r\n********************* NOTICE *********************\r\n"
		   "There was a problem loading your objects from disk.\r\n"
		   "Contact a God for assistance.\r\n", ch);
    }
    sprintf(buf, "%s entering game with no equipment.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    return (1);
  }
  if (!feof(fl))
    fread(&rent, sizeof(struct rent_info), 1, fl);
  else {
    log("SYSERR: Crash_load: %s's rent file was empty!", GET_NAME(ch));
    return (1);
  }

  if (rent.rentcode == RENT_RENTED || rent.rentcode == RENT_TIMEDOUT) {
    num_of_days = (float) (time(0) - rent.time) / SECS_PER_REAL_DAY;
    cost = (int) (rent.net_cost_per_diem * num_of_days);
    if (cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
      fclose(fl);
      sprintf(buf, "%s entering game, rented equipment lost (no $).",
	      GET_NAME(ch));
      mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
      Crash_crashsave(ch);
      return (2);
    } else {
      GET_BANK_GOLD(ch) -= MAX(cost - GET_GOLD(ch), 0);
      GET_GOLD(ch) = MAX(GET_GOLD(ch) - cost, 0);
      save_char(ch, NOWHERE);
    }
  }
  switch (orig_rent_code = rent.rentcode) {
  case RENT_RENTED:
    sprintf(buf, "%s un-renting and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_CRASH:
    sprintf(buf, "%s retrieving crash-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_CRYO:
    sprintf(buf, "%s un-cryo'ing and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  case RENT_FORCED:
  case RENT_TIMEDOUT:
    sprintf(buf, "%s retrieving force-saved items and entering game.", GET_NAME(ch));
    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  default:
    sprintf(buf, "SYSERR: %s entering game with undefined rent code %d.", GET_NAME(ch), rent.rentcode);
    mudlog(buf, BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    break;
  }

  while (!feof(fl)) {
    fread(&object, sizeof(struct obj_file_elem), 1, fl);
    if (ferror(fl)) {
      perror("SYSERR: Reading crash file: Crash_load");
      fclose(fl);
      return (1);
    }
    if (feof(fl))
      break;
    ++num_objs;
    if ((obj = Obj_from_store(object, &location)) == NULL)
      continue;

    auto_equip(ch, obj, location);
    /*
     * What to do with a new loaded item:
     *
     * If there's a list with location less than 1 below this, then its
     * container has disappeared from the file so we put the list back into
     * the character's inventory. (Equipped items are 0 here.)
     *
     * If there's a list of contents with location of 1 below this, then we
     * check if it is a container:
     *   - Yes: Get it from the character, fill it, and give it back so we
     *          have the correct weight.
     *   -  No: The container is missing so we put everything back into the
     *          character's inventory.
     *
     * For items with negative location, we check if there is already a list
     * of contents with the same location.  If so, we put it there and if not,
     * we start a new list.
     *
     * Since location for contents is < 0, the list indices are switched to
     * non-negative.
     *
     * This looks ugly, but it works.
     */
    if (location > 0) {		/* Equipped */
      for (j = MAX_BAG_ROWS - 1; j > 0; j--) {
        if (cont_row[j]) {	/* No container, back to inventory. */
          for (; cont_row[j]; cont_row[j] = obj2) {
            obj2 = cont_row[j]->next_content;
            obj_to_char(cont_row[j], ch);
          }
          cont_row[j] = NULL;
        }
      }
      if (cont_row[0]) {	/* Content list existing. */
        if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
	/* Remove object, fill it, equip again. */
          obj = unequip_char(ch, location - 1);
          obj->contains = NULL;	/* Should be NULL anyway, but just in case. */
          for (; cont_row[0]; cont_row[0] = obj2) {
            obj2 = cont_row[0]->next_content;
            obj_to_obj(cont_row[0], obj);
          }
          equip_char(ch, obj, location - 1);
        } else {			/* Object isn't container, empty the list. */
          for (; cont_row[0]; cont_row[0] = obj2) {
            obj2 = cont_row[0]->next_content;
            obj_to_char(cont_row[0], ch);
          }
          cont_row[0] = NULL;
        }
      }
    } else {	/* location <= 0 */
      for (j = MAX_BAG_ROWS - 1; j > -location; j--) {
        if (cont_row[j]) {	/* No container, back to inventory. */
          for (; cont_row[j]; cont_row[j] = obj2) {
            obj2 = cont_row[j]->next_content;
            obj_to_char(cont_row[j], ch);
          }
          cont_row[j] = NULL;
        }
      }
      if (j == -location && cont_row[j]) {	/* Content list exists. */
        if (GET_OBJ_TYPE(obj) == ITEM_CONTAINER) {
		/* Take the item, fill it, and give it back. */
          obj_from_char(obj);
          obj->contains = NULL;
          for (; cont_row[j]; cont_row[j] = obj2) {
            obj2 = cont_row[j]->next_content;
            obj_to_obj(cont_row[j], obj);
          }
          obj_to_char(obj, ch);	/* Add to inventory first. */
        } else {	/* Object isn't container, empty content list. */
          for (; cont_row[j]; cont_row[j] = obj2) {
            obj2 = cont_row[j]->next_content;
            obj_to_char(cont_row[j], ch);
          }
          cont_row[j] = NULL;
        }
      }
      if (location < 0 && location >= -MAX_BAG_ROWS) {
        /*
         * Let the object be part of the content list but put it at the
         * list's end.  Thus having the items in the same order as before
         * the character rented.
         */
        obj_from_char(obj);
        if ((obj2 = cont_row[-location - 1]) != NULL) {
          while (obj2->next_content)
            obj2 = obj2->next_content;
          obj2->next_content = obj;
        } else
          cont_row[-location - 1] = obj;
      }
    }
  }

  /* Little hoarding check. -gg 3/1/98 */
  sprintf(fname, "%s (level %d) has %d objects (max %d).",
	GET_NAME(ch), GET_LEVEL(ch), num_objs, max_obj_save);
  mudlog(fname, NRM, MAX(GET_INVIS_LEV(ch), LVL_GOD), TRUE);

  /* turn this into a crash file by re-writing the control block */
  rent.rentcode = RENT_CRASH;
  rent.time = time(0);
  rewind(fl);
  Crash_write_rentcode(ch, fl, &rent);

  fclose(fl);

  if ((orig_rent_code == RENT_RENTED) || (orig_rent_code == RENT_CRYO))
    return (0);
  else
    return (1);
}



int Crash_save(struct obj_data * obj, FILE * fp, int location)
{
  struct obj_data *tmp;
  int result;

  if (obj) {
    Crash_save(obj->next_content, fp, location);
    Crash_save(obj->contains, fp, MIN(0, location) - 1);
    result = Obj_to_store(obj, fp, location);

    for (tmp = obj->in_obj; tmp; tmp = tmp->in_obj)
      GET_OBJ_WEIGHT(tmp) -= GET_OBJ_WEIGHT(obj);

    if (!result)
      return (0);
  }
  return (TRUE);
}


void Crash_restore_weight(struct obj_data * obj)
{
  if (obj) {
    Crash_restore_weight(obj->contains);
    Crash_restore_weight(obj->next_content);
    if (obj->in_obj)
      GET_OBJ_WEIGHT(obj->in_obj) += GET_OBJ_WEIGHT(obj);
  }
}

/*
 * Get !RENT items from equipment to inventory and
 * extract !RENT out of worn containers.
 */
void Crash_extract_norent_eq(struct char_data *ch)
{
  int j;

  for (j = 0; j < NUM_WEARS; j++) {
    if (GET_EQ(ch, j) == NULL)
      continue;

    if (Crash_is_unrentable(GET_EQ(ch, j)))
      obj_to_char(unequip_char(ch, j), ch);
    else
      Crash_extract_norents(GET_EQ(ch, j));
  }
}

void Crash_extract_objs(struct obj_data * obj)
{
  if (obj) {
    Crash_extract_objs(obj->contains);
    Crash_extract_objs(obj->next_content);
    extract_obj(obj);
  }
}


int Crash_is_unrentable(struct obj_data * obj)
{
  if (!obj)
    return (0);

  if (IS_OBJ_STAT(obj, ITEM_NORENT) || GET_OBJ_RENT(obj) < 0 ||
      GET_OBJ_RNUM(obj) <= NOTHING || GET_OBJ_TYPE(obj) == ITEM_KEY)
    return (1);

  return (0);
}


void Crash_extract_norents(struct obj_data * obj)
{
  if (obj) {
    Crash_extract_norents(obj->contains);
    Crash_extract_norents(obj->next_content);
    if (Crash_is_unrentable(obj))
      extract_obj(obj);
  }
}


void Crash_extract_expensive(struct obj_data * obj)
{
  struct obj_data *tobj, *max;

  max = obj;
  for (tobj = obj; tobj; tobj = tobj->next_content)
    if (GET_OBJ_RENT(tobj) > GET_OBJ_RENT(max))
      max = tobj;
  extract_obj(max);
}



void Crash_calculate_rent(struct obj_data * obj, int *cost)
{
  if (obj) {
    *cost += MAX(0, GET_OBJ_RENT(obj));
    Crash_calculate_rent(obj->contains, cost);
    Crash_calculate_rent(obj->next_content, cost);
  }
}


void Crash_crashsave(struct char_data * ch)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  rent.rentcode = RENT_CRASH;
  rent.time = time(0);
  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }

  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j)) {
      if (!Crash_save(GET_EQ(ch, j), fp, j + 1)) {
	fclose(fp);
	return;
      }
      Crash_restore_weight(GET_EQ(ch, j));
    }

  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  Crash_restore_weight(ch->carrying);

  fclose(fp);
  REMOVE_BIT(PLR_FLAGS(ch), PLR_CRASH);
}


void Crash_idlesave(struct char_data * ch)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  int cost, cost_eq;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  Crash_extract_norent_eq(ch);
  Crash_extract_norents(ch->carrying);

  cost = 0;
  Crash_calculate_rent(ch->carrying, &cost);

  cost_eq = 0;
  for (j = 0; j < NUM_WEARS; j++)
    Crash_calculate_rent(GET_EQ(ch, j), &cost_eq);

  cost += cost_eq;
  cost *= 2;			/* forcerent cost is 2x normal rent */

  if (cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
    for (j = 0; j < NUM_WEARS; j++)	/* Unequip players with low gold. */
      if (GET_EQ(ch, j))
        obj_to_char(unequip_char(ch, j), ch);

    while ((cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) && ch->carrying) {
      Crash_extract_expensive(ch->carrying);
      cost = 0;
      Crash_calculate_rent(ch->carrying, &cost);
      cost *= 2;
    }
  }

  if (ch->carrying == NULL) {
    for (j = 0; j < NUM_WEARS && GET_EQ(ch, j) == NULL; j++) /* Nothing */ ;
    if (j == NUM_WEARS) {	/* No equipment or inventory. */
      fclose(fp);
      Crash_delete_file(GET_NAME(ch));
      return;
    }
  }
  rent.net_cost_per_diem = cost;

  rent.rentcode = RENT_TIMEDOUT;
  rent.time = time(0);
  rent.gold = GET_GOLD(ch);
  rent.account = GET_BANK_GOLD(ch);
  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  for (j = 0; j < NUM_WEARS; j++) {
    if (GET_EQ(ch, j)) {
      if (!Crash_save(ch->carrying, fp, j + 1)) {
        fclose(fp);
        return;
      }
      Crash_restore_weight(GET_EQ(ch, j));
      Crash_extract_objs(GET_EQ(ch, j));
    }
  }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
}


void Crash_rentsave(struct char_data * ch, int cost)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  Crash_extract_norent_eq(ch);
  Crash_extract_norents(ch->carrying);

  rent.net_cost_per_diem = cost;
  rent.rentcode = RENT_RENTED;
  rent.time = time(0);
  rent.gold = GET_GOLD(ch);
  rent.account = GET_BANK_GOLD(ch);
  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j)) {
      if (!Crash_save(GET_EQ(ch,j), fp, j + 1)) {
        fclose(fp);
        return;
      }
      Crash_restore_weight(GET_EQ(ch, j));
      Crash_extract_objs(GET_EQ(ch, j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
}


void Crash_cryosave(struct char_data * ch, int cost)
{
  char buf[MAX_INPUT_LENGTH];
  struct rent_info rent;
  int j;
  FILE *fp;

  if (IS_NPC(ch))
    return;

  if (!get_filename(GET_NAME(ch), buf, CRASH_FILE))
    return;
  if (!(fp = fopen(buf, "wb")))
    return;

  Crash_extract_norent_eq(ch);
  Crash_extract_norents(ch->carrying);

  GET_GOLD(ch) = MAX(0, GET_GOLD(ch) - cost);

  rent.rentcode = RENT_CRYO;
  rent.time = time(0);
  rent.gold = GET_GOLD(ch);
  rent.account = GET_BANK_GOLD(ch);
  rent.net_cost_per_diem = 0;
  if (!Crash_write_rentcode(ch, fp, &rent)) {
    fclose(fp);
    return;
  }
  for (j = 0; j < NUM_WEARS; j++)
    if (GET_EQ(ch, j)) {
      if (!Crash_save(GET_EQ(ch, j), fp, j + 1)) {
        fclose(fp);
        return;
      }
      Crash_restore_weight(GET_EQ(ch, j));
      Crash_extract_objs(GET_EQ(ch, j));
    }
  if (!Crash_save(ch->carrying, fp, 0)) {
    fclose(fp);
    return;
  }
  fclose(fp);

  Crash_extract_objs(ch->carrying);
  SET_BIT(PLR_FLAGS(ch), PLR_CRYO);
}


/* ************************************************************************
* Routines used for the receptionist					  *
************************************************************************* */

void Crash_rent_deadline(struct char_data * ch, struct char_data * recep,
			      long cost)
{
  long rent_deadline;

  if (!cost)
    return;

  rent_deadline = ((GET_GOLD(ch) + GET_BANK_GOLD(ch)) / cost);
  sprintf(buf,
      "$n tells you, 'You can rent for %ld day%s with the gold you have\r\n"
	  "on hand and in the bank.'\r\n",
	  rent_deadline, (rent_deadline > 1) ? "s" : "");
  act(buf, FALSE, recep, 0, ch, TO_VICT);
}

int Crash_report_unrentables(struct char_data * ch, struct char_data * recep,
			         struct obj_data * obj)
{
  char buf[128];
  int has_norents = 0;

  if (obj) {
    if (Crash_is_unrentable(obj)) {
      has_norents = 1;
      sprintf(buf, "$n tells you, 'You cannot store %s.'", OBJS(obj, ch));
      act(buf, FALSE, recep, 0, ch, TO_VICT);
    }
    has_norents += Crash_report_unrentables(ch, recep, obj->contains);
    has_norents += Crash_report_unrentables(ch, recep, obj->next_content);
  }
  return (has_norents);
}



void Crash_report_rent(struct char_data * ch, struct char_data * recep,
		            struct obj_data * obj, long *cost, long *nitems, int display, int factor)
{
  static char buf[256];

  if (obj) {
    if (!Crash_is_unrentable(obj)) {
      (*nitems)++;
      *cost += MAX(0, (GET_OBJ_RENT(obj) * factor));
      if (display) {
	sprintf(buf, "$n tells you, '%5d coins for %s..'",
		(GET_OBJ_RENT(obj) * factor), OBJS(obj, ch));
	act(buf, FALSE, recep, 0, ch, TO_VICT);
      }
    }
    Crash_report_rent(ch, recep, obj->contains, cost, nitems, display, factor);
    Crash_report_rent(ch, recep, obj->next_content, cost, nitems, display, factor);
  }
}



int Crash_offer_rent(struct char_data * ch, struct char_data * receptionist,
		         int display, int factor)
{
  char buf[MAX_INPUT_LENGTH];
  int i;
  long totalcost = 0, numitems = 0, norent;

  norent = Crash_report_unrentables(ch, receptionist, ch->carrying);
  for (i = 0; i < NUM_WEARS; i++)
    norent += Crash_report_unrentables(ch, receptionist, GET_EQ(ch, i));

  if (norent)
    return (0);

  totalcost = min_rent_cost * factor;

  Crash_report_rent(ch, receptionist, ch->carrying, &totalcost, &numitems, display, factor);

  for (i = 0; i < NUM_WEARS; i++)
    Crash_report_rent(ch, receptionist, GET_EQ(ch, i), &totalcost, &numitems, display, factor);

  if (!numitems) {
    act("$n tells you, 'But you are not carrying anything!  Just quit!'",
	FALSE, receptionist, 0, ch, TO_VICT);
    return (0);
  }
  if (numitems > max_obj_save) {
    sprintf(buf, "$n tells you, 'Sorry, but I cannot store more than %d items.'",
	    max_obj_save);
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    return (0);
  }
  if (display) {
    sprintf(buf, "$n tells you, 'Plus, my %d coin fee..'",
	    min_rent_cost * factor);
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    sprintf(buf, "$n tells you, 'For a total of %ld coins%s.'",
	    totalcost, (factor == RENT_FACTOR ? " per day" : ""));
    act(buf, FALSE, receptionist, 0, ch, TO_VICT);
    if (totalcost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
      act("$n tells you, '...which I see you can't afford.'",
	  FALSE, receptionist, 0, ch, TO_VICT);
      return (0);
    } else if (factor == RENT_FACTOR)
      Crash_rent_deadline(ch, receptionist, totalcost);
  }
  return (totalcost);
}



int gen_receptionist(struct char_data * ch, struct char_data * recep,
		         int cmd, char *arg, int mode)
{
  int cost;
  room_rnum save_room;
  const char *action_table[] = { "smile", "dance", "sigh", "blush", "burp",
	  "cough", "fart", "twiddle", "yawn" };

  if (!ch->desc || IS_NPC(ch))
    return (FALSE);

  if (!cmd && !number(0, 5)) {
    do_action(recep, NULL, find_command(action_table[number(0, 8)]), 0);
    return (FALSE);
  }
  if (!CMD_IS("offer") && !CMD_IS("rent"))
    return (FALSE);
  if (!AWAKE(recep)) {
    sprintf(buf, "%s is unable to talk to you...\r\n", HSSH(recep));
    send_to_char(buf, ch);
    return (TRUE);
  }
  if (!CAN_SEE(recep, ch)) {
    act("$n says, 'I don't deal with people I can't see!'", FALSE, recep, 0, 0, TO_ROOM);
    return (TRUE);
  }
  if (free_rent) {
    act("$n tells you, 'Rent is free here.  Just quit, and your objects will be saved!'",
	FALSE, recep, 0, ch, TO_VICT);
    return (1);
  }
  if (CMD_IS("rent")) {
    if (!(cost = Crash_offer_rent(ch, recep, FALSE, mode)))
      return (TRUE);
    if (mode == RENT_FACTOR)
      sprintf(buf, "$n tells you, 'Rent will cost you %d gold coins per day.'", cost);
    else if (mode == CRYO_FACTOR)
      sprintf(buf, "$n tells you, 'It will cost you %d gold coins to be frozen.'", cost);
    act(buf, FALSE, recep, 0, ch, TO_VICT);
    if (cost > GET_GOLD(ch) + GET_BANK_GOLD(ch)) {
      act("$n tells you, '...which I see you can't afford.'",
	  FALSE, recep, 0, ch, TO_VICT);
      return (TRUE);
    }
    if (cost && (mode == RENT_FACTOR))
      Crash_rent_deadline(ch, recep, cost);

    if (mode == RENT_FACTOR) {
      act("$n stores your belongings and helps you into your private chamber.",
	  FALSE, recep, 0, ch, TO_VICT);
      Crash_rentsave(ch, cost);
      sprintf(buf, "%s has rented (%d/day, %d tot.)", GET_NAME(ch),
	      cost, GET_GOLD(ch) + GET_BANK_GOLD(ch));
    } else {			/* cryo */
      act("$n stores your belongings and helps you into your private chamber.\r\n"
	  "A white mist appears in the room, chilling you to the bone...\r\n"
	  "You begin to lose consciousness...",
	  FALSE, recep, 0, ch, TO_VICT);
      Crash_cryosave(ch, cost);
      sprintf(buf, "%s has cryo-rented.", GET_NAME(ch));
      SET_BIT(PLR_FLAGS(ch), PLR_CRYO);
    }

    mudlog(buf, NRM, MAX(LVL_IMMORT, GET_INVIS_LEV(ch)), TRUE);
    act("$n helps $N into $S private chamber.", FALSE, recep, 0, ch, TO_NOTVICT);
    save_room = ch->in_room;
    extract_char(ch);
    save_char(ch, save_room);
  } else {
    Crash_offer_rent(ch, recep, TRUE, mode);
    act("$N gives $n an offer.", FALSE, ch, 0, recep, TO_ROOM);
  }
  return (TRUE);
}


SPECIAL(receptionist)
{
  return (gen_receptionist(ch, (struct char_data *)me, cmd, argument, RENT_FACTOR));
}


SPECIAL(cryogenicist)
{
  return (gen_receptionist(ch, (struct char_data *)me, cmd, argument, CRYO_FACTOR));
}


void Crash_save_all(void)
{
  struct descriptor_data *d;
  for (d = descriptor_list; d; d = d->next) {
    if ((STATE(d) == CON_PLAYING) && !IS_NPC(d->character)) {
      if (PLR_FLAGGED(d->character, PLR_CRASH)) {
	Crash_crashsave(d->character);
	save_char(d->character, NOWHERE);
	REMOVE_BIT(PLR_FLAGS(d->character), PLR_CRASH);
      }
    }
  }
}
::::::::::::::
oedit.c
::::::::::::::
/************************************************************************
 * OasisOLC - oedit.c						v1.5	*
 * Copyright 1996 Harvey Gilpin.					*
 * Original author: Levork						*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "spells.h"
#include "utils.h"
#include "db.h"
#include "boards.h"
#include "shop.h"
#include "olc.h"
#include "dg_olc.h"

/*------------------------------------------------------------------------*/

/*
 * External variable declarations.
 */

extern struct obj_data *obj_proto;
extern struct index_data *obj_index;
extern struct obj_data *object_list;
extern int top_of_objt;
extern struct zone_data *zone_table;
extern int top_of_zone_table;
extern struct shop_data *shop_index;
extern int top_shop;
extern struct attack_hit_type attack_hit_text[];
extern const char *item_types[];
extern const char *wear_bits[];
extern const char *extra_bits[];
extern const char *drinks[];
extern const char *apply_types[];
extern const char *container_bits[];
extern const char *spells[];
extern struct board_info_type board_info[];
extern struct descriptor_data *descriptor_list;
extern const char *perm_flags[];
extern const char *affected_bits[];

/*------------------------------------------------------------------------*/

/*
 * Handy macros.
 */
#define S_PRODUCT(s, i) ((s)->producing[(i)])

/*------------------------------------------------------------------------*/

void oedit_disp_container_flags_menu(struct descriptor_data *d);
void oedit_disp_extradesc_menu(struct descriptor_data *d);
void oedit_disp_weapon_menu(struct descriptor_data *d);
void oedit_disp_val1_menu(struct descriptor_data *d);
void oedit_disp_val2_menu(struct descriptor_data *d);
void oedit_disp_val3_menu(struct descriptor_data *d);
void oedit_disp_val4_menu(struct descriptor_data *d);
void oedit_disp_type_menu(struct descriptor_data *d);
void oedit_disp_extra_menu(struct descriptor_data *d);
void oedit_disp_wear_menu(struct descriptor_data *d);
void oedit_disp_menu(struct descriptor_data *d);

void oedit_parse(struct descriptor_data *d, char *arg);
void oedit_disp_spells_menu(struct descriptor_data *d);
void oedit_liquid_type(struct descriptor_data *d);
void oedit_setup_new(struct descriptor_data *d);
void oedit_setup_existing(struct descriptor_data *d, int real_num);
void oedit_save_to_disk(int zone);
void oedit_save_internally(struct descriptor_data *d);

void oedit_disp_perm_menu(struct descriptor_data *d);

/*------------------------------------------------------------------------*\
  Utility and exported functions
\*------------------------------------------------------------------------*/

void oedit_setup_new(struct descriptor_data *d)
{
  CREATE(OLC_OBJ(d), struct obj_data, 1);

  clear_object(OLC_OBJ(d));
  OLC_OBJ(d)->name = str_dup("unfinished object");
  OLC_OBJ(d)->description = str_dup("An unfinished object is lying here.");
  OLC_OBJ(d)->short_description = str_dup("an unfinished object");
  GET_OBJ_WEAR(OLC_OBJ(d)) = ITEM_WEAR_TAKE;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = OBJ_TRIGGER;
  oedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

void oedit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct extra_descr_data *this, *temp, *temp2;
  struct obj_data *obj;

  /*
   * Allocate object in memory.
   */
  CREATE(obj, struct obj_data, 1);

  clear_object(obj);
  *obj = obj_proto[real_num];

  /*
   * Copy all strings over.
   */
  obj->name = str_dup(obj_proto[real_num].name ? obj_proto[real_num].name : "undefined");
  obj->short_description = str_dup(obj_proto[real_num].short_description ?
		obj_proto[real_num].short_description : "undefined");
  obj->description = str_dup(obj_proto[real_num].description ?
		obj_proto[real_num].description : "undefined");
  obj->action_description = (obj_proto[real_num].action_description ?
		str_dup(obj_proto[real_num].action_description) : NULL);

  /*
   * Extra descriptions if necessary.
   */
  if (obj_proto[real_num].ex_description) {
    CREATE(temp, struct extra_descr_data, 1);

    obj->ex_description = temp;
    for (this = obj_proto[real_num].ex_description; this; this = this->next) {
      temp->keyword = (this->keyword && *this->keyword) ? str_dup(this->keyword) : NULL;
      temp->description = (this->description && *this->description) ?
		str_dup(this->description) : NULL;
      if (this->next) {
	CREATE(temp2, struct extra_descr_data, 1);
	temp->next = temp2;
	temp = temp2;
      } else
	temp->next = NULL;
    }
  }

  if (SCRIPT(obj))
    script_copy(obj, &obj_proto[real_num], OBJ_TRIGGER);

  /*
   * Attach new object to player's descriptor.
   */
  OLC_OBJ(d) = obj;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = OBJ_TRIGGER;
  dg_olc_script_copy(d);
  oedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

#define ZCMD zone_table[zone].cmd[cmd_no]

void oedit_save_internally(struct descriptor_data *d)
{
  int i, shop, robj_num, found = FALSE, zone, cmd_no;
  struct extra_descr_data *this, *next_one;
  struct obj_data *obj, *swap, *new_obj_proto;
  struct index_data *new_obj_index;
  struct descriptor_data *dsc;

  /*
   * Write object to internal tables.
   */
  if ((robj_num = real_object(OLC_NUM(d))) > 0) {
    /*
     * We need to run through each and every object currently in the
     * game to see which ones are pointing to this prototype.
     * if object is pointing to this prototype, then we need to replace it
     * with the new one.
     */
    CREATE(swap, struct obj_data, 1);

    for (obj = object_list; obj; obj = obj->next) {
      if (obj->item_number == robj_num) {
	*swap = *obj;
	*obj = *OLC_OBJ(d);
	/*
	 * Copy game-time dependent variables over.
	 */
	obj->in_room = swap->in_room;
	obj->item_number = robj_num;
	obj->carried_by = swap->carried_by;
	obj->worn_by = swap->worn_by;
	obj->worn_on = swap->worn_on;
	obj->in_obj = swap->in_obj;
	obj->contains = swap->contains;
	obj->next_content = swap->next_content;
	obj->next = swap->next;
      }
    }
    free_obj(swap);
    /*
     * It is now safe to free the old prototype and write over it.
     */
    if (obj_proto[robj_num].name)
      free(obj_proto[robj_num].name);
    if (obj_proto[robj_num].description)
      free(obj_proto[robj_num].description);
    if (obj_proto[robj_num].short_description)
      free(obj_proto[robj_num].short_description);
    if (obj_proto[robj_num].action_description)
      free(obj_proto[robj_num].action_description);
    if (obj_proto[robj_num].ex_description)
      for (this = obj_proto[robj_num].ex_description; this; this = next_one) {
	next_one = this->next;
	if (this->keyword)
	  free(this->keyword);
	if (this->description)
	  free(this->description);
	free(this);
      }
    obj_proto[robj_num] = *OLC_OBJ(d);
    obj_proto[robj_num].item_number = robj_num;
    obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
  } else {
    /*
     * It's a new object, we must build new tables to contain it.
     */
    CREATE(new_obj_index, struct index_data, top_of_objt + 2);
    CREATE(new_obj_proto, struct obj_data, top_of_objt + 2);

    /*
     * Start counting through both tables.
     */
    for (i = 0; i <= top_of_objt; i++) {
      /*
       * If we haven't found it.
       */
      if (!found) {
	/*
	 * Check if current virtual is bigger than our virtual number.
	 */
	if (obj_index[i].vnum > OLC_NUM(d)) {
	  found = TRUE;
	  robj_num = i;
	  OLC_OBJ(d)->item_number = robj_num;
	  new_obj_index[robj_num].vnum = OLC_NUM(d);
	  new_obj_index[robj_num].number = 0;
	  new_obj_index[robj_num].func = NULL;
	  new_obj_proto[robj_num] = *(OLC_OBJ(d));
          new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
	  new_obj_proto[robj_num].in_room = NOWHERE;
	  /*
	   * Copy over the mob that should be here.
	   */
	  new_obj_index[robj_num + 1] = obj_index[robj_num];
	  new_obj_proto[robj_num + 1] = obj_proto[robj_num];
	  new_obj_proto[robj_num + 1].item_number = robj_num + 1;
	} else {
	  /*
	   * Just copy from old to new, no number change.
	   */
	  new_obj_proto[i] = obj_proto[i];
	  new_obj_index[i] = obj_index[i];
	}
      } else {
	/*
	 * We HAVE already found it, therefore copy to object + 1 
	 */
	new_obj_index[i + 1] = obj_index[i];
	new_obj_proto[i + 1] = obj_proto[i];
	new_obj_proto[i + 1].item_number = i + 1;
      }
    }
    if (!found) {
      robj_num = i;
      OLC_OBJ(d)->item_number = robj_num;
      new_obj_index[robj_num].vnum = OLC_NUM(d);
      new_obj_index[robj_num].number = 0;
      new_obj_index[robj_num].func = NULL;
      new_obj_proto[robj_num] = *(OLC_OBJ(d));
      new_obj_proto[robj_num].proto_script = OLC_SCRIPT(d);
      new_obj_proto[robj_num].in_room = NOWHERE;
    }
    /*
     * Free and replace old tables.
     */
    free(obj_proto);
    free(obj_index);
    obj_proto = new_obj_proto;
    obj_index = new_obj_index;
    top_of_objt++;

    /*
     * Renumber live objects.
     */
    for (obj = object_list; obj; obj = obj->next)
      if (GET_OBJ_RNUM(obj) >= robj_num)
	GET_OBJ_RNUM(obj)++;

    /*
     * Renumber zone table.
     */
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
	switch (ZCMD.command) {
	case 'P':
	  if (ZCMD.arg3 >= robj_num)
	    ZCMD.arg3++;
	  /*
	   * No break here - drop into next case.
	   */
	case 'O':
	case 'G':
	case 'E':
	  if (ZCMD.arg1 >= robj_num)
	    ZCMD.arg1++;
	  break;
	case 'R':
	  if (ZCMD.arg2 >= robj_num)
	    ZCMD.arg2++;
	  break;
	}

    /*
     * Renumber notice boards.
     */
    for (i = 0; i < NUM_OF_BOARDS; i++)
      if (BOARD_RNUM(i) >= robj_num)
	BOARD_RNUM(i) = BOARD_RNUM(i) + 1;

    /*
     * Renumber shop produce.
     */
    for (shop = 0; shop < top_shop; shop++)
      for (i = 0; SHOP_PRODUCT(shop, i) != -1; i++)
	if (SHOP_PRODUCT(shop, i) >= robj_num)
	  SHOP_PRODUCT(shop, i)++;

    /*
     * Renumber produce in shops being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_SEDIT)
	for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != -1; i++)
	  if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
	    S_PRODUCT(OLC_SHOP(dsc), i)++;

  }
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_OBJ);
}

/*------------------------------------------------------------------------*/

void oedit_save_to_disk(int zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct obj_data *obj;
  struct extra_descr_data *ex_desc;

  sprintf(buf, "%s/%d.new", OBJ_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open objects file!", BRF, LVL_BUILDER, TRUE);
    return;
  }
  /*
   * Start running through all objects in this zone.
   */
  for (counter = zone_table[zone_num].number * 100;
       counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_object(counter)) >= 0) {
      if ((obj = (obj_proto + realcounter))->action_description) {
	strcpy(buf1, obj->action_description);
	strip_string(buf1);
      } else
	*buf1 = '\0';

      fprintf(fp,
	      "#%d\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%s~\n"
	      "%d %d %d %ld\n"
	      "%d %d %d %d %d\n"
	      "%d %d %d %d\n",

	      GET_OBJ_VNUM(obj),
	      (obj->name && *obj->name) ? obj->name : "undefined",
	      (obj->short_description && *obj->short_description) ?
			obj->short_description : "undefined",
	      (obj->description && *obj->description) ?
			obj->description : "undefined",
	      buf1, GET_OBJ_TYPE(obj), GET_OBJ_EXTRA(obj), GET_OBJ_WEAR(obj),
	      GET_OBJ_PERM(obj), GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2),
	      GET_OBJ_VAL(obj, 3), GET_OBJ_COND(obj), GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj),
	      GET_OBJ_RENT(obj), GET_OBJ_LEVEL(obj)
	      );

      script_save_to_disk(fp, obj, OBJ_TRIGGER);

      /*
       * Do we have extra descriptions? 
       */
      if (obj->ex_description) {	/* Yes, save them too. */
	for (ex_desc = obj->ex_description; ex_desc; ex_desc = ex_desc->next) {
	  /*
	   * Sanity check to prevent nasty protection faults.
	   */
	  if (!*ex_desc->keyword || !*ex_desc->description) {
	    mudlog("SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!", BRF, LVL_BUILDER, TRUE);
	    continue;
	  }
	  strcpy(buf1, ex_desc->description);
	  strip_string(buf1);
	  fprintf(fp, "E\n"
		  "%s~\n"
		  "%s~\n", ex_desc->keyword, buf1);
	}
      }
      /*
       * Do we have affects? 
       */
      for (counter2 = 0; counter2 < MAX_OBJ_AFFECT; counter2++)
	if (obj->affected[counter2].modifier)
	  fprintf(fp, "A\n"
		  "%d %d\n", obj->affected[counter2].location,
		  obj->affected[counter2].modifier);

    }
  }

  /*
   * Write the final line, close the file.
   */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.obj", OBJ_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_OBJ);
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

/*
 * For container flags.
 */
void oedit_disp_container_flags_menu(struct descriptor_data *d)
{
  get_char_cols(d->character);
  sprintbit(GET_OBJ_VAL(OLC_OBJ(d), 1), container_bits, buf1);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  sprintf(buf,
	  "%s1%s) CLOSEABLE\r\n"
	  "%s2%s) PICKPROOF\r\n"
	  "%s3%s) CLOSED\r\n"
	  "%s4%s) LOCKED\r\n"
	  "Container flags: %s%s%s\r\n"
	  "Enter flag, 0 to quit : ",
	  grn, nrm, grn, nrm, grn, nrm, grn, nrm, cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * For extra descriptions.
 */
void oedit_disp_extradesc_menu(struct descriptor_data *d)
{
  struct extra_descr_data *extra_desc = OLC_DESC(d);

  strcpy(buf1, !extra_desc->next ? "<Not set>\r\n" : "Set.");

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  sprintf(buf,
	  "Extra desc menu\r\n"
	  "%s1%s) Keyword: %s%s\r\n"
	  "%s2%s) Description:\r\n%s%s\r\n"
	  "%s3%s) Goto next description: %s\r\n"
	  "%s0%s) Quit\r\n"
	  "Enter choice : ",

     	  grn, nrm, yel, (extra_desc->keyword && *extra_desc->keyword) ? extra_desc->keyword : "<NONE>",
	  grn, nrm, yel, (extra_desc->description && *extra_desc->description) ? extra_desc->description : "<NONE>",
	  grn, nrm, buf1, grn, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_EXTRADESC_MENU;
}

/*
 * Ask for *which* apply to edit.
 */
void oedit_disp_prompt_apply_menu(struct descriptor_data *d)
{
  int counter;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < MAX_OBJ_AFFECT; counter++) {
    if (OLC_OBJ(d)->affected[counter].modifier) {
      sprinttype(OLC_OBJ(d)->affected[counter].location, apply_types, buf2);
      sprintf(buf, " %s%d%s) %+d to %s\r\n", grn, counter + 1, nrm,
	      OLC_OBJ(d)->affected[counter].modifier, buf2);
      send_to_char(buf, d->character);
    } else {
      sprintf(buf, " %s%d%s) None.\r\n", grn, counter + 1, nrm);
      send_to_char(buf, d->character);
    }
  }
  send_to_char("\r\nEnter affection to modify (0 to quit) : ", d->character);
  OLC_MODE(d) = OEDIT_PROMPT_APPLY;
}

/*
 * Ask for liquid type.
 */
void oedit_liquid_type(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_LIQ_TYPES; counter++) {
    sprintf(buf, " %s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
	    drinks[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n%sEnter drink type : ", nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_VALUE_3;
}

/*
 * The actual apply to set.
 */
void oedit_disp_apply_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_APPLIES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		apply_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter apply type (0 is no apply) : ", d->character);
  OLC_MODE(d) = OEDIT_APPLY;
}

/*
 * Weapon type.
 */
void oedit_disp_weapon_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_ATTACK_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		attack_hit_text[counter].singular,
		!(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter weapon type : ", d->character);
}

/*
 * Spell type.
 */
void oedit_disp_spells_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 1; counter < MAX_SPELLS; counter++) {
	if(str_cmp(spells[counter], "!UNUSED!")){
	    sprintf(buf, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
			spells[counter], !(++columns % 3) ? "\r\n" : "");
	    send_to_char(buf, d->character);
	}
  }
  sprintf(buf, "\r\n%sEnter spell choice (0 for none) : ", nrm);
  send_to_char(buf, d->character);
}

/*
 * Object value #1
 */
void oedit_disp_val1_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_1;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_LIGHT:
    /*
     * values 0 and 1 are unused.. jump to 2 
     */
    oedit_disp_val3_menu(d);
    break;
  case ITEM_SCROLL:
  case ITEM_WAND:
  case ITEM_STAFF:
  case ITEM_POTION:
    send_to_char("Spell level : ", d->character);
    break;
  case ITEM_WEAPON:
    /*
     * This doesn't seem to be used if I remembe right.
     */
    send_to_char("Modifier to Hitroll : ", d->character);
    break;
  case ITEM_ARMOR:
    send_to_char("Apply to AC : ", d->character);
    break;
  case ITEM_CONTAINER:
    send_to_char("Max weight to contain : ", d->character);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    send_to_char("Max drink units : ", d->character);
    break;
  case ITEM_FOOD:
    send_to_char("Hours to fill stomach : ", d->character);
    break;
  case ITEM_MONEY:
    send_to_char("Number of gold coins : ", d->character);
    break;
  case ITEM_NOTE:
    /*
     * This is supposed to be language, but it's unused.
     */
    break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object value #2
 */
void oedit_disp_val2_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_2;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_SCROLL:
  case ITEM_POTION:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    send_to_char("Max number of charges : ", d->character);
    break;
  case ITEM_WEAPON:
    send_to_char("Number of damage dice : ", d->character);
    break;
  case ITEM_FOOD:
    /*
     * Values 2 and 3 are unused, jump to 4...Odd.
     */
    oedit_disp_val4_menu(d);
    break;
  case ITEM_CONTAINER:
    /*
     * These are flags, needs a bit of special handling.
     */
    oedit_disp_container_flags_menu(d);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    send_to_char("Initial drink units : ", d->character);
    break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object value #3
 */
void oedit_disp_val3_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_3;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_LIGHT:
    send_to_char("Number of hours (0 = burnt, -1 is infinite) : ", d->character);
    break;
  case ITEM_SCROLL:
  case ITEM_POTION:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WAND:
  case ITEM_STAFF:
    send_to_char("Number of charges remaining : ", d->character);
    break;
  case ITEM_WEAPON:
    send_to_char("Size of damage dice : ", d->character);
    break;
  case ITEM_CONTAINER:
    send_to_char("Vnum of key to open container (-1 for no key) : ", d->character);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
    oedit_liquid_type(d);
    break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object value #4
 */
void oedit_disp_val4_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = OEDIT_VALUE_4;
  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
  case ITEM_SCROLL:
  case ITEM_POTION:
  case ITEM_WAND:
  case ITEM_STAFF:
    oedit_disp_spells_menu(d);
    break;
  case ITEM_WEAPON:
    oedit_disp_weapon_menu(d);
    break;
  case ITEM_DRINKCON:
  case ITEM_FOUNTAIN:
  case ITEM_FOOD:
    send_to_char("Poisoned (0 = not poison) : ", d->character);
    break;
  default:
    oedit_disp_menu(d);
  }
}

/*
 * Object type.
 */
void oedit_disp_type_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_ITEM_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		item_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter object type : ", d->character);
}

/*
 * Object extra flags.
 */
void oedit_disp_extra_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_ITEM_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		extra_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_EXTRA(OLC_OBJ(d)), extra_bits, buf1);
  sprintf(buf, "\r\nObject flags: %s%s%s\r\n"
	  "Enter object extra flag (0 to quit) : ",
	  cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * Object perm flags.
 */
void oedit_disp_perm_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  if (GET_LEVEL(d->character) < LVL_OLC_FULL) {
    for (counter = 0; counter < NUM_AFF_FLAGS; counter++) {
      sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
                  perm_flags[counter], !(++columns % 2) ? "\r\n" : "");
      send_to_char(buf, d->character);
    }
    sprintf(buf, "&R-->&n Objects marked with a * are NOT to be set.\r\n");
    send_to_char(buf, d->character);
    sprintbit(GET_OBJ_PERM(OLC_OBJ(d)), perm_flags, buf1);
  } else {
    for (counter = 0; counter < NUM_AFF_FLAGS; counter++) {
      sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
                  affected_bits[counter], !(++columns % 2) ? "\r\n" : "");
      send_to_char(buf, d->character);
    }
    sprintbit(GET_OBJ_PERM(OLC_OBJ(d)), affected_bits, buf1);
  }
  sprintf(buf, "\r\nObject perm flags: %s%s%s\r\n"
          "Enter object perm flag (0 to quit) : ",
          cyn, buf1, nrm);
  send_to_char(buf, d->character);
}


/*
 * Object wear flags.
 */
void oedit_disp_wear_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_ITEM_WEARS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		wear_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(GET_OBJ_WEAR(OLC_OBJ(d)), wear_bits, buf1);
  sprintf(buf, "\r\nWear flags: %s%s%s\r\n"
	  "Enter wear flag, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
}

/*
 * Display main menu.
 */
void oedit_disp_menu(struct descriptor_data *d)
{
  struct obj_data *obj;

  obj = OLC_OBJ(d);
  get_char_cols(d->character);

  /*
   * Build buffers for first part of menu.
   */
  sprinttype(GET_OBJ_TYPE(obj), item_types, buf1);
  sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf2);

  /*
   * Build first half of menu.
   */
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  "-- Item number : [%s%d%s]\r\n"
	  "%s1%s) Namelist : %s%s\r\n"
	  "%s2%s) S-Desc   : %s%s\r\n"
	  "%s3%s) L-Desc   :-\r\n%s%s\r\n"
	  "%s4%s) A-Desc   :-\r\n%s%s"
	  "%s5%s) Type        : %s%s\r\n"
	  "%s6%s) Extra flags : %s%s\r\n",

	  cyn, OLC_NUM(d), nrm,
	  grn, nrm, yel, (obj->name && *obj->name) ? obj->name : "undefined",
	  grn, nrm, yel, (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
	  grn, nrm, yel, (obj->description && *obj->description) ? obj->description : "undefined",
	  grn, nrm, yel, (obj->action_description && *obj->action_description) ? obj->action_description : "<not set>\r\n",
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2
	  );
  /*
   * Send first half.
   */
  send_to_char(buf, d->character);

  /*
   * Build second half of menu.
   */
  sprintbit(GET_OBJ_WEAR(obj), wear_bits, buf1);
   if (GET_LEVEL(d->character) < LVL_OLC_FULL)
    sprintbit(GET_OBJ_PERM(obj), perm_flags, buf2);
  else
    sprintbit(GET_OBJ_PERM(obj), affected_bits, buf2);
  sprintf(buf,
	  "%s7%s) Wear flags  : %s%s\r\n"
	  "%s8%s) Weight      : %s%d\r\n"
	  "%s9%s) Cost        : %s%d\r\n"
	  "%sA%s) Cost/Day    : %s%d\r\n"
	  "%sB%s) Timer       : %s%d\r\n"
	  "%sC%s) Values      : %s%d %d %d %d\r\n"
	  "%sD%s) Applies menu\r\n"
	  "%sE%s) Extra descriptions menu\r\n"
          "%sM%s) Min Level   : %s%d\r\n"
          "%sP%s) Perm Affects: %s%s\r\n"
          "%sT%s) Condition   : %s%d\r\n"
          "%sS%s) Script      : %s%s\r\n"
          "%sR%s) Remort      : %s%d\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, GET_OBJ_WEIGHT(obj),
	  grn, nrm, cyn, GET_OBJ_COST(obj),
	  grn, nrm, cyn, GET_OBJ_RENT(obj),
	  grn, nrm, cyn, GET_OBJ_TIMER(obj),
	  grn, nrm, cyn, GET_OBJ_VAL(obj, 0),
	  GET_OBJ_VAL(obj, 1),
	  GET_OBJ_VAL(obj, 2),
	  GET_OBJ_VAL(obj, 3),
	  grn, nrm, grn, nrm, 
	  grn, nrm, cyn, (GET_OBJ_LEVEL(obj)-(div(GET_OBJ_LEVEL(obj), (LVL_IMMORT-1)).quot)*(LVL_IMMORT-1)),
          grn, nrm, cyn, buf2,
	  grn, nrm, cyn, GET_OBJ_COND(obj),
          grn, nrm, cyn, obj->proto_script?"Set.":"Not Set.",
	  grn, nrm, cyn, div(GET_OBJ_LEVEL(obj), (LVL_IMMORT-1)).quot,
          grn, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = OEDIT_MAIN_MENU;
}

/***************************************************************************
 main loop (of sorts).. basically interpreter throws all input to here
 ***************************************************************************/

void oedit_parse(struct descriptor_data *d, char *arg)
{
  int number, max_val, min_val;

  switch (OLC_MODE(d)) {

  case OEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      send_to_char("Saving object to memory.\r\n", d->character);
      oedit_save_internally(d);
      sprintf(buf, "OLC: %s edits obj %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      cleanup_olc(d, CLEANUP_STRUCTS);
      return;
    case 'n':
    case 'N':
      /*
       * Cleanup all.
       */
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save this object internally?\r\n", d->character);
      return;
    }

  case OEDIT_MAIN_MENU:
    /*
     * Throw us out to whichever edit mode based on user input.
     */
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {	/* Something has been modified. */
	send_to_char("Do you wish to save this object internally? : ", d->character);
	OLC_MODE(d) = OEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter namelist : ", d->character);
      OLC_MODE(d) = OEDIT_EDIT_NAMELIST;
      break;
    case '2':
      send_to_char("Enter short desc : ", d->character);
      OLC_MODE(d) = OEDIT_SHORTDESC;
      break;
    case '3':
      send_to_char("Enter long desc :-\r\n| ", d->character);
      OLC_MODE(d) = OEDIT_LONGDESC;
      break;
    case '4':
      OLC_MODE(d) = OEDIT_ACTDESC;
      SEND_TO_Q("Enter action description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_OBJ(d)->action_description) {
	SEND_TO_Q(OLC_OBJ(d)->action_description, d);
	d->backstr = str_dup(OLC_OBJ(d)->action_description);
      }
      d->str = &OLC_OBJ(d)->action_description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '5':
      oedit_disp_type_menu(d);
      OLC_MODE(d) = OEDIT_TYPE;
      break;
    case '6':
      oedit_disp_extra_menu(d);
      OLC_MODE(d) = OEDIT_EXTRAS;
      break;
    case '7':
      oedit_disp_wear_menu(d);
      OLC_MODE(d) = OEDIT_WEAR;
      break;
    case '8':
      send_to_char("Enter weight : ", d->character);
      OLC_MODE(d) = OEDIT_WEIGHT;
      break;
    case '9':
      send_to_char("Enter cost : ", d->character);
      OLC_MODE(d) = OEDIT_COST;
      break;
    case 'a':
    case 'A':
      send_to_char("Enter cost per day : ", d->character);
      OLC_MODE(d) = OEDIT_COSTPERDAY;
      break;
    case 'b':
    case 'B':
      send_to_char("Enter timer : ", d->character);
      OLC_MODE(d) = OEDIT_TIMER;
      break;
    case 'c':
    case 'C':
      /*
       * Clear any old values  
       */
      GET_OBJ_VAL(OLC_OBJ(d), 0) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 1) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 2) = 0;
      GET_OBJ_VAL(OLC_OBJ(d), 3) = 0;
      oedit_disp_val1_menu(d);
      break;
    case 'd':
    case 'D':
      oedit_disp_prompt_apply_menu(d);
      break;
    case 'e':
    case 'E':
      /*
       * If extra descriptions don't exist.
       */
      if (!OLC_OBJ(d)->ex_description) {
	CREATE(OLC_OBJ(d)->ex_description, struct extra_descr_data, 1);
	OLC_OBJ(d)->ex_description->next = NULL;
      }
      OLC_DESC(d) = OLC_OBJ(d)->ex_description;
      oedit_disp_extradesc_menu(d);
      break;
    case 'm':
    case 'M':
       send_to_char("Enter minimum Level: ", d->character);
       OLC_MODE(d) = OEDIT_OBJ_LEVEL;
       break;
    case 'p':
    case 'P':
       oedit_disp_perm_menu(d);
       OLC_MODE(d) = OEDIT_PERM;
       break;
    case 't':
    case 'T':
       send_to_char("Enter object condition: ", d->character);
       OLC_MODE(d) = OEDIT_OBJ_CONDITION;
       break;
    case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
    case 'r':
    case 'R':
       send_to_char("Enter remort: ", d->character);
       OLC_MODE(d) = OEDIT_OBJ_REMORT;
       break;
    default:
      oedit_disp_menu(d);
      break;
    }
    return;			/*
				 * end of OEDIT_MAIN_MENU 
				 */

  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;

  case OEDIT_EDIT_NAMELIST:
    if (OLC_OBJ(d)->name)
      free(OLC_OBJ(d)->name);
    OLC_OBJ(d)->name = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_SHORTDESC:
    if (OLC_OBJ(d)->short_description)
      free(OLC_OBJ(d)->short_description);
    OLC_OBJ(d)->short_description = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_LONGDESC:
    if (OLC_OBJ(d)->description)
      free(OLC_OBJ(d)->description);
    OLC_OBJ(d)->description = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case OEDIT_TYPE:
    number = atoi(arg);
    if ((number < 1) || (number >= NUM_ITEM_TYPES)) {
      send_to_char("Invalid choice, try again : ", d->character);
      return;
    } else
      GET_OBJ_TYPE(OLC_OBJ(d)) = number;
    break;

  case OEDIT_EXTRAS:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ITEM_FLAGS)) {
      oedit_disp_extra_menu(d);
      return;
    } else if (number == 0)
      break;
    else {
      TOGGLE_BIT(GET_OBJ_EXTRA(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_extra_menu(d);
      return;
    }

  case OEDIT_WEAR:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ITEM_WEARS)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      oedit_disp_wear_menu(d);
      return;
    } else if (number == 0)	/* Quit. */
      break;
    else {
      TOGGLE_BIT(GET_OBJ_WEAR(OLC_OBJ(d)), 1 << (number - 1));
      oedit_disp_wear_menu(d);
      return;
    }

  case OEDIT_WEIGHT:
    GET_OBJ_WEIGHT(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_COST:
    GET_OBJ_COST(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_COSTPERDAY:
    GET_OBJ_RENT(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_TIMER:
    GET_OBJ_TIMER(OLC_OBJ(d)) = atoi(arg);
    break;

  case OEDIT_OBJ_LEVEL:
     GET_OBJ_LEVEL(OLC_OBJ(d)) = (div(GET_OBJ_LEVEL(OLC_OBJ(d)), (LVL_IMMORT-1)).quot*(LVL_IMMORT-1))+(MAX(1, MIN((LVL_IMMORT-2), atoi(arg))));
     break;
 
  case OEDIT_PERM:
     number = atoi(arg);
     if ((number < 0) || (number > NUM_AFF_FLAGS)) {
       oedit_disp_perm_menu(d);
       return;
     } else if (number == 0)
       break;
     else {
       TOGGLE_BIT(GET_OBJ_PERM(OLC_OBJ(d)), 1 << (number - 1));
       oedit_disp_perm_menu(d);
       return;
     }

  case OEDIT_OBJ_CONDITION:

    if(GET_LEVEL(d->character) > 201){ 
     GET_OBJ_COND(OLC_OBJ(d)) = MAX(1, MIN(101, atoi(arg)));
    } else
     GET_OBJ_COND(OLC_OBJ(d)) = MAX(1, MIN(100, atoi(arg)));

    break;

  case OEDIT_OBJ_REMORT:
     GET_OBJ_LEVEL(OLC_OBJ(d)) = (GET_OBJ_LEVEL(OLC_OBJ(d))-(div(GET_OBJ_LEVEL(OLC_OBJ(d)), (LVL_IMMORT-1)).quot*(LVL_IMMORT-1)))+(MAX(0, MIN(12, atoi(arg)))*(LVL_IMMORT-1));
     break;
           
  case OEDIT_VALUE_1:
    /*
     * Lucky, I don't need to check any of these for out of range values.
     * Hmm, I'm not so sure - Rv  
     */
    GET_OBJ_VAL(OLC_OBJ(d), 0) = atoi(arg);
    /*
     * proceed to menu 2 
     */
    oedit_disp_val2_menu(d);
    return;
  case OEDIT_VALUE_2:
    /*
     * Here, I do need to check for out of range values.
     */
    number = atoi(arg);
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      if (number < -1 || number >= TRUE_TOP_SPELL_DEFINE)
        oedit_disp_val2_menu(d);
      else {
        GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
        oedit_disp_val3_menu(d);
      }
      break;
    case ITEM_CONTAINER:
      /*
       * Needs some special handling since we are dealing with flag values
       * here.
       */
      if (number < 0 || number > 4)
	oedit_disp_container_flags_menu(d);
      else if (number != 0) {
        TOGGLE_BIT(GET_OBJ_VAL(OLC_OBJ(d), 1), 1 << (number - 1));
        OLC_VAL(d) = 1;
	oedit_disp_val2_menu(d);
      } else
	oedit_disp_val3_menu(d);
      break;

    default:
      GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
      oedit_disp_val3_menu(d);
    }
    return;

  case OEDIT_VALUE_3:
    number = atoi(arg);
    /*
     * Quick'n'easy error checking.
     */
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      min_val = -1;
      max_val = TRUE_TOP_SPELL_DEFINE;
      break;
    case ITEM_WEAPON:
      min_val = 1;
      max_val = 50;
    case ITEM_WAND:
    case ITEM_STAFF:
      min_val = 0;
      max_val = 20;
      break;
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
      min_val = 0;
      max_val = NUM_LIQ_TYPES - 1;
      break;
    default:
      min_val = -32000;
      max_val = 32000;
    }
    GET_OBJ_VAL(OLC_OBJ(d), 2) = MAX(min_val, MIN(number, max_val));
    oedit_disp_val4_menu(d);
    return;

  case OEDIT_VALUE_4:
    number = atoi(arg);
    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      min_val = -1;
      max_val = TRUE_TOP_SPELL_DEFINE;
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      min_val = 1;
      max_val = TOP_SPELL_DEFINE;
      break;
    case ITEM_WEAPON:
      min_val = 0;
      max_val = NUM_ATTACK_TYPES - 1;
      break;
    default:
      min_val = -32000;
      max_val = 32000;
      break;
    }
    GET_OBJ_VAL(OLC_OBJ(d), 3) = MAX(min_val, MIN(number, max_val));
    break;

  case OEDIT_PROMPT_APPLY:
    if ((number = atoi(arg)) == 0)
      break;
    else if (number < 0 || number > MAX_OBJ_AFFECT) {
      oedit_disp_prompt_apply_menu(d);
      return;
    }
    OLC_VAL(d) = number - 1;
    OLC_MODE(d) = OEDIT_APPLY;
    oedit_disp_apply_menu(d);
    return;

  case OEDIT_APPLY:
    if ((number = atoi(arg)) == 0) {
      OLC_OBJ(d)->affected[OLC_VAL(d)].location = 0;
      OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = 0;
      oedit_disp_prompt_apply_menu(d);
    } else if (number < 0 || number >= NUM_APPLIES)
      oedit_disp_apply_menu(d);
    else {
      OLC_OBJ(d)->affected[OLC_VAL(d)].location = number;
      send_to_char("Modifier : ", d->character);
      OLC_MODE(d) = OEDIT_APPLYMOD;
    }
    return;

  case OEDIT_APPLYMOD:
    OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = atoi(arg);
    oedit_disp_prompt_apply_menu(d);
    return;

  case OEDIT_EXTRADESC_KEY:
    if (OLC_DESC(d)->keyword)
      free(OLC_DESC(d)->keyword);
    OLC_DESC(d)->keyword = str_dup((arg && *arg) ? arg : "undefined");
    oedit_disp_extradesc_menu(d);
    return;

  case OEDIT_EXTRADESC_MENU:
    switch ((number = atoi(arg))) {
    case 0:
      if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	struct extra_descr_data **tmp_desc;

	if (OLC_DESC(d)->keyword)
	  free(OLC_DESC(d)->keyword);
	if (OLC_DESC(d)->description)
	  free(OLC_DESC(d)->description);

	/*
	 * Clean up pointers  
	 */
	for (tmp_desc = &(OLC_OBJ(d)->ex_description); *tmp_desc;
	     tmp_desc = &((*tmp_desc)->next)) {
	  if (*tmp_desc == OLC_DESC(d)) {
	    *tmp_desc = NULL;
	    break;
	  }
	}
	free(OLC_DESC(d));
      }
    break;

    case 1:
      OLC_MODE(d) = OEDIT_EXTRADESC_KEY;
      send_to_char("Enter keywords, separated by spaces :-\r\n| ", d->character);
      return;

    case 2:
      OLC_MODE(d) = OEDIT_EXTRADESC_DESCRIPTION;
      SEND_TO_Q("Enter the extra description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_DESC(d)->description) {
	SEND_TO_Q(OLC_DESC(d)->description, d);
	d->backstr = str_dup(OLC_DESC(d)->description);
      }
      d->str = &OLC_DESC(d)->description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      return;

    case 3:
      /*
       * Only go to the next description if this one is finished.
       */
      if (OLC_DESC(d)->keyword && OLC_DESC(d)->description) {
	struct extra_descr_data *new_extra;

	if (OLC_DESC(d)->next)
	  OLC_DESC(d) = OLC_DESC(d)->next;
	else {	/* Make new extra description and attach at end. */
	  CREATE(new_extra, struct extra_descr_data, 1);
	  OLC_DESC(d)->next = new_extra;
	  OLC_DESC(d) = OLC_DESC(d)->next;
	}
      }
      /*
       * No break - drop into default case.
       */
    default:
      oedit_disp_extradesc_menu(d);
      return;
    }
    break;
  default:
    mudlog("SYSERR: OLC: Reached default case in oedit_parse()!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }

  /*
   * If we get here, we have changed something.  
   */
  OLC_VAL(d) = 1;
  oedit_disp_menu(d);
}
::::::::::::::
olc.c
::::::::::::::
/***************************************************************************
 *  OasisOLC - olc.c 		                                           *
 *    				                                           *
 *  Copyright 1996 Harvey Gilpin.                                          *
 ***************************************************************************/
 
#define _OASIS_OLC_
 
#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "interpreter.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "olc.h"
#include "dg_olc.h"
#include "screen.h"
#include "handler.h"
#include "quest.h"

/*
 * External data structures.
 */
extern struct obj_data *obj_proto;
extern struct char_data *mob_proto;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct room_data *world;
extern int top_of_zone_table;
extern struct social_messg *soc_mess_list;
extern int top_of_socialt;
extern int top_of_world;
extern int rev_dir[];
extern const char *dirs[];
extern struct zone_data *zone_table;
extern struct descriptor_data *descriptor_list;
  
/*
 * External functions.
 */
extern int zedit_setup(struct descriptor_data *d, int room_num);
extern int zedit_save_to_disk(int zone);
extern int zedit_new_zone(struct char_data *ch, int new_zone);
extern int medit_setup_new(struct descriptor_data *d);
extern int medit_setup_existing(struct descriptor_data *d, int rmob_num);
extern int medit_save_to_disk(int zone);
extern int redit_setup_new(struct descriptor_data *d);
extern int redit_setup_existing(struct descriptor_data *d, int rroom_num);
extern void redit_save_internally(struct descriptor_data *d);
extern int redit_save_to_disk(int zone);
extern int oedit_setup_new(struct descriptor_data *d);
extern int oedit_setup_existing(struct descriptor_data *d, int robj_num);
extern int oedit_save_to_disk(int zone);
extern int sedit_setup_new(struct descriptor_data *d);
extern int sedit_setup_existing(struct descriptor_data *d, int robj_num);
extern int sedit_save_to_disk(int zone);
extern int real_shop(int vnum);
extern int free_shop(struct shop_data *shop);
extern int free_room(struct room_data *room);
extern void medit_free_mobile(struct char_data *mob);
extern void trigedit_setup_new(struct descriptor_data *d);
extern void trigedit_setup_existing(struct descriptor_data *d, int rtrg_num);
extern int real_trigger(int vnum);
extern int hedit_save_to_disk(void);
extern int free_help(struct help_index_element *help);
int find_help_rnum(char *keyword);
extern int hedit_setup_new(struct descriptor_data *d, char *new_key);
extern int hedit_setup_existing(struct descriptor_data *d, int rnum);
extern int aedit_save_to_disk(struct descriptor_data *d);
extern int free_action(struct social_messg *action);
extern int find_action(int cmd);
int is_name(const char *str, const char *namelist);
extern void qedit_setup_new(struct descriptor_data *d);
extern void qedit_setup_existing(struct descriptor_data *d, int real_num);
extern void qedit_save_to_disk(int znum);
extern void free_quest(struct aq_data *quest);

/*
 * Internal function prototypes.
 */
int can_edit_zone(struct char_data *ch, int number);
int real_zone(int number);
void olc_saveinfo(struct char_data *ch);

/*
 * Global string constants.
 */
const char *save_info_msg[9] = {"Rooms", "Objects", "Zone info",
	"Mobiles", "Shops", "Triggers", "Help", "Actions", "Quests"}; 
 
/*
 * Internal data structures.
 */

struct olc_scmd_data {
  char *text;
  int con_type;
};
  
struct olc_scmd_data olc_scmd_info[9] =
{
  {"room", CON_REDIT},
  {"object", CON_OEDIT},
  {"room", CON_ZEDIT},
  {"mobile", CON_MEDIT},
  {"shop", CON_SEDIT},
  {"help", CON_HEDIT},
  {"action", CON_AEDIT},
  {"trigger", CON_TRIGEDIT},
  {"quest", CON_QEDIT}
};
  
 /*------------------------------------------------------------*/
 
 /*
  * Exported ACMD do_olc function.
  *
  * This function is the OLC interface.  It deals with all the 
  * generic OLC stuff, then passes control to the sub-olc sections.
  */
  
  ACMD(do_olc)
  {
   int number = -1, save = 0, real_num;
   struct descriptor_data *d;
 
   /*
    * No screwing around as a mobile.
    */
   if (IS_NPC(ch))
      return;
  
   if (subcmd == SCMD_OLC_SAVEINFO) {
     olc_saveinfo(ch);
      return;
    }
  
   /*
    * Parse any arguments.
    */
   two_arguments(argument, buf1, buf2);
   if (!*buf1) {		/* No argument given. */
     switch (subcmd) {
     case SCMD_OLC_ZEDIT:
     case SCMD_OLC_REDIT:
       number = world[IN_ROOM(ch)].number;
       break;
     case SCMD_OLC_TRIGEDIT:
     case SCMD_OLC_OEDIT:
     case SCMD_OLC_MEDIT:
     case SCMD_OLC_SEDIT:
     case SCMD_OLC_QEDIT:
       sprintf(buf, "Specify a %s VNUM to edit.\r\n", olc_scmd_info[subcmd].text);
       send_to_char(buf, ch);
       return;
     case SCMD_OLC_HEDIT:
       /*
        * Altered as a nitpick.  Why waste a sprintf() call when you know
        * that it's going to be a help entry?  TR 5-18-98
        */
       send_to_char("Specify a help entry to edit.\r\n", ch);
       return;
     case SCMD_OLC_AEDIT:
       send_to_char("Specify an action to edit.\r\n", ch);
       return;
     }
   } else if (!isdigit(*buf1)) {
     if (strn_cmp("save", buf1, 4) == 0) {
       if ((subcmd == SCMD_OLC_HEDIT) || (subcmd == SCMD_OLC_AEDIT)) {
         save = 1;
         number = 0;
       } else if (!*buf2) {
 	 send_to_char("Save which zone?\r\n", ch);
   	 return;
       } else {
 	 save = 1;
 	 number = atoi(buf2) * 100;
       }
     } else if ((subcmd == SCMD_OLC_HEDIT) || (subcmd == SCMD_OLC_AEDIT))
       number = 0;
     else if (subcmd == SCMD_OLC_ZEDIT && GET_LEVEL(ch) >= LVL_OLC_FULL) {
       if ((strn_cmp("new", buf1, 3) == 0) && *buf2)
 	zedit_new_zone(ch, atoi(buf2));
       else
 	send_to_char("Specify a new zone number.\r\n", ch);
       return;
     } else {
       send_to_char("Yikes!  Stop that, someone will get hurt!\r\n", ch);
       return;
     }
   }
   /*
    * If a numeric argument was given, get it.
    */
   if ((number == -1) && ((subcmd != SCMD_OLC_AEDIT) || (subcmd != SCMD_OLC_HEDIT)))
     number = atoi(buf1);
 
   /*
    * Check that whatever it is isn't already being edited.
    */
   for (d = descriptor_list; d; d = d->next)
     if (d->connected == olc_scmd_info[subcmd].con_type)
       if (d->olc && OLC_NUM(d) == number) {
	if (subcmd == SCMD_OLC_HEDIT)
	  sprintf(buf, "Help files are already being editted by %s.\r\n",
		  (CAN_SEE(ch, d->character) ? GET_NAME(d->character) : "someone"));
	else if (subcmd == SCMD_OLC_AEDIT)
          sprintf(buf, "Help files are already being editted by %s.\r\n",
		  (CAN_SEE(ch, d->character) ? GET_NAME(d->character) : "someone"));
        else
	  sprintf(buf, "That %s is currently being edited by %s.\r\n",
 		olc_scmd_info[subcmd].text, GET_NAME(d->character));
 	send_to_char(buf, ch);
 	return;
       }
   d = ch->desc;
  
   /*
    * Give descriptor an OLC struct.
    */
   CREATE(d->olc, struct olc_data, 1);
 
   /*
    * Find the zone (or help rnum).
    */
   if (subcmd != SCMD_OLC_AEDIT) {
     if (subcmd == SCMD_OLC_HEDIT && !save)
       OLC_ZNUM(d) = find_help_rnum(buf1);
     else if ((OLC_ZNUM(d) = real_zone(number)) == -1) {
       send_to_char("Sorry, there is no zone for that number!\r\n", ch);
       free(d->olc);
       return;
     }
   }
   /*
    * Everyone but IMPLs can only edit zones they have been assigned.
    */
  if (GET_LEVEL(ch) < LVL_BUILDER)
  {
      if (subcmd == SCMD_OLC_HEDIT && GET_OLC_ZONE(ch) != HEDIT_PERMISSION) 
     {
       send_to_char("You do not have permssion to edit help entries.\r\n", ch);
       free(d->olc);
       return;
     }
  }   
   if (GET_LEVEL(ch) < LVL_OLC_FULL)
  {
    
       if (subcmd == SCMD_OLC_AEDIT && GET_OLC_ZONE(ch) != AEDIT_PERMISSION) 
     {
       send_to_char("You do not have permission to edit actions.\r\n", ch);
       free(d->olc);
       return;
     } 
       else if (subcmd == SCMD_OLC_QEDIT && GET_OLC_ZONE(ch) != QEDIT_PERMISSION) 
     {
       send_to_char("You do not have permission to edit quests.\r\n", ch);
       free(d->olc);
       return;
     } 
       else if (subcmd == SCMD_OLC_TRIGEDIT && GET_OLC_ZONE(ch) != TRIGEDIT_PERMISSION) 
     {
       send_to_char("You do not have permission to edit triggers.\r\n", ch);
       free(d->olc);
       return;
     } else if (subcmd != SCMD_OLC_AEDIT && subcmd != SCMD_OLC_HEDIT &&
            subcmd != SCMD_OLC_QEDIT && subcmd != SCMD_OLC_TRIGEDIT &&
            !can_edit_zone(ch, OLC_ZNUM(d)))
     {
       send_to_char("You do not have permission to edit this zone.\r\n", ch);
       free(d->olc);
       return;
     }
  }

   if (save) {
     const char *type = NULL;
  
     switch (subcmd) {
     /*
      * Removed as a nitpick.  Why do something if it's unnecessary?
      * (cases for AEDIT and HEDIT removed)
      */
     case SCMD_OLC_AEDIT: type = "action"; break;
     case SCMD_OLC_HEDIT: type = "help"; break;
     case SCMD_OLC_REDIT: type = "room"; break;
     case SCMD_OLC_ZEDIT: type = "zone"; break;
     case SCMD_OLC_SEDIT: type = "shop"; break;
     case SCMD_OLC_MEDIT: type = "mobile"; break;
     case SCMD_OLC_OEDIT: type = "object"; break;
     case SCMD_OLC_QEDIT: type = "quest"; break;
     }
     if (!type) {
       send_to_char("Oops, I forgot what you wanted to save.\r\n", ch);
       return;
     }
     if (subcmd == SCMD_OLC_HEDIT) {
       send_to_char("Saving all help entries.\r\n", ch);
       sprintf(buf, "OLC: %s saves help entries.", GET_NAME(ch));
       mudlog(buf, NRM, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE);
     } else if (subcmd == SCMD_OLC_AEDIT) {
       send_to_char("Saving all actions.\r\n", ch);
       sprintf(buf, "OLC: %s saves all actions.", GET_NAME(ch));
       mudlog(buf, NRM, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE);
     } else {
       sprintf(buf, "Saving all %ss in zone %d.\r\n",
 		type, zone_table[OLC_ZNUM(d)].number);
       send_to_char(buf, ch);
       sprintf(buf, "OLC: %s saves %s info for zone %d.", GET_NAME(ch),  type,
 		zone_table[OLC_ZNUM(d)].number);
       mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE);
     }
 
     switch (subcmd) {
     case SCMD_OLC_REDIT: redit_save_to_disk(OLC_ZNUM(d)); break;
     case SCMD_OLC_ZEDIT: zedit_save_to_disk(OLC_ZNUM(d)); break;
     case SCMD_OLC_OEDIT: oedit_save_to_disk(OLC_ZNUM(d)); break;
     case SCMD_OLC_MEDIT: medit_save_to_disk(OLC_ZNUM(d)); break;
     case SCMD_OLC_SEDIT: sedit_save_to_disk(OLC_ZNUM(d)); break;
     case SCMD_OLC_QEDIT: qedit_save_to_disk(OLC_ZNUM(d)); break;
     case SCMD_OLC_HEDIT: hedit_save_to_disk(); break;
     case SCMD_OLC_AEDIT: aedit_save_to_disk(d); break;
     }
     free(d->olc);
     return;
   }

   if (subcmd != SCMD_OLC_AEDIT) OLC_NUM(d) = number;
   else {
     OLC_NUM(d) = 0;
     OLC_STORAGE(d) = str_dup(buf1);
     for (OLC_ZNUM(d) = 0; (OLC_ZNUM(d) <= top_of_socialt); OLC_ZNUM(d)++)
       if (is_abbrev(OLC_STORAGE(d), soc_mess_list[OLC_ZNUM(d)].command))
         break;
     if (OLC_ZNUM(d) > top_of_socialt)  {
       if (find_command(OLC_STORAGE(d)) > NOTHING)  {
         cleanup_olc(d, CLEANUP_ALL);
         send_to_char("That command already exists.\r\n", ch);
         return;
       }
       sprintf(buf, "Do you wish to add the '%s' action? ", OLC_STORAGE(d));
       send_to_char(buf, ch);
       OLC_MODE(d) = AEDIT_CONFIRM_ADD;
     } else  {
       sprintf(buf, "Do you wish to edit the '%s' action? ", soc_mess_list[OLC_ZNUM(d)].command);
       send_to_char(buf, ch);
       OLC_MODE(d) = AEDIT_CONFIRM_EDIT;
     }
   }
 
   /*
    * Steal player's descriptor start up subcommands.
    */
   switch (subcmd) {
   case SCMD_OLC_TRIGEDIT:
     if ((real_num = real_trigger(number)) >= 0)
       trigedit_setup_existing(d, real_num);
     else
       trigedit_setup_new(d);
     STATE(d) = CON_TRIGEDIT;
     break;
   case SCMD_OLC_REDIT:
     if ((real_num = real_room(number)) >= 0)
       redit_setup_existing(d, real_num);
     else
       redit_setup_new(d);
     STATE(d) = CON_REDIT;
      break;
   case SCMD_OLC_ZEDIT:
     if ((real_num = real_room(number)) < 0) {
       send_to_char("That room does not exist.\r\n", ch);
       free(d->olc);
       return;
     }
     zedit_setup(d, real_num);
     STATE(d) = CON_ZEDIT;
      break;
   case SCMD_OLC_MEDIT:
     if ((real_num = real_mobile(number)) < 0)
       medit_setup_new(d);
     else
       medit_setup_existing(d, real_num);
     STATE(d) = CON_MEDIT;
      break;
   case SCMD_OLC_OEDIT:
     if ((real_num = real_object(number)) >= 0)
       oedit_setup_existing(d, real_num);
     else
       oedit_setup_new(d);
     STATE(d) = CON_OEDIT;
     break;
   case SCMD_OLC_SEDIT:
     if ((real_num = real_shop(number)) >= 0)
       sedit_setup_existing(d, real_num);
     else
       sedit_setup_new(d);
     STATE(d) = CON_SEDIT;
     break;
   case SCMD_OLC_HEDIT:
     if (OLC_ZNUM(d) < 0)
       hedit_setup_new(d, buf1);
     else
       hedit_setup_existing(d, OLC_ZNUM(d));
     STATE(d) = CON_HEDIT;
     break;
   case SCMD_OLC_AEDIT:
     STATE(d) = CON_AEDIT;
     break;
   case SCMD_OLC_QEDIT:
    real_num = real_quest(number);
    if (real_num >= 0)
      qedit_setup_existing(d, real_num);
    else
      qedit_setup_new(d);
    STATE(d) = CON_QEDIT;
    break;
   }
   act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
   SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
 }
  
 /*------------------------------------------------------------*\
  Internal utilities 
 \*------------------------------------------------------------*/
  
 void olc_saveinfo(struct char_data *ch)
 {
   struct olc_save_info *entry;
  
   if (olc_save_list)
     send_to_char("The following OLC components need saving:-\r\n", ch);
   else
     send_to_char("The database is up to date.\r\n", ch);
  
   for (entry = olc_save_list; entry; entry = entry->next) {
     if ((int)entry->type == OLC_SAVE_HELP)
       sprintf(buf, " - Help Entries.\r\n");
     else if ((int)entry->type == OLC_SAVE_ACTION)
       sprintf(buf, " - Actions.\r\n");
     else if ((int)entry->type == OLC_SAVE_QUEST)
       sprintf(buf, " - Quests for zone %d.\r\n", entry->zone);
     else
       sprintf(buf, " - %s for zone %d.\r\n",
 		save_info_msg[(int)entry->type], entry->zone);
     send_to_char(buf, ch);
    }
  }
  
 int real_zone(int number)
 {
   int counter;
 
   for (counter = 0; counter <= top_of_zone_table; counter++)
     if ((number >= (zone_table[counter].number * 100)) &&
 	(number <= (zone_table[counter].top)))
       return counter;
 
   return -1;
 }
  
 /*------------------------------------------------------------*\
  Exported utilities 
 \*------------------------------------------------------------*/
 
 /*
  * Add an entry to the 'to be saved' list.
  */
 
 void olc_add_to_save_list(int zone, byte type)
  {
   struct olc_save_info *new;
 
   /*
    * Return if it's already in the list.
    */
   for (new = olc_save_list; new; new = new->next)
     if ((new->zone == zone) && (new->type == type))
       return;
 
   CREATE(new, struct olc_save_info, 1);
   new->zone = zone;
   new->type = type;
   new->next = olc_save_list;
   olc_save_list = new;
  }
  
 /*
  * Remove an entry from the 'to be saved' list.
  */
  
 void olc_remove_from_save_list(int zone, byte type)
  {
   struct olc_save_info **entry;
   struct olc_save_info *temp;
  
   for (entry = &olc_save_list; *entry; entry = &(*entry)->next)
     if (((*entry)->zone == zone) && ((*entry)->type == type)) {
       temp = *entry;
       *entry = temp->next;
       free(temp);
       return;
      }
  }
  
 /*
  * Set the colour string pointers for that which this char will
  * see at color level NRM.  Changing the entries here will change 
  * the colour scheme throughout the OLC.
  */
  
 void get_char_cols(struct char_data *ch)
 {
   nrm = CCNRM(ch, C_NRM);
   grn = CCGRN(ch, C_NRM);
   cyn = CCCYN(ch, C_NRM);
   yel = CCYEL(ch, C_NRM);
 }
 
 /*
  * This procedure removes the '\r\n' from a string so that it may be
  * saved to a file.  Use it only on buffers, not on the original
  * strings.
  */
 void strip_string(char *buffer)
  {
   char *ptr, *str;
  
   ptr = buffer;
   str = ptr;
  
   while ((*str = *ptr)) {
     str++;
     ptr++;
     if (*ptr == '\r')
       ptr++;
    }
 }
  
 /*
  * This procdure frees up the strings and/or the structures
  * attatched to a descriptor, sets all flags back to how they
  * should be.
  */
  
 void cleanup_olc(struct descriptor_data *d, byte cleanup_type)
 {
   if (d->olc) {
     /*
      * Check for storage.
      */
     if (OLC_STORAGE(d))
       free(OLC_STORAGE(d));

     /*
      * Check for help.
      */
     if (OLC_HELP(d)) {
       switch (cleanup_type) {
       case CLEANUP_ALL:	free_help(OLC_HELP(d));	break;
       case CLEANUP_STRUCTS:  free(OLC_HELP(d));	break;
       default: /* The caller has screwed up. */	break;
       }
     }
     /*
      * Check for a room.
      */
     if (OLC_ROOM(d)) {
       /*
        * free_room doesn't perform sanity checks, must be careful here.
        */
       switch (cleanup_type) {
       case CLEANUP_ALL:	free_room(OLC_ROOM(d));	break;
       case CLEANUP_STRUCTS:  free(OLC_ROOM(d));	break;
       default: /* The caller has screwed up. */	break;
       }
     }
     /*
      * Check for an object.
      */
     if (OLC_OBJ(d))
       /*
        * free_obj() makes sure strings aern't part of the prototype.
        */
       free_obj(OLC_OBJ(d));
 
     /*
      * Check for a mob.
      */
     if (OLC_MOB(d))
       /*
        * medit_free_mobile() makes sure strings are not in the prototype.
        */
       medit_free_mobile(OLC_MOB(d));
 
     /*
      * Check for a zone.
      */
     if (OLC_ZONE(d)) {
       /*
        * cleanup_type is irrelevant here, free() everything.
        */
       free(OLC_ZONE(d)->name);
       free(OLC_ZONE(d)->cmd);
       free(OLC_ZONE(d));
     }
 
    /*
     * Check for a shop.
     */
    if (OLC_SHOP(d)) {
       /*
        * free_shop doesn't perform sanity checks, we must be careful here.
        */
        switch (cleanup_type) {
        case CLEANUP_ALL: free_shop(OLC_SHOP(d));	break;
        case CLEANUP_STRUCTS:  free(OLC_SHOP(d));	break;
        default: /* The caller has screwed up. */	break;
      }
    }

    /*. Check for aedit stuff -- M. Scott */
    if (OLC_ACTION(d))  {
      switch(cleanup_type)  {
      case CLEANUP_ALL:
        free_action(OLC_ACTION(d));
        break;
      case CLEANUP_STRUCTS:
        free(OLC_ACTION(d));
        break;
      default:
        /* Caller has screwed up */
        break;
      }
    }

    if (OLC_QUEST(d)) {		/*. free_quest performs no sanity checks, must be carefull here . */
      switch (cleanup_type) {
      case CLEANUP_ALL:
	free_quest(OLC_QUEST(d));
	break;
      case CLEANUP_STRUCTS:
	free(OLC_QUEST(d));
	break;
      default:
	/*. Caller has screwed up . */
	break;
      }
    }
	
    /*
     * Restore descriptor playing status.
     */
    if (d->character) {
      REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING);
      STATE(d) = CON_PLAYING;
      act("$n stops using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
    }
    free(d->olc);
  }
}

/* Everything below this line is part of the OLC+ package specifically. */

/* Can they edit a zone?  This takes a zone's rnum.   *
 * Any reason to add a REAL/VIRTUAL setup? TR 5-20-98 */
int can_edit_zone(struct char_data *ch, int number)
{
  if (GET_LEVEL(ch) >= LVL_OLC_FULL)
    return TRUE;

  if (GET_LEVEL(ch) < LVL_BUILDER)
    return FALSE;

  if(number == real_zone(GET_OLC_ZONE(ch)))
    return TRUE;
    
  return FALSE;
}

/* This handy little function will give the zone number *
 * of any object, room, or mob.      TR 5-18-98         */

#define ROOM	0
#define OBJECT	1
#define MOBILE	2

int zone_number(void *what, int type)
{
  struct char_data *character;
  struct obj_data *object;
  struct room_data *room;
  int return_value;

  switch (type) {
  case ROOM:
    room = (struct room_data *)what;
    return_value = zone_table[real_zone(room->number)].number;
    break;
  case OBJECT:
    object = (struct obj_data *)what;
    return_value = (GET_OBJ_VNUM(object) / 100);
    break;
  case MOBILE:
    character = (struct char_data *)what;
    if (IS_NPC(character))
      return_value = -1;
    /* This formula seems to work in all cases, although I   *
     * know it wouldn't in the case of rooms.  The documents *
     * state that the top_of_zone specifies the last ROOM,   *
     * but not object.  I think the default is (zone#*10)+99 */
    else
      /* Doesn't this look like it wouldn't work?  It seems  *
       * that C has decided to simply truncate integers in   *
       * lieu of rounding them...  Is this machine specific? *
       *                                   TR 5-20-98        */
      return_value = (GET_MOB_VNUM(character) / 100);
    break;
  default:
    return_value = -1;
    break;
  }

  return return_value;
}


/* This little function has real potential.  Give it  *
 * a source room's rnum and a target room's rnum, and *
 * it will do a copy.  Use it in your own commands.   *
 *                                 TR 5-20-98         */
void copy_room(int rnum_src, int rnum_targ)
{
  if (world[rnum_src].name)
    world[rnum_targ].name = str_dup(world[rnum_src].name);
  if (world[rnum_src].description)
    world[rnum_targ].description = str_dup(world[rnum_src].description);
  world[rnum_targ].sector_type = world[rnum_src].sector_type;
  world[rnum_targ].room_flags = world[rnum_src].room_flags;
  /* Note:  ex_descriptions are not being      *
   * copied.  I think it will stay that way.   *
   *                       TR 5-20-98          */
  return;
}


/* Same as copy_room, but with objects.  No error checking.  *
 * Should this be made an integer so a check can be made for *
 * success?                             TR 2-20-98           */
void copy_object(int rnum_src, int rnum_targ)
{
  if (obj_proto[rnum_src].name)
    obj_proto[rnum_targ].name = str_dup(obj_proto[rnum_src].name);
  if (obj_proto[rnum_src].description)
    obj_proto[rnum_targ].description = str_dup(obj_proto[rnum_src].description);
  if (obj_proto[rnum_src].short_description)
    obj_proto[rnum_targ].short_description = str_dup(obj_proto[rnum_src].short_description);
  if (obj_proto[rnum_src].action_description)
    obj_proto[rnum_targ].action_description = str_dup(obj_proto[rnum_src].action_description);
  if (obj_proto[rnum_src].ex_description)
    obj_proto[rnum_targ].ex_description = obj_proto[rnum_src].ex_description;
  obj_proto[rnum_targ].obj_flags = obj_proto[rnum_src].obj_flags;
  obj_proto[rnum_targ].worn_on = obj_proto[rnum_src].worn_on;
  /* add more if you want... */

  return;
}

/*
 * Command interface for:
 * Copying a room or object to another.
 * Attempt at ending the spaghetti:  5-20-98
 */

#define COPY_FORMAT	"Usage:  copy { room | obj } <source> <target>\r\n"

ACMD(do_copy)
{
  char src_num[256], targ_num[256], type[256];
  int vnum_targ = 0, rnum_targ = 0, vnum_src = 0, rnum_src = 0;
  int save_zone = 0, room_or_obj = -1;

  argument = two_arguments(argument, type, src_num);
  one_argument(argument, targ_num);

  /* Here are reasons to give up.  I think they're all right here. */
  if (!*type || !*src_num) {
    send_to_char(COPY_FORMAT, ch);
    return;
  } else if (!*targ_num && (room_or_obj == OBJECT)) {
    send_to_char("You must specify a target when copying objects.\r\n", ch);
    return;
  }

  if (is_abbrev(type, "room") && is_number(src_num)) {
    room_or_obj = ROOM;
    vnum_src = atoi(src_num);
    rnum_src = real_room(vnum_src);
    if (!*targ_num) {
      vnum_targ = world[IN_ROOM(ch)].number;
      rnum_targ = IN_ROOM(ch);
    } else {
      if (!is_number(targ_num)) {
        send_to_char(COPY_FORMAT, ch);
        return;
      }
      vnum_targ = atoi(targ_num);
      rnum_targ = real_room(vnum_targ);
    }
    save_zone = zone_number(&world[rnum_targ], ROOM);
  } else if (is_abbrev(type, "obj") && *targ_num && is_number(src_num) && is_number(targ_num)) {
    room_or_obj = OBJECT;
    vnum_src = atoi(src_num);
    rnum_src = real_object(vnum_src);
    vnum_targ = atoi(targ_num);
    rnum_targ = real_object(vnum_targ);
    save_zone = zone_number(&obj_index[rnum_targ], OBJECT);
  } else {
    send_to_char(COPY_FORMAT, ch);
    return;
  }

  if ((rnum_src < 0) || (rnum_targ < 0)) {
    sprintf(buf, "The source and target %ss must both currently exist.\r\n", (room_or_obj == OBJECT ? "object" : "room"));
    send_to_char(buf, ch);
    return;
  } else if (!can_edit_zone(ch, real_zone(save_zone))) {
    send_to_char("You cannot edit that zone.\r\n", ch);
    return;
  }

  /* We should now be ready to go.  All errors have been trapped (?) *
   * and we know what to do.                      TR 5-21-98         */
  switch (room_or_obj) {
  case ROOM:
    copy_room(rnum_src, rnum_targ);
    break;
  case OBJECT:
    copy_object(rnum_src, rnum_targ);
    break;
  default:
    mudlog("SYSERR: OLC: Reached default case in do_copy!", NRM, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE);
    send_to_char("There was an error in your copy.  Please report to an "
		"administrator.\r\n", ch);
    return;
  }

  /* I cheated right here a little bit.  By coincidence, *
   * ROOM == OLC_SAVE_ROOM, and OBJECT = OLC_SAVE_OBJ.   *
   * I think this is a Good Thing(tm), although if you   *
   * change the OLC_SAVE_x defines, it will blow up.  :P *
   *                                    TR 5-21-98       */
  sprintf(buf, "You copy %s %d to %d.\r\n", (room_or_obj == ROOM ? "room" : "object"), vnum_src, vnum_targ);
  send_to_char(buf, ch);
  olc_add_to_save_list(save_zone, room_or_obj);
}


/* Supporting functions for RLINK.  A few of these are right out of *
 * OBuild, but I can't remember which.  :P  Credits to Samedi, and  *
 * Daniel Burke, I believe.                   TR 5-21-98            */

/* Create an exit in a room (rnum) in this direction.  (No target) */
int create_dir(int room, int dir)
{
   if ((room > top_of_world) || (room < 0)) {
      log("create_dir(): tried to create invalid door");
      return FALSE;
   }
   if (world[room].dir_option[dir])
     return FALSE;

   CREATE(world[room].dir_option[dir], struct room_direction_data, 1);
   world[room].dir_option[dir]->to_room = NOWHERE;
   world[room].dir_option[dir]->exit_info = 0;
   world[room].dir_option[dir]->general_description = str_dup("You see nothing special.\r\n");
   world[room].dir_option[dir]->keyword = NULL;
   world[room].dir_option[dir]->key = -1;

   return TRUE;

}


/* Remove an exit from a room (rnum). */
int free_dir(int room, int dir)
{
   if ((room > top_of_world) || (room < 0)) {
      log("free_dir(): tried to free invalid door");
      return FALSE;   
   }
   if ((dir < 0) || (dir >= NUM_OF_DIRS)) {
      log("free_dir(): tried to free invalid door");
      return FALSE;
   }

   if (!world[room].dir_option[dir])
     return FALSE;

   world[room].dir_option[dir]->to_room = NOWHERE;
   world[room].dir_option[dir]->exit_info = 0;
   if (world[room].dir_option[dir]->general_description)
     free(world[room].dir_option[dir]->general_description);
   if (world[room].dir_option[dir]->keyword)
     free(world[room].dir_option[dir]->keyword);
   world[room].dir_option[dir]->key = -1;
   free(world[room].dir_option[dir]);
   world[room].dir_option[dir] = NULL;

   return TRUE;

}


/* These defines were harvested from....  zedit.c ?      */
#define ZCMD (zone_table[zone].cmd[cmd_no])
#define W_EXIT(room, num) (world[(room)].dir_option[(num)])
/* ***************************************************** */
#define RLINK_FORMAT	"Usage:  rlink <dir> <connect|disconnect> <1|2> [target]\r\n"

/* The big baby. */
ACMD(do_rlink)
{
  char direction[10], command[20], type[10], target[10];
  int vnum_base = 0, vnum_targ = 0, rnum_base = 0, rnum_targ = 0;
  int dir = 0, k = 0, type_int = 0, top_room = 0;
  int save_zone_1 = 0, save_zone_2 = 0, create_new_room = FALSE;

  argument = two_arguments(argument, direction, command);
  two_arguments(argument, type, target);

  if (!*direction || !*command || !*type) {
    send_to_char(RLINK_FORMAT, ch); 
    return;
  } else if (!is_number(type)) {
    send_to_char(RLINK_FORMAT, ch);
    return;
  }

  type_int = atoi(type);

  if (type_int != 1 && type_int != 2) {
    send_to_char(RLINK_FORMAT, ch);
    return;
  }

  vnum_base = world[IN_ROOM(ch)].number;
  rnum_base = IN_ROOM(ch);

  if (!*target && !is_abbrev(command, "disconnect")) {
    create_new_room = TRUE; 
  } else {
    if (!is_number(target)) {
      send_to_char(RLINK_FORMAT, ch);
      return;
    }
    vnum_targ = atoi(target);
    rnum_targ = real_room(vnum_targ);
  }

  if (rnum_targ < 0) {
    send_to_char(RLINK_FORMAT, ch);
    return;
  }

  save_zone_1 = zone_number(&world[IN_ROOM(ch)], ROOM);

  if (!can_edit_zone(ch, real_zone(save_zone_1))) {
    send_to_char("You cannot create exits in this zone.\r\n", ch);
    return;
  }

  if (!create_new_room) {
    if (rnum_targ < 0) {
      send_to_char(RLINK_FORMAT, ch);
      return;
    }
    save_zone_2 = zone_number(&world[rnum_targ], ROOM);
  } else {
    top_room = (zone_table[real_zone(world[IN_ROOM(ch)].number)].top);

    for (k = (save_zone_1 * 100); k <= top_room; k++) {
      if (k > top_room) {
        send_to_char("Cannot create a new room in this zone!\r\n", ch);
        return;
      }
      if (real_room(k) < 0) {
        CREATE(ch->desc->olc, struct olc_data, 1);
        CREATE(OLC_ROOM(ch->desc), struct room_data, 1);

        OLC_ZNUM(ch->desc) = world[ch->in_room].zone;
        OLC_NUM(ch->desc) = k;
        OLC_ROOM(ch->desc)->number = k;
        OLC_ROOM(ch->desc)->zone = world[ch->in_room].zone;
        OLC_ROOM(ch->desc)->name = str_dup("An unfinished room");
        OLC_ROOM(ch->desc)->description = str_dup("You are in an unfinished room.\r\n");
        OLC_ITEM_TYPE(ch->desc) = WLD_TRIGGER;
        OLC_VAL(ch->desc) = 0;
        vnum_targ = k;
    
        redit_save_internally(ch->desc);
        cleanup_olc(ch->desc, CLEANUP_STRUCTS);
        rnum_targ = real_room(vnum_targ);
        save_zone_2 = save_zone_1;
        sprintf(buf, "You have created new room #%i.\r\n", vnum_targ);
        send_to_char(buf, ch);
        break;
      }
    }
  }

  /* save_zone_2 has definitely been established.  If it's a two *
   * way exit, don't let them do the linkage.   TR 5-21-98       */

  if (!can_edit_zone(ch, real_zone(save_zone_2)) && type_int == 2) {
    send_to_char("You cannot create exits in the target zone.\r\n", ch);
    return;
  }

  switch (*direction) {
    case 'n':
    case 'N':
      dir = NORTH;
      break;
    case 'e':
    case 'E':
      dir = EAST;
      break;
    case 's':
    case 'S':
      dir = SOUTH;
      break;
    case 'w':
    case 'W':
      dir = WEST;
      break;
    case 'u':
    case 'U':
      dir = UP;
      break;
    case 'd':
    case 'D':
      dir = DOWN;
      break;
    default:
      send_to_char("No such direction!\r\n", ch);
      return;
  }

  if (is_abbrev(command, "connect")) {
    if (!world[ch->in_room].dir_option[dir]) {
      create_dir(IN_ROOM(ch), dir);
      world[IN_ROOM(ch)].dir_option[dir]->to_room = rnum_targ;
    } else
      world[IN_ROOM(ch)].dir_option[dir]->to_room = rnum_targ;

    if (type_int == 2) {
      if (!world[rnum_targ].dir_option[rev_dir[dir]])
        create_dir(rnum_targ, rev_dir[dir]);
      world[rnum_targ].dir_option[rev_dir[dir]]->to_room = IN_ROOM(ch);
      if (!save_zone_2) save_zone_2 = zone_number(&world[rnum_targ], ROOM);
    }
  } else if (is_abbrev(command, "disconnect")) {
    if (type_int == 2) {
      if (world[IN_ROOM(ch)].dir_option[dir]->to_room) {
        free_dir(world[IN_ROOM(ch)].dir_option[dir]->to_room, rev_dir[dir]);
        if (world[IN_ROOM(ch)].dir_option[dir])
          free_dir(IN_ROOM(ch), dir);
        else {
          send_to_char("No such exit!\r\n", ch);
          return;
        }
        save_zone_2 = zone_number(&world[rnum_targ], ROOM);
      } else {
        send_to_char("There is no reciprocol exit to remove.\r\n", ch);
        if (world[IN_ROOM(ch)].dir_option[dir]->to_room) {
          free_dir(IN_ROOM(ch), dir);
        } else {
          send_to_char("No such exit!\r\n", ch);
          return;
        }

      }
    } else if (type_int == 1) {
      if (!world[IN_ROOM(ch)].dir_option[dir]->to_room) {
        send_to_char("No such exit!\r\n", ch); 
        return;
      } else {
        free_dir(IN_ROOM(ch), dir);
      }
    } else {
      send_to_char("Invalid disconnect type.\r\n", ch);
      return;
    }
  } else {
    send_to_char("Invalid command type.  Valid choices are connect and disconnect.\r\n", ch);
    return;
  }

  if (is_abbrev(command, "connect")) {
    sprintf(buf, "You make an exit %s to room %d.\r\n", dirs[dir], vnum_targ);
    send_to_char(buf, ch);
  } else
    send_to_char("Exit deleted.\r\n", ch);

  olc_add_to_save_list(save_zone_1, OLC_SAVE_ROOM);
  if (save_zone_2)
    olc_add_to_save_list(save_zone_2, OLC_SAVE_ROOM);
  return;
}
::::::::::::::
prgrun.c
::::::::::::::
/******************************************************************************
 *    File: prgrun.c                                 an addition to CircleMUD *
 *   Usage: Asynchronyously run unix programs from MUD                        *
 *  Author: Petr Vilim (Petr.Vilim@st.mff.cuni.cz)                            *
 *                                                                            *
 *****************************************************************************/

/*
 * WARNING 1: It works on Linux. It should work on all UNIXes but
 *            I didn't try it.
 *
 * WARNING 2: Use on your own risk :-)
 *
 * WARNING 3: Playing with this you can easily make some security hole,
 *            if you make some command modifying spefied file for example.
 *            Mud password travels through net uncrypted and can be easily
 *            caught (try tcpdump). So some hacker can log on mud with your
 *            char and can destroy all your files...  (and can modify
 *            file ~/.klogin and I don't know what more)
 *            This is the reason why I didn't make command exec which
 *            calls function system with given parametrs.
 */

 /*
  * You haven't to give me a credit. If you want you can mail me.
  */

#include <sys/types.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/wait.h>
#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "db.h"

#define PQUEUE_LENGTH    20  /* Max. number of requests in queue */
#define MAX_ARGS         5   /* Max. number of arguments of program */

struct program_info {
  char *args[MAX_ARGS+1];/* args[0] is name of program,
                            rest are arguments, after last argument
                            must be NULL  */
  char *input;           /* Input sended to process 		*/
  long char_id;          /* ID of character 			*/
  char *name;            /* Name used when printing output      */
  int timeout;           /* Timeout in seconds 			*/
};

extern struct descriptor_data *descriptor_list;

struct program_info program_queue[PQUEUE_LENGTH];
int pqueue_counter=0;	 /* Number of requests in queue */

int pid=-1;		 /* PID of runnig command, -1 if none 		*/
int to[2], from[2];	 /* file descriptors of pipes between processes */
int  start_time;	 /* Time when process started, for timeout 	*/
int had_output;		 /* Flag if running command already had an output */
FILE *process_in;        /* Standart input for runned program 		*/

/*
 * get_ch_by_id : given an ID number, searches every descriptor for a
 *              character with that number and returns a pointer to it.
 */
/*struct char_data *get_ch_by_id(long idnum)
{
  struct descriptor_data *d;
  extern struct descriptor_data *descriptor_list;

  for (d = descriptor_list; d; d = d->next)
    if (d && d->character && GET_IDNUM(d->character) == idnum)
      return (d->character);

  return NULL;
}*/

struct char_data *get_ch_by_id(long idnum)
{
  struct descriptor_data *d;

  for (d = descriptor_list; d; d = d->next)
    if (d && d->character && GET_IDNUM(d->character) == idnum)
      return (d->character);

  return NULL;
}

void program_fork() {	 /* Start new command */
  int i;
  long flags;

  pipe(to);
  pipe(from);
  start_time=time(0);
  had_output=0;
  pid=fork();
  if (pid < 0) {
    pid=-1;		 /* Some problem with fork */
    return;
  }
  if (pid==0) {		 /* Child process */
    dup2 (from[1], 1);	 /* Set from[1] as standart output */
    close (from[0]);
    close (from[1]);
    dup2 (to[0], 0);
    close (to[0]);
    close (to[1]);
    for (i=2; i<1000; i++)
      close(i);		 /* Close all opened file descriptors
			    1000 should be enough I hope :-) */
    execvp(program_queue[0].args[0], program_queue[0].args);
    exit(0);
  }
  close(from[1]);
  close(to[0]);
  process_in=fdopen(to[1], "w");
  setbuf(process_in, NULL);
  if (program_queue[0].input)   /* Send input to program if any */
    fprintf(process_in, program_queue[0].input);
  flags=fcntl(from[0], F_GETFL);
  fcntl(from[0], F_SETFL, flags | O_NONBLOCK);
			 /* Set from[0] into no-blocking mode */
}

void program_done() {
  int i;

  if (pid!=-1) {
    close(from[0]);	   /* Close process standart output */
    fclose(process_in);	   /* Close process standart input  */
    waitpid(pid, NULL, 0); /* Wait for process termination  */
    for (i=0; i<MAX_ARGS+1; i++)
      if (program_queue[0].args[i]) free(program_queue[0].args[i]);
      else break;
    free(program_queue[0].name);
    if (program_queue[0].input) free(program_queue[0].input);
    for (i=0; i<pqueue_counter; i++)
      program_queue[i]=program_queue[i+1]; /* shift queue */
    pqueue_counter--;
    if (pqueue_counter)
      program_fork();	 /* Start next process */
    else
      pid=-1;
  }
}

void process_program_output() {
  int len;
  struct char_data *ch;
  char *c, *d;

  if (pid==-1)
    return;
  len=read(from[0], buf, MAX_STRING_LENGTH);
  if ((len==-1) && (errno==EAGAIN)) { /* No datas are available now */
    if (time(0)<start_time+program_queue[0].timeout)
      return;
    else
      sprintf(buf, "&wKilling &c%s&w becouse of timeout.\r\n",
	      program_queue[0].name);
  } else if (len < 0) {	 /* Error with read or timeout */
    sprintf(buf, "&wError with reading from &c%s&w, killed.",
	    program_queue[0].name);
  } else if (len == 0) {  /* EOF readed  */
    if (had_output)
      buf[0]=0;
    else
      sprintf(buf, "&wNo output from &c%s&w.\r\n", program_queue[0].name);
  };
  ch=get_ch_by_id(program_queue[0].char_id);
  if (len<=0) {
    kill(pid, 9);         /* kill process with signal 9 if is still running */
    program_done();
    if ((ch) && (buf[0]))
      send_to_char(buf, ch);
    return;
  }
  had_output=1;
  buf[len]='\0';
  for (c=buf, d=buf1; *c; *d++=*c++)
    if (*c=='\n') *d++='\r';
  *d=0;
  if (!ch) return;	 /* Player quited the game? */
  send_to_char("&wOutput from &c", ch);
  send_to_char(program_queue[0].name, ch);
  send_to_char("&w:&g\r\n", ch);
  send_to_char(buf1, ch);
}

/* Following function add program into queue */
void add_program(struct program_info prg, struct char_data *ch)
{
  prg.char_id=GET_IDNUM(ch);
  if (pqueue_counter==PQUEUE_LENGTH) {
    send_to_char("Sorry, there are too many requests now, try later.\r\n", ch);
    return;
  }
  program_queue[pqueue_counter]=prg;
  pqueue_counter++;
  if (pqueue_counter==1)	 /* No process is running now so start new process */
    program_fork();
}

/*
 * swho calls program w.
 * It shows who is logged on (not in mud, in unix)
 * and what they are doing
 */

ACMD(do_swho) {
  struct program_info swho;

  swho.args[0]=strdup("w");
  swho.args[1]=NULL;
  swho.input=NULL;
  swho.timeout=3;
  swho.name=strdup("swho");
  add_program(swho, ch);
}

/*
 * slast calls program last.
 * It shows last 10 login of specified user or last 10 logins
 * if no user is specified.
 */

ACMD(do_slast) {
  struct program_info slast;

  slast.args[0]=strdup("last");
  slast.args[1]=strdup("-10");
  one_argument(argument, arg);
  if (!*arg) 			/* No user specified */
    slast.args[2]=NULL;
  else
    slast.args[2]=strdup(arg);
  slast.args[3]=NULL;
  slast.input=NULL;
  slast.timeout=5;
  slast.name=strdup("slast");
  add_program(slast, ch);
}

/*
 * grep is normal grep <pattern> <file>
 * Useful is for example:
 * 	grep ../syslog <player>
 *  or  grep ../log/syslog.2 <player>
 */

ACMD(do_grep) {
  struct program_info grep;

  argument=one_argument(argument, arg);
  skip_spaces(&argument);
  grep.args[0]=strdup("grep");
  /* Ignore cas, becouse one_argument function makes all characters lower. */
  grep.args[1]=strdup("-i");
  grep.args[2]=strdup(arg);
  grep.args[3]=strdup(argument);
  grep.args[4]=NULL;
  grep.input=NULL;
  grep.timeout=10;
  grep.name=strdup("grep");
  add_program(grep, ch);
}

/*
 * sps calls program ps.
 * I use for example sps aux, sps ux on Linux, but on other
 * platforms it can have another parameters
 */

ACMD(do_sps) {
  struct program_info sps;

  skip_spaces(&argument);
  sps.args[0]=strdup("ps");
  sps.args[1]=strdup(argument);
  sps.args[2]=NULL;
  sps.input=NULL;
  sps.timeout=1;
  sps.name=strdup("sps");
  add_program(sps, ch);
}

/*
 * ukill kills runnig child process before his timeout.
 */

ACMD(do_ukill) {
  struct char_data *user;

  if (pid!=-1) {
    user=get_ch_by_id(program_queue[0].char_id);
    sprintf(buf, "&c%s&w has been killed.\r\n", program_queue[0].name);
    kill(pid, 9);	 /* Send SIGKILL to process */
    program_done();
    send_to_char("Process killed.\r\n", ch);
    if (user)
      send_to_char(buf, user);
  } else
    send_to_char("No process is running now.\r\n", ch);
}

 ACMD(do_sexec) {
  struct program_info sexec;

  if ((!strcmp(GET_NAME(ch),"Seker")) || (!strcmp(GET_NAME(ch),"Bennu")) ||
     (!strcmp(GET_NAME(ch),"Luna")) || (GET_LEVEL(ch) >= LVL_SUBIMPL))
  {
    argument=one_argument(argument, arg);
    skip_spaces(&argument);
    if (!*arg) 			/* No user specified */
      sexec.args[0]=NULL;
    else
      sexec.args[0]=strdup(arg);
    argument=one_argument(argument, arg);
    skip_spaces(&argument);
    if (!*arg) 			/* No user specified */
      sexec.args[1]=NULL;
    else
      sexec.args[1]=strdup(arg);
    if (!*argument) 			/* No user specified */
      sexec.args[2]=NULL;
    else
      sexec.args[2]=strdup(argument);
    sexec.args[3]=NULL;
    sexec.input=NULL;
    sexec.timeout=10;
    sexec.name=strdup("sexec");
    add_program(sexec, ch);
  }
  else
   send_to_char("Huhh??\r\n", ch);
}
::::::::::::::
qedit.c
::::::::::::::
/************************************************************************
 * OasisOLC - qedit.c						v1.6	*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "utils.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "boards.h"
#include "olc.h"
#include "quest.h"

/*------------------------------------------------------------------------*/
/*. External data . */

struct index_data *mob_index;
extern int top_of_aquestt;
extern struct aq_data *aquest_table;
extern struct zone_data *zone_table;
extern char *quest_types[];
extern char *aq_flags[];
extern char *reward_types[];
extern void strip_string(char *buffer);

/*------------------------------------------------------------------------*/
/* function protos */
void qedit_setup_new(struct descriptor_data *d);
void qedit_setup_existing(struct descriptor_data *d, int real_num);
void qedit_save_internally(struct descriptor_data *d);
void qedit_save_to_disk(int znum);
void free_quest(struct aq_data *quest);
void qedit_disp_type_menu(struct descriptor_data *d);
void qedit_disp_reward_menu(struct descriptor_data *d);
void qedit_disp_menu(struct descriptor_data *d);
void qedit_parse(struct descriptor_data *d, char *arg);
void qedit_disp_flags_menu(struct descriptor_data *d);
void oedit_disp_val0_menu(struct descriptor_data *d);
void oedit_disp_val1_menu(struct descriptor_data *d);
void oedit_disp_val2_menu(struct descriptor_data *d);
void oedit_disp_val3_menu(struct descriptor_data *d);
void smash_tilde(char *string);

/*------------------------------------------------------------------------*\
  Utils and exported functions.
\*------------------------------------------------------------------------*/

void qedit_setup_new(struct descriptor_data *d)
{

  CREATE(OLC_QUEST(d), struct aq_data, 1);
  OLC_QUEST(d)->short_desc = str_dup("an unfinished quest");
  OLC_QUEST(d)->desc = str_dup("This is an unfinished quest.");
  OLC_QUEST(d)->info = str_dup("Information for unfinished quest.\r\n");
  OLC_QUEST(d)->ending = str_dup("Ending for unfinished quest.\r\n");
  OLC_QUEST(d)->flags = 0;
  OLC_QUEST(d)->next_quest = -1;
  OLC_QUEST(d)->complete = -1;
  OLC_QUEST(d)->id = -1;
  qedit_disp_menu(d);
  OLC_VAL(d) = 0;
}

/*------------------------------------------------------------------------*/

void qedit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct aq_data *quest;
  int i;

  /*. Build a copy of the quest . */
  CREATE(quest, struct aq_data, 1);
  *quest = aquest_table[real_num];
  /* allocate space for all strings  */
  if (aquest_table[real_num].short_desc)
    quest->short_desc = str_dup(aquest_table[real_num].short_desc);
  if (aquest_table[real_num].desc)
    quest->desc = str_dup(aquest_table[real_num].desc);
  if (aquest_table[real_num].info)
    quest->info = str_dup(aquest_table[real_num].info);
  if (aquest_table[real_num].ending)
    quest->ending = str_dup(aquest_table[real_num].ending);
  quest->type = aquest_table[real_num].type;
  quest->mob_vnum = aquest_table[real_num].mob_vnum;
  quest->flags = aquest_table[real_num].flags;
  quest->target = aquest_table[real_num].target;
  quest->reward_type = aquest_table[real_num].reward_type;
  quest->reward = aquest_table[real_num].reward;
  quest->next_quest = aquest_table[real_num].next_quest;
  quest->complete = aquest_table[real_num].complete;
  quest->min_level = aquest_table[real_num].min_level;
  quest->max_level = aquest_table[real_num].max_level;
  quest->id = aquest_table[real_num].id;
  for (i = 0; i < 4; i++)
    quest->value[i] = aquest_table[real_num].value[i];
  /*. Attach room copy to players descriptor . */
  OLC_QUEST(d) = quest;
  OLC_VAL(d) = 0;
  qedit_disp_menu(d);
}

/*------------------------------------------------------------------------*/
void qedit_save_internally(struct descriptor_data *d)
{
  int i = 0, quest_num, found = 0;
  struct aq_data *new_quest = NULL;

  quest_num = real_quest(OLC_NUM(d));
  if (quest_num >= 0) {
    free_quest(aquest_table + quest_num);
    aquest_table[quest_num] = *OLC_QUEST(d);
  } else {
    /*. Quest doesn't exist, hafta add it . */
    CREATE(new_quest, struct aq_data, top_of_aquestt + 2);

    /* count thru quest tables */
    for (i = 0; i <= top_of_aquestt; i++) {
      if (!found) {
	/*. Is this the place? . */
	if (aquest_table[i].virtual > OLC_NUM(d)) {
	  found = 1;

	  new_quest[i] = *(OLC_QUEST(d));
	  new_quest[i].virtual = OLC_NUM(d);
	  quest_num = i;
	  new_quest[i + 1] = aquest_table[i];

	} else {
	  new_quest[i] = aquest_table[i];
	}
      } else {			/*. Already been found  . */
	new_quest[i + 1] = aquest_table[i];
      }
    }
    if (!found) {		/*. Still not found, insert at top of table . */
      new_quest[i] = *(OLC_QUEST(d));
      new_quest[i].virtual = OLC_NUM(d);
      quest_num = i;
    }
    /* copy quest table over */
    free(aquest_table);
    aquest_table = new_quest;
    top_of_aquestt++;

  }
/*
   rnum = real_mobile(new_quest[i].mob_vnum);
   if (!mob_index[OLC_NUM(d)].func && rnum)
   mob_index[new_quest[rnum].mob_vnum].func = questmaster;
 */
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_QUEST);
}


/*------------------------------------------------------------------------*/

void qedit_save_to_disk(int znum)
{
  int counter, realcounter;
  FILE *fp;
  struct aq_data *quest;
  char buf3[MAX_STRING_LENGTH];
  char buf4[MAX_STRING_LENGTH];

  sprintf(buf, "%s/%d.qst", QST_PREFIX, zone_table[znum].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open quest file!", BRF, LVL_BUILDER, TRUE);
    return;
  }
  for (counter = zone_table[znum].number * 100;
       counter <= zone_table[znum].top;
       counter++) {
    realcounter = real_quest(counter);
    if (realcounter >= 0) {
      quest = (aquest_table + realcounter);
      strcpy(buf1, quest->short_desc ? quest->short_desc : "an unfinished quest");
      smash_tilde(buf1);
      strcpy(buf2, quest->desc ? quest->desc : "This is an unfinished quest.");
      smash_tilde(buf2);
      strcpy(buf3, quest->info ? quest->info : "Information for an unfinished quest.\r\n");
      strip_string(buf3);
      smash_tilde(buf3);
      strcpy(buf4, quest->ending ? quest->ending : "There is no ending!\r\n");
      strip_string(buf4);
      smash_tilde(buf4);

      /*. Build a buffer ready to save . */
      sprintf(buf, "#%d\n%s~\n%s~\n%s~\n%s~\n%d %d %ld %d %d %d %d %d %d %d %d\n",
	      counter, buf1, buf2, buf3, buf4,
	      quest->type, quest->mob_vnum,
	      quest->flags, quest->target, quest->reward_type,
	      quest->reward, quest->next_quest, quest->complete,
	      quest->min_level, quest->max_level, quest->id
	  );
      /*. Save this section . */
      fputs(buf, fp);

      sprintf(buf, "%d %d %d %d\n", quest->value[0], quest->value[1],
	      quest->value[2], quest->value[3]);
      fputs(buf, fp);

      fprintf(fp, "S\n");
    }
  }
  /* write final line and close */
  fprintf(fp, "$~\n");
  fclose(fp);
  olc_remove_from_save_list(zone_table[znum].number, OLC_SAVE_QUEST);
}

/*------------------------------------------------------------------------*/

void free_quest(struct aq_data *quest)
{
  if (quest->desc)
    free(quest->desc);
  if (quest->short_desc)
    free(quest->short_desc);
  if (quest->info)
    free(quest->info);
  if (quest->ending)
    free(quest->ending);
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

void qedit_disp_flags_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
  send_to_char("[J", d->character);
  for (counter = 0; counter < NUM_AQ_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s ",
	    grn, counter + 1, nrm, aq_flags[counter]);
    if (!(++columns % 2))
      strcat(buf, "\r\n");
    send_to_char(buf, d->character);
  }
  sprintf(buf,
	  "\r\nQuest flags: %s%s%s\r\n"
	  "Enter quest flags, 0 to quit : ",
	  cyn, aq_flags[OLC_QUEST(d)->flags], nrm
      );
  send_to_char(buf, d->character);
  OLC_MODE(d) = QEDIT_FLAGS;
}


void qedit_disp_type_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  send_to_char("[J", d->character);
  for (counter = 0; counter < NUM_AQ_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s ",
	    cyn, counter, nrm, quest_types[counter]);
    if (!(++columns % 2))
      strcat(buf, "\r\n");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter quest type : ", d->character);
  OLC_MODE(d) = QEDIT_TYPE;
}

void qedit_disp_reward_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  send_to_char("[J", d->character);
  for (counter = 0; counter < NUM_REWARD_TYPES; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s ",
	    cyn, counter, nrm, reward_types[counter]);
    if (!(++columns % 2))
      strcat(buf, "\r\n");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter reward type : ", d->character);
  OLC_MODE(d) = QEDIT_REWARD_TYPE;
}
void qedit_disp_val0_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = QEDIT_VALUE_0;
  switch (OLC_QUEST(d)->type) {
  case AQ_RETURN_OBJ:
    send_to_char("Enter vnum of mob to receive object: ", d->character);
    break;
  default:
    qedit_disp_menu(d);
  }
}

void qedit_disp_val1_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = QEDIT_VALUE_1;
  switch (OLC_QUEST(d)->type) {
  default:
    qedit_disp_menu(d);
  }
}

void qedit_disp_val2_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = QEDIT_VALUE_2;
  switch (OLC_QUEST(d)->type) {
  default:
    qedit_disp_menu(d);
  }
}

void qedit_disp_val3_menu(struct descriptor_data *d)
{
  OLC_MODE(d) = QEDIT_VALUE_3;
  switch (OLC_QUEST(d)->type) {
  default:
    qedit_disp_menu(d);
  }
}

/* the main menu */
void qedit_disp_menu(struct descriptor_data *d)
{
  struct aq_data *quest;
  extern struct char_data *mob_proto;

  get_char_cols(d->character);
  quest = OLC_QUEST(d);

//  sprintbit(quest->flags, aq_flags, buf1);
  sprintf(buf2, "%d %d %d %d", quest->value[0], quest->value[1], quest->value[2],
	  quest->value[3]);
  sprintf(buf,
	  "[J"
	  "-- Quest number : [%s%d%s]  	Quest zone: [%s%d%s]\r\n"
	  "%s1%s) Name        : %s%s%s\r\n"
	  "%s2%s) Description :\r\n%s%s%s\r\n"
	  "%s3%s) Information :\r\n%s%s%s"
	  "%s4%s) Ending      :\r\n%s%s%s"
	  "%s5%s) Questmaster : %s%d%s -- %s%s%s\r\n"
	  "%s6%s) Type        : %s%s%s\r\n"
	  "%s7%s) Flags       : %s%s%s\r\n"
	  "%s8%s) Target vnum : %s%d%s\r\n"
	  "%s9%s) Reward type : %s%s%s\r\n"
	  "%sA%s) Reward      : %s%d%s\r\n"
	  "%sB%s) Next quest  : %s%d%s\r\n"
	  "%sC%s) Values      : %s%s%s\r\n"
	  "%sD%s) Min level   : %s%d%s\r\n"
	  "%sE%s) Max level   : %s%d%s\r\n"
	  "%s*%s) Completed?  : %s%s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  cyn, OLC_NUM(d), nrm,
	  cyn, zone_table[OLC_ZNUM(d)].number, nrm,
	  cyn, nrm, grn, quest->short_desc, nrm,
	  cyn, nrm, grn, quest->desc, nrm,
	  cyn, nrm, grn, quest->info, nrm,
	  cyn, nrm, grn, quest->ending, nrm,
	  cyn, nrm, grn, quest->mob_vnum, nrm, grn,
	  real_mobile(quest->mob_vnum) > -1 ? mob_proto[real_mobile(quest->mob_vnum)].player.short_descr : "None", nrm,
	  cyn, nrm, grn, quest_types[quest->type], nrm,
	  cyn, nrm, grn, aq_flags[quest->flags], nrm,
	  cyn, nrm, grn, quest->target, nrm,
	  cyn, nrm, grn, reward_types[quest->reward_type], nrm,
	  cyn, nrm, grn, quest->reward, nrm,
	  cyn, nrm, grn, quest->next_quest, nrm,
	  cyn, nrm, grn, buf2, nrm,
	  cyn, nrm, grn, quest->min_level, nrm,
	  cyn, nrm, grn, quest->max_level, nrm,
	  cyn, nrm, grn, quest->complete == 1 ? "YES" : "NO", nrm,
	  cyn, nrm
      );
  send_to_char(buf, d->character);

  OLC_MODE(d) = QEDIT_MAIN_MENU;
}



/**************************************************************************
  The main loop
 **************************************************************************/

void qedit_parse(struct descriptor_data *d, char *arg)
{
//  extern struct aq_data *aquest_table;
  int number = 0;

  switch (OLC_MODE(d)) {
  case QEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      qedit_save_internally(d);
      sprintf(buf, "OLC: %s edits quest %d", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, LVL_BUILDER, TRUE);
      /*. Do NOT free strings! just the room structure . */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Quest saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /* free everything up, including strings etc */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save this quest internally? : ", d->character);
      break;
    }
    return;

  case QEDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {		/*. Something has been modified . */
	send_to_char("Do you wish to save this quest internally? : ", d->character);
	OLC_MODE(d) = QEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter quest name:-\r\n| ", d->character);
      OLC_MODE(d) = QEDIT_NAME;
      break;
    case '2':
      send_to_char("Enter quest description:-\r\n| ", d->character);
      OLC_MODE(d) = QEDIT_DESC;
      break;
    case '3':
      OLC_MODE(d) = QEDIT_INFO;
#if defined(CLEAR_SCREEN)
      SEND_TO_Q("\x1B[H\x1B[J", d);
#endif
      SEND_TO_Q("Enter quest information: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_QUEST(d)->info) {
	SEND_TO_Q(OLC_QUEST(d)->info, d);
	d->backstr = str_dup(OLC_QUEST(d)->info);
      }
      d->str = &OLC_QUEST(d)->info;
      d->max_str = MAX_QUEST_INFO;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '4':
      OLC_MODE(d) = QEDIT_ENDING;
#if defined(CLEAR_SCREEN)
      SEND_TO_Q("\x1B[H\x1B[J", d);
#endif
      SEND_TO_Q("Enter quest ending: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_QUEST(d)->ending) {
	SEND_TO_Q(OLC_QUEST(d)->ending, d);
	d->backstr = str_dup(OLC_QUEST(d)->ending);
      }
      d->str = &OLC_QUEST(d)->ending;
      d->max_str = MAX_QUEST_ENDING;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '5':
      send_to_char("Enter questmaster vnum: ", d->character);
      OLC_MODE(d) = QEDIT_QUESTMASTER;
      break;
    case '6':
      qedit_disp_type_menu(d);
      break;
    case '7':
      qedit_disp_flags_menu(d);
      break;
    case '8':
      send_to_char("Enter target vnum: ", d->character);
      OLC_MODE(d) = QEDIT_TARGET;
      break;
    case '9':
      qedit_disp_reward_menu(d);
      OLC_MODE(d) = QEDIT_REWARD_TYPE;
      break;
    case 'a':
    case 'A':
      send_to_char("Reward (object vnum, experience, cash amount): ", d->character);
      OLC_MODE(d) = QEDIT_REWARD;
      break;
    case 'b':
    case 'B':
      send_to_char("Next quest (-1 to end): ", d->character);
      OLC_MODE(d) = QEDIT_NEXT;
      break;
    case 'c':
    case 'C':
      OLC_QUEST(d)->value[0] = 0;
      OLC_QUEST(d)->value[1] = 0;
      OLC_QUEST(d)->value[2] = 0;
      OLC_QUEST(d)->value[3] = 0;
      qedit_disp_val0_menu(d);
      break;
    case 'd':
    case 'D':
      send_to_char("Min Level: ", d->character);
      OLC_MODE(d) = QEDIT_MIN_LEVEL;
      break;
    case 'e':
    case 'E':
      send_to_char("Max Level: ", d->character);
      OLC_MODE(d) = QEDIT_MAX_LEVEL;
      break;
    default:
      send_to_char("Invalid choice!", d->character);
      qedit_disp_menu(d);
      break;
    }
    return;

  case QEDIT_NAME:
    if (OLC_QUEST(d)->short_desc)
      free(OLC_QUEST(d)->short_desc);
    if (strlen(arg) > MAX_QUEST_NAME)
      arg[MAX_QUEST_NAME - 1] = 0;
    OLC_QUEST(d)->short_desc = str_dup(arg);
    break;

  case QEDIT_DESC:
    if (OLC_QUEST(d)->desc)
      free(OLC_QUEST(d)->desc);
    if (strlen(arg) > 80)
      arg[79] = 0;
    OLC_QUEST(d)->desc = str_dup(arg);
    break;

  case QEDIT_INFO:
    /*
     * We will NEVER get here, we hope.
     */
    mudlog("SYSERR: Reached QEDIT_INFO case in parse_qedit", BRF, LVL_BUILDER, TRUE);
    break;

  case QEDIT_ENDING:
    /*
     * We will NEVER get here, we hope.
     */
    mudlog("SYSERR: Reached QEDIT_ENDING case in parse_qedit", BRF, LVL_BUILDER, TRUE);
    break;

  case QEDIT_QUESTMASTER:
    number = atoi(arg);
    if (real_mobile(number) >= 0)
      OLC_QUEST(d)->mob_vnum = number;
    else
      OLC_QUEST(d)->mob_vnum = -1;
    break;

  case QEDIT_TYPE:
    number = atoi(arg);
    if (number < 0 || number >= NUM_AQ_TYPES) {
      send_to_char("Invalid choice!", d->character);
      qedit_disp_type_menu(d);
      return;
    } else
      OLC_QUEST(d)->type = number;
    break;

  case QEDIT_FLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_AQ_FLAGS)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      qedit_disp_flags_menu(d);
    } else {
      if (number == 0)
	break;
      else {
	/* toggle bits */
	if (IS_SET(OLC_QUEST(d)->flags, 1 << (number - 1)))
	  REMOVE_BIT(OLC_QUEST(d)->flags, 1 << (number - 1));
	else
	  SET_BIT(OLC_QUEST(d)->flags, 1 << (number - 1));
	qedit_disp_flags_menu(d);
      }
    }
    return;

  case QEDIT_TARGET:
    number = atoi(arg);
    OLC_QUEST(d)->target = MAX(0, number);
    break;

  case QEDIT_REWARD_TYPE:
    number = atoi(arg);
    if (number < 0 || number >= NUM_REWARD_TYPES) {
      send_to_char("Invalid choice!", d->character);
      qedit_disp_reward_menu(d);
      return;
    } else
      OLC_QUEST(d)->reward_type = number;
    break;

  case QEDIT_REWARD:
    number = atoi(arg);
    OLC_QUEST(d)->reward = MAX(0, MIN(number, 100000));
    break;

  case QEDIT_NEXT:
    number = atoi(arg);
    if (real_quest(number) >= 0)
      OLC_QUEST(d)->next_quest = number;
    else
      OLC_QUEST(d)->next_quest = -1;
    break;

  case QEDIT_MIN_LEVEL:
    number = atoi(arg);
    OLC_QUEST(d)->min_level = MAX(0, MIN(number, OLC_QUEST(d)->max_level));
    break;

  case QEDIT_MAX_LEVEL:
    number = atoi(arg);
    OLC_QUEST(d)->max_level = MAX(OLC_QUEST(d)->min_level+1, MIN(number, LVL_IMMORT-1));
    break;
    
  case QEDIT_VALUE_0:
    number = atoi(arg);
    switch (OLC_QUEST(d)->type) {
    case AQ_RETURN_OBJ:
      if (real_mobile(number) < 0)
	number = 0;
      break;
    }
    OLC_QUEST(d)->value[0] = number;
    qedit_disp_val1_menu(d);
    return;

  case QEDIT_VALUE_1:
    OLC_QUEST(d)->value[1] = atoi(arg);
    qedit_disp_val2_menu(d);
    return;

  case QEDIT_VALUE_2:
    OLC_QUEST(d)->value[2] = atoi(arg);
    qedit_disp_val3_menu(d);
    return;

  case QEDIT_VALUE_3:
    OLC_QUEST(d)->value[3] = atoi(arg);
    break;

  default:
    /* we should never get here */
    mudlog("SYSERR: Reached default case in parse_qedit", BRF, LVL_BUILDER, TRUE);
    break;
  }
  /*. If we get this far, something has be changed . */
  OLC_VAL(d) = 1;
  qedit_disp_menu(d);
}
::::::::::::::
quest.c
::::::::::::::
/************************************************************************
 * Quest system - quest.c					v1.6	*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include <signal.h>

#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "interpreter.h"
#include "db.h"
#include "handler.h"
#include "comm.h"
#include "olc.h"
#include "quest.h"

extern struct aq_data *aquest_table;
extern struct zone_data *zone_table;
extern struct index_data *mob_index;
extern int top_of_aquestt;
extern struct index_data *obj_index;
extern struct room_data *world;
extern long asciiflag_conv(char *flag);
extern struct player_index_element *player_table;

void smash_tilde(char *string);
void qedit_save_to_disk(int zone_num);
void free_quest(struct aq_data *quest);
int find_name(char *name);

const char *quest_types[] =
{
  "Object",
  "Room",
  "Find mob",
  "Kill mob",
  "Save mob",
  "Return object",
  "\n"
};

const char *reward_types[] =
{
  "Experience",
  "Object",
  "Money",
  "Quest Points",
  "\n"
};

/* Autoquest flags */
char *aq_flags[] =
{
  "REPEATABLE",
  "\n"
};

int real_quest(int vnum)
{
  int rnum;

  for (rnum = 0; rnum <= top_of_aquestt; rnum++) {
    if (rnum <= top_of_aquestt)
      if (aquest_table[rnum].virtual == vnum)
	break;
  }

  if (rnum > top_of_aquestt)
    rnum = -1;
  return (rnum);
}

int is_complete(int vnum)
{

  if (aquest_table[real_quest(vnum)].complete == 1)
      return TRUE;

  return FALSE;

}

int find_quest_by_qmnum(int qm, int num)
{
  int i;
  int found = 0;

  for (i = 0; i <= top_of_aquestt; i++)
    if (qm == aquest_table[i].mob_vnum) {
      found++;
      if (found == num)
	return (aquest_table[i].virtual);
    }
  return -1;
}

/* PARSE_QUEST */
void parse_quest(FILE * quest_f, int nr)
{
  static char line[256];
  static int i = 0, j;
  int retval = 0, t[10];
  char f1[128];

//  sprintf(debug, "Parsing quest #%d", nr);
  //  log(debug);

  aquest_table[i].virtual = nr;
  aquest_table[i].mob_vnum = -1;
  aquest_table[i].short_desc = NULL;
  aquest_table[i].desc = NULL;
  aquest_table[i].info = NULL;
  aquest_table[i].ending = NULL;
  aquest_table[i].flags = -1;
  aquest_table[i].type = -1;
  aquest_table[i].target = -1;
  aquest_table[i].reward_type = 0;
  aquest_table[i].reward = 0;
  for (j = 0; j < 4; j++)
    aquest_table[i].value[j] = 0;
  aquest_table[i].next_quest = -1;
  aquest_table[i].complete = -1;
  aquest_table[i].min_level = 0;
  aquest_table[i].max_level = 0;
  aquest_table[i].id = -1;
  
  /* begin to parse the data */
  aquest_table[i].short_desc = fread_string(quest_f, buf2);
  aquest_table[i].desc = fread_string(quest_f, buf2);
  aquest_table[i].info = fread_string(quest_f, buf2);
  aquest_table[i].ending = fread_string(quest_f, buf2);

  if (!get_line(quest_f, line) ||
      (retval = sscanf(line, " %d %d %s %d %d %d %d %d %d %d %d", t, t + 1, f1, t + 2, t + 3, t + 4, t + 5, t + 6, t + 7, t + 8, t + 9)) != 11) {
    fprintf(stderr, "Format error in numeric line (expected 11, got %d), %s\n", retval, buf2);
    raise(SIGSEGV);
  }
  aquest_table[i].type = t[0];
  aquest_table[i].mob_vnum = t[1];
  aquest_table[i].flags = asciiflag_conv(f1);
  aquest_table[i].target = t[2];
  aquest_table[i].reward_type = t[3];
  aquest_table[i].reward = t[4];
  aquest_table[i].next_quest = t[5];
  aquest_table[i].complete = t[6];
  aquest_table[i].min_level = t[7];
  aquest_table[i].max_level = t[8];
  aquest_table[i].id = t[9];
    
  if (!get_line(quest_f, line) ||
  (retval = sscanf(line, " %d %d %d %d", t, t + 1, t + 2, t + 3)) != 4) {
    fprintf(stderr, "Format error in numeric line (expected 4, got %d), %s\n", retval, buf2);
    raise(SIGSEGV);
  }
  aquest_table[i].value[0] = t[0];
  aquest_table[i].value[1] = t[1];
  aquest_table[i].value[2] = t[2];
  aquest_table[i].value[3] = t[3];

  for (;;) {
    if (!get_line(quest_f, line)) {
      fprintf(stderr, "Format error in %s\n", buf2);
      raise(SIGSEGV);
    }
    switch (*line) {
    case 'S':
      top_of_aquestt = i++;
      return;
    }
  }
}

void list_quests(struct char_data *ch, int questmaster)
{
  int i;
  int number = 1;
  char envia[100];
  
  sprintf(buf, "\r\nYou can join this quests, choose with care one of them because after join you\r\n"
               "can't get out. You have two ways to get out, completing the quest or if another\r\n"
               "player complete the quest before you.\r\n\r\n"
               "To join type: join <num>\r\n"
	       "To get info: list <num>\r\n"
	       "---  ------------------------------------------------------------------------\r\n"
	       "&RNum  &WDescription&n\r\n"
	       "---  ------------------------------------------------------------------------\r\n");

  for (i = 0; i <= top_of_aquestt; i++)
    if (questmaster == aquest_table[i].mob_vnum) {
  
      if(get_name_by_id(aquest_table[i].id) != NULL)
	  sprintf(envia, "&c(completed by &R%s&c)&n", get_name_by_id(aquest_table[i].id));
      else
          strcpy(envia, "&c(completed)&n");
        
      sprintf(buf+strlen(buf), "&R%3d  &W%s %s &C[&c%d &Cto &c%d&C]&n\r\n", number, aquest_table[i].desc,
	  is_complete(aquest_table[i].virtual) ? envia : "", aquest_table[i].min_level,
	  aquest_table[i].max_level);
      number++;
    }
  page_string(ch->desc, buf, 1);
}

void quest_save_internally(int num, struct char_data *ch)
{
  struct aq_data *quest;
  int i, real_num;

  real_num = real_quest(num);

  /*. Build a copy of the quest . */
  CREATE(quest, struct aq_data, 1);
  *quest = aquest_table[real_num];
  /* allocate space for all strings  */
  if (aquest_table[real_num].short_desc)
    quest->short_desc = str_dup(aquest_table[real_num].short_desc);
  if (aquest_table[real_num].desc)
    quest->desc = str_dup(aquest_table[real_num].desc);
  if (aquest_table[real_num].info)
    quest->info = str_dup(aquest_table[real_num].info);
  if (aquest_table[real_num].ending)
    quest->ending = str_dup(aquest_table[real_num].ending);
  quest->type = aquest_table[real_num].type;
  quest->mob_vnum = aquest_table[real_num].mob_vnum;
  quest->flags = aquest_table[real_num].flags;
  quest->target = aquest_table[real_num].target;
  quest->reward_type = aquest_table[real_num].reward_type;
  quest->reward = aquest_table[real_num].reward;
  quest->next_quest = aquest_table[real_num].next_quest;
  quest->complete = 1;
  quest->min_level = aquest_table[real_num].min_level;
  quest->max_level = aquest_table[real_num].max_level;
  quest->id = player_table[find_name(GET_NAME(ch))].id;
  
  for (i = 0; i < 4; i++)
    quest->value[i] = aquest_table[real_num].value[i];

  free_quest(aquest_table + real_num);
  aquest_table[real_num] = *(quest);

  olc_add_to_save_list(zone_table[num/100].number, OLC_SAVE_QUEST);
}


void add_completed_quest(struct char_data * ch, int num)
{

   sprintf(buf, "(QUEST) %s has completed the quest %d.", GET_NAME(ch), num);
   mudlog(buf, BRF, LVL_OLC_FULL, TRUE);

   quest_save_internally(num, ch);
   qedit_save_to_disk(num/100);
   
}

/* Generic reward character, cleanup stuff fn */
void generic_complete_quest(struct char_data *ch)
{
  int rnum, r_num;
  struct obj_data *obj;

  rnum = real_quest(GET_QUEST(ch));

  switch (aquest_table[rnum].reward_type) {
  case REWARD_EXP:
    GET_EXP(ch) += aquest_table[rnum].reward;
    sprintf(buf, "Your reward is %s points of experience.\r\n", add_points(aquest_table[rnum].reward));
    send_to_char(buf, ch);
    break;
  case REWARD_OBJ:
    if ((r_num = real_object(aquest_table[rnum].reward)) < 0) {
      log("Quest #%d attempted to load a reward obj that doesnt exist!", aquest_table[rnum].virtual);
      return;
    }
    obj = read_object(r_num, REAL);
    obj_to_char(obj, ch);
    sprintf(buf, "Your reward is %s.\r\n", obj->short_description);
    send_to_char(buf, ch);
    break;
  case REWARD_GOLD:
    GET_GOLD(ch) += aquest_table[rnum].reward;
    sprintf(buf, "Your reward is %s gold coins.\r\n", add_points(aquest_table[rnum].reward));
    send_to_char(buf, ch);
    break;
  case REWARD_QP:
    GET_QP(ch) += aquest_table[rnum].reward;
    sprintf(buf, "Your reward is %s questpoints.\r\n", add_points(aquest_table[rnum].reward));
    send_to_char(buf, ch);
    break;
  default:
    log("Quest #%d has an invalid reward type!", aquest_table[rnum].virtual);
    break;
  }
  send_to_char(aquest_table[rnum].ending, ch);
  if (IS_SET(aquest_table[rnum].flags, AQ_REPEATABLE))
    add_completed_quest(ch, GET_QUEST(ch));
  if ((real_quest(aquest_table[rnum].next_quest) >= 0) &&
      (aquest_table[rnum].next_quest != GET_QUEST(ch)) &&
      !is_complete(aquest_table[rnum].next_quest)) {
    GET_QUEST(ch) = aquest_table[real_quest((int) GET_QUEST(ch))].next_quest;
    send_to_char(aquest_table[real_quest((int) GET_QUEST(ch))].info, ch);
  } else
    GET_QUEST(ch) = -1;

  save_char(ch, ch->in_room);
}

void autoquest_trigger_check(struct char_data *ch, struct char_data *vict,
			     struct obj_data *object, int type)
{
  struct char_data *i;
  int rnum, found;

  if (IS_NPC(ch))
    return;

  if (GET_QUEST(ch) < 0)	/* No current quest, skip this */
    return;

  if (GET_QUEST_TYPE(ch) != type)
    return;

  if ((rnum = real_quest(GET_QUEST(ch))) < 0)
    return;

  switch (type) {
  case AQ_OBJECT:
    if (aquest_table[rnum].target == GET_OBJ_VNUM(object))
      generic_complete_quest(ch);
    break;
  case AQ_ROOM:
    if (aquest_table[rnum].target == world[ch->in_room].number)
      generic_complete_quest(ch);
    break;
  case AQ_MOB_FIND:
    for (i = world[ch->in_room].people; i; i = i->next_in_room)
      if (IS_NPC(i))
	if (aquest_table[rnum].target == GET_MOB_VNUM(i))
	  generic_complete_quest(ch);
    break;
  case AQ_MOB_KILL:
    if (!IS_NPC(ch) && IS_NPC(vict) && (ch != vict))
      if (aquest_table[rnum].target == GET_MOB_VNUM(vict))
	generic_complete_quest(ch);
    break;
  case AQ_MOB_SAVE:
    found = TRUE;
    if (ch == vict)
      found = FALSE;

    for (i = world[ch->in_room].people; i && found; i = i->next_in_room)
      if (i && IS_NPC(i))
	if ((GET_MOB_VNUM(i) != aquest_table[rnum].target) && !AFF_FLAGGED(i, AFF_CHARM))
	  found = FALSE;

    if (found)
      generic_complete_quest(ch);
    break;
  case AQ_RETURN_OBJ:
    if (IS_NPC(vict) && (GET_MOB_VNUM(vict) == aquest_table[rnum].value[0]))
      if (object && (GET_OBJ_VNUM(object) == aquest_table[rnum].target))
	generic_complete_quest(ch);
    break;
  default:
    log("SYSERR: Invalid quest type passed to autoquest_trigger_check");
    break;
  }
}

int can_join(struct char_data *ch, int tmp)
{
    if(GET_LEVEL(ch) > aquest_table[real_quest(tmp)].min_level &&
       GET_LEVEL(ch) < aquest_table[real_quest(tmp)].max_level)
          return (1);

    return (0);
}

SPECIAL(questmaster)
{
  int tmp, num;
  struct char_data *qm = me;

  if (CMD_IS("list")) {
    if (!*argument)
      list_quests(ch, GET_MOB_VNUM(qm));
    else {
      if ((num = find_quest_by_qmnum(GET_MOB_VNUM(qm), atoi(argument))) >= 0) {
	if (aquest_table[real_quest(num)].info)
	  send_to_char(aquest_table[real_quest(num)].info, ch);
	else
	  send_to_char("There is no further information on that quest.\r\n", ch);
      } else
	send_to_char("That is not a valid quest number!\r\n", ch);
    }
    return 1;
  }
  if (CMD_IS("join")) {
    if (!*argument) {
      send_to_char("Join what quest?\r\n", ch);
      return 1;
    }
    if (GET_QUEST(ch) != -1) {
      send_to_char("You are already part of a quest!\r\n", ch);
      return 1;
    }
    tmp = atoi(argument);
    tmp = find_quest_by_qmnum(GET_MOB_VNUM(qm), tmp);
    if ((tmp >= 0) && !is_complete(tmp) && can_join(ch, tmp)) {
      send_to_char(aquest_table[real_quest(tmp)].info, ch);
      send_to_char("You are now part of that quest!\r\n", ch);
      GET_QUEST(ch) = tmp;
      save_char(ch, ch->in_room);
      return 1;
    } else if (is_complete(tmp)) {
      send_to_char("This quest are already completed!\r\n", ch);
      return 1;
    } else if (!can_join(ch, tmp)) {
      send_to_char("You need be in the quest range to join.\r\n", ch);
      return 1;
    } else {
      send_to_char("That is not a valid quest!\r\n", ch);
      return 1;
    }
  }
  return 0;
}

ACMD(do_qstat)
{
  int vnum, rnum;
  char str[MAX_INPUT_LENGTH];
  struct char_data *tmp;

  if (GET_LEVEL(ch) < LVL_OLC_FULL){
   if(GET_OLC_ZONE(ch) != QEDIT_PERMISSION){
    send_to_char("You do not have permission to edit quests.\r\n", ch);
    return;
   }
  }
  
  half_chop(argument, str, argument);
  if (*str) {
    vnum = atoi(str);
    rnum = real_quest(vnum);
    if (rnum < 0) {
      send_to_char("That vnum does not exist.\r\n", ch);
      return;
    }
    *buf = '\0';
    tmp = read_mobile(aquest_table[rnum].mob_vnum, VIRTUAL);
    sprintf(buf, "VNum: [%5d], RNum: [%5d] -- Questmaster: %s\r\n",
	    vnum, rnum, GET_NAME(tmp));
    sprintf(buf, "%sName: %s\r\n", buf, aquest_table[rnum].short_desc);
    sprintf(buf, "%sDesc: %s\r\n", buf, aquest_table[rnum].desc);
    sprintf(buf, "%sInformation:\r\n%s", buf, aquest_table[rnum].info);
    sprintf(buf, "%sEnding:\r\n%s", buf, aquest_table[rnum].ending);
    sprintf(buf, "%sType : %s, Target: %d, Reward Type: %s\r\n Reward: %d, Next quest: %d\r\n",
    buf, quest_types[aquest_table[rnum].type], aquest_table[rnum].target,
	    reward_types[aquest_table[rnum].reward_type],
	    aquest_table[rnum].reward, aquest_table[rnum].next_quest);
    sprintf(buf, "%sLevel Range: %d to %d\r\n", buf, aquest_table[rnum].min_level,
	    aquest_table[rnum].max_level);
    sprintf(buf, "%sValue: %d %d %d %d\r\n", buf, aquest_table[rnum].value[0],
	    aquest_table[rnum].value[1], aquest_table[rnum].value[2],
	    aquest_table[rnum].value[3]);
    sprintf(buf, "%sFlags: %s\r\n", buf, aq_flags[aquest_table[rnum].flags]);
    send_to_char(buf, ch);

  } else
    send_to_char("Usage: qstat <vnum>\r\n", ch);
}

ACMD(do_qlist)
{

  int first, last, nr, found = 0;
  char pagebuf[65536];

  strcpy(pagebuf, "");

  two_arguments(argument, buf, buf2);

  if (!*buf) {
    send_to_char("Usage: qlist <begining number or zone> [<ending number>]\r\n", ch);
    return;
  }
  first = atoi(buf);
  if (*buf2)
    last = atoi(buf2);
  else {
    first *= 100;
    last = first + 99;
  }

  if ((first < 0) || (first > 9999) || (last < 0) || (last > 99999)) {
    send_to_char("Values must be between 0 and 99999.\n\r", ch);
    return;
  }
  if (first >= last) {
    send_to_char("Second value must be greater than first.\n\r", ch);
    return;
  }
  for (nr = 0; nr <= top_of_aquestt && (aquest_table[nr].virtual <= last); nr++) {
    if (aquest_table[nr].virtual >= first) {
      sprintf(buf, "%5d. [%5d] %s\r\n", ++found,
	      aquest_table[nr].virtual,
	      aquest_table[nr].short_desc);
      strcat(pagebuf, buf);
    }
  }

  if (!found)
    send_to_char("No quests were found in those parameters.\n\r", ch);
  else
    page_string(ch->desc, pagebuf, TRUE);
}

/* reads quest from mob file, and attaches it */
void read_quest(FILE * fp, int i)
{
  char line[256];
  char junk[8];
  int vnum, count;

  get_line(fp, line);
  count = sscanf(line, "%s %d", junk, &vnum);

  if (count != 2) {
    /* should do a better job of making this message */
    log("SYSERR: Error assigning quest!");
    return;
  }
  mob_index[i].func = questmaster;
}

void quest_save_to_file(FILE * fp, struct char_data *mob)
{
  if (mob_index[mob->nr].func == (questmaster))
    fprintf(fp, "Q 1\n");
}
::::::::::::::
race.c
::::::::::::::
/* Race file created by Archangel to WarDome MUD */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "interpreter.h"
#include "utils.h"
#include "db.h"

void    write_to_output(const char *txt, struct descriptor_data *d);
#define SEND_TO_Q(messg, desc)  write_to_output((messg), desc)
//int invalid_race(struct char_data *ch, struct obj_data *obj);

const char *race_abbrevs[] = {   
  "Hum",
  "Dro",
  "Dwa",
  "Elf",
  "Ogr",
  "Orc",
  "Tro",
  "Git",
  "Gno",
  "Hal",
  "Liz",
  "Sea",
  "Gor",
  "Dun",
  "Anc",
  "Nau",
  "Hig",
  "Hil",
  "Bug", 
  "Cav",
  "Lic",
  "Tin",
  "Dra",
  "Hse",
  "Arc",
  "\n"
};                               
                                 
const char *pc_race_types[] = {  
  "Human",
  "Drow",
  "Dwarf",
  "Elf",
  "Ogre",
  "Orc",
  "Troll",
  "Gith",
  "Gnome",
  "Lizardman",
  "Sea Elf",
  "Gorak",
  "Dunedain",
  "Ancient Drow",
  "Naugrim",
  "High Elf",
  "Hill Ogre",
  "BugBear",
  "Cave Troll",
  "Lich",
  "Tinker",
  "Draconian",
  "High Sea Elf",
  "Archons",
  "\n"                           
};

char *pc_race_help_types[] = {  
  "Human",
  "Drow",
  "Dwarf",
  "Elf",
  "Ogre",
  "Orc",
  "Troll",
  "Gith",
  "Gnome",
  "Lizardman",
  "Sea Elf",
  "Gorak",
  "Dunedain",
  "Ancient Drow",
  "Naugrim",
  "High Elf",
  "Hill Ogre",
  "BugBear",
  "Cave Troll",
  "Lich",
  "Tinker",
  "Draconian",
  "High Sea Elf",
  "Archons",
  "\n"                           
};                                    

/* The menu for choosing a race in interpreter.c: */ 
const char *race_menu =                              
"\r\n"
"Here you can select you race, a race defines your personality...\r\n"
"You will never change your race, so think before the selection.\r\n"
"\r\n"
"  [a] Human		""  [b] Drow		""  [c] Dwarf		\r\n"
"  [d] Elf		""  [e] Ogre		""  [f] Orc		\r\n"
"  [g] Troll		""  [h] Gith		""  [i] Gnome		\r\n"
"  [j] Lizardman		""  [l] Sea Elf		""  [m] Gorak		\r\n"
"-----------------------------------------------------------------------------  \r\n"
"  [R]Dunedain          ""  [R]Ancient Drow     ""  [R]Naugrim         \r\n" 
"  [R]High Elf          ""  [R]Hill Ogre        ""  [R]BugBear         \r\n"
"  [R]Cave Troll        ""  [R]Lich             ""  [R]Tinker          \r\n"
"  [R]Draconian                 ""  [R]High Sea Elf     ""  [R]Archons         \r\n"
" ** &b[&BR&b]&n - REMORT RACES, NOT AVAIBLE FOR NEW PLAYERS \r\r";

const char *pc_race_menu[] = {  
  "[A]    &WHuman&n        ",
  "[B]    &bDrow&n         ",
  "[C]    &GDwarf&n        ",
  "[D]    &gElf&n          ",
  "[E]    &BOgre&n         ",
  "[F]    &wOrc&n          ",
  "[G]    &cTroll&n        ",
  "[H]    &YGith&n         ",
  "[I]    &MGnome&n        ",
  "[J]    &yLizardman&n    ",
  "[L]    &CSea Elf&n      ",
  "[M]    &mGorak&n        ",
  "[R]    &WDunedain&n     ",     
  "[R]    &bAncient Drow&n ",    
  "[R]    &GNaugrim&n      ", 
  "[R]    &gHigh Elf&n     ",   
  "[R]    &BHill Ogre&n    ", 
  "[R]    &wBugBea&nr      ",
  "[R]    &cCave Troll&n   ",   
  "[R]    &YLich&n         ", 
  "[R]    &MTinker&n       ", 
  "[R]    &yDraconian&n    ",         
  "[R]    &CHigh Sea Elf&n ",  
  "[R]    &mArchons&n      ",
  "\n"                           
};

#define STR	0
#define DEX	1
#define CON	2
#define INW	3
#define WIS	4
#define CHA	5

#define MAX_ATTRIB	6
/*
int race_attrib[][MAX_ATTRIB] = {
//  STR DEX CON INT WIS CHA
    { 0,  0,  0,  0,  0,  0},//HUM  *
    { 0,  0,  0,  0,  2, -2},//DRO *
    { 0,  0,  2, -1, -1, -1},//DWA *
    { 0,  1, -1,  0,  0,  0},//ELF *
    { 4,  0,  1, -2, -2, -1},//OGR *
    { 2,  0,  1, -2, -2, -1},//ORC *
    { 0,  0,  2, -1, -1,  0},//TRO *
    {-1,  0, -2,  3,  0,  0},//GIT *
    {-1,  0,  0,  1,  0,  0},//GNO *
    { 2,  2,  0, -2, -2,  0},//LIZ
    { 0, -1, -1,  0,  2,  0},//SEA *
    { 2,  0,  0,  1,  1,  0} //GOR
};
*/

int race_attrib[][MAX_ATTRIB] = {
//  STR DEX CON INT WIS CHA
    { 9,  9,  9,  9,  9, 10},//HUM
    { 8,  9,  8, 10, 13,  8},//DRO
    {10,  9, 13,  8,  9,  8},//DWA
    { 8, 12,  8,  9,  9, 10},//ELF
    {12, 12, 13,  6,  7,  8},//OGR
    {13, 11, 13,  6,  7,  8},//ORC
    {11, 12, 13,  7,  7,  8},//TRO
    { 9, 10,  7, 13, 10,  6},//GIT
    { 9,  9,  9, 13,  9, 10},//GNO
    {13, 12, 10,  7,  8,  8},//LIZ
    { 9,  9,  8,  9, 12, 14},//SEA
    { 13, 9,  9,  8, 8,  10 }, // GORAK
    {11,  9,  9,  9, 11, 10},// dunedain
    { 8,  11,  8, 10, 15, 8},// ancient drow
    {12,  9, 15,  8,  9,  8},// naugrim
    { 8, 13,  8,  9,  11, 12},// high elf
    {14, 13, 14,  6,  7,  8},// hill ogre
    {14, 13, 14,  6,  7,  8},// bugbear
    {12, 13, 15,  7,  7,  8},// cave troll
    { 9, 10,  9, 15, 10,  6},// lich
    { 9,  9,  11, 13, 11, 10},// tinker
    {15, 12, 10,  7,  8,  12},// draconian
    {11,  9,  8, 11, 12, 14},// high sea elf
    { 13, 11,  9,  10, 8,  10 } // archons

};

char *atrib_line(int race)
{
   int j;

	*buf3 = '\0';
	for(j = 0; j < MAX_ATTRIB; j++)
		sprintf(buf3+strlen(buf3), "   %3d", 
race_attrib[race][j]);

   return (buf3);
}

void display_races(struct descriptor_data *d)
{
  int x;
  char tes[65536];
  
	strcpy(tes, "\r\n  &C[&cOption&C]  &WRACE&n 		  STR   DEX   CON   INT   WIS   CHA\r\n");
	for(x = 0; x < NUM_RACES; x++)
		sprintf(tes+strlen(tes), "     %s        %s\r\n", pc_race_menu[x], atrib_line(x));

	SEND_TO_Q(tes, d);
}

/*
 * The code to interpret a race letter (used in interpreter.c when a 
 * new character is selecting a race).                               
 */                                                                  
int parse_race(char arg)                                             
{                                                                    
  arg = LOWER(arg);                                                  
                                                                     
  switch (arg) {                                                     
  case 'A':
  case 'a':
    return RACE_VAMPIRE;
    break;
  case 'B':
  case 'b':
    return RACE_DROW;
    break;
  case 'C':
  case 'c':
    return RACE_DWARF;
    break;
  case 'D':
  case 'd':
    return RACE_ELF;
    break;
  case 'E':
  case 'e':
    return RACE_OGRE;
    break;
  case 'F':
  case 'f':
    return RACE_ORC;
    break;
  case 'G':
  case 'g':
    return RACE_TROLL;
    break;
  case 'H':
  case 'h':
    return RACE_GITH;
    break;
  case 'I':
  case 'i':
    return RACE_GNOME;
    break;
  case 'J':
  case 'j':
    return RACE_LIZARDMAN;
    break;
  case 'L':
  case 'l':
    return RACE_SEA_ELF;
    break;
  case 'M':
  case 'm':
    return RACE_GORAK;
    break;
  case 'N':
  case 'n':
    return RACE_DUNEDAIN;
    break;
  case 'O':
  case 'o':
    return RACE_ANCI_DROW;
    break;
  case 'P':
  case 'p':
    return RACE_NAUGRIM;
    break;
  case 'Q':
  case 'q':
    return RACE_HIGH_ELF;
    break;
  case 'R':
  case 'r':
    return RACE_HILL_OGRE;
    break;
  case 'S':
  case 's':
    return RACE_BUGBEAR;
    break;
  case 'T':
  case 't':
    return RACE_CAVE_TROLL;
    break;
  case 'U':
  case 'u':
    return RACE_LICH;
    break;
  case 'V':
  case 'v':
    return RACE_TINKER;
    break;
  case 'X':
  case 'x':
    return RACE_DRACONIAN;
    break;
  case 'Y':
  case 'y':
    return RACE_H_SEA_ELF;
    break;
  case 'Z':
  case 'z':
    return RACE_ARCHONS;
    break;
    
  default:                                                           
    return RACE_UNDEFINED;                                           
    break;                                                           
  }                                                                  
}                                                                    

long find_race_bitvector(char arg)                                   
{                                                                    
 arg = LOWER(arg);                                                  
                                                                     
 switch (arg) {                                                     

  case 'A':
  case 'a':
    return ( 1 << RACE_VAMPIRE);
    break;
  case 'B':
  case 'b':
    return ( 1 << RACE_DROW);
    break;
  case 'C':
  case 'c':
    return ( 1 << RACE_DWARF);
    break;
  case 'D':
  case 'd':
    return ( 1 << RACE_ELF);
    break;
  case 'E':
  case 'e':
    return ( 1 << RACE_OGRE);
    break;
  case 'F':
  case 'f':
    return ( 1 << RACE_ORC);
    break;
  case 'G':
  case 'g':
    return ( 1 << RACE_TROLL);
    break;
  case 'H':
  case 'h':
    return ( 1 << RACE_GITH);
    break;
  case 'I':
  case 'i':
    return ( 1 << RACE_GNOME);
    break;
  case 'J':
  case 'j':
    return ( 1 << RACE_LIZARDMAN);
    break;
  case 'L':
  case 'l':
    return ( 1 << RACE_SEA_ELF);
    break;
  case 'M':
  case 'm':
    return ( 1 << RACE_GORAK);
    break;
    case 'N':
  case 'n':
    return ( 1 << RACE_DUNEDAIN);
    break;
  case 'O':
  case 'o':
    return ( 1 << RACE_ANCI_DROW);
    break;
  case 'P':
  case 'p':
    return ( 1 << RACE_NAUGRIM);
    break;
  case 'Q':
  case 'q':
    return ( 1 << RACE_HIGH_ELF);
    break;
  case 'R':
  case 'r':
    return ( 1 << RACE_HILL_OGRE);
    break;
  case 'S':
  case 's':
    return ( 1 << RACE_BUGBEAR);
    break;
  case 'T':
  case 't':
    return ( 1 << RACE_CAVE_TROLL);
    break;
  case 'U':
  case 'u':
    return ( 1 << RACE_LICH);
    break;
  case 'V':
  case 'v':
    return ( 1 << RACE_TINKER);
    break;
  case 'X':
  case 'x':
    return ( 1 << RACE_DRACONIAN);
    break;
  case 'Y':
  case 'y':
    return ( 1 << RACE_H_SEA_ELF);
    break;
  case 'Z':
  case 'z':
    return ( 1 << RACE_ARCHONS);
    break;  
          
  default:                                                         
    return RACE_UNDEFINED;                                                      
    break;                                                         
 }                                                                  
}
/*
int invalid_race(struct char_data *ch, struct obj_data *obj) {
  if (GET_LEVEL(ch) >= LVL_GOD ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_VAMPIRE)  && IS_VAMPIRE(ch) )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_DROW)      && IS_DROW(ch)     )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_DWARF) && IS_DWARF(ch))  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_ELF)     && IS_ELF(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_OGRE)     && IS_OGRE(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_ORC)       && IS_ORC(ch)      )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_TROLL)       && IS_TROLL(ch)      )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_GITH)      && IS_GITH(ch)     )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_GNOME)     && IS_GNOME(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_LIZARDMAN)     && IS_LIZARDMAN(ch)    )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_SEA_ELF)    && IS_SEA_ELF(ch)   )  ||
      (IS_OBJ_STAT(obj, ITEM_ANTI_GORAK)   && IS_GORAK(ch)) )

        return 1;
  else
        return 0;
}
*/
::::::::::::::
random.c
::::::::::::::
/* ************************************************************************
*   File: random.c                                      Part of CircleMUD *
*  Usage: pseudo-random number generator                                  *
************************************************************************ */

/*
 * I am bothered by the non-portablility of 'rand' and 'random' -- rand
 * is ANSI C, but on some systems such as Suns, rand has seriously tragic
 * spectral properties (the low bit alternates between 0 and 1!).  random
 * is better but isn't supported by all systems.  So, in my quest for Ultimate
 * CircleMUD Portability, I decided to include this code for a simple but
 * relatively effective random number generator.  It's not the best RNG code
 * around, but I like it because it's very short and simple, and for our
 * purposes it's "random enough".
 *               --Jeremy Elson  2/23/95
 *
 * Now that we're using GNU's autoconf, I've coded Circle to always use
 * random(), and automatically link in this object file if random() isn't
 * supported on the target system.  -JE 2/3/96
 *
 * Well, despite autoconf we're back to using this random all the
 * time.  Oh well, there's no harm in changing my mind on this one
 * from release to release...  -JE 10/28/97
 */

/***************************************************************************/

/*
 *
 * This program is public domain and was written by William S. England
 * (Oct 1988).  It is based on an article by:
 *
 * Stephen K. Park and Keith W. Miller. RANDOM NUMBER GENERATORS:
 * GOOD ONES ARE HARD TO FIND. Communications of the ACM,
 * New York, NY.,October 1988 p.1192

 The following is a portable c program for generating random numbers.
 The modulus and multipilier have been extensively tested and should
 not be changed except by someone who is a professional Lehmer generator
 writer.  THIS GENERATOR REPRESENTS THE MINIMUM STANDARD AGAINST WHICH
 OTHER GENERATORS SHOULD BE JUDGED. ("Quote from the referenced article's
 authors. WSE" )
*/

#define m  (unsigned long)2147483647
#define q  (unsigned long)127773

#define a (unsigned int)16807
#define r (unsigned int)2836

/*
** F(z) = (az)%m
**      = az-m(az/m)
**
** F(z)  = G(z)+mT(z)
** G(z)  = a(z%q)- r(z/q)
** T(z)  = (z/q) - (az/m)
**
** F(z)  = a(z%q)- rz/q+ m((z/q) - a(z/m))
**       = a(z%q)- rz/q+ m(z/q) - az
*/

static unsigned long seed;

/* local functions */
void circle_srandom(unsigned long initial_seed);
unsigned long circle_random(void);


void circle_srandom(unsigned long initial_seed)
{
    seed = initial_seed; 
}


unsigned long circle_random(void)
{
   int lo, hi, test;

    hi   = seed/q;
    lo   = seed%q;

    test = a*lo - r*hi;

    if (test > 0)
        seed = test;
    else
        seed = test+ m;

    return (seed);
}
::::::::::::::
redit.c
::::::::::::::
/************************************************************************
 *  OasisOLC - redit.c						v1.5	*
 *  Copyright 1996 Harvey Gilpin.					*
 *  Original author: Levork						*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "boards.h"
#include "olc.h"
#include "dg_olc.h"
#include "teleport.h"

/* List each room saved, was used for debugging. */
#if 0
#define REDIT_LIST	1
#endif

/*------------------------------------------------------------------------*/

/*
 * External data structures.
 */
extern int top_of_world;
extern struct room_data *world;
extern struct obj_data *obj_proto;
extern struct char_data *mob_proto;
extern const char *room_bits[];
extern const char *sector_types[];
extern const char *exit_bits[];
extern struct zone_data *zone_table;
extern sh_int r_mortal_start_room;
extern sh_int r_immort_start_room;
extern sh_int r_frozen_start_room;
extern sh_int mortal_start_room;
extern sh_int immort_start_room;
extern sh_int frozen_start_room;
extern int top_of_zone_table;
extern struct descriptor_data *descriptor_list;
extern long asciiflag_conv(char *flag);
extern const char *teleport_bits[];
/*------------------------------------------------------------------------*/

/*
 * Function Prototypes
 */
void redit_disp_extradesc_menu(struct descriptor_data *d);
void redit_disp_exit_menu(struct descriptor_data *d);
void redit_disp_exit_flag_menu(struct descriptor_data *d);
void redit_disp_flag_menu(struct descriptor_data *d);
void redit_disp_sector_menu(struct descriptor_data *d);
void redit_disp_teleport_menu(struct descriptor_data *d);
void redit_disp_menu(struct descriptor_data *d);
void redit_parse(struct descriptor_data *d, char *arg);
void redit_setup_new(struct descriptor_data *d);
void redit_setup_existing(struct descriptor_data *d, int real_num);
void redit_save_to_disk(int zone);
void redit_save_internally(struct descriptor_data *d);
void free_room(struct room_data *room);

/*------------------------------------------------------------------------*/

#define  W_EXIT(room, num) (world[(room)].dir_option[(num)])

/*------------------------------------------------------------------------*\
  Utils and exported functions.
\*------------------------------------------------------------------------*/

void redit_setup_new(struct descriptor_data *d)
{
  struct teleport_data *new_tele;

  CREATE(OLC_ROOM(d), struct room_data, 1);
  OLC_ROOM(d)->name = str_dup("An unfinished room");
  OLC_ROOM(d)->description = str_dup("You are in an unfinished room.\r\n");
  CREATE(new_tele, struct teleport_data, 1);
  OLC_ROOM(d)->tele = new_tele;
  OLC_ROOM(d)->tele->targ = 0;
  OLC_ROOM(d)->tele->time = MIN_TELEPORT_FREQ;
  OLC_ROOM(d)->tele->mask = 0;
  OLC_ROOM(d)->tele->cnt = 0;
  OLC_ROOM(d)->tele->obj = 0;

  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = WLD_TRIGGER;
  redit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

void redit_setup_existing(struct descriptor_data *d, int real_num)
{
  struct room_data *room;
  struct trig_proto_list *proto, *fproto;
  int counter;
  struct teleport_data *new_tele;
  
  /*
   * Build a copy of the room for editing.
   */
  CREATE(room, struct room_data, 1);

  *room = world[real_num];
  /*
   * Allocate space for all strings.
   */
  room->name = str_dup(world[real_num].name ? world[real_num].name : "undefined");
  room->description = str_dup(world[real_num].description ?
			world[real_num].description : "undefined\r\n");
  /*
   * Exits - We allocate only if necessary.
   */
  for (counter = 0; counter < NUM_OF_DIRS; counter++) {
    if (world[real_num].dir_option[counter]) {
      CREATE(room->dir_option[counter], struct room_direction_data, 1);

      /*
       * Copy the numbers over.
       */
      *room->dir_option[counter] = *world[real_num].dir_option[counter];
      /*
       * Allocate the strings.
       */
      room->dir_option[counter]->general_description =
		(world[real_num].dir_option[counter]->general_description ?
		str_dup(world[real_num].dir_option[counter]->general_description)
		: NULL);
      room->dir_option[counter]->keyword =
		(world[real_num].dir_option[counter]->keyword ?
		str_dup(world[real_num].dir_option[counter]->keyword) : NULL);
    }
  }

  /*
   * Extra descriptions, if necessary.
   */
  if (world[real_num].ex_description) {
    struct extra_descr_data *this, *temp, *temp2;
    CREATE(temp, struct extra_descr_data, 1);

    room->ex_description = temp;
    for (this = world[real_num].ex_description; this; this = this->next) {
      temp->keyword = (this->keyword ? str_dup(this->keyword) : NULL);
      temp->description = (this->description ? str_dup(this->description) : NULL);
      if (this->next) {
	CREATE(temp2, struct extra_descr_data, 1);
	temp->next = temp2;
	temp = temp2;
      } else
	temp->next = NULL;
    }
  }

  if (SCRIPT(&world[real_num]))
    script_copy(room, &world[real_num], WLD_TRIGGER);
  proto = world[real_num].proto_script;
  while (proto) {
    CREATE(fproto, struct trig_proto_list, 1);
    fproto->vnum = proto->vnum;
    if (room->proto_script==NULL)
      room->proto_script = fproto;
    proto = proto->next;
    fproto = fproto->next; /* NULL */
  }

  /* setup teleporter */
  CREATE(new_tele, struct teleport_data, 1);
  room->tele = new_tele;
  if (world[real_num].tele != NULL) {
      room->tele->targ = world[real_num].tele->targ;
      room->tele->time = world[real_num].tele->time;
      room->tele->mask = world[real_num].tele->mask;
      room->tele->cnt = world[real_num].tele->cnt;
      room->tele->obj = world[real_num].tele->obj;
  } else {
      room->tele->time = MIN_TELEPORT_FREQ;
  }
    
  /*
   * Attach copy of room to player's descriptor.
   */
  OLC_ROOM(d) = room;
  OLC_VAL(d) = 0;
  OLC_ITEM_TYPE(d) = WLD_TRIGGER;
  dg_olc_script_copy(d);
  redit_disp_menu(d);
}

/*------------------------------------------------------------------------*/

#define ZCMD (zone_table[zone].cmd[cmd_no])

void redit_save_internally(struct descriptor_data *d)
{
  int i, j, room_num, found = 0, zone, cmd_no;
  struct room_data *new_world;
  struct char_data *temp_ch;
  struct obj_data *temp_obj;
  struct descriptor_data *dsc;

  room_num = real_room(OLC_NUM(d));

  /*
   * Room exists: move contents over then free and replace it.
   */
  if (room_num > 0) {
    OLC_ROOM(d)->contents = world[room_num].contents;
    OLC_ROOM(d)->people = world[room_num].people;
    free_room(world + room_num);
    world[room_num] = *OLC_ROOM(d);
    world[room_num].proto_script = OLC_SCRIPT(d);
  } else {			/* Room doesn't exist, hafta add it. */
    CREATE(new_world, struct room_data, top_of_world + 2);

    /*
     * Count through world tables.
     */
    for (i = 0; i <= top_of_world; i++) {
      if (!found) {
	/*
	 * Is this the place? 
	 */
	if (world[i].number > OLC_NUM(d)) {
	  found = TRUE;
	  new_world[i] = *(OLC_ROOM(d));
	  new_world[i].number = OLC_NUM(d);
	  new_world[i].func = NULL;
          new_world[i].proto_script = OLC_SCRIPT(d);
	  room_num = i;

	  /*
	   * Copy from world to new_world + 1.
	   */
	  new_world[i + 1] = world[i];

	  /*
	   * People in this room must have their numbers moved up one.
	   */
	  for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
	    if (temp_ch->in_room != NOWHERE)
	      temp_ch->in_room = i + 1;

	  /*
	   * Move objects up one room.
	   */
	  for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
	    if (temp_obj->in_room != NOWHERE)
	      temp_obj->in_room = i + 1;
	} else	/* Not yet placed, copy straight over. */
	  new_world[i] = world[i];
      } else {		/* Already been found. */
	/*
	 * People in this room must have their in_rooms moved.
	 */
	for (temp_ch = world[i].people; temp_ch; temp_ch = temp_ch->next_in_room)
	  if (temp_ch->in_room != NOWHERE)
	    temp_ch->in_room = i + 1;
	/*
	 * Move objects too.
	 */
	for (temp_obj = world[i].contents; temp_obj; temp_obj = temp_obj->next_content)
	  if (temp_obj->in_room != -1)
	    temp_obj->in_room = i + 1;

	new_world[i + 1] = world[i];
      }
    }
    if (!found) {	/* Still not found, insert at top of table. */
      new_world[i] = *(OLC_ROOM(d));
      new_world[i].number = OLC_NUM(d);
      new_world[i].func = NULL;
      new_world[i].proto_script = OLC_SCRIPT(d);
      room_num = i;
    }

    /*
     * Copy world table over to new one.
     */
    free(world);
    world = new_world;
    top_of_world++;

    /*
     * Update zone table.
     */
    for (zone = 0; zone <= top_of_zone_table; zone++)
      for (cmd_no = 0; ZCMD.command != 'S'; cmd_no++)
	switch (ZCMD.command) {
	case 'M':
	case 'O':
	  if (ZCMD.arg3 >= room_num)
	    ZCMD.arg3++;
	  break;
	case 'D':
	case 'R':
	  if (ZCMD.arg1 >= room_num)
	    ZCMD.arg1++;
	case 'G':
	case 'P':
	case 'E':
	case '*':
	  break;
	default:
	  mudlog("SYSERR: OLC: redit_save_internally: Unknown comand", BRF, LVL_BUILDER, TRUE);
	}

    /*
     * Update load rooms, to fix creeping load room problem.
     */
    if (room_num <= r_mortal_start_room)
      r_mortal_start_room++;
    if (room_num <= r_immort_start_room)
      r_immort_start_room++;
    if (room_num <= r_frozen_start_room)
      r_frozen_start_room++;

    /*
     * Update world exits.
     */
    for (i = 0; i < top_of_world + 1; i++)
      for (j = 0; j < NUM_OF_DIRS; j++)
	if (W_EXIT(i, j))
	  if (W_EXIT(i, j)->to_room >= room_num)
	    W_EXIT(i, j)->to_room++;
    /*
     * Update any rooms being edited.
     */
    for (dsc = descriptor_list; dsc; dsc = dsc->next)
      if (dsc->connected == CON_REDIT)
	for (j = 0; j < NUM_OF_DIRS; j++)
	  if (OLC_ROOM(dsc)->dir_option[j])
	    if (OLC_ROOM(dsc)->dir_option[j]->to_room >= room_num)
	      OLC_ROOM(dsc)->dir_option[j]->to_room++;

    if (OLC_ROOM(d)->tele == NULL) {
        /* this is a null teleport! Remove it! */
        REMOVE_BIT(OLC_ROOM(d)->room_flags, ROOM_TELEPORT);
        free(OLC_ROOM(d)->tele);
        OLC_ROOM(d)->tele = NULL;
    }
  }
  assign_triggers(&world[room_num], WLD_TRIGGER);
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_ROOM);
}

/*------------------------------------------------------------------------*/

void redit_save_to_disk(int zone_num)
{
  int counter, counter2, realcounter;
  FILE *fp;
  struct room_data *room;
  struct extra_descr_data *ex_desc;

  if (zone_num < 0 || zone_num > top_of_zone_table) {
    log("SYSERR: redit_save_to_disk: Invalid real zone passed!");
    return;
  }

  sprintf(buf, "%s/%d.new", WLD_PREFIX, zone_table[zone_num].number);
  if (!(fp = fopen(buf, "w+"))) {
    mudlog("SYSERR: OLC: Cannot open room file!", BRF, LVL_BUILDER, TRUE);
    return;
  }
  for (counter = zone_table[zone_num].number * 100;
       counter <= zone_table[zone_num].top; counter++) {
    if ((realcounter = real_room(counter)) >= 0) {
      room = (world + realcounter);

#if defined(REDIT_LIST)
      sprintf(buf1, "OLC: Saving room %d.", room->number);
      log(buf1);
#endif

      /*
       * Remove the '\r\n' sequences from description.
       */
      strcpy(buf1, room->description ? room->description : "Empty");
      strip_string(buf1);

      /*
       * Forget making a buffer, lets just write the thing now.
       */
      fprintf(fp, "#%d\n%s~\n%s~\n%d %d %d\n", counter,
	      room->name ? room->name : "undefined", buf1,
	      zone_table[room->zone].number,
	      room->room_flags, room->sector_type);

      /*
       * Handle exits.
       */
      for (counter2 = 0; counter2 < NUM_OF_DIRS; counter2++) {
	if (room->dir_option[counter2]) {
	  int temp_door_flag;

	  /*
	   * Again, strip out the garbage.
	   */
	  if (room->dir_option[counter2]->general_description) {
	    strcpy(buf1, room->dir_option[counter2]->general_description);
	    strip_string(buf1);
	  } else
	    *buf1 = 0;

	  /*
	   * Figure out door flag. 
	   */
	  if (IS_SET(room->dir_option[counter2]->exit_info, EX_ISDOOR)) {
	    if (IS_SET(room->dir_option[counter2]->exit_info, EX_PICKPROOF))
	      temp_door_flag = 2;
	    else
	      temp_door_flag = 1;
	  } else
	    temp_door_flag = 0;

	  /*
	   * Check for keywords.
	   */
	  if (room->dir_option[counter2]->keyword)
	    strcpy(buf2, room->dir_option[counter2]->keyword);
	  else
	    *buf2 = '\0';

	  /*
	   * Ok, now wrote output to file.
	   */
	  fprintf(fp, "D%d\n%s~\n%s~\n%d %d %d\n", counter2, buf1, buf2,
		  temp_door_flag, room->dir_option[counter2]->key,
		  room->dir_option[counter2]->to_room != -1 ?
		  world[room->dir_option[counter2]->to_room].number : -1);
	}
      }
      /*
       * Home straight, just deal with extra descriptions.
       */
      if (room->ex_description) {
	for (ex_desc = room->ex_description; ex_desc; ex_desc = ex_desc->next) {
	  strcpy(buf1, ex_desc->description);
	  strip_string(buf1);
	  fprintf(fp, "E\n%s~\n%s~\n", ex_desc->keyword, buf1);
	}
      }

      /* save teleport info */
      if ((room->tele != NULL) && (room->tele->targ > 0)) {
        fprintf(fp, "T\n%d %ld %d %d\n",
                room->tele->targ,
                room->tele->mask,
                room->tele->time,
                room->tele->obj);
      }
            
      fprintf(fp, "S\n");
      script_save_to_disk(fp, room, WLD_TRIGGER);

    }
  }
  /*
   * Write final line and close.
   */
  fprintf(fp, "$~\n");
  fclose(fp);
  sprintf(buf2, "%s/%d.wld", WLD_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(buf, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_ROOM);
}

/*------------------------------------------------------------------------*/

void free_room(struct room_data *room)
{
  int i;
  struct extra_descr_data *this, *next;

  if (room->name)
    free(room->name);
  if (room->description)
    free(room->description);
  if (room->tele)
    free(room->tele);
    
  /*
   * Free exits.
   */
  for (i = 0; i < NUM_OF_DIRS; i++) {
    if (room->dir_option[i]) {
      if (room->dir_option[i]->general_description)
	free(room->dir_option[i]->general_description);
      if (room->dir_option[i]->keyword)
	free(room->dir_option[i]->keyword);
    }
    free(room->dir_option[i]);
  }

  /*
   * Free extra descriptions.
   */
  for (this = room->ex_description; this; this = next) {
    next = this->next;
    if (this->keyword)
      free(this->keyword);
    if (this->description)
      free(this->description);
    free(this);
  }
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

/*
 * For extra descriptions.
 */
void redit_disp_extradesc_menu(struct descriptor_data *d)
{
  struct extra_descr_data *extra_desc = OLC_DESC(d);

  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  "%s1%s) Keyword: %s%s\r\n"
	  "%s2%s) Description:\r\n%s%s\r\n"
	  "%s3%s) Goto next description: ",

	  grn, nrm, yel, extra_desc->keyword ? extra_desc->keyword : "<NONE>",
	  grn, nrm, yel, extra_desc->description ? extra_desc->description : "<NONE>",
	  grn, nrm
	  );

  strcat(buf, !extra_desc->next ? "<NOT SET>\r\n" : "Set.\r\n");
  strcat(buf, "Enter choice (0 to quit) : ");
  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_EXTRADESC_MENU;
}

/*
 * For exits.
 */
void redit_disp_exit_menu(struct descriptor_data *d)
{
  /*
   * if exit doesn't exist, alloc/create it 
   */
  if (!OLC_EXIT(d))
    CREATE(OLC_EXIT(d), struct room_direction_data, 1);

  /*
   * Weird door handling! 
   */
  if (IS_SET(OLC_EXIT(d)->exit_info, EX_ISDOOR)) {
    if (IS_SET(OLC_EXIT(d)->exit_info, EX_PICKPROOF))
      strcpy(buf2, "Pickproof");
    else
      strcpy(buf2, "Is a door");
  } else
    strcpy(buf2, "No door");

  get_char_cols(d->character);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  "%s1%s) Exit to     : %s%d\r\n"
	  "%s2%s) Description :-\r\n%s%s\r\n"
	  "%s3%s) Door name   : %s%s\r\n"
	  "%s4%s) Key         : %s%d\r\n"
	  "%s5%s) Door flags  : %s%s\r\n"
	  "%s6%s) Purge exit.\r\n"
	  "Enter choice, 0 to quit : ",

	  grn, nrm, cyn, OLC_EXIT(d)->to_room != -1 ? world[OLC_EXIT(d)->to_room].number : -1,
	  grn, nrm, yel, OLC_EXIT(d)->general_description ? OLC_EXIT(d)->general_description : "<NONE>",
	  grn, nrm, yel, OLC_EXIT(d)->keyword ? OLC_EXIT(d)->keyword : "<NONE>",
	  grn, nrm, cyn, OLC_EXIT(d)->key,
	  grn, nrm, cyn, buf2, grn, nrm
	  );

  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_EXIT_MENU;
}

/*
 * For exit flags.
 */
void redit_disp_exit_flag_menu(struct descriptor_data *d)
{
  get_char_cols(d->character);
  sprintf(buf, "%s0%s) No door\r\n"
	  "%s1%s) Closeable door\r\n"
	  "%s2%s) Pickproof\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);
}

/*
 * For room flags.
 */
void redit_disp_flag_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_ROOM_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		room_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(OLC_ROOM(d)->room_flags, room_bits, buf1);
  sprintf(buf, "\r\nRoom flags: %s%s%s\r\n"
	  "Enter room flags, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = REDIT_FLAGS;
}

/*
 * For sector type.
 */
void redit_disp_sector_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (counter = 0; counter < NUM_ROOM_SECTORS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
		sector_types[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  send_to_char("\r\nEnter sector type : ", d->character);
  OLC_MODE(d) = REDIT_SECTOR;
}

/*
 * The main menu.
 */
void redit_disp_menu(struct descriptor_data *d)
{
  struct room_data *room;
  char buf3[200];

  get_char_cols(d->character);
  room = OLC_ROOM(d);

  sprintbit(room->tele->mask, teleport_bits, buf3);
  sprintbit((long)room->room_flags, room_bits, buf1);
  sprinttype(room->sector_type, sector_types, buf2);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  "-- Room number : [%s%d%s]  	Room zone: [%s%d%s]\r\n"
	  "%s1%s) Name        : %s%s\r\n"
	  "%s2%s) Description :\r\n%s%s"
	  "%s3%s) Room flags  : %s%s\r\n"
	  "%s4%s) Sector type : %s%s\r\n"
	  "%s5%s) Exit north  : %s%d\r\n"
	  "%s6%s) Exit east   : %s%d\r\n"
	  "%s7%s) Exit south  : %s%d\r\n"
	  "%s8%s) Exit west   : %s%d\r\n"
	  "%s9%s) Exit up     : %s%d\r\n"
	  "%sA%s) Exit down   : %s%d\r\n"
	  "%sB%s) Extra descriptions menu\r\n"
          "%sC%s) Tele-Target : %s%s(%d) (Set to '0' (The Void) to disable)\r\n"
          "%sD%s) Tele-Freq   : %s%d*10 seconds\r\n"
          "%sE%s) Tele-Flags  : %s%s\r\n"
          "%sF%s) Tele-Obj    : %s%d (%s flag is set)\r\n"
          "%sS%s) Script      : %s%s\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ",

	  cyn, OLC_NUM(d), nrm,
	  cyn, zone_table[OLC_ZNUM(d)].number, nrm,
	  grn, nrm, yel, room->name,
	  grn, nrm, yel, room->description,
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2,
	  grn, nrm, cyn,
	  room->dir_option[NORTH] && room->dir_option[NORTH]->to_room != -1 ?
	  world[room->dir_option[NORTH]->to_room].number : -1,
	  grn, nrm, cyn,
	  room->dir_option[EAST] && room->dir_option[EAST]->to_room != -1 ?
	  world[room->dir_option[EAST]->to_room].number : -1,
	  grn, nrm, cyn,
	  room->dir_option[SOUTH] && room->dir_option[SOUTH]->to_room != -1 ?
	  world[room->dir_option[SOUTH]->to_room].number : -1,
	  grn, nrm, cyn,
	  room->dir_option[WEST] && room->dir_option[WEST]->to_room != -1 ?
	  world[room->dir_option[WEST]->to_room].number : -1,
	  grn, nrm, cyn,
	  room->dir_option[UP] && room->dir_option[UP]->to_room != -1 ? 
	  world[room->dir_option[UP]->to_room].number : -1,
	  grn, nrm, cyn,
	  room->dir_option[DOWN] && room->dir_option[DOWN]->to_room != -1 ?
	  world[room->dir_option[DOWN]->to_room].number : -1,
	  grn, nrm, 
          grn, nrm, cyn, world[real_room(room->tele->targ)].name, room->tele->targ,
          grn, nrm, cyn, room->tele->time,
          grn, nrm, cyn, buf3,
          grn, nrm, cyn, room->tele->obj,
            (IS_SET(room->tele->mask, TELE_NOOBJ) ? "if not have Obj" : "if has Obj"),
          grn, nrm, cyn, room->proto_script?"Set.":"Not Set.",
          grn, nrm
	  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = REDIT_MAIN_MENU;
}

/**************************************************************************
  The main loop
 **************************************************************************/

void redit_parse(struct descriptor_data *d, char *arg)
{
  int number;

  switch (OLC_MODE(d)) {
  case REDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      redit_save_internally(d);
      sprintf(buf, "OLC: %s edits room %d.", GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /*
       * Do NOT free strings! Just the room structure. 
       */
      cleanup_olc(d, CLEANUP_STRUCTS);
      send_to_char("Room saved to memory.\r\n", d->character);
      break;
    case 'n':
    case 'N':
      /*
       * Free everything up, including strings, etc.
       */
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save this room internally? : ", d->character);
      break;
    }
    return;

  case REDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) { /* Something has been modified. */
	send_to_char("Do you wish to save this room internally? : ", d->character);
	OLC_MODE(d) = REDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '1':
      send_to_char("Enter room name:-\r\n] ", d->character);
      OLC_MODE(d) = REDIT_NAME;
      break;
    case '2':
      OLC_MODE(d) = REDIT_DESC;
#if defined(CLEAR_SCREEN)
      SEND_TO_Q("\x1B[H\x1B[J", d);
#endif
      SEND_TO_Q("Enter room description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_ROOM(d)->description) {
	SEND_TO_Q(OLC_ROOM(d)->description, d);
	d->backstr = str_dup(OLC_ROOM(d)->description);
      }
      d->str = &OLC_ROOM(d)->description;
      d->max_str = MAX_ROOM_DESC;
      d->mail_to = 0;
      OLC_VAL(d) = 1;
      break;
    case '3':
      redit_disp_flag_menu(d);
      break;
    case '4':
      redit_disp_sector_menu(d);
      break;
    case '5':
      OLC_VAL(d) = NORTH;
      redit_disp_exit_menu(d);
      break;
    case '6':
      OLC_VAL(d) = EAST;
      redit_disp_exit_menu(d);
      break;
    case '7':
      OLC_VAL(d) = SOUTH;
      redit_disp_exit_menu(d);
      break;
    case '8':
      OLC_VAL(d) = WEST;
      redit_disp_exit_menu(d);
      break;
    case '9':
      OLC_VAL(d) = UP;
      redit_disp_exit_menu(d);
      break;
    case 'a':
    case 'A':
      OLC_VAL(d) = DOWN;
      redit_disp_exit_menu(d);
      break;
    case 'b':
    case 'B':
      /*
       * If the extra description doesn't exist.
       */
      if (!OLC_ROOM(d)->ex_description) {
	CREATE(OLC_ROOM(d)->ex_description, struct extra_descr_data, 1);
	OLC_ROOM(d)->ex_description->next = NULL;
      }
      OLC_DESC(d) = OLC_ROOM(d)->ex_description;
      redit_disp_extradesc_menu(d);
      break;
    case 'c':
    case 'C':
      send_to_char("Enter target vnum: ", d->character);
      OLC_MODE(d) = REDIT_TELEPORT_TARGET;
      break;
    case 'd':
    case 'D':
      send_to_char("Enter teleport frequency: ", d->character);
      OLC_MODE(d) = REDIT_TELEPORT_FREQ;
      break;
    case 'e':
    case 'E':
      redit_disp_teleport_menu(d);
      break;
    case 'f':
    case 'F':
      send_to_char("Enter Object's Vnum: ", d->character);
      OLC_MODE(d) = REDIT_TELEPORT_OBJ;
      break;
    case 's':
    case 'S':
      OLC_SCRIPT_EDIT_MODE(d) = SCRIPT_MAIN_MENU;
      dg_script_menu(d);
      return;
    default:
      send_to_char("Invalid choice!", d->character);
      redit_disp_menu(d);
      break;
    }
    return;

  case OLC_SCRIPT_EDIT:
    if (dg_script_edit_parse(d, arg)) return;
    break;

  case REDIT_NAME:
    if (OLC_ROOM(d)->name)
      free(OLC_ROOM(d)->name);
    if (strlen(arg) > MAX_ROOM_NAME)
      arg[MAX_ROOM_NAME - 1] = '\0';
    OLC_ROOM(d)->name = str_dup((arg && *arg) ? arg : "undefined");
    break;

  case REDIT_DESC:
    /*
     * We will NEVER get here, we hope.
     */
    mudlog("SYSERR: Reached REDIT_DESC case in parse_redit", BRF, LVL_BUILDER, TRUE);
    break;

  case REDIT_FLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > NUM_ROOM_FLAGS)) {
      send_to_char("That is not a valid choice!\r\n", d->character);
      redit_disp_flag_menu(d);
    } else if (number == 0)
	break;
    else {
      /*
       * Toggle the bit.
       */
      TOGGLE_BIT(OLC_ROOM(d)->room_flags, 1 << (number - 1));
      redit_disp_flag_menu(d);
    }
    return;

  case REDIT_SECTOR:
    number = atoi(arg);
    if (number < 0 || number >= NUM_ROOM_SECTORS) {
      send_to_char("Invalid choice!", d->character);
      redit_disp_sector_menu(d);
      return;
    } else
      OLC_ROOM(d)->sector_type = number;
    break;

  case REDIT_EXIT_MENU:
    switch (*arg) {
    case '0':
      break;
    case '1':
      OLC_MODE(d) = REDIT_EXIT_NUMBER;
      send_to_char("Exit to room number : ", d->character);
      return;
    case '2':
      OLC_MODE(d) = REDIT_EXIT_DESCRIPTION;
      SEND_TO_Q("Enter exit description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_EXIT(d)->general_description) {
	SEND_TO_Q(OLC_EXIT(d)->general_description, d);
	d->backstr = str_dup(OLC_EXIT(d)->general_description);
      }
      d->str = &OLC_EXIT(d)->general_description;
      d->max_str = MAX_EXIT_DESC;
      d->mail_to = 0;
      return;
    case '3':
      OLC_MODE(d) = REDIT_EXIT_KEYWORD;
      send_to_char("Enter keywords : ", d->character);
      return;
    case '4':
      OLC_MODE(d) = REDIT_EXIT_KEY;
      send_to_char("Enter key number : ", d->character);
      return;
    case '5':
      redit_disp_exit_flag_menu(d);
      OLC_MODE(d) = REDIT_EXIT_DOORFLAGS;
      return;
    case '6':
      /*
       * Delete an exit.
       */
      if (OLC_EXIT(d)->keyword)
	free(OLC_EXIT(d)->keyword);
      if (OLC_EXIT(d)->general_description)
	free(OLC_EXIT(d)->general_description);
      if (OLC_EXIT(d))
	free(OLC_EXIT(d));
      OLC_EXIT(d) = NULL;
      break;
     default:
      send_to_char("Try again : ", d->character);
      return;
    }
    break;

  case REDIT_EXIT_NUMBER:
    if ((number = atoi(arg)) != -1)
      if ((number = real_room(number)) < 0) {
	send_to_char("That room does not exist, try again : ", d->character);
	return;
      }
    OLC_EXIT(d)->to_room = number;
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_DESCRIPTION:
    /*
     * We should NEVER get here, hopefully.
     */
    mudlog("SYSERR: Reached REDIT_EXIT_DESC case in parse_redit", BRF, LVL_BUILDER, TRUE);
    break;

  case REDIT_EXIT_KEYWORD:
    if (OLC_EXIT(d)->keyword)
      free(OLC_EXIT(d)->keyword);
    OLC_EXIT(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_KEY:
    OLC_EXIT(d)->key = atoi(arg);
    redit_disp_exit_menu(d);
    return;

  case REDIT_EXIT_DOORFLAGS:
    number = atoi(arg);
    if ((number < 0) || (number > 2)) {
      send_to_char("That's not a valid choice!\r\n", d->character);
      redit_disp_exit_flag_menu(d);
    } else {
      /*
       * Doors are a bit idiotic, don't you think? :) I agree.
       */
      OLC_EXIT(d)->exit_info = (number == 0 ? 0 :
				(number == 1 ? EX_ISDOOR :
				(number == 2 ? EX_ISDOOR | EX_PICKPROOF : 0)));
      /*
       * Jump back to the menu system.
       */
      redit_disp_exit_menu(d);
    }
    return;

  case REDIT_EXTRADESC_KEY:
    OLC_DESC(d)->keyword = ((arg && *arg) ? str_dup(arg) : NULL);
    redit_disp_extradesc_menu(d);
    return;

  case REDIT_EXTRADESC_MENU:
    switch ((number = atoi(arg))) {
    case 0:
      {
	/*
	 * If something got left out, delete the extra description
	 * when backing out to the menu.
	 */
	if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	  struct extra_descr_data **tmp_desc;

	  if (OLC_DESC(d)->keyword)
	    free(OLC_DESC(d)->keyword);
	  if (OLC_DESC(d)->description)
	    free(OLC_DESC(d)->description);

	  /*
	   * Clean up pointers.
	   */
	  for (tmp_desc = &(OLC_ROOM(d)->ex_description); *tmp_desc;
	       tmp_desc = &((*tmp_desc)->next))
	    if (*tmp_desc == OLC_DESC(d)) {
	      *tmp_desc = NULL;
	      break;
	    }
	  free(OLC_DESC(d));
	}
      }
      break;
    case 1:
      OLC_MODE(d) = REDIT_EXTRADESC_KEY;
      send_to_char("Enter keywords, separated by spaces : ", d->character);
      return;
    case 2:
      OLC_MODE(d) = REDIT_EXTRADESC_DESCRIPTION;
      SEND_TO_Q("Enter extra description: (/s saves /h for help)\r\n\r\n", d);
      d->backstr = NULL;
      if (OLC_DESC(d)->description) {
	SEND_TO_Q(OLC_DESC(d)->description, d);
	d->backstr = str_dup(OLC_DESC(d)->description);
      }
      d->str = &OLC_DESC(d)->description;
      d->max_str = MAX_MESSAGE_LENGTH;
      d->mail_to = 0;
      return;

    case 3:
      if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
	send_to_char("You can't edit the next extra desc without completing this one.\r\n", d->character);
	redit_disp_extradesc_menu(d);
      } else {
	struct extra_descr_data *new_extra;

	if (OLC_DESC(d)->next)
	  OLC_DESC(d) = OLC_DESC(d)->next;
	else {
	  /*
	   * Make new extra description and attach at end.
	   */
	  CREATE(new_extra, struct extra_descr_data, 1);
	  OLC_DESC(d)->next = new_extra;
	  OLC_DESC(d) = new_extra;
	}
	redit_disp_extradesc_menu(d);
      }
      return;
    }
    break;

  case REDIT_TELEPORT_TARGET:
    if (isdigit(*arg)) {
        number = atoi(arg);
        if (real_room(number) != -1) {
                if (number == 0) {
                        /* remove TELEPORT flag from room */
                        REMOVE_BIT(OLC_ROOM(d)->room_flags, ROOM_TELEPORT);
                } else {
                        SET_BIT(OLC_ROOM(d)->room_flags, ROOM_TELEPORT);
                }
                OLC_ROOM(d)->tele->targ = number;
                break;
        }
    }
    send_to_char("That was not a valid room, please try again: ", d->character);
    return;

  case REDIT_TELEPORT_FREQ:
    if (isdigit(*arg)) {
        number = atoi(arg);
        if (number >= MIN_TELEPORT_FREQ && number <= MAX_TELEPORT_FREQ) {
                OLC_ROOM(d)->tele->time = number;
                break;
        }
    }
    sprintf(buf, "That was not a valid number.\r\n"
            "Please enter a frequency between %d and %d: ",
            MIN_TELEPORT_FREQ, MAX_TELEPORT_FREQ);
    send_to_char(buf, d->character);
    return;

  case REDIT_TELEPORT_OBJ:
    if (isdigit(*arg)) {
        number = atoi(arg);
        if (real_object(number) != -1) {
                OLC_ROOM(d)->tele->obj = number;
                break;
        }
    }
    send_to_char("That was not a valid number, please enter the object's VNUM: ", d->character);
    return;

  case REDIT_TELEPORT_MENU:
    number = atoi(arg);
    if (number < 0 || number > NUM_TELEPORT) {
                redit_disp_teleport_menu(d);
    } else {
          if (number == 0)
                break;
          else {
                if (IS_SET(OLC_ROOM(d)->tele->mask, 1 << (number - 1)))
                        REMOVE_BIT(OLC_ROOM(d)->tele->mask, 1 << (number - 1));
                else
                        SET_BIT(OLC_ROOM(d)->tele->mask, 1 << (number - 1));
                redit_disp_teleport_menu(d);
          }
    }
    return;
    
  default:
    /*
     * We should never get here.
     */
    mudlog("SYSERR: Reached default case in parse_redit", BRF, LVL_BUILDER, TRUE);
    break;
  }
  /*
   * If we get this far, something has been changed.
   */
  OLC_VAL(d) = 1;
  redit_disp_menu(d);
}

/* For teleport flags */
void redit_disp_teleport_menu(struct descriptor_data *d) {
        int counter, columns = 0;

        get_char_cols(d->character);
        send_to_char("^[[H^[[J", d->character);
        for (counter = 0; counter < NUM_TELEPORT; counter ++) {
          sprintf(buf, "%s%2d%s) %-20.20s ",
                  grn, counter + 1, nrm, teleport_bits[counter]);
          if(!(++columns % 2))
                strcat(buf, "\r\n");
          send_to_char(buf, d->character);
        }
        sprintbit(OLC_ROOM(d)->tele->mask, teleport_bits, buf1);
        sprintf(buf,
                "\r\nTeleport flags, %s%s%s\r\n"
                "Enter teleport flags, 0 to quit : ",
                cyn, buf1, nrm );
        send_to_char(buf, d->character);
        OLC_MODE(d) = REDIT_TELEPORT_MENU;
}
::::::::::::::
sedit.c
::::::::::::::
/************************************************************************
 * OasisOLC - sedit.c						v1.5	*
 * Copyright 1996 Harvey Gilpin.					*
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "shop.h"
#include "olc.h"

/*-------------------------------------------------------------------*/

/*
 * External variable declarations.
 */
extern struct shop_data *shop_index;
extern int top_shop;
extern struct char_data *mob_proto;
extern struct obj_data *obj_proto;
extern struct room_data *world;
extern struct zone_data *zone_table;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern const char *trade_letters[];
extern const char *shop_bits[];
extern const char *item_types[];

/*-------------------------------------------------------------------*/

/*
 * Handy macros.
 */
#define S_NUM(i)		((i)->vnum)
#define S_KEEPER(i)		((i)->keeper)
#define S_OPEN1(i)		((i)->open1)
#define S_CLOSE1(i)		((i)->close1)
#define S_OPEN2(i)		((i)->open2)
#define S_CLOSE2(i)		((i)->close2)
#define S_BANK(i)		((i)->bankAccount)
#define S_BROKE_TEMPER(i)	((i)->temper1)
#define S_BITVECTOR(i)		((i)->bitvector)
#define S_NOTRADE(i)		((i)->with_who)
#define S_SORT(i)		((i)->lastsort)
#define S_BUYPROFIT(i)		((i)->profit_buy)
#define S_SELLPROFIT(i)		((i)->profit_sell)
#define S_FUNC(i)		((i)->func)

#define S_ROOMS(i)		((i)->in_room)
#define S_PRODUCTS(i)		((i)->producing)
#define S_NAMELISTS(i)		((i)->type)
#define S_ROOM(i, num)		((i)->in_room[(num)])
#define S_PRODUCT(i, num)	((i)->producing[(num)])
#define S_BUYTYPE(i, num)	(BUY_TYPE((i)->type[(num)]))
#define S_BUYWORD(i, num)	(BUY_WORD((i)->type[(num)]))

#define S_NOITEM1(i)		((i)->no_such_item1)
#define S_NOITEM2(i)		((i)->no_such_item2)
#define S_NOCASH1(i)		((i)->missing_cash1)
#define S_NOCASH2(i)		((i)->missing_cash2)
#define S_NOBUY(i)		((i)->do_not_buy)
#define S_BUY(i)		((i)->message_buy)
#define S_SELL(i)		((i)->message_sell)

/*-------------------------------------------------------------------*/

/*
 * Function prototypes.
 */
int real_shop(int vshop_num);
void sedit_setup_new(struct descriptor_data *d);
void sedit_setup_existing(struct descriptor_data *d, int rmob_num);
void sedit_parse(struct descriptor_data *d, char *arg);
void sedit_disp_menu(struct descriptor_data *d);
void sedit_namelist_menu(struct descriptor_data *d);
void sedit_types_menu(struct descriptor_data *d);
void sedit_products_menu(struct descriptor_data *d);
void sedit_rooms_menu(struct descriptor_data *d);
void sedit_compact_rooms_menu(struct descriptor_data *d);
void sedit_shop_flags_menu(struct descriptor_data *d);
void sedit_no_trade_menu(struct descriptor_data *d);
void sedit_save_internally(struct descriptor_data *d);
void sedit_save_to_disk(int zone);
void copy_shop(struct shop_data *tshop, struct shop_data *fshop);
void copy_list(int **tlist, int *flist);
void copy_type_list(struct shop_buy_data **tlist, struct shop_buy_data *flist);
void sedit_add_to_type_list(struct shop_buy_data **list, struct shop_buy_data *new);
void sedit_remove_from_type_list(struct shop_buy_data **list, int num);
void free_shop_strings(struct shop_data *shop);
void free_type_list(struct shop_buy_data **list);
void free_shop(struct shop_data *shop);
void sedit_modify_string(char **str, char *new);

/*
 * External functions.
 */
SPECIAL(shop_keeper);

/*-------------------------------------------------------------------*\
  utility functions 
\*-------------------------------------------------------------------*/

void sedit_setup_new(struct descriptor_data *d)
{
  struct shop_data *shop;

  /*
   * Allocate a scratch shop structure.
   */
  CREATE(shop, struct shop_data, 1);

  /*
   * Fill in some default values.
   */
  S_KEEPER(shop) = -1;
  S_CLOSE1(shop) = 28;
  S_BUYPROFIT(shop) = 1.0;
  S_SELLPROFIT(shop) = 1.0;
  /*
   * Add a spice of default strings.
   */
  S_NOITEM1(shop) = str_dup("%s Sorry, I don't stock that item.");
  S_NOITEM2(shop) = str_dup("%s You don't seem to have that.");
  S_NOCASH1(shop) = str_dup("%s I can't afford that!");
  S_NOCASH2(shop) = str_dup("%s You are too poor!");
  S_NOBUY(shop) = str_dup("%s I don't trade in such items.");
  S_BUY(shop) = str_dup("%s That'll be %d coins, thanks.");
  S_SELL(shop) = str_dup("%s I'll give you %d coins for that.");
  /*
   * Stir the lists lightly.
   */
  CREATE(S_PRODUCTS(shop), int, 1);

  S_PRODUCT(shop, 0) = -1;
  CREATE(S_ROOMS(shop), int, 1);

  S_ROOM(shop, 0) = -1;
  CREATE(S_NAMELISTS(shop), struct shop_buy_data, 1);

  S_BUYTYPE(shop, 0) = -1;

  /*
   * Presto! A shop.
   */
  OLC_SHOP(d) = shop;
  sedit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

void sedit_setup_existing(struct descriptor_data *d, int rshop_num)
{
  /*
   * Create a scratch shop structure.
   */
  CREATE(OLC_SHOP(d), struct shop_data, 1);

  copy_shop(OLC_SHOP(d), shop_index + rshop_num);
  sedit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

void copy_shop(struct shop_data *tshop, struct shop_data *fshop)
{
  /*
   * Copy basic information over.
   */
  S_NUM(tshop) = S_NUM(fshop);
  S_KEEPER(tshop) = S_KEEPER(fshop);
  S_OPEN1(tshop) = S_OPEN1(fshop);
  S_CLOSE1(tshop) = S_CLOSE1(fshop);
  S_OPEN2(tshop) = S_OPEN2(fshop);
  S_CLOSE2(tshop) = S_CLOSE2(fshop);
  S_BANK(tshop) = S_BANK(fshop);
  S_BROKE_TEMPER(tshop) = S_BROKE_TEMPER(fshop);
  S_BITVECTOR(tshop) = S_BITVECTOR(fshop);
  S_NOTRADE(tshop) = S_NOTRADE(fshop);
  S_SORT(tshop) = S_SORT(fshop);
  S_BUYPROFIT(tshop) = S_BUYPROFIT(fshop);
  S_SELLPROFIT(tshop) = S_SELLPROFIT(fshop);
  S_FUNC(tshop) = S_FUNC(fshop);

  /*
   * Copy lists over.
   */
  copy_list(&(S_ROOMS(tshop)), S_ROOMS(fshop));
  copy_list(&(S_PRODUCTS(tshop)), S_PRODUCTS(fshop));
  copy_type_list(&(tshop->type), fshop->type);

  /*
   * Copy notification strings over.
   */
  free_shop_strings(tshop);
  S_NOITEM1(tshop) = str_dup(S_NOITEM1(fshop));
  S_NOITEM2(tshop) = str_dup(S_NOITEM2(fshop));
  S_NOCASH1(tshop) = str_dup(S_NOCASH1(fshop));
  S_NOCASH2(tshop) = str_dup(S_NOCASH2(fshop));
  S_NOBUY(tshop) = str_dup(S_NOBUY(fshop));
  S_BUY(tshop) = str_dup(S_BUY(fshop));
  S_SELL(tshop) = str_dup(S_SELL(fshop));

}

/*-------------------------------------------------------------------*/

/*
 * Copy a -1 terminated integer array list.
 */
void copy_list(int **tlist, int *flist)
{
  int num_items, i;

  if (*tlist)
    free(*tlist);

  /*
   * Count number of entries.
   */
  for (i = 0; flist[i] != -1; i++);
  num_items = i + 1;

  /*
   * Make space for entries.
   */
  CREATE(*tlist, int, num_items);

  /*
   * Copy entries over.
   */
  i = 0;
  do {
    (*tlist)[i] = flist[i];
  } while (++i < num_items);
}

/*-------------------------------------------------------------------*/

/*
 * Copy a -1 terminated (in the type field) shop_buy_data 
 * array list.
 */
void copy_type_list(struct shop_buy_data **tlist, struct shop_buy_data *flist)
{
  int num_items, i;

  if (*tlist)
    free_type_list(tlist);

  /*
   * Count number of entries.
   */
  for (i = 0; BUY_TYPE(flist[i]) != -1; i++);
  num_items = i + 1;

  /*
   * Make space for entries.
   */
  CREATE(*tlist, struct shop_buy_data, num_items);

  /*
   * Copy entries over.
   */
  i = 0;
  do {
    (*tlist)[i].type = flist[i].type;
    if (BUY_WORD(flist[i]))
      BUY_WORD((*tlist)[i]) = str_dup(BUY_WORD(flist[i]));
  } while (++i < num_items);
}

/*-------------------------------------------------------------------*/

void sedit_remove_from_type_list(struct shop_buy_data **list, int num)
{
  int i, num_items;
  struct shop_buy_data *nlist;

  /*
   * Count number of entries.
   */
  for (i = 0; (*list)[i].type != -1; i++);

  if (num >= i || num < 0)
    return;
  num_items = i;

  CREATE(nlist, struct shop_buy_data, num_items);

  for (i = 0; i < num_items; i++)
    nlist[i] = (i < num) ? (*list)[i] : (*list)[i + 1];

  free(BUY_WORD((*list)[num]));
  free(*list);
  *list = nlist;
}

/*-------------------------------------------------------------------*/

void sedit_add_to_type_list(struct shop_buy_data **list, struct shop_buy_data *new)
{
  int i, num_items;
  struct shop_buy_data *nlist;

  /*
   * Count number of entries.
   */
  for (i = 0; (*list)[i].type != -1; i++);
  num_items = i;

  /*
   * Make a new list and slot in the new entry.
   */
  CREATE(nlist, struct shop_buy_data, num_items + 2);

  for (i = 0; i < num_items; i++)
    nlist[i] = (*list)[i];
  nlist[num_items] = *new;
  nlist[num_items + 1].type = -1;

  /*
   * Out with the old, in with the new.
   */
  free(*list);
  *list = nlist;
}

/*-------------------------------------------------------------------*/

void sedit_add_to_int_list(int **list, int new)
{
  int i, num_items, *nlist;

  /*
   * Count number of entries.
   */
  for (i = 0; (*list)[i] != -1; i++);
  num_items = i;

  /*
   * Make a new list and slot in the new entry.
   */
  CREATE(nlist, int, num_items + 2);

  for (i = 0; i < num_items; i++)
    nlist[i] = (*list)[i];
  nlist[num_items] = new;
  nlist[num_items + 1] = -1;

  /*
   * Out with the old, in with the new.
   */
  free(*list);
  *list = nlist;
}

/*-------------------------------------------------------------------*/

void sedit_remove_from_int_list(int **list, int num)
{
  int i, num_items, *nlist;

  /*
   * Count number of entries.
   */
  for (i = 0; (*list)[i] != -1; i++);

  if (num >= i || num < 0)
    return;
  num_items = i;

  CREATE(nlist, int, num_items);

  for (i = 0; i < num_items; i++)
    nlist[i] = (i < num) ? (*list)[i] : (*list)[i + 1];

  free(*list);
  *list = nlist;
}

/*-------------------------------------------------------------------*/

/*
 * Free all the notice character strings in a shop structure.
 */
void free_shop_strings(struct shop_data *shop)
{
  if (S_NOITEM1(shop)) {
    free(S_NOITEM1(shop));
    S_NOITEM1(shop) = NULL;
  }
  if (S_NOITEM2(shop)) {
    free(S_NOITEM2(shop));
    S_NOITEM2(shop) = NULL;
  }
  if (S_NOCASH1(shop)) {
    free(S_NOCASH1(shop));
    S_NOCASH1(shop) = NULL;
  }
  if (S_NOCASH2(shop)) {
    free(S_NOCASH2(shop));
    S_NOCASH2(shop) = NULL;
  }
  if (S_NOBUY(shop)) {
    free(S_NOBUY(shop));
    S_NOBUY(shop) = NULL;
  }
  if (S_BUY(shop)) {
    free(S_BUY(shop));
    S_BUY(shop) = NULL;
  }
  if (S_SELL(shop)) {
    free(S_SELL(shop));
    S_SELL(shop) = NULL;
  }
}

/*-------------------------------------------------------------------*/

/*
 * Free a type list and all the strings it contains.
 */
void free_type_list(struct shop_buy_data **list)
{
  int i;

  for (i = 0; (*list)[i].type != -1; i++)
    if (BUY_WORD((*list)[i]))
      free(BUY_WORD((*list)[i]));
  free(*list);
  *list = NULL;
}

/*-------------------------------------------------------------------*/

/*
 * Free up the whole shop structure and it's content.
 */
void free_shop(struct shop_data *shop)
{
  free_shop_strings(shop);
  free_type_list(&(S_NAMELISTS(shop)));
  free(S_ROOMS(shop));
  free(S_PRODUCTS(shop));
  free(shop);
}

/*-------------------------------------------------------------------*/

int real_shop(int vshop_num)
{
  int rshop_num;

  for (rshop_num = 0; rshop_num < top_shop; rshop_num++)
    if (SHOP_NUM(rshop_num) == vshop_num)
      return rshop_num;

  return -1;
}

/*-------------------------------------------------------------------*/

/*
 * Generic string modifyer for shop keeper messages.
 */
void sedit_modify_string(char **str, char *new)
{
  char *pointer;

  /*
   * Check the '%s' is present, if not, add it.
   */
  if (*new != '%') {
    strcpy(buf, "%s ");
    strcat(buf, new);
    pointer = buf;
  } else
    pointer = new;

  if (*str)
    free(*str);
  *str = str_dup(pointer);
}

/*-------------------------------------------------------------------*/

void sedit_save_internally(struct descriptor_data *d)
{
  int rshop, found = 0;
  struct shop_data *shop;
  struct shop_data *new_index;

  rshop = real_shop(OLC_NUM(d));
  shop = OLC_SHOP(d);
  S_NUM(shop) = OLC_NUM(d);

  if (rshop > -1) {	/* The shop already exists, just update it. */
    copy_shop((shop_index + rshop), shop);
  } else {		/* Doesn't exist - have to insert it. */
    CREATE(new_index, struct shop_data, top_shop + 1);

    for (rshop = 0; rshop < top_shop; rshop++) {
      if (!found) {	/* Is this the place? */
	if (SHOP_NUM(rshop) > OLC_NUM(d)) {	/* Yep, stick it in here. */
	  found = 1;
	  copy_shop(&(new_index[rshop]), shop);
	  /*
	   * Move the entry that used to go here up a place.
	   */
	  new_index[rshop + 1] = shop_index[rshop];
	} else	/* This isn't the place, copy over info. */
	  new_index[rshop] = shop_index[rshop];
      } else {	/* Shop's already inserted, copy rest over. */
	new_index[rshop + 1] = shop_index[rshop];
      }
    }
    if (!found)
      copy_shop(&(new_index[rshop]), shop);

    /*
     * Switch the new index in.
     */
    free(shop_index);
    shop_index = new_index;
    top_shop++;
  }
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_SHOP);
}

/*-------------------------------------------------------------------*/

void sedit_save_to_disk(int zone_num)
{
  int i, j, rshop, zone, top;
  FILE *shop_file;
  char fname[64];
  struct shop_data *shop;

  zone = zone_table[zone_num].number;
  top = zone_table[zone_num].top;

  sprintf(fname, "%s/%d.new", SHP_PREFIX, zone);
  if (!(shop_file = fopen(fname, "w"))) {
    mudlog("SYSERR: OLC: Cannot open shop file!", BRF, LVL_BUILDER, TRUE);
    return;
  } else if (fprintf(shop_file, "CircleMUD v3.0 Shop File~\n") < 0) {
    mudlog("SYSERR: OLC: Cannot write to shop file!", BRF, LVL_BUILDER, TRUE);
    fclose(shop_file);
    return;
  }
  /*
   * Search database for shops in this zone.
   */
  for (i = zone * 100; i <= top; i++) {
    if ((rshop = real_shop(i)) != -1) {
      fprintf(shop_file, "#%d~\n", i);
      shop = shop_index + rshop;

      /*
       * Save the products.
       */
      for (j = 0; S_PRODUCT(shop, j) != -1; j++)
	fprintf(shop_file, "%d\n", obj_index[S_PRODUCT(shop, j)].vnum);

      /*
       * Save the rates.
       */
      fprintf(shop_file, "-1\n%1.2f\n%1.2f\n", S_BUYPROFIT(shop), S_SELLPROFIT(shop));

      /*
       * Save the buy types and namelists.
       */
      j = -1;
      do {
	j++;
	fprintf(shop_file, "%d%s\n", S_BUYTYPE(shop, j),
		S_BUYWORD(shop, j) ? S_BUYWORD(shop, j) : "");
      } while (S_BUYTYPE(shop, j) != -1);

      /*
       * Save messages'n'stuff.
       * Added some small'n'silly defaults as sanity checks.
       */
      fprintf(shop_file,
	      "%s~\n%s~\n%s~\n%s~\n%s~\n%s~\n%s~\n"
	      "%d\n%d\n%d\n%d\n",
	      S_NOITEM1(shop) ? S_NOITEM1(shop) : "%s Ke?!",
	      S_NOITEM2(shop) ? S_NOITEM2(shop) : "%s Ke?!",
	      S_NOBUY(shop) ? S_NOBUY(shop) : "%s Ke?!",
	      S_NOCASH1(shop) ? S_NOCASH1(shop) : "%s Ke?!",
	      S_NOCASH2(shop) ? S_NOCASH2(shop) : "%s Ke?!",
	      S_BUY(shop) ? S_BUY(shop) : "%s Ke?! %d?",
	      S_SELL(shop) ? S_SELL(shop) : "%s Ke?! %d?",
	      S_BROKE_TEMPER(shop),
	      S_BITVECTOR(shop),
	      mob_index[S_KEEPER(shop)].vnum,
	      S_NOTRADE(shop)
	      );

      /*
       * Save the rooms.
       */
      j = -1;
      do {
	j++;
	fprintf(shop_file, "%d\n", S_ROOM(shop, j));
      } while (S_ROOM(shop, j) != -1);

      /*
       * Save open/closing times 
       */
      fprintf(shop_file, "%d\n%d\n%d\n%d\n", S_OPEN1(shop), S_CLOSE1(shop),
		S_OPEN2(shop), S_CLOSE2(shop));
    }
  }
  fprintf(shop_file, "$~\n");
  fclose(shop_file);
  sprintf(buf2, "%s/%d.shp", SHP_PREFIX, zone);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(fname, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_SHOP);
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

void sedit_products_menu(struct descriptor_data *d)
{
  struct shop_data *shop;
  int i;

  shop = OLC_SHOP(d);
  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  send_to_char("##     VNUM     Product\r\n", d->character);
  for (i = 0; S_PRODUCT(shop, i) != -1; i++) {
    sprintf(buf, "%2d - [%s%5d%s] - %s%s%s\r\n", i,
	    cyn, obj_index[S_PRODUCT(shop, i)].vnum, nrm,
	    yel, obj_proto[S_PRODUCT(shop, i)].short_description, nrm);
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n"
	  "%sA%s) Add a new product.\r\n"
	  "%sD%s) Delete a product.\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);

  OLC_MODE(d) = SEDIT_PRODUCTS_MENU;
}

/*-------------------------------------------------------------------*/

void sedit_compact_rooms_menu(struct descriptor_data *d)
{
  struct shop_data *shop;
  int i, count = 0;

  shop = OLC_SHOP(d);
  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; S_ROOM(shop, i) != -1; i++) {
    sprintf(buf, "%2d - [%s%5d%s]  | %s", i, cyn, S_ROOM(shop, i), nrm,
			!(++count % 5) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n"
	  "%sA%s) Add a new room.\r\n"
	  "%sD%s) Delete a room.\r\n"
	  "%sL%s) Long display.\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);

  OLC_MODE(d) = SEDIT_ROOMS_MENU;
}

/*-------------------------------------------------------------------*/

void sedit_rooms_menu(struct descriptor_data *d)
{
  struct shop_data *shop;
  int i;

  shop = OLC_SHOP(d);
  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  send_to_char("##     VNUM     Room\r\n\r\n", d->character);
  for (i = 0; S_ROOM(shop, i) != -1; i++) {
    sprintf(buf, "%2d - [%s%5d%s] - %s%s%s\r\n", i, cyn, S_ROOM(shop, i), nrm,
	    yel, world[real_room(S_ROOM(shop, i))].name, nrm);
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n"
	  "%sA%s) Add a new room.\r\n"
	  "%sD%s) Delete a room.\r\n"
	  "%sC%s) Compact Display.\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);

  OLC_MODE(d) = SEDIT_ROOMS_MENU;
}

/*-------------------------------------------------------------------*/

void sedit_namelist_menu(struct descriptor_data *d)
{
  struct shop_data *shop;
  int i;

  shop = OLC_SHOP(d);
  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  send_to_char("##              Type   Namelist\r\n\r\n", d->character);
  for (i = 0; S_BUYTYPE(shop, i) != -1; i++) {
    sprintf(buf, "%2d - %s%15s%s - %s%s%s\r\n", i, cyn,
		item_types[S_BUYTYPE(shop, i)], nrm, yel,
		S_BUYWORD(shop, i) ? S_BUYWORD(shop, i) : "<None>", nrm);
    send_to_char(buf, d->character);
  }
  sprintf(buf, "\r\n"
	  "%sA%s) Add a new entry.\r\n"
	  "%sD%s) Delete an entry.\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = SEDIT_NAMELIST_MENU;
}

/*-------------------------------------------------------------------*/

void sedit_shop_flags_menu(struct descriptor_data *d)
{
  int i, count = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_SHOP_FLAGS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s   %s", grn, i + 1, nrm, shop_bits[i],
		!(++count % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(S_BITVECTOR(OLC_SHOP(d)), shop_bits, buf1);
  sprintf(buf, "\r\nCurrent Shop Flags : %s%s%s\r\nEnter choice : ",
		cyn, buf1, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = SEDIT_SHOP_FLAGS;
}

/*-------------------------------------------------------------------*/

void sedit_no_trade_menu(struct descriptor_data *d)
{
  int i, count = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_TRADERS; i++) {
    sprintf(buf, "%s%2d%s) %-20.20s   %s", grn, i + 1, nrm, trade_letters[i],
		!(++count % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(S_NOTRADE(OLC_SHOP(d)), trade_letters, buf1);
  sprintf(buf, "\r\nCurrently won't trade with: %s%s%s\r\n"
	  "Enter choice : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = SEDIT_NOTRADE;
}

/*-------------------------------------------------------------------*/

void sedit_types_menu(struct descriptor_data *d)
{
  struct shop_data *shop;
  int i, count = 0;

  shop = OLC_SHOP(d);
  get_char_cols(d->character);

#if defined(CLEAR_SCREEN)
  send_to_char("[H[J", d->character);
#endif
  for (i = 0; i < NUM_ITEM_TYPES; i++) {
    sprintf(buf, "%s%2d%s) %s%-20s%s  %s", grn, i, nrm, cyn, item_types[i],
		nrm, !(++count % 3) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintf(buf, "%sEnter choice : ", nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = SEDIT_TYPE_MENU;
}

/*-------------------------------------------------------------------*/

/*
 * Display main menu.
 */
void sedit_disp_menu(struct descriptor_data *d)
{
  struct shop_data *shop;

  shop = OLC_SHOP(d);
  get_char_cols(d->character);

  sprintbit(S_NOTRADE(shop), trade_letters, buf1);
  sprintbit(S_BITVECTOR(shop), shop_bits, buf2);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
	  "[H[J"
#endif
	  "-- Shop Number : [%s%d%s]\r\n"
	  "%s0%s) Keeper      : [%s%d%s] %s%s\r\n"
   "%s1%s) Open 1      : %s%4d%s          %s2%s) Close 1     : %s%4d\r\n"
   "%s3%s) Open 2      : %s%4d%s          %s4%s) Close 2     : %s%4d\r\n"
	  "%s5%s) Sell rate   : %s%1.2f%s          %s6%s) Buy rate    : %s%1.2f\r\n"
	  "%s7%s) Keeper no item : %s%s\r\n"
	  "%s8%s) Player no item : %s%s\r\n"
	  "%s9%s) Keeper no cash : %s%s\r\n"
	  "%sA%s) Player no cash : %s%s\r\n"
	  "%sB%s) Keeper no buy  : %s%s\r\n"
	  "%sC%s) Buy sucess     : %s%s\r\n"
	  "%sD%s) Sell sucess    : %s%s\r\n"
	  "%sE%s) No Trade With  : %s%s\r\n"
	  "%sF%s) Shop flags     : %s%s\r\n"
	  "%sR%s) Rooms Menu\r\n"
	  "%sP%s) Products Menu\r\n"
	  "%sT%s) Accept Types Menu\r\n"
	  "%sQ%s) Quit\r\n"
	  "Enter Choice : ",

	  cyn, OLC_NUM(d), nrm,
	  grn, nrm, cyn, S_KEEPER(shop) == -1 ?
	  -1 : mob_index[S_KEEPER(shop)].vnum, nrm,
	  yel, S_KEEPER(shop) == -1 ?
	  "None" : mob_proto[S_KEEPER(shop)].player.short_descr,
	  grn, nrm, cyn, S_OPEN1(shop), nrm,
	  grn, nrm, cyn, S_CLOSE1(shop),
	  grn, nrm, cyn, S_OPEN2(shop), nrm,
	  grn, nrm, cyn, S_CLOSE2(shop),
	  grn, nrm, cyn, S_BUYPROFIT(shop), nrm,
	  grn, nrm, cyn, S_SELLPROFIT(shop),
	  grn, nrm, yel, S_NOITEM1(shop),
	  grn, nrm, yel, S_NOITEM2(shop),
	  grn, nrm, yel, S_NOCASH1(shop),
	  grn, nrm, yel, S_NOCASH2(shop),
	  grn, nrm, yel, S_NOBUY(shop),
	  grn, nrm, yel, S_BUY(shop),
	  grn, nrm, yel, S_SELL(shop),
	  grn, nrm, cyn, buf1,
	  grn, nrm, cyn, buf2,
	  grn, nrm, grn, nrm, grn, nrm, grn, nrm
	  );
  send_to_char(buf, d->character);

  OLC_MODE(d) = SEDIT_MAIN_MENU;
}

/**************************************************************************
  The GARGANTUAN event handler
 **************************************************************************/

void sedit_parse(struct descriptor_data *d, char *arg)
{
  int i;

  if (OLC_MODE(d) > SEDIT_NUMERICAL_RESPONSE) {
    if (!isdigit(arg[0]) && ((*arg == '-') && (!isdigit(arg[1])))) {
      send_to_char("Field must be numerical, try again : ", d->character);
      return;
    }
  }
  switch (OLC_MODE(d)) {
/*-------------------------------------------------------------------*/
  case SEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      send_to_char("Saving shop to memory.\r\n", d->character);
      sedit_save_internally(d);
      sprintf(buf, "OLC: %s edits shop %d", GET_NAME(d->character),
	      OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      cleanup_olc(d, CLEANUP_STRUCTS);
      return;
    case 'n':
    case 'N':
      cleanup_olc(d, CLEANUP_ALL);
      return;
    default:
      send_to_char("Invalid choice!\r\nDo you wish to save the shop? : ", d->character);
      return;
    }
    break;

/*-------------------------------------------------------------------*/
  case SEDIT_MAIN_MENU:
    i = 0;
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_VAL(d)) {		/* Anything been changed? */
	send_to_char("Do you wish to save the changes to the shop? (y/n) : ", d->character);
	OLC_MODE(d) = SEDIT_CONFIRM_SAVESTRING;
      } else
	cleanup_olc(d, CLEANUP_ALL);
      return;
    case '0':
      OLC_MODE(d) = SEDIT_KEEPER;
      send_to_char("Enter virtual number of shop keeper : ", d->character);
      return;
    case '1':
      OLC_MODE(d) = SEDIT_OPEN1;
      i++;
      break;
    case '2':
      OLC_MODE(d) = SEDIT_CLOSE1;
      i++;
      break;
    case '3':
      OLC_MODE(d) = SEDIT_OPEN2;
      i++;
      break;
    case '4':
      OLC_MODE(d) = SEDIT_CLOSE2;
      i++;
      break;
    case '5':
      OLC_MODE(d) = SEDIT_BUY_PROFIT;
      i++;
      break;
    case '6':
      OLC_MODE(d) = SEDIT_SELL_PROFIT;
      i++;
      break;
    case '7':
      OLC_MODE(d) = SEDIT_NOITEM1;
      i--;
      break;
    case '8':
      OLC_MODE(d) = SEDIT_NOITEM2;
      i--;
      break;
    case '9':
      OLC_MODE(d) = SEDIT_NOCASH1;
      i--;
      break;
    case 'a':
    case 'A':
      OLC_MODE(d) = SEDIT_NOCASH2;
      i--;
      break;
    case 'b':
    case 'B':
      OLC_MODE(d) = SEDIT_NOBUY;
      i--;
      break;
    case 'c':
    case 'C':
      OLC_MODE(d) = SEDIT_BUY;
      i--;
      break;
    case 'd':
    case 'D':
      OLC_MODE(d) = SEDIT_SELL;
      i--;
      break;
    case 'e':
    case 'E':
      sedit_no_trade_menu(d);
      return;
    case 'f':
    case 'F':
      sedit_shop_flags_menu(d);
      return;
    case 'r':
    case 'R':
      sedit_rooms_menu(d);
      return;
    case 'p':
    case 'P':
      sedit_products_menu(d);
      return;
    case 't':
    case 'T':
      sedit_namelist_menu(d);
      return;
    default:
      sedit_disp_menu(d);
      return;
    }

    if (i != 0) {
      send_to_char(i == 1 ? "\r\nEnter new value : " : (i == -1 ?
		"\r\nEnter new text :\r\n] " : "Oops...\r\n"), d->character);
      return;
    }
    break;
/*-------------------------------------------------------------------*/
  case SEDIT_NAMELIST_MENU:
    switch (*arg) {
    case 'a':
    case 'A':
      sedit_types_menu(d);
      return;
    case 'd':
    case 'D':
      send_to_char("\r\nDelete which entry? : ", d->character);
      OLC_MODE(d) = SEDIT_DELETE_TYPE;
      return;
    case 'q':
    case 'Q':
      break;
    }
    break;
/*-------------------------------------------------------------------*/
  case SEDIT_PRODUCTS_MENU:
    switch (*arg) {
    case 'a':
    case 'A':
      send_to_char("\r\nEnter new product virtual number : ", d->character);
      OLC_MODE(d) = SEDIT_NEW_PRODUCT;
      return;
    case 'd':
    case 'D':
      send_to_char("\r\nDelete which product? : ", d->character);
      OLC_MODE(d) = SEDIT_DELETE_PRODUCT;
      return;
    case 'q':
    case 'Q':
      break;
    }
    break;
/*-------------------------------------------------------------------*/
  case SEDIT_ROOMS_MENU:
    switch (*arg) {
    case 'a':
    case 'A':
      send_to_char("\r\nEnter new room virtual number : ", d->character);
      OLC_MODE(d) = SEDIT_NEW_ROOM;
      return;
    case 'c':
    case 'C':
      sedit_compact_rooms_menu(d);
      return;
    case 'l':
    case 'L':
      sedit_rooms_menu(d);
      return;
    case 'd':
    case 'D':
      send_to_char("\r\nDelete which room? : ", d->character);
      OLC_MODE(d) = SEDIT_DELETE_ROOM;
      return;
    case 'q':
    case 'Q':
      break;
    }
    break;
/*-------------------------------------------------------------------*/
    /*
     * String edits.
     */
  case SEDIT_NOITEM1:
    sedit_modify_string(&S_NOITEM1(OLC_SHOP(d)), arg);
    break;
  case SEDIT_NOITEM2:
    sedit_modify_string(&S_NOITEM2(OLC_SHOP(d)), arg);
    break;
  case SEDIT_NOCASH1:
    sedit_modify_string(&S_NOCASH1(OLC_SHOP(d)), arg);
    break;
  case SEDIT_NOCASH2:
    sedit_modify_string(&S_NOCASH2(OLC_SHOP(d)), arg);
    break;
  case SEDIT_NOBUY:
    sedit_modify_string(&S_NOBUY(OLC_SHOP(d)), arg);
    break;
  case SEDIT_BUY:
    sedit_modify_string(&S_BUY(OLC_SHOP(d)), arg);
    break;
  case SEDIT_SELL:
    sedit_modify_string(&S_SELL(OLC_SHOP(d)), arg);
    break;
  case SEDIT_NAMELIST:
    {
      struct shop_buy_data new_entry;

      BUY_TYPE(new_entry) = OLC_VAL(d);
      BUY_WORD(new_entry) = (arg && *arg) ? str_dup(arg) : NULL;
      sedit_add_to_type_list(&(S_NAMELISTS(OLC_SHOP(d))), &new_entry);
    }
    sedit_namelist_menu(d);
    return;

/*-------------------------------------------------------------------*/
    /*
     * Numerical responses.
     */
  case SEDIT_KEEPER:
    i = atoi(arg);
    if ((i = atoi(arg)) != -1)
      if ((i = real_mobile(i)) < 0) {
	send_to_char("That mobile does not exist, try again : ", d->character);
	return;
      }
    S_KEEPER(OLC_SHOP(d)) = i;
    if (i == -1)
      break;
    /*
     * Fiddle with special procs.
     */
    S_FUNC(OLC_SHOP(d)) = mob_index[i].func;
    mob_index[i].func = shop_keeper;
    break;
  case SEDIT_OPEN1:
    S_OPEN1(OLC_SHOP(d)) = MAX(0, MIN(28, atoi(arg)));
    break;
  case SEDIT_OPEN2:
    S_OPEN2(OLC_SHOP(d)) = MAX(0, MIN(28, atoi(arg)));
    break;
  case SEDIT_CLOSE1:
    S_CLOSE1(OLC_SHOP(d)) = MAX(0, MIN(28, atoi(arg)));
    break;
  case SEDIT_CLOSE2:
    S_CLOSE2(OLC_SHOP(d)) = MAX(0, MIN(28, atoi(arg)));
    break;
  case SEDIT_BUY_PROFIT:
    sscanf(arg, "%f", &S_BUYPROFIT(OLC_SHOP(d)));
    break;
  case SEDIT_SELL_PROFIT:
    sscanf(arg, "%f", &S_SELLPROFIT(OLC_SHOP(d)));
    break;
  case SEDIT_TYPE_MENU:
    OLC_VAL(d) = MAX(0, MIN(NUM_ITEM_TYPES - 1, atoi(arg)));
    send_to_char("Enter namelist (return for none) :-\r\n] ", d->character);
    OLC_MODE(d) = SEDIT_NAMELIST;
    return;
  case SEDIT_DELETE_TYPE:
    sedit_remove_from_type_list(&(S_NAMELISTS(OLC_SHOP(d))), atoi(arg));
    sedit_namelist_menu(d);
    return;
  case SEDIT_NEW_PRODUCT:
    if ((i = atoi(arg)) != -1)
      if ((i = real_object(i)) == -1) {
	send_to_char("That object does not exist, try again : ", d->character);
	return;
      }
    if (i > 0)
      sedit_add_to_int_list(&(S_PRODUCTS(OLC_SHOP(d))), i);
    sedit_products_menu(d);
    return;
  case SEDIT_DELETE_PRODUCT:
    sedit_remove_from_int_list(&(S_PRODUCTS(OLC_SHOP(d))), atoi(arg));
    sedit_products_menu(d);
    return;
  case SEDIT_NEW_ROOM:
    if ((i = atoi(arg)) != -1)
      if ((i = real_room(i)) < 0) {
	send_to_char("That room does not exist, try again : ", d->character);
	return;
      }
    if (i >= 0)
      sedit_add_to_int_list(&(S_ROOMS(OLC_SHOP(d))), atoi(arg));
    sedit_rooms_menu(d);
    return;
  case SEDIT_DELETE_ROOM:
    sedit_remove_from_int_list(&(S_ROOMS(OLC_SHOP(d))), atoi(arg));
    sedit_rooms_menu(d);
    return;
  case SEDIT_SHOP_FLAGS:
    if ((i = MAX(0, MIN(NUM_SHOP_FLAGS, atoi(arg)))) > 0) {
      TOGGLE_BIT(S_BITVECTOR(OLC_SHOP(d)), 1 << (i - 1));
      sedit_shop_flags_menu(d);
      return;
    }
    break;
  case SEDIT_NOTRADE:
    if ((i = MAX(0, MIN(NUM_TRADERS, atoi(arg)))) > 0) {
      TOGGLE_BIT(S_NOTRADE(OLC_SHOP(d)), 1 << (i - 1));
      sedit_no_trade_menu(d);
      return;
    }
    break;

/*-------------------------------------------------------------------*/
  default:
    /*
     * We should never get here.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: sedit_parse(): Reached default case!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }

/*-------------------------------------------------------------------*/

/*
 * END OF CASE 
 * If we get here, we have probably changed something, and now want to
 * return to main menu.  Use OLC_VAL as a 'has changed' flag.
 */
  OLC_VAL(d) = 1;
  sedit_disp_menu(d);
}
::::::::::::::
shop.c
::::::::::::::
/* ************************************************************************
*   File: shop.c                                        Part of CircleMUD *
*  Usage: shopkeepers: loading config files, spec procs.                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/***
 * The entire shop rewrite for Circle 3.0 was done by Jeff Fink.  Thanks Jeff!
 ***/

#define __SHOP_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "handler.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "shop.h"
#include "dg_scripts.h"

/* External variables */
extern struct str_app_type str_app[];
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct char_data *mob_proto;
extern struct obj_data *obj_proto;
extern struct room_data *world;
extern struct time_info_data time_info;
extern char *drinks[];
extern char *item_types[];
extern char *extra_bits[];
extern int top_of_world;

/* Forward/External function declarations */
ACMD(do_tell);
ACMD(do_action);
ACMD(do_echo);
ACMD(do_say);
void sort_keeper_objs(struct char_data * keeper, int shop_nr);

/* Local variables */
struct shop_data *shop_index;
int top_shop = 0;
int cmd_say, cmd_tell, cmd_emote, cmd_slap, cmd_puke;

/* local functions */
int read_type_list(FILE * shop_f, struct shop_buy_data * list, int new_format, int max);
int read_list(FILE * shop_f, struct shop_buy_data * list, int new_format, int max, int type);
void shopping_list(char *arg, struct char_data * ch, struct char_data * keeper, int shop_nr);
void shopping_value(char *arg, struct char_data * ch, struct char_data * keeper, int shop_nr);
void shopping_sell(char *arg, struct char_data * ch, struct char_data * keeper, int shop_nr);
struct obj_data *get_selling_obj(struct char_data * ch, char *name, struct char_data * keeper, int shop_nr, int msg);
struct obj_data *slide_obj(struct obj_data * obj, struct char_data * keeper, int shop_nr);
void shopping_buy(char *arg, struct char_data * ch, struct char_data * keeper, int shop_nr);
struct obj_data *get_purchase_obj(struct char_data * ch, char *arg, struct char_data * keeper, int shop_nr, int msg);
struct obj_data *get_hash_obj_vis(struct char_data * ch, char *name, struct obj_data * list);
struct obj_data *get_slide_obj_vis(struct char_data * ch, char *name, struct obj_data * list);
void boot_the_shops(FILE * shop_f, char *filename, int rec_count);
void assign_the_shopkeepers(void);
char *customer_string(int shop_nr, int detailed);
void list_all_shops(struct char_data * ch);
void handle_detailed_list(char *buf, char *buf1, struct char_data * ch);
void list_detailed_shop(struct char_data * ch, int shop_nr);
void show_shops(struct char_data * ch, char *arg);
int is_ok_char(struct char_data * keeper, struct char_data * ch, int shop_nr);
int is_open(struct char_data * keeper, int shop_nr, int msg);
int is_ok(struct char_data * keeper, struct char_data * ch, int shop_nr);
void push(struct stack_data * stack, int pushval);
int top(struct stack_data * stack);
int pop(struct stack_data * stack);
void evaluate_operation(struct stack_data * ops, struct stack_data * vals);
int find_oper_num(char token);
int evaluate_expression(struct obj_data * obj, char *expr);
int trade_with(struct obj_data * item, int shop_nr);
int same_obj(struct obj_data * obj1, struct obj_data * obj2);
int shop_producing(struct obj_data * item, int shop_nr);
int transaction_amt(char *arg);
char *times_message(struct obj_data * obj, char *name, int num);
int buy_price(struct obj_data * obj, int shop_nr);
int sell_price(struct char_data * ch, struct obj_data * obj, int shop_nr);
char *list_object(struct obj_data * obj, int cnt, int index, int shop_nr);
int ok_shop_room(int shop_nr, int room);
SPECIAL(shop_keeper);
int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim);
int add_to_list(struct shop_buy_data * list, int type, int *len, int *val);
int end_read_list(struct shop_buy_data * list, int len, int error);
void read_line(FILE * shop_f, const char *string, void *data);
void stop_fighting(struct char_data * ch);
char *add_points(int value);
int invalid_class(struct char_data *ch, struct obj_data *obj);
char *complete_char(char *string, int num);
int conta_cores(const char *texto);

/* config arrays */
const char *operator_str[] = {
        "[({",
        "])}",
        "|+",
        "&*",
        "^'"
} ;

/* Constant list for printing out who we sell to */
const char *trade_letters[] = {
        "Good",                 /* First, the alignment based ones */
        "Evil",
        "Neutral",
        "Magic User",           /* Then the class based ones */
        "Cleric",
        "Thief",
        "Warrior",
        "\n"
};


const char *shop_bits[] = {
        "WILL_FIGHT",
        "USES_BANK",
        "\n"
};

int is_ok_char(struct char_data * keeper, struct char_data * ch, int shop_nr)
{
  char buf[200];

  if (!(CAN_SEE(keeper, ch))) {
    do_say(keeper, MSG_NO_SEE_CHAR, cmd_say, 0);
    return (FALSE);
  }
  if (IS_GOD(ch))
    return (TRUE);

  if ((IS_GOOD(ch) && NOTRADE_GOOD(shop_nr)) ||
      (IS_EVIL(ch) && NOTRADE_EVIL(shop_nr)) ||
      (IS_NEUTRAL(ch) && NOTRADE_NEUTRAL(shop_nr))) {
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_SELL_ALIGN);
    do_tell(keeper, buf, cmd_tell, 0);
    return (FALSE);
  }
  if (IS_NPC(ch))
    return (TRUE);

  if ((IS_MAGIC_USER(ch) && NOTRADE_MAGIC_USER(shop_nr)) ||
      (IS_CLERIC(ch) && NOTRADE_CLERIC(shop_nr)) ||
      (IS_THIEF(ch) && NOTRADE_THIEF(shop_nr)) ||
      (IS_WARRIOR(ch) && NOTRADE_WARRIOR(shop_nr))) {
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_SELL_CLASS);
    do_tell(keeper, buf, cmd_tell, 0);
    return (FALSE);
  }
  return (TRUE);
}


int is_open(struct char_data * keeper, int shop_nr, int msg)
{
  char buf[200];

  *buf = 0;
  if (SHOP_OPEN1(shop_nr) > time_info.hours)
    strcpy(buf, MSG_NOT_OPEN_YET);
  else if (SHOP_CLOSE1(shop_nr) < time_info.hours) {
    if (SHOP_OPEN2(shop_nr) > time_info.hours)
      strcpy(buf, MSG_NOT_REOPEN_YET);
    else if (SHOP_CLOSE2(shop_nr) < time_info.hours)
      strcpy(buf, MSG_CLOSED_FOR_DAY);
  }
  if (!(*buf))
    return (TRUE);
  if (msg)
    do_say(keeper, buf, cmd_tell, 0);
  return (FALSE);
}


int is_ok(struct char_data * keeper, struct char_data * ch, int shop_nr)
{
  if (is_open(keeper, shop_nr, TRUE))
    return (is_ok_char(keeper, ch, shop_nr));
  else
    return (FALSE);
}


void push(struct stack_data * stack, int pushval)
{
  S_DATA(stack, S_LEN(stack)++) = pushval;
}


int top(struct stack_data * stack)
{
  if (S_LEN(stack) > 0)
    return (S_DATA(stack, S_LEN(stack) - 1));
  else
    return (NOTHING);
}


int pop(struct stack_data * stack)
{
  if (S_LEN(stack) > 0)
    return (S_DATA(stack, --S_LEN(stack)));
  else {
    log("Illegal expression %d in shop keyword list.", S_LEN(stack));
    return (0);
  }
}


void evaluate_operation(struct stack_data * ops, struct stack_data * vals)
{
  int oper;

  if ((oper = pop(ops)) == OPER_NOT)
    push(vals, !pop(vals));
  else if (oper == OPER_AND)
    push(vals, pop(vals) && pop(vals));
  else if (oper == OPER_OR)
    push(vals, pop(vals) || pop(vals));
}


int find_oper_num(char token)
{
  int index;

  for (index = 0; index <= MAX_OPER; index++)
    if (strchr(operator_str[index], token))
      return (index);
  return (NOTHING);
}


int evaluate_expression(struct obj_data * obj, char *expr)
{
  struct stack_data ops, vals;
  char *ptr, *end, name[200];
  int temp, index;

  if (!expr)
    return TRUE;

  if (!isalpha(*expr))
        return TRUE;

  ops.len = vals.len = 0;
  ptr = expr;
  while (*ptr) {
    if (isspace(*ptr))
      ptr++;
    else {
      if ((temp = find_oper_num(*ptr)) == NOTHING) {
        end = ptr;
        while (*ptr && !isspace(*ptr) && (find_oper_num(*ptr) == NOTHING))
          ptr++;
        strncpy(name, end, ptr - end);
        name[ptr - end] = 0;
        for (index = 0; *extra_bits[index] != '\n'; index++)
          if (!str_cmp(name, extra_bits[index])) {
            push(&vals, IS_SET(GET_OBJ_EXTRA(obj), 1 << index));
            break;
          }
        if (*extra_bits[index] == '\n')
          push(&vals, isname(name, obj->name));
      } else {
        if (temp != OPER_OPEN_PAREN)
          while (top(&ops) > temp)
            evaluate_operation(&ops, &vals);

        if (temp == OPER_CLOSE_PAREN) {
          if ((temp = pop(&ops)) != OPER_OPEN_PAREN) {
            log("Illegal parenthesis in shop keyword expression.");
            return (FALSE);
          }
        } else
          push(&ops, temp);
        ptr++;
      }
    }
  }
  while (top(&ops) != NOTHING)
    evaluate_operation(&ops, &vals);
  temp = pop(&vals);
  if (top(&vals) != NOTHING) {
    log("Extra operands left on shop keyword expression stack.");
    return (FALSE);
  }
  return (temp);
}


int trade_with(struct obj_data * item, int shop_nr)
{
  int counter;

  if (GET_OBJ_COST(item) < 1)
    return (OBJECT_NOVAL);

  if (IS_OBJ_STAT(item, ITEM_NOSELL))
    return (OBJECT_NOTOK);

  for (counter = 0; SHOP_BUYTYPE(shop_nr, counter) != NOTHING; counter++)
    if (SHOP_BUYTYPE(shop_nr, counter) == GET_OBJ_TYPE(item)) {
      if ((GET_OBJ_VAL(item, 2) == 0) &&
          ((GET_OBJ_TYPE(item) == ITEM_WAND) ||
           (GET_OBJ_TYPE(item) == ITEM_STAFF)))
        return (OBJECT_DEAD);
      else if (evaluate_expression(item, SHOP_BUYWORD(shop_nr, counter)))
        return (OBJECT_OK);
    }
  return (OBJECT_NOTOK);
}


int same_obj(struct obj_data * obj1, struct obj_data * obj2)
{
  int index;

  if (!obj1 || !obj2)
    return (obj1 == obj2);

  if (GET_OBJ_RNUM(obj1) != GET_OBJ_RNUM(obj2))
    return (FALSE);

  if (GET_OBJ_COST(obj1) != GET_OBJ_COST(obj2))
    return (FALSE);

  if (GET_OBJ_EXTRA(obj1) != GET_OBJ_EXTRA(obj2))
    return (FALSE);

  for (index = 0; index < MAX_OBJ_AFFECT; index++)
    if ((obj1->affected[index].location != obj2->affected[index].location) ||
        (obj1->affected[index].modifier != obj2->affected[index].modifier))
      return (FALSE);

  return (TRUE);
}


int shop_producing(struct obj_data * item, int shop_nr)
{
  int counter;

  if (GET_OBJ_RNUM(item) < 0)
    return (FALSE);

  for (counter = 0; SHOP_PRODUCT(shop_nr, counter) != NOTHING; counter++)
    if (same_obj(item, &obj_proto[SHOP_PRODUCT(shop_nr, counter)]))
      return (TRUE);
  return (FALSE);
}


int transaction_amt(char *arg)
{
  int num;

  one_argument(arg, buf);
  if (*buf)
    if ((is_number(buf))) {
      num = atoi(buf);
      strcpy(arg, arg + strlen(buf) + 1);
      return (num);
    }
  return (1);
}


char *times_message(struct obj_data * obj, char *name, int num)
{
  static char buf[256];
  char *ptr;

  if (obj->short_description)
    strcpy(buf, obj->short_description);
  else {
    if ((ptr = strchr(name, '.')) == NULL)
      ptr = name;
    else
      ptr++;
    sprintf(buf, "%s %s", AN(ptr), ptr);

  }

  if (num > 1)
    sprintf(END_OF(buf), " (x %s)", add_points(num));

  return (buf);
}


struct obj_data *get_slide_obj_vis(struct char_data * ch, char *name,
                                            struct obj_data * list)
{
  struct obj_data *i, *last_match = 0;
  int j, number;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp;

  strcpy(tmpname, name);
  tmp = tmpname;
  if (!(number = get_number(&tmp)))
    return (0);

  for (i = list, j = 1; i && (j <= number); i = i->next_content)
    if (isname(tmp, i->name))
      if (CAN_SEE_OBJ(ch, i) && !same_obj(last_match, i)) {
        if (j == number)
          return (i);
        last_match = i;
        j++;
      }
  return (0);
}


struct obj_data *get_hash_obj_vis(struct char_data * ch, char *name,
                                           struct obj_data * list)
{
  struct obj_data *loop, *last_obj = 0;
  int index;

  if ((is_number(name + 1)))
    index = atoi(name + 1);
  else
    return (0);

  for (loop = list; loop; loop = loop->next_content)
    if (CAN_SEE_OBJ(ch, loop) && (loop->obj_flags.cost > 0))
      if (!same_obj(last_obj, loop)) {
        if (--index == 0)
          return (loop);
        last_obj = loop;
      }
  return (0);
}


struct obj_data *get_purchase_obj(struct char_data * ch, char *arg,
                            struct char_data * keeper, int shop_nr, int msg)
{
  char buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj;

  one_argument(arg, name);
  do {
    if (*name == '#')
      obj = get_hash_obj_vis(ch, name, keeper->carrying);
    else
      obj = get_slide_obj_vis(ch, name, keeper->carrying);
    if (!obj) {
      if (msg) {
        sprintf(buf, shop_index[shop_nr].no_such_item1, GET_NAME(ch));
        do_tell(keeper, buf, cmd_tell, 0);
      }
      return (0);
    }
    if (GET_OBJ_COST(obj) <= 0) {
      extract_obj(obj);
      obj = 0;
    }
  } while (!obj);
  return (obj);
}


int buy_price(struct obj_data * obj, int shop_nr)
{
  return ((int) (GET_OBJ_COST(obj) * SHOP_BUYPROFIT(shop_nr)));
}


void shopping_buy(char *arg, struct char_data * ch,
                       struct char_data * keeper, int shop_nr)
{
  char tempstr[200], buf[MAX_STRING_LENGTH];
  struct obj_data *obj, *last_obj = NULL;
  int goldamt = 0, buynum, bought = 0;

  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);

  if ((buynum = transaction_amt(arg)) < 0) {
    sprintf(buf, "%s A negative amount?  Try selling me something.",
            GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!(*arg) || !(buynum)) {
    sprintf(buf, "%s What do you want to buy??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!(obj = get_purchase_obj(ch, arg, keeper, shop_nr, TRUE)))
    return;

  if ((buy_price(obj, shop_nr) > GET_GOLD(ch)) && !IS_GOD(ch)) {
    sprintf(buf, shop_index[shop_nr].missing_cash2, GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);

    switch (SHOP_BROKE_TEMPER(shop_nr)) {
    case 0:
      do_action(keeper, GET_NAME(ch), cmd_puke, 0);
      return;
    case 1:
      do_echo(keeper, "smokes on his joint.", cmd_emote, SCMD_EMOTE);
      return;
    default:
      return;
    }
  }
  if ((IS_CARRYING_N(ch) + 1 > CAN_CARRY_N(ch))) {
    sprintf(buf, "%s: You can't carry any more items.\r\n",
            fname(obj->name));
    send_to_char(buf, ch);
    return;
  }
  if ((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) > CAN_CARRY_W(ch)) {
    sprintf(buf, "%s: You can't carry that much weight.\r\n",
            fname(obj->name));
    send_to_char(buf, ch);
    return;
  }
  while ((obj) && ((GET_GOLD(ch) >= buy_price(obj, shop_nr)) || IS_GOD(ch))
         && (IS_CARRYING_N(ch) < CAN_CARRY_N(ch)) && (bought < buynum)
         && (IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj) <= CAN_CARRY_W(ch))) {
    bought++;
    /* Test if producing shop ! */
    if (shop_producing(obj, shop_nr)) {
      obj = read_object(GET_OBJ_RNUM(obj), REAL);
      load_otrigger(obj);
    } else {
      obj_from_char(obj);
      SHOP_SORT(shop_nr)--;
    }
    obj_to_char(obj, ch);

    goldamt += buy_price(obj, shop_nr);
    if (!IS_GOD(ch))
      GET_GOLD(ch) -= buy_price(obj, shop_nr);

    last_obj = obj;
    obj = get_purchase_obj(ch, arg, keeper, shop_nr, FALSE);
    if (!same_obj(obj, last_obj))
      break;
  }

  if (bought < buynum) {
    if (!obj || !same_obj(last_obj, obj))
      sprintf(buf, "%s I only have %s to sell you.", GET_NAME(ch), add_points(bought));
    else if (GET_GOLD(ch) < buy_price(obj, shop_nr))
      sprintf(buf, "%s You can only afford %s.", GET_NAME(ch), add_points(bought));
    else if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch))
      sprintf(buf, "%s You can only hold %s.", GET_NAME(ch), add_points(bought));
    else if (IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj) > CAN_CARRY_W(ch))
      sprintf(buf, "%s You can only carry %s.", GET_NAME(ch), add_points(bought));
    else
      sprintf(buf, "%s Something screwy only gave you %s.", GET_NAME(ch),
              add_points(bought));
    do_tell(keeper, buf, cmd_tell, 0);
  }
//  if (!IS_GOD(ch))
//    GET_GOLD(keeper) += goldamt;

  sprintf(tempstr, times_message(ch->carrying, 0, bought));
  sprintf(buf, "$U$n buys %s.", tempstr);
  act(buf, FALSE, ch, obj, 0, TO_ROOM);

  sprintf(buf, shop_index[shop_nr].message_buy, GET_NAME(ch), goldamt);
  do_tell(keeper, buf, cmd_tell, 0);
  sprintf(buf, "You now have %s.\r\n", tempstr);
  send_to_char(buf, ch);

  if (SHOP_USES_BANK(shop_nr))
    if (GET_GOLD(keeper) > MAX_OUTSIDE_BANK) {
      SHOP_BANK(shop_nr) += (GET_GOLD(keeper) - MAX_OUTSIDE_BANK);
      GET_GOLD(keeper) = MAX_OUTSIDE_BANK;
    }
}


struct obj_data *get_selling_obj(struct char_data * ch, char *name,
                            struct char_data * keeper, int shop_nr, int msg)
{
  char buf[MAX_STRING_LENGTH];
  struct obj_data *obj;
  int result;

  if (!(obj = get_obj_in_list_vis(ch, name, ch->carrying))) {
    if (msg) {
      sprintf(buf, shop_index[shop_nr].no_such_item2, GET_NAME(ch));
      do_tell(keeper, buf, cmd_tell, 0);
    }
    return (0);
  }
  if ((result = trade_with(obj, shop_nr)) == OBJECT_OK)
    return (obj);

  switch (result) {
  case OBJECT_NOVAL:
    sprintf(buf, "%s You've got to be kidding, that thing is worthless!",
            GET_NAME(ch));
    break;
  case OBJECT_NOTOK:
    sprintf(buf, shop_index[shop_nr].do_not_buy, GET_NAME(ch));
    break;
  case OBJECT_DEAD:
    sprintf(buf, "%s %s", GET_NAME(ch), MSG_NO_USED_WANDSTAFF);
    break;
  default:
    log("SYSERR: Illegal return value of %d from trade_with() (%s)",
            result, __FILE__);  /* Someone might rename it... */
    sprintf(buf, "%s An error has occurred.", GET_NAME(ch));
    break;
  }
  if (msg)
    do_tell(keeper, buf, cmd_tell, 0);
  return (0);
}


int sell_price(struct char_data * ch, struct obj_data * obj, int shop_nr)
{
  return ((int) (((GET_OBJ_COST(obj)*obj->obj_flags.cond)/100) * SHOP_SELLPROFIT(shop_nr)));
}


struct obj_data *slide_obj(struct obj_data * obj, struct char_data * keeper,
                                    int shop_nr)
/*
   This function is a slight hack!  To make sure that duplicate items are
   only listed once on the "list", this function groups "identical"
   objects together on the shopkeeper's inventory list.  The hack involves
   knowing how the list is put together, and manipulating the order of
   the objects on the list.  (But since most of DIKU is not encapsulated,
   and information hiding is almost never used, it isn't that big a deal) -JF
*/
{
  struct obj_data *loop;
  int temp;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);

  /* Extract the object if it is identical to one produced */
  if (shop_producing(obj, shop_nr)) {
    temp = GET_OBJ_RNUM(obj);
    extract_obj(obj);
    return (&obj_proto[temp]);
  }
  SHOP_SORT(shop_nr)++;
  loop = keeper->carrying;
  obj_to_char(obj, keeper);
  keeper->carrying = loop;
  while (loop) {
    if (same_obj(obj, loop)) {
      obj->next_content = loop->next_content;
      loop->next_content = obj;
      return (obj);
    }
    loop = loop->next_content;
  }
  keeper->carrying = obj;
  return (obj);
}


void sort_keeper_objs(struct char_data * keeper, int shop_nr)
{
  struct obj_data *list = 0, *temp;

  while (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper)) {
    temp = keeper->carrying;
    obj_from_char(temp);
    temp->next_content = list;
    list = temp;
  }

  while (list) {
    temp = list;
    list = list->next_content;
    if ((shop_producing(temp, shop_nr)) &&
        !(get_obj_in_list_num(GET_OBJ_RNUM(temp), keeper->carrying))) {
      obj_to_char(temp, keeper);
      SHOP_SORT(shop_nr)++;
    } else
      (void) slide_obj(temp, keeper, shop_nr);
  }
}


void shopping_sell(char *arg, struct char_data * ch,
                        struct char_data * keeper, int shop_nr)
{
  char tempstr[200], buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj, *tag = 0;
  int sellnum, sold = 0, goldamt = 0;

  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if ((sellnum = transaction_amt(arg)) < 0) {
    sprintf(buf, "%s A negative amount?  Try buying something.",
            GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  if (!(*arg) || !(sellnum)) {
    sprintf(buf, "%s What do you want to sell??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  one_argument(arg, name);
  if (!(obj = get_selling_obj(ch, name, keeper, shop_nr, TRUE)))
    return;

  if (GET_GOLD(keeper) + SHOP_BANK(shop_nr) < sell_price(ch, obj, shop_nr)) {
    sprintf(buf, shop_index[shop_nr].missing_cash1, GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  while ((obj) && (GET_GOLD(keeper) + SHOP_BANK(shop_nr) >=
                   sell_price(ch, obj, shop_nr)) && (sold < sellnum)) {
    sold++;

    goldamt = sell_price(ch, obj, shop_nr);
    GET_GOLD(keeper) -= sell_price(ch, obj, shop_nr);

    obj_from_char(obj);
    tag = slide_obj(obj, keeper, shop_nr);

    GET_GOLD(ch) += goldamt;
    strcpy(tempstr, times_message(obj, name, 1));
    sprintf(buf, "$U$n sells %s.", tempstr);
    act(buf, FALSE, ch, obj, 0, TO_ROOM);

    sprintf(buf, shop_index[shop_nr].message_sell, GET_NAME(ch), goldamt);
    do_tell(keeper, buf, cmd_tell, 0);
    sprintf(buf, "The shopkeeper now has %s.\r\n", tempstr);
    send_to_char(buf, ch);

    obj = get_selling_obj(ch, name, keeper, shop_nr, FALSE);
  }

  if (sold < sellnum) {
    if (!obj)
      sprintf(buf, "%s You only have %s of those.", GET_NAME(ch), add_points(sold));
    else if (GET_GOLD(keeper) + SHOP_BANK(shop_nr) <
             sell_price(ch, obj, shop_nr))
      sprintf(buf, "%s I can only afford to buy %s of those.",
              GET_NAME(ch), add_points(sold));
    else
      sprintf(buf, "%s Something really screwy made me buy %s.",
              GET_NAME(ch), add_points(sold));

    do_tell(keeper, buf, cmd_tell, 0);
  }

  if (GET_GOLD(keeper) < MIN_OUTSIDE_BANK) {
    goldamt = MIN(MAX_OUTSIDE_BANK - GET_GOLD(keeper), SHOP_BANK(shop_nr));
    SHOP_BANK(shop_nr) -= goldamt;
    GET_GOLD(keeper) += goldamt;
  }
}


void shopping_value(char *arg, struct char_data * ch,
                         struct char_data * keeper, int shop_nr)
{
  char buf[MAX_STRING_LENGTH];
  struct obj_data *obj;
  char name[MAX_INPUT_LENGTH];

  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if (!(*arg)) {
    sprintf(buf, "%s What do you want me to evaluate??", GET_NAME(ch));
    do_tell(keeper, buf, cmd_tell, 0);
    return;
  }
  one_argument(arg, name);
  if (!(obj = get_selling_obj(ch, name, keeper, shop_nr, TRUE)))
    return;

  sprintf(buf, "%s I'll give you %s gold coins for that!", GET_NAME(ch),
          add_points(sell_price(ch, obj, shop_nr)));
  do_tell(keeper, buf, cmd_tell, 0);

  return;
}

char *list_object(struct obj_data * obj, int cnt, int index, int shop_nr)
{
  static char buf[256];
  char buf2[1000], buf3[1000], nome[3000];

  if (shop_producing(obj, shop_nr))
    strcpy(buf2, "&RUnlimited&n   ");
  else
    sprintf(buf2, "&R%5s&n       ", add_points(cnt));
  sprintf(buf, "&B%3d&b)&n  %s", index, buf2);


  strcpy(nome, obj->short_description);
  if ((GET_OBJ_TYPE(obj) == ITEM_DRINKCON) && (GET_OBJ_VAL(obj, 1)))
    sprintf(END_OF(nome), " of %s", drinks[GET_OBJ_VAL(obj, 2)]);

  /* Compile object name and information */
  strcpy(buf3, complete_char(reprimir(nome, 43+conta_cores(nome)+conta_cores(nome)), 43));

  /* FUTURE: */
  /* Add glow/hum/etc */

  if ((GET_OBJ_TYPE(obj) == ITEM_WAND) || (GET_OBJ_TYPE(obj) == ITEM_STAFF))
    if (GET_OBJ_VAL(obj, 2) < GET_OBJ_VAL(obj, 1))
      strcat(buf3, " (partially used)");

  sprintf(buf2, "&g%-43s&n&C%s%3d&n &Y%10s&n ", buf3, (GET_OBJ_LEVEL(obj) > (LVL_IMMORT-1) ? "R+" : "  "), (GET_OBJ_LEVEL(obj)-(div(GET_OBJ_LEVEL(obj), (LVL_IMMORT-1)).quot)*(LVL_IMMORT-1)), add_points(buy_price(obj, shop_nr)));
  strcat(buf, CAP(buf2));
  return (buf);
}

char *bomitem(struct char_data *ch, struct obj_data *object)
{
    if(invalid_class(ch, object) && GET_LEVEL(ch) < LVL_GOD) {
     if (GET_OBJ_TYPE(object) == ITEM_WEAPON || GET_OBJ_TYPE(object) == ITEM_ARMOR ||
    	GET_OBJ_TYPE(object) == ITEM_WAND || GET_OBJ_TYPE(object) == ITEM_LIGHT ||
    	GET_OBJ_TYPE(object) == ITEM_STAFF || GET_OBJ_TYPE(object) == ITEM_WORN ||
    	(GET_OBJ_TYPE(object) == ITEM_CONTAINER && (object->carried_by || object->worn_by) && !IS_CORPSE(object)))
        strcpy(buf3, "&R!&n\r\n");
    } else {
        strcpy(buf3, "&B*&n\r\n");
    }
  return (buf3);
}

void shopping_list(char *arg, struct char_data * ch,
                        struct char_data * keeper, int shop_nr)
{
  char buf[MAX_STRING_LENGTH], name[MAX_INPUT_LENGTH];
  struct obj_data *obj, *last_obj = 0;
  int cnt = 0, index = 0;

  if (!(is_ok(keeper, ch, shop_nr)))
    return;

  if (SHOP_SORT(shop_nr) < IS_CARRYING_N(keeper))
    sort_keeper_objs(keeper, shop_nr);

  one_argument(arg, name);
  strcpy(buf, " &B##&n   &RAvailable&n   &gItem&n                                       &CLevel&n       &YCost &R?&n\r\n");
  strcat(buf, "&G-------------------------------------------------------------------------------&n\r\n");
  if (keeper->carrying)
    for (obj = keeper->carrying; obj; obj = obj->next_content)
      if (CAN_SEE_OBJ(ch, obj) && (obj->obj_flags.cost > 0)) {
        if (!last_obj) {
          last_obj = obj;
          cnt = 1;
        } else if (same_obj(last_obj, obj))
          cnt++;
        else {
          index++;
          if (!(*name) || isname(name, last_obj->name))
            strcat(buf, list_object(last_obj, cnt, index, shop_nr));
	    strcat(buf, bomitem(ch, last_obj));
          cnt = 1;
          last_obj = obj;
        }
      }
  index++;
  if (!last_obj) {
    if (*name)
      strcpy(buf, "Presently, none of those are for sale.\r\n");
    else
      strcpy(buf, "Currently, there is nothing for sale.\r\n");
  } else if (!(*name) || isname(name, last_obj->name)) {
    strcat(buf, list_object(last_obj, cnt, index, shop_nr));
    strcat(buf, bomitem(ch, last_obj));
  }
  page_string(ch->desc, buf, 1);
}


int ok_shop_room(int shop_nr, int room)
{
  int index;

  for (index = 0; SHOP_ROOM(shop_nr, index) != NOWHERE; index++)
    if (SHOP_ROOM(shop_nr, index) == room)
      return (TRUE);
  return (FALSE);
}


SPECIAL(shop_keeper)
{
  char argm[MAX_INPUT_LENGTH];
  struct char_data *keeper = (struct char_data *) me;
  int shop_nr;

  for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
    if (SHOP_KEEPER(shop_nr) == keeper->nr)
      break;

  if (shop_nr >= top_shop)
    return (FALSE);

  if (SHOP_FUNC(shop_nr))       /* Check secondary function */
    if ((SHOP_FUNC(shop_nr)) (ch, me, cmd, arg))
      return (TRUE);

  if (keeper == ch) {
    if (cmd)
      SHOP_SORT(shop_nr) = 0;   /* Safety in case "drop all" */
    return (FALSE);
  }
  if (!ok_shop_room(shop_nr, GET_ROOM_VNUM(IN_ROOM(ch))))
    return (0);

  if (!AWAKE(keeper))
    return (FALSE);

  if (CMD_IS("steal")) {
    sprintf(argm, "$U$N shouts '%s'", MSG_NO_STEAL_HERE);
    do_action(keeper, GET_NAME(ch), cmd_slap, 0);
    act(argm, FALSE, ch, 0, keeper, TO_CHAR);
    return (TRUE);
  }

  if (CMD_IS("buy")) {
    shopping_buy(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("sell")) {
    shopping_sell(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("value")) {
    shopping_value(argument, ch, keeper, shop_nr);
    return (TRUE);
  } else if (CMD_IS("list")) {
    shopping_list(argument, ch, keeper, shop_nr);
    return (TRUE);
  }
  return (FALSE);
}


int ok_damage_shopkeeper(struct char_data * ch, struct char_data * victim)
{
  char buf[200];
  int index;

  if (IS_MOB(victim) && (mob_index[GET_MOB_RNUM(victim)].func == shop_keeper))
    for (index = 0; index < top_shop; index++)
      if ((GET_MOB_RNUM(victim) == SHOP_KEEPER(index)) && !SHOP_KILL_CHARS(index)) {
        do_action(victim, GET_NAME(ch), cmd_slap, 0);
        sprintf(buf, "%s %s", GET_NAME(ch), MSG_CANT_KILL_KEEPER);
        do_tell(victim, buf, cmd_tell, 0);
	stop_fighting(ch);
	stop_fighting(victim);
        return (FALSE);
      }
  return (TRUE);
}


int add_to_list(struct shop_buy_data * list, int type, int *len, int *val)
{
  if (*val >= 0) {
    if (*len < MAX_SHOP_OBJ) {
      if (type == LIST_PRODUCE)
        *val = real_object(*val);
      if (*val >= 0) {
        BUY_TYPE(list[*len]) = *val;
        BUY_WORD(list[(*len)++]) = 0;
      } else
        *val = 0;
      return (FALSE);
    } else
      return (TRUE);
  }
  return (FALSE);
}


int end_read_list(struct shop_buy_data * list, int len, int error)
{
  if (error)
    log("Raise MAX_SHOP_OBJ constant in shop.h to %d", len + error);
  BUY_WORD(list[len]) = 0;
  BUY_TYPE(list[len++]) = NOTHING;
  return (len);
}


void read_line(FILE * shop_f, const char *string, void *data)
{
  if (!get_line(shop_f, buf) || !sscanf(buf, string, data)) {
    log("SYSERR: Error in shop #%d\n", SHOP_NUM(top_shop));
    exit(1);
  }
}


int read_list(FILE * shop_f, struct shop_buy_data * list, int new_format,
                  int max, int type)
{
  int count, temp, len = 0, error = 0;

  if (new_format) {
    do {
      read_line(shop_f, "%d", &temp);
      error += add_to_list(list, type, &len, &temp);
    } while (temp >= 0);
  } else
    for (count = 0; count < max; count++) {
      read_line(shop_f, "%d", &temp);
      error += add_to_list(list, type, &len, &temp);
    }
  return (end_read_list(list, len, error));
}


int read_type_list(FILE * shop_f, struct shop_buy_data * list,
                       int new_format, int max)
{
  int index, num, len = 0, error = 0;
  char *ptr;

  if (!new_format)
    return (read_list(shop_f, list, 0, max, LIST_TRADE));
  do {
    fgets(buf, MAX_STRING_LENGTH - 1, shop_f);
    if ((ptr = strchr(buf, ';')) != NULL)
      *ptr = 0;
    else
      *(END_OF(buf) - 1) = 0;
    for (index = 0, num = NOTHING; *item_types[index] != '\n'; index++)
      if (!strn_cmp(item_types[index], buf, strlen(item_types[index]))) {
        num = index;
        strcpy(buf, buf + strlen(item_types[index]));
        break;
      }
    ptr = buf;
    if (num == NOTHING) {
      sscanf(buf, "%d", &num);
      while (!isdigit(*ptr))
        ptr++;
      while (isdigit(*ptr))
        ptr++;
    }
    while (isspace(*ptr))
      ptr++;
    while (isspace(*(END_OF(ptr) - 1)))
      *(END_OF(ptr) - 1) = 0;
    error += add_to_list(list, LIST_TRADE, &len, &num);
    if (*ptr)
      BUY_WORD(list[len - 1]) = str_dup(ptr);
  } while (num >= 0);
  return (end_read_list(list, len, error));
}


void boot_the_shops(FILE * shop_f, char *filename, int rec_count)
{
  char *buf, buf2[150];
  int temp, count, new_format = 0;
  struct shop_buy_data list[MAX_SHOP_OBJ + 1];
  int done = 0;

  sprintf(buf2, "beginning of shop file %s", filename);

  while (!done) {
    buf = fread_string(shop_f, buf2);
    if (*buf == '#') {          /* New shop */
      sscanf(buf, "#%d\n", &temp);
      sprintf(buf2, "shop #%d in shop file %s", temp, filename);
      free(buf);                /* Plug memory leak! */
      if (!top_shop)
        CREATE(shop_index, struct shop_data, rec_count);

      SHOP_NUM(top_shop) = temp;
      temp = read_list(shop_f, list, new_format, MAX_PROD, LIST_PRODUCE);
      CREATE(shop_index[top_shop].producing, int, temp);
      for (count = 0; count < temp; count++)
        SHOP_PRODUCT(top_shop, count) = BUY_TYPE(list[count]);

      read_line(shop_f, "%f", &SHOP_BUYPROFIT(top_shop));
      read_line(shop_f, "%f", &SHOP_SELLPROFIT(top_shop));

      temp = read_type_list(shop_f, list, new_format, MAX_TRADE);
      CREATE(shop_index[top_shop].type, struct shop_buy_data, temp);
      for (count = 0; count < temp; count++) {
        SHOP_BUYTYPE(top_shop, count) = BUY_TYPE(list[count]);
        SHOP_BUYWORD(top_shop, count) = BUY_WORD(list[count]);
      }

      shop_index[top_shop].no_such_item1 = fread_string(shop_f, buf2);
      shop_index[top_shop].no_such_item2 = fread_string(shop_f, buf2);
      shop_index[top_shop].do_not_buy = fread_string(shop_f, buf2);
      shop_index[top_shop].missing_cash1 = fread_string(shop_f, buf2);
      shop_index[top_shop].missing_cash2 = fread_string(shop_f, buf2);
      shop_index[top_shop].message_buy = fread_string(shop_f, buf2);
      shop_index[top_shop].message_sell = fread_string(shop_f, buf2);
      read_line(shop_f, "%d", &SHOP_BROKE_TEMPER(top_shop));
      read_line(shop_f, "%d", &SHOP_BITVECTOR(top_shop));
      read_line(shop_f, "%d", &SHOP_KEEPER(top_shop));

      SHOP_KEEPER(top_shop) = real_mobile(SHOP_KEEPER(top_shop));
      read_line(shop_f, "%d", &SHOP_TRADE_WITH(top_shop));

      temp = read_list(shop_f, list, new_format, 1, LIST_ROOM);
      CREATE(shop_index[top_shop].in_room, int, temp);
      for (count = 0; count < temp; count++)
        SHOP_ROOM(top_shop, count) = BUY_TYPE(list[count]);

      read_line(shop_f, "%d", &SHOP_OPEN1(top_shop));
      read_line(shop_f, "%d", &SHOP_CLOSE1(top_shop));
      read_line(shop_f, "%d", &SHOP_OPEN2(top_shop));
      read_line(shop_f, "%d", &SHOP_CLOSE2(top_shop));

      SHOP_BANK(top_shop) = 0;
      SHOP_SORT(top_shop) = 0;
      SHOP_FUNC(top_shop) = 0;
      top_shop++;
    } else {
      if (*buf == '$')          /* EOF */
        done = TRUE;
      else if (strstr(buf, VERSION3_TAG))       /* New format marker */
        new_format = 1;
      free(buf);                /* Plug memory leak! */
    }
  }
}


void assign_the_shopkeepers(void)
{
  int index;

  cmd_say = find_command("say");
  cmd_tell = find_command("tell");
  cmd_emote = find_command("emote");
  cmd_slap = find_command("slap");
  cmd_puke = find_command("puke");
  for (index = 0; index < top_shop; index++) {
    if (SHOP_KEEPER(index) == NOBODY)
      continue;
    if (mob_index[SHOP_KEEPER(index)].func)
      SHOP_FUNC(index) = mob_index[SHOP_KEEPER(index)].func;
    mob_index[SHOP_KEEPER(index)].func = shop_keeper;

    if (!MOB_FLAGGED(&mob_proto[SHOP_KEEPER(index)], MOB_NOCHARM))
         SET_BIT(MOB_FLAGS(&mob_proto[SHOP_KEEPER(index)]), MOB_NOCHARM);
    if (!MOB_FLAGGED(&mob_proto[SHOP_KEEPER(index)], MOB_NOSUMMON))
         SET_BIT(MOB_FLAGS(&mob_proto[SHOP_KEEPER(index)]), MOB_NOSUMMON);
  }
}


char *customer_string(int shop_nr, int detailed)
{
  int index, cnt = 1;
  static char buf[256];

  *buf = 0;
  for (index = 0; *trade_letters[index] != '\n'; index++, cnt *= 2)
    if (!(SHOP_TRADE_WITH(shop_nr) & cnt)) {
      if (detailed) {
        if (*buf)
          strcat(buf, ", ");
        strcat(buf, trade_letters[index]);
      } else
        sprintf(END_OF(buf), "%c", *trade_letters[index]);
    } else if (!detailed)
      strcat(buf, "_");

  return (buf);
}


void list_all_shops(struct char_data * ch)
{
  int shop_nr;

  strcpy(buf, "\r\n");
  for (shop_nr = 0; shop_nr < top_shop; shop_nr++) {
    if (!(shop_nr % 19)) {
      strcat(buf, " ##   Virtual   Where    Keeper    Buy   Sell   Customers\r\n");
      strcat(buf, "---------------------------------------------------------\r\n");
    }
    sprintf(buf2, "%3d   %6d   %6d    ", shop_nr + 1, SHOP_NUM(shop_nr),
            SHOP_ROOM(shop_nr, 0));
    if (SHOP_KEEPER(shop_nr) < 0)
      strcpy(buf1, "<NONE>");
    else
      sprintf(buf1, "%6d", mob_index[SHOP_KEEPER(shop_nr)].vnum);
    sprintf(END_OF(buf2), "%s   %3.2f   %3.2f    ", buf1,
            SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr));
    strcat(buf2, customer_string(shop_nr, FALSE));
    sprintf(END_OF(buf), "%s\r\n", buf2);
  }

  page_string(ch->desc, buf, 1);
}


void handle_detailed_list(char *buf, char *buf1, struct char_data * ch)
{
  if ((strlen(buf1) + strlen(buf) < 78) || (strlen(buf) < 20))
    strcat(buf, buf1);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
    sprintf(buf, "            %s", buf1);
  }
}


void list_detailed_shop(struct char_data * ch, int shop_nr)
{
  struct obj_data *obj;
  struct char_data *k;
  int index, temp;

  sprintf(buf, "Vnum:       [%5d], Rnum: [%5d]\r\n", SHOP_NUM(shop_nr),
          shop_nr + 1);
  send_to_char(buf, ch);

  strcpy(buf, "Rooms:      ");
  for (index = 0; SHOP_ROOM(shop_nr, index) != NOWHERE; index++) {
    if (index)
      strcat(buf, ", ");
    if ((temp = real_room(SHOP_ROOM(shop_nr, index))) != NOWHERE)
      sprintf(buf1, "%s (#%d)", world[temp].name, GET_ROOM_VNUM(temp));
    else
      sprintf(buf1, "<UNKNOWN> (#%d)", SHOP_ROOM(shop_nr, index));
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Rooms:      None!\r\n", ch);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }

  strcpy(buf, "Shopkeeper: ");
  if (SHOP_KEEPER(shop_nr) >= 0) {
    sprintf(END_OF(buf), "%s (#%d), Special Function: %s\r\n",
            GET_NAME(&mob_proto[SHOP_KEEPER(shop_nr)]),
        mob_index[SHOP_KEEPER(shop_nr)].vnum, YESNO(SHOP_FUNC(shop_nr)));
    if ((k = get_char_num(SHOP_KEEPER(shop_nr)))) {
      send_to_char(buf, ch);
      sprintf(buf, "Coins:      [%s], Bank: [%s] (Total: %s)\r\n",
         add_points(GET_GOLD(k)), add_points(SHOP_BANK(shop_nr)), add_points(GET_GOLD(k) + SHOP_BANK(shop_nr)));
    }
  } else
    strcat(buf, "<NONE>\r\n");
  send_to_char(buf, ch);

  strcpy(buf1, customer_string(shop_nr, TRUE));
  sprintf(buf, "Customers:  %s\r\n", (*buf1) ? buf1 : "None");
  send_to_char(buf, ch);

  strcpy(buf, "Produces:   ");
  for (index = 0; SHOP_PRODUCT(shop_nr, index) != NOTHING; index++) {
    obj = &obj_proto[SHOP_PRODUCT(shop_nr, index)];
    if (index)
      strcat(buf, ", ");
    sprintf(buf1, "%s (#%d)", obj->short_description,
            obj_index[SHOP_PRODUCT(shop_nr, index)].vnum);
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Produces:   Nothing!\r\n", ch);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }

  strcpy(buf, "Buys:       ");
  for (index = 0; SHOP_BUYTYPE(shop_nr, index) != NOTHING; index++) {
    if (index)
      strcat(buf, ", ");
    sprintf(buf1, "%s (#%d) ", item_types[SHOP_BUYTYPE(shop_nr, index)],
            SHOP_BUYTYPE(shop_nr, index));
    if (SHOP_BUYWORD(shop_nr, index))
      sprintf(END_OF(buf1), "[%s]", SHOP_BUYWORD(shop_nr, index));
    else
      strcat(buf1, "[all]");
    handle_detailed_list(buf, buf1, ch);
  }
  if (!index)
    send_to_char("Buys:       Nothing!\r\n", ch);
  else {
    strcat(buf, "\r\n");
    send_to_char(buf, ch);
  }

  sprintf(buf, "Buy at:     [%4.2f], Sell at: [%4.2f], Open: [%d-%d, %d-%d]%s",
     SHOP_SELLPROFIT(shop_nr), SHOP_BUYPROFIT(shop_nr), SHOP_OPEN1(shop_nr),
   SHOP_CLOSE1(shop_nr), SHOP_OPEN2(shop_nr), SHOP_CLOSE2(shop_nr), "\r\n");

  send_to_char(buf, ch);

  sprintbit((long) SHOP_BITVECTOR(shop_nr), shop_bits, buf1);
  sprintf(buf, "Bits:       %s\r\n", buf1);
  send_to_char(buf, ch);
}


void show_shops(struct char_data * ch, char *arg)
{
  int shop_nr;

  if (!*arg)
    list_all_shops(ch);
  else {
    if (!str_cmp(arg, ".")) {
      for (shop_nr = 0; shop_nr < top_shop; shop_nr++)
        if (ok_shop_room(shop_nr, GET_ROOM_VNUM(IN_ROOM(ch))))
          break;

      if (shop_nr == top_shop) {
        send_to_char("This isn't a shop!\r\n", ch);
        return;
      }
    } else if (is_number(arg))
      shop_nr = atoi(arg) - 1;
    else
      shop_nr = -1;

    if ((shop_nr < 0) || (shop_nr >= top_shop)) {
      send_to_char("Illegal shop number.\r\n", ch);
      return;
    }
    list_detailed_shop(ch, shop_nr);
  }
}
::::::::::::::
spec_assign.c
::::::::::::::
/* ************************************************************************
*   File: spec_assign.c                                 Part of CircleMUD *
*  Usage: Functions to assign function pointers to objs/mobs/rooms        *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "db.h"
#include "interpreter.h"
#include "utils.h"
#include "winddragon.h"
#include "buffer.h"

extern int top_of_world;
extern int dts_are_dumps;
extern int mini_mud;
extern struct room_data *world;
extern struct index_data *mob_index;
extern struct index_data *obj_index;

SPECIAL(dump);
SPECIAL(pet_shops);
SPECIAL(archer);
SPECIAL(postmaster);
SPECIAL(cityguard);
SPECIAL(gym);
SPECIAL(temple);
SPECIAL(receptionist);
SPECIAL(cryogenicist);
SPECIAL(puff);
SPECIAL(fido);
SPECIAL(janitor);
SPECIAL(mayor);
SPECIAL(forger);
SPECIAL(snake);
SPECIAL(thief);
SPECIAL(magic_user);
SPECIAL(marbles);
SPECIAL(bank);
SPECIAL(winddragon);
SPECIAL(windroom);
SPECIAL(gen_board);
SPECIAL(priest_healer);
SPECIAL(priest);
SPECIAL(blacksmith);
SPECIAL(icewizard);
SPECIAL(preparation_room);
SPECIAL(questmaster);
SPECIAL(sund_earl);
SPECIAL(hangman);
SPECIAL(blinder);
SPECIAL(silktrader);
SPECIAL(butcher);
SPECIAL(idiot);
SPECIAL(athos);
SPECIAL(stu);
SPECIAL(wardome);
SPECIAL(questshop);
SPECIAL(black_dragon);
SPECIAL(black_monster);
SPECIAL(sith_guard);
SPECIAL(night_guard);
SPECIAL(army_guard);
SPECIAL(helms_guard);
SPECIAL(purple_dragons_guard);
SPECIAL(reborn);
SPECIAL(alinhamento);
SPECIAL(religiao) ;
SPECIAL(random_room);
SPECIAL(espada_fica_azul);
SPECIAL(tiamat2);
SPECIAL(tiamat_heads);
SPECIAL(oracle);


void assign_kings_castle(void);

/* local functions */
void assign_mobiles(void);
void assign_objects(void);
void assign_rooms(void);
void ASSIGNROOM(int room, SPECIAL(fname));
void ASSIGNMOB(int mob, SPECIAL(fname));
void ASSIGNOBJ(int obj, SPECIAL(fname));

/* functions to perform assignments */

void ASSIGNMOB(int mob, SPECIAL(fname))
{
  int rnum;

  if ((rnum = real_mobile(mob)) >= 0)
    mob_index[rnum].func = fname;
  else if (!mini_mud)
    log("SYSERR: Attempt to assign spec to non-existant mob #%d", mob);
}

void ASSIGNOBJ(int obj, SPECIAL(fname))
{
  if (real_object(obj) >= 0)
    obj_index[real_object(obj)].func = fname;
  else if (!mini_mud)
    log("SYSERR: Attempt to assign spec to non-existant obj #%d", obj);
}

void ASSIGNROOM(int room, SPECIAL(fname))
{
  if (real_room(room) >= 0)
    world[real_room(room)].func = fname;
  else if (!mini_mud)
    log("SYSERR: Attempt to assign spec to non-existant room #%d", room);
}


/* ********************************************************************
*  Assignments                                                        *
******************************************************************** */

/* assign special procedures to mobiles */
void assign_mobiles(void)
{
  assign_kings_castle();

  ASSIGNMOB(1, puff);
  //ASSIGNMOB(499, darkside_guard);
  ASSIGNMOB(31001, night_guard);
  ASSIGNMOB(30201, purple_dragons_guard);
  ASSIGNMOB(2400, army_guard);
  ASSIGNMOB(30401, sith_guard);
  ASSIGNMOB(10198, army_guard);
  ASSIGNMOB(10100, night_guard);
  ASSIGNMOB(9400 , helms_guard);

  ASSIGNMOB(500, preparation_room);
//  ASSIGNMOB(503, mayor);
  ASSIGNMOB(505, questmaster);
  ASSIGNMOB(506, questshop);
  ASSIGNMOB(513, oracle);
  ASSIGNMOB(575, gym);
  ASSIGNMOB(576, temple);
  ASSIGNMOB(508, wardome);
  ASSIGNMOB(580, alinhamento);
  ASSIGNMOB(598, religiao) ;


  /* Immortal Zone */
  ASSIGNMOB(1200, receptionist);
  ASSIGNMOB(1201, postmaster);
  ASSIGNMOB(1202, janitor);

  /* Midgaard */
 // ASSIGNMOB(3005, receptionist);
  ASSIGNMOB(3010, postmaster);
 // ASSIGNMOB(3059, cityguard);
//  ASSIGNMOB(3060, cityguard);
//  ASSIGNMOB(3061, janitor);
//  ASSIGNMOB(3062, fido);
//  ASSIGNMOB(3066, fido);
//  ASSIGNMOB(3067, cityguard);
//  ASSIGNMOB(3068, janitor);
  ASSIGNMOB(3095, cryogenicist);
//  ASSIGNMOB(3105, mayor);
  ASSIGNMOB(3080, priest);
  ASSIGNMOB(3030, forger);
  ASSIGNMOB(3097, black_dragon);
  ASSIGNMOB(3098, black_monster);
  ASSIGNMOB(567, cityguard);
  ASSIGNMOB(502, archer);

  /* MORIA */
  ASSIGNMOB(4000, snake);
  ASSIGNMOB(4001, snake);
  ASSIGNMOB(4053, snake);
  ASSIGNMOB(4100, magic_user);
  ASSIGNMOB(4102, snake);
  ASSIGNMOB(4103, thief);

  /* Redferne's */
  ASSIGNMOB(7900, cityguard);

  /* PYRAMID */
  ASSIGNMOB(5300, snake);
  ASSIGNMOB(5301, snake);
  ASSIGNMOB(5304, thief);
  ASSIGNMOB(5305, thief);
  ASSIGNMOB(5309, magic_user); /* should breath fire */
  ASSIGNMOB(5311, magic_user);
  ASSIGNMOB(5313, magic_user); /* should be a cleric */
  ASSIGNMOB(5314, magic_user); /* should be a cleric */
  ASSIGNMOB(5315, magic_user); /* should be a cleric */
  ASSIGNMOB(5316, magic_user); /* should be a cleric */
  ASSIGNMOB(5317, magic_user);

  /* High Tower Of Sorcery */
  ASSIGNMOB(2501, magic_user); /* should likely be cleric */
  ASSIGNMOB(2504, magic_user);
  ASSIGNMOB(2507, magic_user);
  ASSIGNMOB(2508, magic_user);
  ASSIGNMOB(2510, magic_user);
  ASSIGNMOB(2511, thief);
  ASSIGNMOB(2514, magic_user);
  ASSIGNMOB(2515, magic_user);
  ASSIGNMOB(2516, magic_user);
  ASSIGNMOB(2517, magic_user);
  ASSIGNMOB(2518, magic_user);
  ASSIGNMOB(2520, magic_user);
  ASSIGNMOB(2521, magic_user);
  ASSIGNMOB(2522, magic_user);
  ASSIGNMOB(2523, magic_user);
  ASSIGNMOB(2524, magic_user);
  ASSIGNMOB(2525, magic_user);
  ASSIGNMOB(2526, magic_user);
  ASSIGNMOB(2527, magic_user);
  ASSIGNMOB(2528, magic_user);
  ASSIGNMOB(2529, magic_user);
  ASSIGNMOB(2530, magic_user);
  ASSIGNMOB(2531, magic_user);
  ASSIGNMOB(2532, magic_user);
  ASSIGNMOB(2533, magic_user);
  ASSIGNMOB(2534, magic_user);
  ASSIGNMOB(2536, magic_user);
  ASSIGNMOB(2537, magic_user);
  ASSIGNMOB(2538, magic_user);
  ASSIGNMOB(2540, magic_user);
  ASSIGNMOB(2541, magic_user);
  ASSIGNMOB(2548, magic_user);
  ASSIGNMOB(2549, magic_user);
  ASSIGNMOB(2552, magic_user);
  ASSIGNMOB(2553, magic_user);
  ASSIGNMOB(2554, magic_user);
  ASSIGNMOB(2556, magic_user);
  ASSIGNMOB(2557, magic_user);
  ASSIGNMOB(2559, magic_user);
  ASSIGNMOB(2560, magic_user);
  ASSIGNMOB(2562, magic_user);
  ASSIGNMOB(2564, magic_user);

  /* SEWERS */
  ASSIGNMOB(7006, snake);
  ASSIGNMOB(7009, magic_user);
  ASSIGNMOB(7200, magic_user);
  ASSIGNMOB(7201, magic_user);
  ASSIGNMOB(7202, magic_user);

  /* FOREST */
  ASSIGNMOB(6112, magic_user);
  ASSIGNMOB(6113, snake);
  ASSIGNMOB(6114, magic_user);
  ASSIGNMOB(6115, magic_user);
  ASSIGNMOB(6116, magic_user); /* should be a cleric */
  ASSIGNMOB(6117, magic_user);

  /* ARACHNOS */
  ASSIGNMOB(6302, magic_user);
  ASSIGNMOB(6309, magic_user);
  ASSIGNMOB(6312, magic_user);
  ASSIGNMOB(6314, magic_user);
  ASSIGNMOB(6315, magic_user);

  /* Desert */
  ASSIGNMOB(5004, magic_user);
  ASSIGNMOB(5010, magic_user);
  ASSIGNMOB(5014, magic_user);

  /* Drow City */
  ASSIGNMOB(5103, magic_user);
  ASSIGNMOB(5104, magic_user);
  ASSIGNMOB(5107, magic_user);
  ASSIGNMOB(5108, magic_user);

  /* Old Thalos */
  ASSIGNMOB(5200, magic_user);
  ASSIGNMOB(5201, magic_user);
  ASSIGNMOB(5209, magic_user);

  /* New Thalos */
/* 5481 - Cleric (or Mage... but he IS a high priest... *shrug*) */
  ASSIGNMOB(5404, receptionist);
  ASSIGNMOB(5421, magic_user);
  ASSIGNMOB(5422, magic_user);
  ASSIGNMOB(5423, magic_user);
  ASSIGNMOB(5424, magic_user);
  ASSIGNMOB(5425, magic_user);
  ASSIGNMOB(5426, magic_user);
  ASSIGNMOB(5427, magic_user);
  ASSIGNMOB(5428, magic_user);
  ASSIGNMOB(5434, cityguard);
  ASSIGNMOB(5440, magic_user);
  ASSIGNMOB(5455, magic_user);
  ASSIGNMOB(5461, cityguard);
  ASSIGNMOB(5462, cityguard);
  ASSIGNMOB(5463, cityguard);
  ASSIGNMOB(5482, cityguard);

  /* WASTELAND */
  ASSIGNMOB(9002, snake);
  ASSIGNMOB(9012, magic_user);
  ASSIGNMOB(9011, icewizard);

  /* ROME */
  ASSIGNMOB(12009, magic_user);
  ASSIGNMOB(12018, cityguard);
  ASSIGNMOB(12020, magic_user);
  ASSIGNMOB(12021, cityguard);
  ASSIGNMOB(12025, magic_user);
  ASSIGNMOB(12030, magic_user);
  ASSIGNMOB(12031, magic_user);
  ASSIGNMOB(12032, magic_user);

  /* King Welmar's Castle (not covered in castle.c) */
  ASSIGNMOB(15015, thief);      /* Ergan... have a better idea? */
  ASSIGNMOB(15032, magic_user); /* Pit Fiend, have something better?  Use it */
  ASSIGNMOB(15001, wardome);

  /* DWARVEN KINGDOM */
  ASSIGNMOB(6500, cityguard);
  ASSIGNMOB(6502, magic_user);
  ASSIGNMOB(6509, magic_user);
  ASSIGNMOB(6516, magic_user);

  /* SUNDHEAVEN */
  ASSIGNMOB(6700, sund_earl);        /* Earl of Sundhaven */
  ASSIGNMOB(6701, cityguard);
 // ASSIGNMOB(6702, hangman);
  ASSIGNMOB(6764, postmaster);
  ASSIGNMOB(6766, stu);
  ASSIGNMOB(6706, fido);             /* Smoke rat */
  ASSIGNMOB(6759, cityguard);
  ASSIGNMOB(6760, cityguard);
  ASSIGNMOB(6707, thief);
  ASSIGNMOB(6748, butcher);
  ASSIGNMOB(6761, blinder);
  ASSIGNMOB(6737, silktrader);
  ASSIGNMOB(6715, idiot);
  ASSIGNMOB(6753, athos);
  ASSIGNMOB(6704, priest);

  ASSIGNMOB(2244, tiamat2);

  ASSIGNMOB(2216, tiamat_heads);
  ASSIGNMOB(2217, tiamat_heads);
  ASSIGNMOB(2218, tiamat_heads);
  ASSIGNMOB(2219, tiamat_heads);
  ASSIGNMOB(2220, tiamat_heads);

}



/* assign special procedures to objects */
void assign_objects(void)
{
  ASSIGNOBJ(30401, gen_board); /*sith clan board*/
  ASSIGNOBJ(500, gen_board);   /* mortal board */
  ASSIGNOBJ(507, gen_board);   /* idea board */
  ASSIGNOBJ(509, gen_board);   /* mortal board */
  ASSIGNOBJ(512, gen_board);   /* mortal board */
  ASSIGNOBJ(3077, gen_board);   /*    bug board */
  ASSIGNOBJ(3096, gen_board);   /* social board */
  ASSIGNOBJ(3097, gen_board);   /* purple dragon board (ex-freeze board */
  ASSIGNOBJ(3098, gen_board);   /* immortal board */
  /*ASSIGNOBJ(3099, gen_board);   mortal board */
  ASSIGNOBJ(31001, gen_board);   /* Army's clan board */
  ASSIGNOBJ(30100, gen_board);   /* Night's clan Board */
  ASSIGNOBJ(97, gen_board);
  ASSIGNOBJ(98, gen_board);
  ASSIGNOBJ(1300, gen_board);  /*questbook board*/
  ASSIGNOBJ(9403, gen_board);  /* Helm's Deep Clan Board */
  ASSIGNOBJ(3034, bank);        /* atm */
  ASSIGNOBJ(3036, bank);        /* cashcard */
  ASSIGNOBJ(6747, marbles);        /* marbles */
  ASSIGNOBJ(10113, espada_fica_azul);
}



/* assign special procedures to rooms */
void assign_rooms(void)
{
  int i;

//  ASSIGNROOM(500, preparation_room);
  ASSIGNROOM(3030, dump);      /* The Dump            */
  ASSIGNROOM(3031, pet_shops); /* The Pet Shop Store  */
  ASSIGNROOM(534, pet_shops);  /* The Wardome City Pet Shop Store  */
  ASSIGNROOM(3067, gym);       /* The Midgaard's Gym  */
  ASSIGNROOM(3005, temple);    /* The Temple Square   */
  ASSIGNROOM(DRAGONROOM_INI, winddragon);/* sanctuary   */
  ASSIGNROOM(500, reborn);
//  ASSIGNROOM(599, alinhamento);
  ASSIGNROOM(to_fly_rooms[0], windroom);/* flying   */
  ASSIGNROOM(to_fly_rooms[1], windroom);/* flying   */
  ASSIGNROOM(to_fly_rooms[2], windroom);/* flying   */
  ASSIGNROOM(2701, random_room);
  ASSIGNROOM(2702, random_room);
  ASSIGNROOM(2703, random_room);
  ASSIGNROOM(2705, random_room);
  ASSIGNROOM(2707, random_room);
  ASSIGNROOM(2708, random_room);
  ASSIGNROOM(2710, random_room);

  if (dts_are_dumps)
    for (i = 0; i < top_of_world; i++)
      if (ROOM_FLAGGED(i, ROOM_DEATH))
        world[i].func = dump;
}
::::::::::::::
spec_procs.c
::::::::::::::
/* ************************************************************************
*   File: spec_procs.c                                  Part of CircleMUD *
*  Usage: implementation of special procedures for mobiles/objects/rooms  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "dg_scripts.h"
#include "winddragon.h"


/*   external vars  */
extern struct room_data *world;
extern struct char_data *character_list;
extern struct descriptor_data *descriptor_list;
extern struct index_data *mob_index;
extern struct index_data *obj_index;
extern struct time_info_data time_info;
extern struct spell_info_type spell_info[];
extern struct int_app_type int_app[];
extern int top_of_world;
extern char *spells[];
byte number_of_small_houses;
byte number_of_medium_houses;
byte number_of_large_houses;

/* extern functions */
void add_follower(struct char_data * ch, struct char_data * leader);
char *add_points(int value);
void save_char(struct char_data * ch, sh_int load_room);
ACMD(do_drop);
ACMD(do_gen_door);
ACMD(do_say);
void obj_to_char(struct obj_data * object, struct char_data * ch);
void die_in_dt(struct char_data * ch);
int conta_cores(const char *texto);

/* local functions */
int aceita_ra(int num1, int num2) ;
void sort_spells(void);
const char *how_good(int percent);
void list_skills(struct char_data * ch);
SPECIAL(dump);
SPECIAL(mayor);
SPECIAL(forger);
void npc_steal(struct char_data * ch, struct char_data * victim);
SPECIAL(snake);
SPECIAL(thief);
SPECIAL(magic_user);
SPECIAL(puff);
SPECIAL(fido);
SPECIAL(janitor);
SPECIAL(cityguard);
SPECIAL(gym);
SPECIAL(temple);
SPECIAL(archer);
SPECIAL(pet_shops);
SPECIAL(marbles);
SPECIAL(bank);
SPECIAL(priest_healer);
SPECIAL(priest);
SPECIAL(blacksmith);
SPECIAL(icewizard);
SPECIAL(preparation_room);
SPECIAL(sund_earl);
SPECIAL(hangman);
SPECIAL(blinder);
SPECIAL(silktrader);
SPECIAL(butcher);
SPECIAL(idiot);
SPECIAL(athos);
SPECIAL(stu);
SPECIAL(winddragon);
SPECIAL(windroom);
SPECIAL(wardome);
SPECIAL(questshop);
SPECIAL(black_dragon);
SPECIAL(black_monster);
SPECIAL(helms_guard);
SPECIAL(army_guard);
SPECIAL(house_shop);
SPECIAL(reborn);
SPECIAL(darkside_resea);
SPECIAL(purple_dragons_guard);
SPECIAL(night_guard);
SPECIAL(sith_guard);
SPECIAL(alinhamento);
SPECIAL(random_room);
SPECIAL(espada_fica_azul);
SPECIAL(religiao) ;
SPECIAL(oracle);


/* ********************************************************************
*  Special procedures for mobiles                                     *
******************************************************************** */

int spell_sort_info[MAX_SKILLS+1];

void sort_spells(void)
{
  int a, b, tmp;

  /* initialize array */
  for (a = 1; a < MAX_SKILLS; a++)
    spell_sort_info[a] = a;

  /* Sort.  'a' starts at 1, not 0, to remove 'RESERVED' */
  for (a = 1; a < MAX_SKILLS - 1; a++)
    for (b = a + 1; b < MAX_SKILLS; b++)
      if (strcmp(spells[spell_sort_info[a]], spells[spell_sort_info[b]]) > 0) {
        tmp = spell_sort_info[a];
        spell_sort_info[a] = spell_sort_info[b];
        spell_sort_info[b] = tmp;
      }
}
/*
void actualize_splskl(struct char_data *ch)
{
  int i, x;
  char skillbuf[MAX_STRING_LENGTH];

 for (i = 1; i < MAX_SPELLS+1; i++) {
  if (GET_LEVEL(ch) >= spell_info[i].min_level[(int) GET_CLASS(ch)] && GET_SKILL_LS(ch, i) < 20){
      SET_SKILL(ch, i, 20);
      sprintf(skillbuf, "&GYou learn the &gnew&G spell &Y%s&G.&n\r\n", spells[i]);
      send_to_char(skillbuf, ch);
  }
 }
 for (x = MAX_SPELLS + 1; x < MAX_SKILLS + 1; x++){
  if (GET_LEVEL(ch) >= spell_info[x].min_level[(int) GET_CLASS(ch)] && GET_SKILL_LS(ch, x) < 20){
      SET_SKILL(ch, x, 20);
      sprintf(skillbuf, "&GYou learn the &gnew&G skill &Y%s&G.&n\r\n", spells[x]);
      send_to_char(skillbuf, ch);
  }
 }
}
*/

int check_remort_sk(struct char_data *ch, int x)
{
	int y, remort;

	if(GET_REMORT(ch) > 0)
		for(remort = 1; remort <= GET_REMORT(ch); remort++)
			for(y = 0; y < MAX_RSKILLS; y++)
				if(GET_RSKILL(ch, remort, y) == x && GET_LEVEL(ch) >= spell_info[x].min_level[(int) GET_CLASS_REMORT(ch, remort)])
					return 1;

	return 0;
}
void actualize_splskl(struct char_data *ch)
{
	int x;
	char skillbuf[MAX_STRING_LENGTH];

	for(x = 1; x <= MAX_SKILLS; x++)
	{
		if(!GET_SKILL(ch, x))
		{
				if(GET_LEVEL(ch) >= spell_info[x].min_level[(int) GET_CLASS(ch)] || check_remort_sk(ch, x))
				{
					SET_SKILL(ch, x, 20);
					sprintf(skillbuf, "&GYou learn the &gnew&G %s &Y%s&G.&n\r\n", (x >= MAX_SPELLS ? "skill" : "spell"), spells[x]);
					send_to_char(skillbuf, ch);
				}
		}
	}
}

SPECIAL(dump)
{
  struct obj_data *k;
  int value = 0;

  for (k = world[ch->in_room].contents; k; k = world[ch->in_room].contents) {
    act("$p vanishes in a puff of smoke!", FALSE, 0, k, 0, TO_ROOM);
    extract_obj(k);
  }

  if (!CMD_IS("drop"))
    return 0;

  do_drop(ch, argument, cmd, 0);

  for (k = world[ch->in_room].contents; k; k = world[ch->in_room].contents) {
    act("$p vanishes in a puff of smoke!", FALSE, 0, k, 0, TO_ROOM);
    value += MAX(1, MIN(50, GET_OBJ_COST(k) / 10));
    extract_obj(k);
  }

  if (value) {
    act("You are awarded for outstanding performance.", FALSE, ch, 0, 0, TO_CHAR);
    act("$n has been awarded for being a good citizen.", TRUE, ch, 0, 0, TO_ROOM);

    if (GET_LEVEL(ch) < 3)
      gain_exp(ch, value);
    else
      GET_GOLD(ch) += value;
      GET_GOLD_SUM(ch) += value;
  }
  return 1;
}

struct pont_player {
   struct char_data *player;
   struct obj_data *obj;
  };

static int fila_fim = 0;
static int fila_inicio = 0;

SPECIAL(forger)
{
  long preco;
  int cont;
  struct obj_data *obj;
  struct char_data *self;
  int j = 0, number,pos = 0;
  char tmpname[MAX_INPUT_LENGTH];
  char *tmp = tmpname;
  static struct pont_player buf_player[100];

  self = (struct char_data *) me;

  if (CMD_IS("value")){
    one_argument(argument, arg);
    if (!*arg){
     send_to_char("Value what?\r\n", ch);
     return(1);
    }

     strcpy(tmp, arg);
     if (!(number = get_number(&tmp)))
       number = 1;
     cont = 0;
     obj = NULL;
     for (j = 0; j < NUM_WEARS; j++)
           if (GET_EQ(ch, j) && CAN_SEE_OBJ(ch, GET_EQ(ch, j)) &&
               isname(tmp, GET_EQ(ch, j)->name)) {
             cont = cont + 1;
             if (cont == number){
              obj = GET_EQ(ch, j);
              pos = j;
             }
           }

    if (obj == NULL)
     {
       sprintf(buf, "You don't seem to be using any %s.\r\n", tmp);
       send_to_char(buf, ch);
       return (1);
      }

    if (((GET_OBJ_TYPE(obj)) == ITEM_WAND) || ((GET_OBJ_TYPE(obj)) == ITEM_STAFF) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_TREASURE) || ((GET_OBJ_TYPE(obj)) == ITEM_POTION) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_OTHER) || ((GET_OBJ_TYPE(obj)) == ITEM_TRASH) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_CONTAINER) || ((GET_OBJ_TYPE(obj)) == ITEM_NOTE) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_DRINKCON) || ((GET_OBJ_TYPE(obj)) == ITEM_KEY) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_FOOD) || ((GET_OBJ_TYPE(obj)) == ITEM_PEN) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_BOAT) || ((GET_OBJ_TYPE(obj)) == ITEM_SCROLL))
    {
       sprintf(buf, "&c$n tells you, 'I don't repair this item type.&c'" );
       act(buf, FALSE, self, 0, ch, TO_VICT);
       return (1);
    }

    preco = (obj->obj_flags.cost*0.8)/((obj->obj_flags.cond/25)+1);
    sprintf(buf, "The value of the repair is %ld gold coins.\r\n", preco);
    send_to_char(buf, ch);
    return (1);
  }


  if ((CMD_IS("repair")) || (CMD_IS("forge")))
   {

     one_argument(argument, arg);

     if (!*arg) {
      if ((CMD_IS("repair"))){
       send_to_char("Blacksmith commands:\n\r", ch);
       send_to_char("\n\r", ch);
       send_to_char("      command                          price/action              \n\r", ch);
       send_to_char("=====================  ==========================================\n\r", ch);
       send_to_char(" repair                 this help                                \n\r", ch);
       send_to_char(" repair <object name>   depends of the equipament condition      \n\r", ch);
       send_to_char(" forge <object name>    100,000,000/make the object indestructible\n\r", ch);
       send_to_char(" value <object name>    evaluates the price of the repair        \n\r", ch);
       send_to_char("\n\r", ch);
       send_to_char("Example: repair 2.ring\n\r", ch);
       send_to_char("\n\r", ch);
       send_to_char("&ROBS:&w The equipment might beeing used by the player.\n\r", ch);
       send_to_char("     In case the owner of the equipment is not in this room in the \n\r", ch);
       send_to_char("     finish of the repair, the equipment will be confiscated as rent payment.\n\r", ch);
      }
      else
       send_to_char("Forge what?\r\n", ch);
      return (1);
     }
     strcpy(tmp, arg);
     if (!(number = get_number(&tmp)))
       number = 1;
     cont = 0;
     obj = NULL;
     for (j = 0; j < NUM_WEARS; j++)
           if (GET_EQ(ch, j) && CAN_SEE_OBJ(ch, GET_EQ(ch, j)) &&
               isname(tmp, GET_EQ(ch, j)->name)) {
             cont = cont + 1;
             if (cont == number){
              obj = GET_EQ(ch, j);
              pos = j;
             }
           }

    if (obj == NULL)
     {
       sprintf(buf, "You don't seem to be using any %s.\r\n", tmp);
       send_to_char(buf, ch);
       return (1);
     }

     if (((GET_OBJ_TYPE(obj)) == ITEM_WAND) || ((GET_OBJ_TYPE(obj)) == ITEM_STAFF) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_TREASURE) || ((GET_OBJ_TYPE(obj)) == ITEM_POTION) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_OTHER) || ((GET_OBJ_TYPE(obj)) == ITEM_TRASH) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_CONTAINER) || ((GET_OBJ_TYPE(obj)) == ITEM_NOTE) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_DRINKCON) || ((GET_OBJ_TYPE(obj)) == ITEM_KEY) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_FOOD) || ((GET_OBJ_TYPE(obj)) == ITEM_PEN) ||
        ((GET_OBJ_TYPE(obj)) == ITEM_BOAT) || ((GET_OBJ_TYPE(obj)) == ITEM_SCROLL))
     {
       sprintf(buf, "&c$n tells you, 'I don't repair this item type.&c'" );
       act(buf, FALSE, self, 0, ch, TO_VICT);
       return (1);
     }

     if (IS_OBJ_STAT(obj, ITEM_NODROP)){
       sprintf(buf, "I can't remove %s from you, it must be CURSED!\r\n", GET_EQ(ch, pos)->name);
       send_to_char(buf, ch);
       return (1);
     }

     if ((CMD_IS("repair")))
      preco = (obj->obj_flags.cost*0.8)/((obj->obj_flags.cond/25)+1);
     else
      preco = 100000000;

     if ((GET_GOLD(ch) < preco)) {
  	send_to_char("You don't have enough gold!\r\n", ch);
  	return (1);
     }
    // if (IS_CARRYING_N(ch) >= CAN_CARRY_N(ch)){
    //   act("$p: you can't carry that many items!", FALSE, ch, obj, 0, TO_CHAR);
   //    return 1;
   //  }


     GET_GOLD(ch) -= preco;
     sprintf(buf, "That'll be %ld gold coins.\r\n", preco);
     send_to_char(buf, ch);
     if ((CMD_IS("repair")))
      obj->obj_flags.cond = 100;
     else
      obj->obj_flags.cond = 101;
     buf_player[fila_fim].player = ch;
     buf_player[fila_fim].obj = obj;
     fila_fim++;
     if (fila_fim == 101)
      fila_fim = 0;
     unequip_char(ch, pos);
     //obj_from_char(obj);
     obj_to_char(obj, self);
     act("$N get $p from you.", FALSE, ch, obj, self, TO_CHAR);
     act("You get $p from $n.", FALSE, ch, obj, self, TO_VICT);
     act("$N get $p from $n.", TRUE, ch, obj,self, TO_NOTVICT);
     save_char(ch, NOWHERE);
     save_char(self, NOWHERE);
     do_say(self, "Wait a minute here.", 0, 0);
     if ((CMD_IS("repair")))
      act("$n start his work.", FALSE, self, 0, 0, TO_ROOM);
     else
      act("$n get a holy metal and start his work.", FALSE, self, 0, 0, TO_ROOM);
     return (1);
  }

  if (!cmd) {
   sprintf(buf,"inicio: %d.\r\n",fila_inicio);
   send_to_char(buf, ch);
   sprintf(buf,"fim: %d.\r\n",fila_fim);
   send_to_char(buf, ch);

    if (fila_inicio != fila_fim){
      obj_from_char(buf_player[fila_inicio].obj);
      if (buf_player[fila_inicio].player->in_room == self->in_room){
        obj_to_char(buf_player[fila_inicio].obj, buf_player[fila_inicio].player);

        act("$N give $p to you.", FALSE, buf_player[fila_inicio].player, buf_player[fila_inicio].obj, self, TO_CHAR);
        act("You give $p to $n.", FALSE, buf_player[fila_inicio].player, buf_player[fila_inicio].obj, self, TO_VICT);
        act("$N give $p to $n.", TRUE, buf_player[fila_inicio].player, buf_player[fila_inicio].obj, self, TO_NOTVICT);
        save_char(buf_player[fila_inicio].player, NOWHERE);
        save_char(self, NOWHERE);
      }
      else{
        save_char(self, NOWHERE);
        act("You forgot to get your $p with $N.", FALSE, buf_player[fila_inicio].player, buf_player[fila_inicio].obj, self, TO_CHAR);
        act("You kept $p in the closet to pay your rent service..", FALSE, buf_player[fila_inicio].player, buf_player[fila_inicio].obj, self, TO_VICT);
        act("$N kept $p in the closet to pay your rent service.", FALSE, self, buf_player[fila_inicio].obj, self, TO_ROOM);
        extract_obj(buf_player[fila_inicio].obj);
      }
      if (fila_inicio == 100){
          fila_inicio = 0;
      }
      else {
          fila_inicio++;
      }
    }
    return (1);
  }
  return (0);
}


SPECIAL(winddragon)
{
  int k, found;
  struct char_data *targ;
  struct char_data *dragao;

  if (CMD_IS("mount")) {

     skip_spaces(&argument);


     if (!AWAKE(ch)) {
       sprintf(buf, "Stand first to mount any.\r\n");
       send_to_char(buf, ch);
       return (1);
     }

     if (!*argument) {
       sprintf(buf, "Mount what?.\r\n");
       send_to_char(buf, ch);
       return (1);
     }

    if (is_abbrev(argument,"dragon")){

      if IS_NPC(ch) {
      	return 0;
      }

      k = real_room(DRAGONROOM_INI);
      dragao = NULL;
      for(targ = world[k].people; targ; targ = targ->next_in_room)
       if (IS_NPC(targ) && (GET_MOB_VNUM(targ) == DRAGON_VNUM) && (dragao == NULL)) {
       	dragao = targ;
       }
      if (dragao == NULL) {
       sprintf(buf, "I don't see any dragon here.\r\n");
       send_to_char(buf, ch);
       return (1);
      }

      if (IS_AFFECTED(ch, AFF_FLY)){
       sprintf(buf, "You don't mount while flying.\r\n");
       send_to_char(buf, ch);
       return (1);
      }

      k=0;
      found=0;
      while ((!found) && (k<=NUM_DRAGONS)){
      	if (vet_dragons[k] == 0){
      	  vet_dragons[k] = 1;
          buf_dragon_indo[k].player = ch;
          buf_dragon_indo[k].room = 0;
          found = 1;
        }
        k++;
      }
      act("You mount $n and starts fly.", FALSE, dragao, 0, ch, TO_VICT);
      act("$N mount $n and starts fly to the sky.", TRUE, dragao, 0, ch, TO_NOTVICT);

      extract_char(dragao);

      char_from_room(ch);
      char_to_room(ch, real_room(to_fly_rooms[0]));
      look_at_room(ch, 0);
      act("$n flies from down mounting a winged dragon.", TRUE, buf_dragon_indo[k-1].player, 0, 0, TO_NOTVICT);

      return 1;
    }
    else{
     sprintf(buf, "You don't mount this.\r\n");
     send_to_char(buf, ch);
     return (1);
    }

  }

  return 0;

}

SPECIAL(windroom)
{
  int k;
  struct char_data *mob;

   if (IS_NPC(ch) || (GET_LEVEL(ch) >= LVL_IMMORT))  {
      	return 0;
      }

  if (CMD_IS("unmount")) {

     skip_spaces(&argument);

  if (!is_abbrev(argument,"dragon")){
       sprintf(buf, "Unmount what?.\r\n");
       send_to_char(buf, ch);
       return (1);
     }

     act("$n unmount the dragon and falls to death.", TRUE, ch, 0, 0, TO_NOTVICT);
     act("The dragon go away.", TRUE, ch, 0, 0, TO_NOTVICT);
     for(k=0;k <= NUM_DRAGONS;k++)
      if (vet_dragons[k] == 1)
       if (ch->desc->descriptor == buf_dragon_indo[k].player->desc->descriptor)
        vet_dragons[k] = 0;

     mob = read_mobile(real_mobile(DRAGON_VNUM), REAL);
     char_to_room(mob, real_room(DRAGONROOM_INI));
     send_to_room("A Dragon comes from sky.\n\r", real_room(DRAGONROOM_INI));
     char_from_room(ch);
     char_to_room(ch, real_room(DRAGONROOM_FALL));
     look_at_room(ch, 0);
     log_death_trap(ch);
     die_in_dt(ch);
     return (1);
  }

  if (CMD_IS("mount")) {
     sprintf(buf, "You already mount a dragon.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("quit")) {
     sprintf(buf, "You don't quit while flying mount a dragon.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("recall")) {
     sprintf(buf, "You don't recall while flying mount a dragon.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("cast")) {
     sprintf(buf, "You are not concentrated enough to cast spells.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("recite")) {
     sprintf(buf, "You are not concentrated enough to recite.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("use")) {
     sprintf(buf, "You are not concentrated enough to use any.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("quaff")) {
     sprintf(buf, "You are not concentrated enough to quaff any.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("kill")) {
     sprintf(buf, "Kill anyone flying in a dragon??Isn't a good idea.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("hit")) {
     sprintf(buf, "Hit anyone flying in a dragon??Isn't a good idea.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("kick")) {
     sprintf(buf, "Kick anyone flying in a dragon??Are you crazy?.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("backstab")) {
     sprintf(buf, "Backstab anyone flying in a dragon??Isn't a good idea.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("bash")) {
     sprintf(buf, "Bash anyone flying in a dragon??Are you crazy?\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("murder")) {
     sprintf(buf, "Murder anyone flying in a dragon??Isn't a good idea.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("steal")) {
     sprintf(buf, "Steal anyone flying in a dragon??Isn't a good idea.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("rest")) {
     sprintf(buf, "Can you fly by yourself? wait here...\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("sleep")) {
     sprintf(buf, "Can you fly by yourself? wait here...\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("sit")) {
     sprintf(buf, "Can you fly by yourself? wait here...\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("stand")) {
     sprintf(buf, "Can you fly by yourself? wait here...\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("meditate")) {
     sprintf(buf, "Can you fly by yourself? wait here...\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("follow")) {
     sprintf(buf, "Say to the dragon follow.\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("hide")) {
     sprintf(buf, "Hide where?Below of the dragon wings?\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("gas")) {
     sprintf(buf, "Hide where?Below of the dragon wings?\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("take")) {
     sprintf(buf, "Take the clouds?\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("drop")) {
     sprintf(buf, "Drop any in the clouds?\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("war")) {
     sprintf(buf, "Will it be that the dragon wants war too?\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  if (CMD_IS("harakiri")) {
     sprintf(buf, "Well, do you think the suicide is the best choice??\r\n");
     send_to_char(buf, ch);
     return (1);
  }

  return (0);
}


SPECIAL(mayor)
{
  const char open_path[] =
        "W3a3003b33000c111d0d111Oe333333Oe22c222112212111a1S.";
  const char close_path[] =
        "W3a3003b33000c111d0d111CE333333CE22c222112212111a1S.";

  static const char *path;
  static int index;
  static bool move = FALSE;

  if (!move) {
    if (time_info.hours == 6) {
      move = TRUE;
      path = open_path;
      index = 0;
    } else if (time_info.hours == 20) {
      move = TRUE;
      path = close_path;
      index = 0;
    }
  }
  if (cmd || !move || (GET_POS(ch) < POS_SLEEPING) ||
      (GET_POS(ch) == POS_FIGHTING))
    return FALSE;

  switch (path[index]) {
  case '0':
  case '1':
  case '2':
  case '3':
    perform_move(ch, path[index] - '0', 1);
    break;

  case 'W':
    GET_POS(ch) = POS_STANDING;
    act("$n awakens and groans loudly.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'S':
    GET_POS(ch) = POS_SLEEPING;
    act("$n lies down and instantly falls asleep.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'a':
    act("$n says 'Hello Honey!'", FALSE, ch, 0, 0, TO_ROOM);
    act("$n smirks.", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'b':
    act("$n says 'What a view!  I must get something done about that dump!'",
        FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'c':
    act("$n says 'Vandals!  Youngsters nowadays have no respect for anything!'",
        FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'd':
    act("$n says 'Good day, citizens!'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'e':
    act("$n says 'I hereby declare the bazaar open!'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'E':
    act("$n says 'I hereby declare Wardome city closed!'", FALSE, ch, 0, 0, TO_ROOM);
    break;

  case 'O':
   // do_gen_door(ch, "gate", 0, SCMD_UNLOCK);
    do_gen_door(ch, "gate", 0, SCMD_OPEN);
    break;

  case 'C':
    do_gen_door(ch, "gate", 0, SCMD_CLOSE);
   // do_gen_door(ch, "gate", 0, SCMD_LOCK);
    break;

  case '.':
    move = FALSE;
    break;

  }

  index++;
  return FALSE;
}


/* ********************************************************************
*  General special procedures for mobiles                             *
******************************************************************** */


void npc_steal(struct char_data * ch, struct char_data * victim)
{
  int gold;

  if (IS_NPC(victim))
    return;
  if (GET_LEVEL(victim) >= LVL_IMMORT)
    return;

  if (AWAKE(victim) && (number(0, (GET_LEVEL(ch)/2)) == 0)) {
    act("You discover that $n has $s hands in your wallet.", FALSE, ch, 0, victim, TO_VICT);
    act("$n tries to steal gold from $N.", TRUE, ch, 0, victim, TO_NOTVICT);
  } else {
    /* Steal some gold coins */
    gold = (int) ((GET_GOLD(victim) * number(1, 10)) / 100);
    if (gold > 0) {
      GET_GOLD(ch) += gold;
      GET_GOLD(victim) -= gold;
    }
  }
}


SPECIAL(snake)
{
  if (cmd)
    return FALSE;

  if (GET_POS(ch) != POS_FIGHTING)
    return FALSE;

  if (FIGHTING(ch) && (FIGHTING(ch)->in_room == ch->in_room) &&
      (number(0, (((LVL_IMPL + 10) - GET_LEVEL(ch)) /3)) == 0)) {
    act("$n bites $N!", 1, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("$n bites you!", 1, ch, 0, FIGHTING(ch), TO_VICT);
    call_magic(ch, FIGHTING(ch), 0, SPELL_POISON, GET_LEVEL(ch), CAST_SPELL);
    return TRUE;
  }
  return FALSE;
}


SPECIAL(thief)
{
  struct char_data *cons;

  if (cmd)
    return FALSE;

  if (GET_POS(ch) != POS_STANDING)
    return FALSE;

  for (cons = world[ch->in_room].people; cons; cons = cons->next_in_room)
    if (!IS_NPC(cons) && (GET_LEVEL(cons) < LVL_IMMORT) && (!number(0, 4))) {
      npc_steal(ch, cons);
      return TRUE;
    }
  return FALSE;
}


SPECIAL(magic_user)
{
  struct char_data *vict;

  if (cmd || GET_POS(ch) != POS_FIGHTING || GET_LEVEL(ch) < 25)
    return FALSE;

  /* pseudo-randomly choose someone in the room who is fighting me */
  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
    if (FIGHTING(vict) == ch && !number(0, 4))
      break;

  /* if I didn't pick any of those, then just slam the guy I'm fighting */
  if (vict == NULL && IN_ROOM(FIGHTING(ch)) == IN_ROOM(ch))
    vict = FIGHTING(ch);

  /* Hm...didn't pick anyone...I'll wait a round. */
  if (vict == NULL)
    return TRUE;

  if ((GET_LEVEL(ch) > 13) && (number(0, 10) == 0))
    cast_spell(ch, vict, NULL, SPELL_SLEEP);

  if ((GET_LEVEL(ch) > 7) && (number(0, 8) == 0))
    cast_spell(ch, vict, NULL, SPELL_BLINDNESS);

  if ((GET_LEVEL(ch) > 12) && (number(0, 12) == 0)) {
    if (IS_EVIL(ch))
      cast_spell(ch, vict, NULL, SPELL_ENERGY_DRAIN);
    else if (IS_GOOD(ch))
      cast_spell(ch, vict, NULL, SPELL_DISPEL_EVIL);
  }
  if (number(0, 4))
    return TRUE;

  switch (number(0, 17)) {
  case 4:
  case 5:
    cast_spell(ch, vict, NULL, SPELL_MAGIC_MISSILE);
    break;
  case 6:
  case 7:
    cast_spell(ch, vict, NULL, SPELL_CHILL_TOUCH);
    break;
  case 8:
  case 9:
    cast_spell(ch, vict, NULL, SPELL_BURNING_HANDS);
    break;
  case 10:
  case 11:
    cast_spell(ch, vict, NULL, SPELL_SHOCKING_GRASP);
    break;
  case 12:
  case 13:
    cast_spell(ch, vict, NULL, SPELL_LIGHTNING_BOLT);
    break;
  case 14:
  case 15:
  case 16:
  case 17:
    cast_spell(ch, vict, NULL, SPELL_COLOR_SPRAY);
    break;
  default:
    cast_spell(ch, vict, NULL, SPELL_SHOCKING_GRASP);
    break;
  }
  return TRUE;

}


/* ********************************************************************
*  Special procedures for mobiles                                      *
******************************************************************** */

SPECIAL(puff)
{
  if (cmd)
    return (0);

  switch (number(0, 60)) {
  case 0:
    do_say(ch, "My god!  It's full of stars!", 0, 0);
    return (1);
  case 1:
    do_say(ch, "How'd all those fish get up here?", 0, 0);
    return (1);
  case 2:
    do_say(ch, "I'm a very female dragon.", 0, 0);
    return (1);
  case 3:
    do_say(ch, "I've got a peaceful, easy feeling.", 0, 0);
    return (1);
  case 4:
    do_say(ch, "I don't wanna play another MUD. Wardome is the best!", 0, 0);
    return (1);
  default:
    return (0);
  }
}



SPECIAL(fido)
{

  struct obj_data *i, *temp, *next_obj;

  if (cmd || !AWAKE(ch))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = i->next_content) {
    if (IS_CORPSE(i)) {
      act("$n savagely devours a corpse.", FALSE, ch, 0, 0, TO_ROOM);
      for (temp = i->contains; temp; temp = next_obj) {
        next_obj = temp->next_content;
        obj_from_obj(temp);
        obj_to_room(temp, ch->in_room);
      }
      extract_obj(i);
      return (TRUE);
    }
  }
  return (FALSE);
}



SPECIAL(janitor)
{
  struct obj_data *i;

  if (cmd || !AWAKE(ch))
    return (FALSE);

  for (i = world[ch->in_room].contents; i; i = i->next_content) {
    if (!CAN_WEAR(i, ITEM_WEAR_TAKE))
      continue;
    if (GET_OBJ_TYPE(i) != ITEM_DRINKCON && GET_OBJ_COST(i) >= 15)
      continue;
    act("$n picks up some trash.", FALSE, ch, 0, 0, TO_ROOM);
    obj_from_room(i);
    obj_to_char(i, ch);
    return TRUE;
  }

  return FALSE;
}


SPECIAL(cityguard)
{
  struct char_data *tch, *evil;
  int max_evil;

  if (cmd || !AWAKE(ch) || FIGHTING(ch))
    return FALSE;

  max_evil = 1000;
  evil = 0;

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && PLR_FLAGGED(tch, PLR_KILLER)) {
      act("$n screams 'HEY!!!  You're one of those PLAYER KILLERS!!!!!!'", FALSE, ch, 0, 0, TO_ROOM);
      hit(ch, tch, TYPE_UNDEFINED);
      return (TRUE);
    }
  }

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (!IS_NPC(tch) && CAN_SEE(ch, tch) && PLR_FLAGGED(tch, PLR_THIEF)){
      act("$n screams 'HEY!!!  You're one of those PLAYER THIEVES!!!!!!'", FALSE, ch, 0, 0, TO_ROOM);
      hit(ch, tch, TYPE_UNDEFINED);
      return (TRUE);
    }
  }

  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room) {
    if (CAN_SEE(ch, tch) && FIGHTING(tch)) {
      if ((GET_ALIGNMENT(tch) < max_evil) &&
          (IS_NPC(tch) || IS_NPC(FIGHTING(tch)))) {
        max_evil = GET_ALIGNMENT(tch);
        evil = tch;
      }
    }
  }

  if (evil && (GET_ALIGNMENT(FIGHTING(evil)) >= 0)) {
    act("$n screams 'PROTECT THE INNOCENT!  BANZAI!  CHARGE!  ARARARAGGGHH!'", FALSE, ch, 0, 0, TO_ROOM);
    hit(ch, evil, TYPE_UNDEFINED);
    return (TRUE);
  }
  return (FALSE);
}


#define MSG_GYM \
"THE PIT BULL GYM\r\n" \
"\r\n" \
"Here you can train your phisical abilities.\r\n" \
"Type META <field> to train a specific item.\r\n" \
"\r\n" \
"You can train the following:\r\n" \
"  Field          Cost\r\n" \
"  -----------    ------------------------\r\n" \
"  constitution    30 points and 1,000 gold\r\n" \
"  health         %2d points and %5s gold\r\n" \
"  move           %2d points and %5s gold\r\n" \
"  strength       %2d points and %5s gold\r\n" \
"  dexterity      %2d points and %5s gold\r\n" \
"\r\n" \
"  check          %2d points and %5s gold\r\n" \
"\r\n" \
"TIP: You can train mana, inteligence and wisdom on the Cryogenic center." \
"\r\n"

SPECIAL(gym)
{
                    /*   Hp   Mv   Str   Dex   Not*/
  const int costs[] = {   3,   2,   40,   35,   0, 30 };
  const int money[] = {1000, 500, 2500, 2500, 300, 1000 };
  const int gains[] = {  15,   7,    1,    1,   0, 1 };
  int mode;

  if (IS_NPC(ch) || !CMD_IS("meta"))
    return 0;

  skip_spaces(&argument);

  if (!*argument) { /* no argument, just display the options. */
    sprintf(buf, MSG_GYM, costs[0], add_points(money[0]), costs[1], add_points(money[1]),
                          costs[2], add_points(money[2]), costs[3], add_points(money[3]),
                          costs[4], add_points(money[4]));
    send_to_char(buf, ch);
    return 1;
  }

  if (!strcmp(argument, "health") || !strcmp(argument, "hp"))
    mode = 0;
  else if (!strcmp(argument, "move") || !strcmp(argument, "mv"))
    mode = 1;
  else if (!strcmp(argument, "strenght") || !strcmp(argument, "str"))
    mode = 2;
  else if (!strcmp(argument, "dexterity") || !strcmp(argument, "dex"))
    mode = 3;
  else if (!strcmp(argument, "check") || !strcmp(argument, "che"))
    mode = 4;
  else if (!strcmp(argument, "constitution") || !strcmp(argument, "con"))
    mode = 5;
  else if (!strcmp(argument, "mana") || !strcmp(argument, "mn") ||
           !strcmp(argument, "wisdom") || !strcmp(argument, "wis") ||
           !strcmp(argument, "inteligence") || !strcmp(argument, "int")) {
    send_to_char("Find a Temple to train mana, inteligence or wisdom.\r\n", ch);
    return 1;
  }
  else {
    send_to_char("Invalid training type.\r\n", ch);
    return 1;
  }

  if (GET_POINTS(ch) < costs[mode]) {
    send_to_char("You don't have enough points!\r\n", ch);
    return 1;
  }
  if (GET_GOLD(ch) < money[mode]) {
    send_to_char("You don't have enough money!\r\n", ch);
    return 1;
  }

  switch (mode) {
    case 0: /* health */
      GET_MAX_HIT(ch) += MAX(15, ch->real_abils.con);
      GET_HIT(ch) += ch->real_abils.con ;
      save_char(ch, NOWHERE);
      send_to_char("Your vitality increases!\r\n", ch);
      break;
    case 1: /* move */
      GET_MAX_MOVE(ch) += MAX(12,ch->real_abils.dex) ;
      GET_MOVE(ch) += ch->real_abils.dex ;
      save_char(ch, NOWHERE);
      send_to_char("Your movement points increases!\r\n", ch);
      break;
    case 2: /* str */
      if (ch->real_abils.str  >= 18) {
        if (ch->real_abils.str_add >= 100) {
          send_to_char("You are already strong enough.\r\n", ch);
          return 1;
        }
        ch->real_abils.str_add += gains[mode] * 10;
        save_char(ch, NOWHERE);
      }
      else
      ch->real_abils.str += gains[mode];
      save_char(ch, NOWHERE);
      send_to_char("You feel stronger a lot!\r\n", ch);
      break;
    case 3: /* dex */
      if (ch->real_abils.dex >= 18) {
        send_to_char("You don't need to train your dexterity.\r\n", ch);
        return 1;
      }
      ch->real_abils.dex += gains[mode];
      save_char(ch, NOWHERE);
      send_to_char("You feel more skillful.\r\n", ch);
      break;
    case 4: /* not */
      send_to_char("You MAX stats are:\r\n", ch);
      sprintf(buf, " &CHp&c[&r%s&c] &CMv&c[&r%d&c]&n\r\n", add_points(GET_MAX_HIT(ch)), (GET_MAX_MOVE(ch)));
      sprintf(buf + strlen(buf), " &CStr&c[&r%d&c] &CDex&c[&r%d&c] &CCon&c[&r%d&c]&n\r\n", (GET_STR(ch)), (GET_DEX(ch)), (GET_CON(ch)));
      send_to_char(buf, ch);
      save_char(ch, NOWHERE);
      break;
    case 5: /* con */
      if (ch->real_abils.con >= 18) {
        send_to_char("You don't need to train your con.\r\n", ch);
        return 1;
      }
      ch->real_abils.con += gains[mode];
      save_char(ch, NOWHERE);
      send_to_char("You feel more robust.\r\n", ch);
      break;
  }
  GET_POINTS(ch) -= costs[mode];
  GET_POINTS_GS(ch) += costs[mode];
  GET_GOLD(ch) -= money[mode];

  act("$n trains in the Gym.", TRUE, ch, 0, FALSE, TO_ROOM);
  return 1;
}

#define MSG_TEMPLE \
"THE CRYOGENIC CENTER\r\n" \
"\r\n" \
"Here you can train your mental abilities.\r\n" \
"Type META <field> to train a specific item.\r\n" \
"\r\n" \
"You can train the following:\r\n" \
"  Field          Cost\r\n" \
"  -----------    ------------------------\r\n" \
"  charisma       60  points and 1,000 gold\r\n" \
"  mana           %2d points and %5s gold\r\n" \
"  inteligence    %2d points and %5s gold\r\n" \
"  wisdom         %2d points and %5s gold\r\n" \
"\r\n" \
"  check          %2d points and %5s gold\r\n" \
"\r\n" \
"TIP: You can train health, movement, strength and dexterity on the Pit Bull Gym."

SPECIAL(temple)
{
                    /*   Mn   Int   Wis  Not */
  const int costs[] = {   2,   30,   30,   0, 60 };
  const int money[] = {1200, 2500, 2500, 300, 1000 };
  const int gains[] = {  15,    1,    1,   0, 1 };
  int mode;

  if (IS_NPC(ch) || !CMD_IS("meta"))
    return 0;

  skip_spaces(&argument);

  if (!*argument) { /* no argument, just display the options. */
    sprintf(buf, MSG_TEMPLE, costs[0], add_points(money[0]), costs[1],
                       add_points(money[1]), costs[2], add_points(money[2]),
                          costs[3], add_points(money[3]));
    send_to_char(buf, ch);
    return 1;
  }

  if (!strcmp(argument, "mana") || !strcmp(argument, "mn"))
    mode = 0;
  else if (!strcmp(argument, "inteligence") || !strcmp(argument, "int"))
    mode = 1;
  else if (!strcmp(argument, "wisdom") || !strcmp(argument, "wis"))
    mode = 2;
  else if (!strcmp(argument, "check") || !strcmp(argument, "che"))
    mode = 3;
  else if (!strcmp(argument, "cha") || !strcmp(argument, "charisma"))
    mode = 4;
  else if (!strcmp(argument, "health") || !strcmp(argument, "hp") ||
           !strcmp(argument, "movement") || !strcmp(argument, "mv") ||
           !strcmp(argument, "strength") || !strcmp(argument, "str") ||
           !strcmp(argument, "dexterity") || !strcmp(argument, "dex")) {
    send_to_char("Find a Gym to train health, movements, strength or dexterity.\r\n", ch);
    return 1;
  }
  else {
    send_to_char("Invalid training type.\r\n", ch);
    return 1;
  }

  if (GET_POINTS(ch) < costs[mode]) {
    send_to_char("You don't have enough points!\r\n", ch);
    return 1;
  }
  if (GET_GOLD(ch) < money[mode]) {
    send_to_char("You don't have enough money!\r\n", ch);
    return 1;
  }

  switch (mode) {
    case 0: /* mana */
      GET_MAX_MANA(ch) += MAX(12,((ch->real_abils.intel + ch->real_abils.wis)/2)) ;
      GET_MANA(ch) += (ch->real_abils.intel + ch->real_abils.wis) /2 ;
      save_char(ch, NOWHERE);
      send_to_char("Your magic power increases!\r\n", ch);
      break;
    case 1: /* inteligence */
      if (ch->real_abils.intel >= 18) {
        send_to_char("You are already Einstein.\r\n", ch);
        return 1;
      }
      ch->real_abils.intel += gains[mode];
      save_char(ch, NOWHERE);
      send_to_char("You feel yourself more intelligent.\r\n", ch);
      break;
    case 2: /* wisdom */
      if (ch->real_abils.wis >= 18) {
        send_to_char("You are already wise a lot.\r\n", ch);
        return 1;
      }
      ch->real_abils.wis += gains[mode];
      save_char(ch, NOWHERE);
      send_to_char("You have become more wise.\r\n", ch);
      break;
    case 3: /* not */
    send_to_char("Your MAX stats are:\r\n", ch);
      sprintf(buf, " &CMn&c[&r%s&c] &CCha&c[&r%d&c]&n\r\n", add_points(GET_MAX_MANA(ch)), (GET_CHA(ch)));
      sprintf(buf + strlen(buf), "&CInt&c[&r%d&c] &CWis&c[&r%d&c]&n\r\n", (GET_INT(ch)), (GET_WIS(ch)));
      send_to_char(buf, ch);
      save_char(ch, NOWHERE);
      break;

    case 4: /* cha */
      if (ch->real_abils.cha >= 18) {
        send_to_char("You are already charismatic a lot.\r\n", ch);
        return 1;
      }
      ch->real_abils.cha += gains[mode];
      save_char(ch, NOWHERE);
      send_to_char("You have become more charismatic.\r\n", ch);
      break;
  }
  GET_POINTS(ch) -= costs[mode];
  GET_POINTS_GS(ch) += costs[mode];
  GET_GOLD(ch) -= money[mode];

  act("$n meditates in the Temple.", TRUE, ch, 0, FALSE, TO_ROOM);
  return 1;
}

#define NUM_ARCHERS      1              /* # of rooms archers can shoot from */
#define NUM_TARGETS      3              /* # of rooms an archer can shoot at */
#define HIT_CHANCE       60             /* accuracy 60% chance to hit */
#define ARCHER_NUM_DICE  3              /*  archer damage dice */
#define ARCHER_SIZE_DICE 3              /*  archer does 3d3 each hit */

SPECIAL(archer)
{
  struct char_data *targ;
  int i, j, k;
  int damage;

  sh_int to_from_rooms[NUM_ARCHERS][NUM_TARGETS + 1] =
{
   /* archer room     target room #1     #2       #3 */
      { 523,              524,        6092,     6091}//,/* archer room #1 */
      //{ 3041,              3501,        3500,     -1} /* room #2 */
  };

  char *mssgs[] = {
    "You feel a sharp pain in your side as an arrow finds its mark!",
    "You hear a dull thud as an arrow pierces $N!",
    "An arrow whistles by your ear, barely missing you!",
    "An arrow narrowly misses $N!"
  };

  if(cmd)
    return FALSE;

  if(GET_POS(ch) != POS_STANDING)
    return FALSE;

  for(i = 0; i < NUM_ARCHERS; i++) {
    if(real_room(to_from_rooms[i][0]) == ch->in_room) {
      for(j = 1; j <= NUM_TARGETS; j++) {
        if((k = real_room(to_from_rooms[i][j])) >= 0) {
          for(targ = world[k].people; targ; targ = targ->next_in_room) {
            if(!IS_NPC(targ) && (GET_LEVEL(targ) < LVL_IMMORT) && (GET_LEVEL(targ) > 5) &&
              (!number(0, 2))) {
              if(number(1, 100) <= HIT_CHANCE) {
                act(mssgs[0], 1, ch, 0, targ, TO_VICT);
                act(mssgs[1], 1, ch, 0, targ, TO_NOTVICT);
                damage = (ARCHER_NUM_DICE *  ARCHER_SIZE_DICE);
                GET_HIT(targ) -= damage + (number(1,6));
                /*  these above numbers can be changed for different
                 *  damage levels.
                 */
                update_pos(targ);
                return TRUE;
              } else {
                act(mssgs[2], 1, ch, 0, targ, TO_VICT);
                act(mssgs[3], 1, ch, 0, targ, TO_NOTVICT);
                return TRUE;
              }
            }
          }
        }
      }
    }
  }
  return FALSE;
}

long PET_PRICE(char_data *pet)
{
  long price;

   if (GET_LEVEL(pet) <= 5)
    price =(GET_LEVEL(pet) * 400);
   else
    price =(GET_LEVEL(pet) * 1200);
   return(price);
}


SPECIAL(pet_shops)
{
  char buf[MAX_STRING_LENGTH], pet_name[256];
  int pet_room;
  struct char_data *pet;

  pet_room = real_room(557);

  if (CMD_IS("list")) {
    send_to_char("&RAvailable pets are:&n\r\n", ch);
    for (pet = world[pet_room].people; pet; pet = pet->next_in_room) {
       sprintf(buf, "&Y%8ld &C- &G%s&n\r\n", PET_PRICE(pet), GET_NAME(pet));
       send_to_char(buf, ch);
    }
    return (TRUE);
  } else if (CMD_IS("buy")) {

    argument = one_argument(argument, buf);
    argument = one_argument(argument, pet_name);

    if (!(pet = get_char_room(buf, pet_room))) {
      send_to_char("There is no such pet!\r\n", ch);
      return (TRUE);
    }
    if (GET_GOLD(ch) < PET_PRICE(pet)) {
      send_to_char("You don't have enough gold!\r\n", ch);
      return (TRUE);
    }

    if (!allow_follower(ch, 5)) {
	send_to_char("You can't have any more followers.\n\r", ch);
	return(TRUE);
      }

    GET_GOLD(ch) -= PET_PRICE(pet);

    pet = read_mobile(GET_MOB_RNUM(pet), REAL);
    GET_EXP(pet) = 0;
    SET_BIT(AFF_FLAGS(pet), AFF_CHARM);

    if (*pet_name) {
      sprintf(buf, "%s %s", pet->player.name, pet_name);
      /* free(pet->player.name); don't free the prototype! */
      pet->player.name = str_dup(buf);

      sprintf(buf, "%sA small sign on a chain around the neck says 'My name is %s'\r\n",
              pet->player.description, pet_name);
      /* free(pet->player.description); don't free the prototype! */
      pet->player.description = str_dup(buf);
    }
    char_to_room(pet, ch->in_room);
    add_follower(pet, ch);
    load_mtrigger(pet);

    /* Be certain that pets can't get/carry/use/wield/wear items */
    IS_CARRYING_W(pet) = 1000;
    IS_CARRYING_N(pet) = 100;

    send_to_char("May you enjoy your pet.\r\n", ch);
    act("$n buys $N as a pet.", FALSE, ch, 0, pet, TO_ROOM);

    return 1;
  }
  /* All commands except list and buy */
  return 0;
}


/*sundheaven*/

SPECIAL(silktrader)
{
  ACMD(do_say);

  if (cmd)
    return 0;

  if (world[ch->in_room].sector_type == SECT_CITY)
  switch (number(0, 30)) {
   case 0:
      act("$n eyes a passing woman.", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "Come, m'lady, and have a look at this precious silk!", 0, 0);
      return(1);
   case 1:
      act("$n says to you, 'Wouldn't you look lovely in this!'", FALSE, ch, 0, 0,TO_ROOM);
      act("$n shows you a gown of indigo silk.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 2:
      act("$n holds a pair of silk gloves up for you to inspect.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 3:
      act("$n cries out, 'Have at this fine silk from exotic corners of the world you will likely never see!", FALSE, ch, 0, 0,TO_ROOM);
      act("$n smirks.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 4:
      do_say(ch, "Step forward, my pretty locals!", 0, 0);
      return(1);
   case 5:
      act("$n shades his eyes with his hand.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 6:
      do_say(ch, "Have you ever seen an ogre in a silken gown?", 0, 0);
      do_say(ch, "I didn't *think* so!", 0, 0);
      act("$n throws his head back and cackles with insane glee!", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 7:
      act("$n hands you a glass of wine.", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "Come, have a seat and view my wares.", 0, 0);
      return(1);
   case 8:
      act("$n looks at you.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n shakes his head sadly.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 9:
      act("$n fiddles with some maps.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 10:
      do_say(ch, "Here here! Beggars and nobles alike come forward and make your bids!", 0, 0);
      return(1);
   case 11:
      do_say(ch, "I am in this bourgeois hamlet for a limited time only!", 0, 0);
      act("$n swirls some wine in a glass.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
  }

  if (world[ch->in_room].sector_type != SECT_CITY)
  switch (number(0, 20)) {
   case 0:
      do_say(ch, "Ah! Fellow travellers! Come have a look at the finest silk this side of the infamous Ched Razimtheth!", 0, 0);
      return(1);
   case 1:
      act("$n looks at you.", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "You are feebly attired for the danger that lies ahead.", 0, 0);
      do_say(ch, "Silk is the way to go.", 0, 0);
      act("$n smiles warmly.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 2:
      do_say(ch, "Worthy adventurers, hear my call!", 0, 0);
      return(1);
   case 3:
      act("$n adjusts his cloak.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 4:
      act("$n says to you, 'Certain doom awaits you, therefore shall you die in silk.'", FALSE, ch, 0, 0,TO_ROOM);
      act("$n bows respectfully.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 5:
      do_say(ch, "Can you direct me to the nearest tavern?", 0, 0);
      return(1);
   case 6:
      do_say(ch, "Heard the latest ogre joke?", 0, 0);
      act("$n snickers to himself.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 7:
      do_say(ch, "What ho, traveller! Rest your legs here for a spell and peruse the latest in fashion!", 0, 0);
      return(1);
   case 8:
      do_say(ch, "Beware ye, traveller, lest ye come to live in Exile!", 0, 0);
      act("$n grins evilly.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 9:
      act("$n touches your shoulder.", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "A word of advice. Beware of any ale labled 'mushroom' or 'pumpkin'.", 0, 0);
      act("$n shivers uncomfortably.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);

  }
  return(0);
}


SPECIAL(athos)
{
  ACMD(do_say);

  if(cmd)
   return 0;
    switch (number(0, 20)) {
    case 0:
      act("$n gazes into his wine gloomily.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
    case 1:
      act("$n grimaces.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
    case 2:
      act("$n asks you, 'Have you seen the lady, pale and fair, with a heart of stone?'", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "That monster will be the death of us all.", 0, 0);
      return(1);
    case 3:
      do_say(ch, "God save the King!", 0, 0);
      return(1);
    case 4:
      do_say(ch, "All for one and .. one for...", 0, 0);
      act("$n drowns himself in a swig of wine.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
    case 5:
      act("$n looks up with a philosophical air.", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "Women - God's eternal punishment on man.", 0, 0);
      return(1);
    case 6:
      act("$n downs his glass and leans heavily on the oaken table.", FALSE, ch, 0, 0,TO_ROOM);
      do_say(ch, "You know, we would best band together and wrestle the monstrous woman from her lair and home!", 0, 0);
      return(1);
  default: return(FALSE);
                break; }
    return(0);
}


/*
SPECIAL(hangman)
{
ACMD(do_say);
if(cmd) return 0;
  switch (number(0, 15)) {
  case 0:
    act("$n whirls his noose like a lasso and it lands neatly around your neck.", FALSE, ch, 0, 0,TO_ROOM);
    do_say(ch, "You're next, you ugly rogue!", 0, 0);
    do_say(ch, "Just kidding.", 0, 0);
    act("$n pats you on your head.", FALSE, ch, 0, 0,TO_ROOM);
    return(1);
  case 1:
    do_say(ch, "I was conceived in Exile and have been integrated into society!", 0, 0);
    do_say(ch, "Muahaha!", 0, 0);
    return(1);
  case 2:
    do_say(ch, "Anyone have a butterknife I can borrow?", 0, 0);
    return(1);
  case 3:
    act("$n suddenly pulls a lever.", FALSE, ch, 0, 0,TO_ROOM);
    act("With the flash of light on metal a giant guillotine comes crashing down!", FALSE, ch, 0, 0,TO_ROOM);
    act("A head drops to the ground from the platform.", FALSE, ch, 0, 0,TO_ROOM);
    act("$n looks up and shouts wildly.", FALSE, ch, 0, 0,TO_ROOM);
    act("$n shouts, 'Next!'", FALSE, ch, 0, 0, TO_ROOM);
    return(1);
  case 4:
   act("$n whistles a local tune.", FALSE, ch, 0, 0,TO_ROOM);
   return(1);
   default:
     return(FALSE);
     break;
  }
  return(0);
}

*/

SPECIAL(butcher)
{
ACMD(do_say);
if(cmd) return 0;
  switch (number(0, 40)) {
   case 0:
      do_say(ch, "I need a Union.", 0, 0);
      act("$n glares angrily.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n rummages about for an axe.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 1:
      act("$n gnaws on a toothpick.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 2:
      act("$n runs a finger along the edge of a giant meat cleaver.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n grins evilly.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 3:
      do_say(ch, "Pork for sale!", 0, 0);
      return(1);
   case 4:
      act("$n whispers to you, 'I've got some great damage eq in the back room. Wanna see?'", FALSE, ch, 0, 0,TO_ROOM);
      act("$n throws back his head and cackles with insane glee!", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 5:
      act("$n yawns.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 6:
      act("$n throws an arm around the headless body of an ogre and asks to have his picture taken.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 7:
      act("$n listlessly grabs a cleaver and hurls it into the wall behind your head.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 8:
      act("$n juggles some fingers.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 9:
      act("$n eyes your limbs.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n chuckles.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 10:
      do_say(ch, "Hi, Alice.", 0, 0);
      return(1);
   case 11:
      do_say(ch, "Everyone looks like food to me these days.", 0, 0);
      act("$n sighs loudly.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 12:
      act("$n throws up his head and shouts wildly.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n shouts, 'Bring out your dead!'", FALSE, ch, 0, 0, TO_ROOM);
      return(1);
   case 13:
      do_say(ch, "The worms crawl in, the worms crawl out..", 0, 0);
      return(1);
   case 14:
      act("$n sings 'Brave, brave Sir Patton...'", FALSE, ch, 0, 0,TO_ROOM);
      act("$n whistles a tune.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n smirks.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 15:
      do_say(ch, "Get Lurch to bring me over a case and I'll sport you a year's supply of grilled ogre.", 0, 0);
      return(1);
    default: return(FALSE);
                break; }
    return(0);
}



SPECIAL(stu)
{
  ACMD(do_say);
  ACMD(do_flee);
  if(cmd)
    return 0;

  switch (number(0, 60)) {
    case 0:
      do_say(ch, "I'm so damn cool, I'm too cool to hang out with myself!", 0, 0);
      break;
    case 1:
      do_say(ch, "I'm really the NICEST guy you ever MEET!", 0, 0);
      break;
    case 2:
      do_say(ch, "Follow me for exp, gold and lessons in ADVANCED C!", 0, 0);
      break;
    case 3:
      do_say(ch, "Mind if I upload 200 megs of pregnant XXX gifs with no descriptions to your bbs?", 0, 0);
      break;
    case 4:
      do_say(ch, "Sex? No way! I'd rather jog 20 miles!", 0, 0);
      break;
    case 5:
      do_say(ch, "I'll take you OUT!!   ...tomorrow", 0, 0);
      break;
    case 6:
      do_say(ch, "I invented Mud you know...", 0, 0);
      break;
    case 7:
      do_say(ch, "Can I have a cup of water?", 0, 0);
      break;
    case 8:
      do_say(ch, "I'll be jogging down ventnor ave in 10 minutes if you want some!", 0, 0);
      break;
    case 9:
      do_say(ch, "Just let me pull a few strings and I'll get ya a site, they love me! - doesnt everyone?", 0, 0);
      break;
    case 10:
      do_say(ch, "Pssst! Someone tell Mercy to sport me some levels.", 0, 0);
      act("$n nudges you with his elbow.", FALSE, ch, 0, 0,TO_ROOM);
      break;
    case 11:
      do_say(ch, "Edgar! Buddy! Let's group and hack some ogres to tiny quivering bits!", 0, 0);
      break;
    case 12:
      act("$n tells you, 'Skylar has bad taste in women!'", FALSE, ch, 0, 0,TO_ROOM);
      act("$n screams in terror!", FALSE, ch, 0, 0,TO_ROOM);
      do_flee(ch, 0, 0, 0);
      break;
    case 13:
      if (number(0, 32767)<10){
      act("$n whispers to you, 'Dude! If you fucking say 'argle bargle' to the glowing fido he'll raise you a level!'", FALSE, ch, 0, 0,TO_ROOM);
      act("$n flexes.", FALSE, ch, 0, 0,TO_ROOM);}
      return(1);
    default:
      return(FALSE);
      break;
   return(1);
  }
  return 0;
}


SPECIAL(sund_earl)
{
  ACMD(do_say);
  if (cmd)
    return(FALSE);
  switch (number(0, 20)) {
   case 0:
      do_say(ch, "Lovely weather today.", 0, 0);
      return(1);
   case 1:
    act("$n practices a lunge with an imaginary foe.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
   case 2:
      do_say(ch, "Hot performance at the gallows tonight.", 0, 0);
     act("$n winks suggestively.", FALSE, ch, 0, 0,TO_ROOM);
     return(1);
   case 3:
      do_say(ch, "Must remember to up the taxes at my convenience.", 0, 0);
      return(1);
   case 4:
      do_say(ch, "Sundhaven is impermeable to the enemy!", 0, 0);
      act("$n growls menacingly.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
 case 5:
      do_say(ch, "Decadence is the credence of the abominable.", 0, 0);
      return(1);
 case 6:
      do_say(ch, "I look at you and get a wonderful sense of impending doom.", 0, 0);
      act("$n chortles merrily.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
 case 7:
      act("$n touches his goatee ponderously.", FALSE, ch, 0, 0,TO_ROOM);
      return(1);
 case 8:
      do_say(ch, "It's Mexican Madness night at Maynards!", 0, 0);
      act("$n bounces around.", FALSE, ch, 0, 0, TO_ROOM);
      return(1);
    default: return(FALSE);
              break;
    return(0);
 }
}


SPECIAL(blinder)
{
  ACMD(do_say);

  if (cmd)
    return FALSE;

  if (GET_POS(ch) != POS_FIGHTING)
    return FALSE;

  if (FIGHTING(ch) && (FIGHTING(ch)->in_room == ch->in_room) &&
      (number(0, 100)+GET_LEVEL(ch) >= 100)) {
    act("$n whispers, 'So, $N! You wouldst share my affliction!", 1, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("$n whispers, 'So, $N! You wouldst share my affliction!", 1, ch, 0, FIGHTING(ch), TO_VICT);
    act("$n's frayed cloak blows as he points at $N.", 1, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("$n's frayed cloak blows as he aims a bony finger at you.", 1, ch, 0, FIGHTING(ch), TO_VICT);
    act("A flash of pale fire explodes in $N's face!", 1, ch, 0, FIGHTING(ch), TO_NOTVICT);
    act("A flash of pale fire explodes in your face!", 1, ch, 0, FIGHTING(ch), TO_VICT);
    call_magic(ch, FIGHTING(ch), 0, SPELL_BLINDNESS, GET_LEVEL(ch), CAST_SPELL);
    return TRUE;
  }
  return FALSE;
}


SPECIAL(idiot)
{
  ACMD(do_say);

if(cmd) return FALSE;
  switch (number(0, 40)) {
   case 0:
      do_say(ch, "even if idiot = god", 0, 0);
      do_say(ch, "and Stu = idiot", 0, 0);
      do_say(ch, "Stu could still not = god.", 0, 0);
      act("$n smiles.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 1:
      act("$n balances a newbie sword on his head.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 2:
      act("$n doesn't think you could stand up to him in a duel.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 3:
      do_say(ch, "Rome really was built in a day.", 0, 0);
      act("$n snickers.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 4:
      act("$n flips over and walks around on his hands.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 5:
      act("$n cartwheels around the room.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 6:
      do_say(ch, "How many ogres does it take to screw in a light bulb?", 0, 0);
      act("$n stops and whaps himself upside the head.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 7:
      do_say(ch, "Uh huh. Uh huh huh.", 0, 0);
      return TRUE;
   case 8:
      act("$n looks at you.", FALSE, ch, 0, 0,TO_ROOM);
      act("$n whistles quietly.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 9:
      act("$n taps out a tune on your forehead.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 10:
      act("$n has a battle of wits with himself and comes out unharmed.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 11:
      do_say(ch, "All this and I am just a number.", 0, 0);
      act("$n cries on your shoulder.", FALSE, ch, 0, 0,TO_ROOM);
      return TRUE;
   case 12:
      do_say(ch, "A certain hunchback I know dresses very similar to you, very similar...", 0, 0);
      return TRUE;
   default:
      return FALSE;
  }
 return FALSE;
}



/* ********************************************************************
*  Special procedures for objects                                     *
******************************************************************** */

SPECIAL(marbles)
{
  struct obj_data *tobj = me;

  if (tobj->in_room == NOWHERE)
    return 0;

  if (CMD_IS("north") || CMD_IS("south") || CMD_IS("east") || CMD_IS("west") ||
      CMD_IS("up") || CMD_IS("down")) {
    if (!AFF_FLAGGED(ch, AFF_FLY)){
     if (number(1, 100) - GET_DEX(ch) > 35) {
       act("You slip on $p and fall.", FALSE, ch, tobj, 0, TO_CHAR);
       act("$n slips on $p and falls.", FALSE, ch, tobj, 0, TO_ROOM);
       GET_POS(ch) = POS_SITTING;
       return 1;
     }
     else {
       act("You slip on $p, but manage to retain your balance.", FALSE, ch, tobj, 0, TO_CHAR);
       act("$n slips on $p, but manages to retain $s balance.", FALSE, ch, tobj, 0, TO_ROOM);
     }
    }
   }
  return 0;
}

SPECIAL(bank)
{
  int amount;

  if (CMD_IS("balance")) {
    if (GET_BANK_GOLD(ch) > 0)
      sprintf(buf, "Your current balance is %s coins.\r\n",
              add_points(GET_BANK_GOLD(ch)));
    else
      sprintf(buf, "You currently have no money deposited.\r\n");
    send_to_char(buf, ch);
    return 1;
  } else if (CMD_IS("deposit")) {
    if ((amount = atoi(argument)) <= 0) {
      send_to_char("How much do you want to deposit?\r\n", ch);
      return 1;
    }
    if (GET_GOLD(ch) < amount) {
      send_to_char("You don't have that many coins!\r\n", ch);
      return 1;
    }
    GET_GOLD(ch) -= amount;
    GET_BANK_GOLD(ch) += amount;
    sprintf(buf, "You deposit %s coins.\r\n", add_points(amount));
    send_to_char(buf, ch);
    act("$n makes a bank transaction.", TRUE, ch, 0, FALSE, TO_ROOM);
    return 1;
  } else if (CMD_IS("withdraw")) {
    if ((amount = atoi(argument)) <= 0) {
      send_to_char("How much do you want to withdraw?\r\n", ch);
      return 1;
    }
    if (GET_BANK_GOLD(ch) < amount) {
      send_to_char("You don't have that many coins deposited!\r\n", ch);
      return 1;
    }
    GET_GOLD(ch) += amount;
    GET_BANK_GOLD(ch) -= amount;
    sprintf(buf, "You withdraw %s coins.\r\n", add_points(amount));
    send_to_char(buf, ch);
    act("$n makes a bank transaction.", TRUE, ch, 0, FALSE, TO_ROOM);
    return 1;
  } else
    return 0;
}

static  char  *priest_strings[] =  {
    "$n says 'Buy HEAL from me in the name of the Gods.  Only 15000  coins!'",
    "$n says 'Live in the way of the Gods!'",
    "$n is blessed by the Gods.",
    "$n says 'Buy STRENGTH from me in the name of the Gods. Only 10000 coins!'",
    "$n says 'Buy SANCTUARY from me in the name of the Gods. Only 20000 coins!'",
    "$n looks around for customers.",
    "$n says 'Buy CURE from me in the name of the Gods.  Only 5000 coins!'",
    "$n says 'Buy MANA in the name of the Gods.  Only 15000 coins!'",
    "$n smiles happily.",
    "$n says 'Buy MOVE from me in the name of the Gods. Only 15000 coins!'",
    "$n says 'Buy RESTORE from me in the name of the Gods. Only 5000 coins per level!'",
    "$n says 'Type 'list' and find out how I may help you!'",
    "$n says 'Buy ARMOR from me in the name of the Gods. Only 7500 coins!'",
    "$n says 'Buy BLESS from me in the name of the Gods. Only 10000 coins!'",
    "$n looks compassionately at the unfaithful godless mortals."
};


SPECIAL(priest)
{
  struct char_data *vict;
  struct char_data *hitme = NULL;
  static int this_hour;
  float temp1 = 1;
  float temp2 = 1;
  struct char_data *self;

  self=(struct char_data *)me;


    if (CMD_IS("list")) {
      if (!AWAKE(ch)){
	return(0);
      }
      else {
       send_to_char("&gCommand     &YCost(Gold)   &REffect              &n\n\r", ch);
       send_to_char("&G=======     ==========   ==================  &n\n\r", ch);
       send_to_char("&g cure       &Y   5000     &R   Small Cure        &n\n\r", ch);
       send_to_char("&g armor      &Y   7500     &R   -20 AC            &n\n\r", ch);
       send_to_char("&g bless      &Y  10000     &R   +5 Hitroll         &n\n\r", ch);
       send_to_char("&g strength   &Y  10000     &R   +2 STR            &n\n\r", ch);
       send_to_char("&g move       &Y  15000     &R   100-120 Mv        &n\n\r", ch);
       send_to_char("&g mana       &Y  15000     &R   100-120 Mn	&n\n\r", ch);
       send_to_char("&g heal       &Y  15000     &R   100-120 Hp        &n\n\r", ch);
       send_to_char("&g sanctuary  &Y  20000     &R   Damage reduction  &n\n\r", ch);
       send_to_char("&g restore   &Y5000 per level&R  Full Hp/Mn/Mv     &n\n\r", ch);
       send_to_char("\n\r", ch);
       send_to_char("&BTo buy effect, type:&n\n\r", ch);
       send_to_char("&Cbuy <Command>&n\n\r", ch);
       send_to_char("&CExample: buy cure&n\n\r", ch);
       return 1;
      }
    }

    if (CMD_IS("buy")) {

     skip_spaces(&argument);

     if (!AWAKE(ch)) {
	return(0);
     }
     else {
	if (!strcmp(argument, "heal")) {
	    if (GET_GOLD(ch) >= 15000) {
		GET_GOLD(ch) -= 15000;
		GET_HIT(ch) += number(100, 120);
		if (GET_HIT(ch) > GET_MAX_HIT(ch))
		    GET_HIT(ch) = GET_MAX_HIT(ch);
		send_to_char("You have been healed by the Priest!\n\r", ch);
		act("$n has been healed by the Priest.\n\r", TRUE, ch, 0, 0, TO_ROOM);
	    } else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "mana")) {
	    if (GET_GOLD(ch) >= 15000) {
		GET_GOLD(ch) -= 15000;
		GET_MANA(ch) += number(100, 120);
		if (GET_MANA(ch) > GET_MAX_MANA(ch))
		    GET_MANA(ch) = GET_MAX_MANA(ch);
		send_to_char("You have been vitalized by the Priest!\n\r", ch);
		act("$n has been vitalized by the Priest.", TRUE, ch, 0, 0, TO_ROOM);
	    } else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "armor")) {
	    if (GET_GOLD(ch) >= 7500) {
		GET_GOLD(ch) -= 7500;
		cast_spell(self, ch, NULL, SPELL_ARMOR);
	    }
	    else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "bless")) {
	    if (GET_GOLD(ch) >= 10000) {
		GET_GOLD(ch) -= 10000;
		cast_spell(self, ch, NULL, SPELL_BLESS);
	    }
	    else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "sanctuary")) {
	    if (GET_GOLD(ch) >= 20000) {
		GET_GOLD(ch) -= 20000;
		cast_spell(self, ch, NULL, SPELL_SANCTUARY);
	    }
	    else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "strength")) {
	    if (GET_GOLD(ch) >= 10000) {
		GET_GOLD(ch) -= 10000;
		cast_spell(self, ch, NULL, SPELL_STRENGTH);
	    }
	    else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "cure")) {
	    if (GET_GOLD(ch) >= 5000) {
		GET_GOLD(ch) -= 5000;
		if (affected_by_spell(ch, SPELL_POISON))
		    affect_from_char(ch, SPELL_POISON);
		if (affected_by_spell(ch, SPELL_CURSE))
		    affect_from_char(ch, SPELL_CURSE);
                if (affected_by_spell(ch, SPELL_BLINDNESS))
                    affect_from_char(ch, SPELL_BLINDNESS);
		send_to_char("You have been cured by the Priest!\n\r", ch);
		act("$n has been cured by the Priest.", TRUE, ch, 0, 0, TO_ROOM);
	    }
	    else {
	        send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "move")) {
	    if (GET_GOLD(ch) >= 15000){
		GET_GOLD(ch) -= 15000;
		GET_MOVE(ch) += number(100,120);
		if (GET_MOVE(ch) > GET_MAX_MOVE(ch))
		    GET_MOVE(ch) = GET_MAX_MOVE(ch);
		send_to_char("You have been refreshed by the priest!\n\r", ch);
		act("$n has been refreshed by the priest.", TRUE, ch, 0,0,TO_ROOM);
	    } else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else if (!strcmp(argument, "restore")){
	    if (GET_GOLD(ch) >= (5000*GET_LEVEL(ch))){
		GET_GOLD(ch) -= (5000*GET_LEVEL(ch));
		GET_HIT(ch) = GET_MAX_HIT(ch);
		GET_MANA(ch) = GET_MAX_MANA(ch);
		GET_MOVE(ch) = GET_MAX_MOVE(ch);
		send_to_char("You have ben fully restored by the priest !!\n\r", ch);
		act("$n has been fully restored by the priest.", TRUE, ch, 0,0, TO_ROOM);
	    }
	    else {
		send_to_char("The Priest tells you 'You don't have enough money, Sorry!'\n\r", ch);
	    }
	    return 1;
	} else {
	    send_to_char("The Priest tells you 'Sorry, buy WHAT?'\n\r", ch);
	}

	return 1;
      }
    }

    if (!cmd) {
    	if (time_info.hours != this_hour) {

          this_hour = time_info.hours;

          temp2 = 1;
          hitme = NULL;
          for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
          {
           if ((GET_LEVEL(vict) < LVL_IMMORT) && (!IS_NPC(vict))){
             temp1 = GET_HIT(vict) / GET_MAX_HIT(vict);
             if (temp1 < temp2) {
              temp2 = temp1;
              hitme = vict;
             }
           }
         }

         vict = hitme;

         if (hitme != NULL) {

          if(!IS_NPC(vict) && GET_LEVEL(vict) <= 40){
            if (hitme != NULL) {
              cast_spell(self, hitme, NULL, SPELL_CURE_LIGHT);
              return 1;
            }
          }
          if(!IS_NPC(vict) && GET_LEVEL(vict) <= 110){
            if (hitme != NULL) {
             cast_spell(self, hitme, NULL, SPELL_CURE_CRITIC);
             return 1;
            }
          }
          if(!IS_NPC(vict) && GET_LEVEL(vict) <= 200){
            if (hitme != NULL) {
              cast_spell(self, hitme, NULL, SPELL_HEAL);
              return 1;
            }
          }
          if(!IS_NPC(vict) && GET_LEVEL(vict) > 200){
            if (hitme != NULL) {
              return 1;
            }
          }
         }
       }

	if (!number(0, 10)) {
	    act(priest_strings[number(0,14)], FALSE, ch, 0, 0, TO_ROOM);
	    return(1);
	}
    }

    return 0;
}


SPECIAL(priest_healer)
{
  struct char_data *vict;
  struct char_data *hitme = NULL;
  static int this_hour;
  float temp1 = 1;
  float temp2 = 1;

if (cmd) return FALSE;

if (time_info.hours != this_hour) {

  this_hour = time_info.hours;

  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
    {
       temp1 = GET_HIT(vict) / GET_MAX_HIT(vict);
       if (temp1 < temp2) {
             temp2 = temp1;
             hitme = vict;
            }
    }

    vict = world[ch->in_room].people;

    if(!IS_NPC(vict) && GET_LEVEL(vict) <= 50){
       if (hitme != NULL) {
             cast_spell(ch, hitme, NULL, SPELL_CURE_LIGHT);
             return 1;
            }
    }
    if(!IS_NPC(vict) && GET_LEVEL(vict) <= 75){
       if (hitme != NULL) {
             cast_spell(ch, hitme, NULL, SPELL_CURE_CRITIC);
             return 1;
            }
    }
    if(!IS_NPC(vict) && GET_LEVEL(vict) <= 200){
       if (hitme != NULL) {
             cast_spell(ch, hitme, NULL, SPELL_HEAL);
             return 1;
            }
    }

  }
  return 0;
}

#define MSG_BS \
"THE BLACKSMITH\r\n" \
"You can talk to the blackmisth to his forge\r\n" \
"this items. Type FORGE <field> to him create that...\r\n" \
"\r\n" \
"You can buy the following weapons:\r\n" \
"  Field          Cost\r\n" \
"  -----------    ------------------------\r\n" \
"  Fire Sword     %2d points and %5s gold\r\n" \
"  Ice Sword      %2d points and %5s gold\r\n" \
"  Light Sword    %2d points and %5s gold\r\n" \
"\r\n" \

SPECIAL(blacksmith)
{
  struct obj_data *obj;

                    /*         Fw          Iw          Lw   */
  const int costs[] = {      1000,        850,        650 };
  const int money[] = { 100000000,  100000000,  100000000 };
  int mode;

  if (IS_NPC(ch) || !CMD_IS("forge"))
    return 0;

  skip_spaces(&argument);

  if (!*argument) { /* no argument, just display the options. */
    sprintf(buf, MSG_BS, costs[0], add_points(money[0]), costs[1], add_points(money[1]),
                          costs[2], add_points(money[2]));
    send_to_char(buf, ch);
    return 1;
  }

  if (!strcmp(argument, "fire weapon") || !strcmp(argument, "fw"))
    mode = 0;
  else if (!strcmp(argument, "ice weapon") || !strcmp(argument, "iw"))
    mode = 1;
  else if (!strcmp(argument, "light weapon") || !strcmp(argument, "lw"))
    mode = 2;
  else {
    send_to_char("Invalid weapon to forge.\r\n", ch);
    return 1;
  }

  if (GET_POINTS(ch) < costs[mode]) {
    send_to_char("You don't have enough points!\r\n", ch);
    return 1;
  }
  if (GET_GOLD(ch) < money[mode]) {
    send_to_char("You don't have enough money!\r\n", ch);
    return 1;
  }

  switch (mode) {
    case 0: /* fire sword */
      obj = read_object(1230, VIRTUAL);
      obj_to_char(obj, ch);
      send_to_char("The Blacksmith forges your weapon...\r\n", ch);
      break;
    case 1: /* ice sword */
      obj = read_object(1231, VIRTUAL);
      obj_to_char(obj, ch);
      send_to_char("The Blacksmith forges your weapon...\r\n", ch);
      break;
    case 2: /* light sword */
      obj = read_object(1233, VIRTUAL);
      obj_to_char(obj, ch);
      send_to_char("The Blacksmith forges your weapon...\r\n", ch);
      break;
  }
  GET_POINTS(ch) -= costs[mode];
  GET_GOLD(ch) -= money[mode];

  act("The blacksmith makes a weapon to $n.", TRUE, ch, 0, FALSE, TO_ROOM);
  return 1;
}

SPECIAL(icewizard)
{

  struct char_data *tch;
  int low_on_hits = 10000;

  if (cmd)
    return (FALSE);

  /* Find out who has the lowest hitpoints and burn his ass off */
  for (tch = world[ch->in_room].people; tch; tch = tch->next_in_room){
    if (!IS_NPC(tch))
      if (tch->points.hit < low_on_hits){
	low_on_hits = tch->points.hit;
      }
  }

  act("$n screams 'Bonjour! you tiny, little looser!!'", FALSE, ch, 0, 0, TO_ROOM);
  act("$n looks at $N", 1, ch, 0, tch, TO_NOTVICT);
  act("$n looks at YOU!", 1, ch, 0, tch, TO_VICT);
  cast_spell(ch, tch, 0, SPELL_FIREBALL);
  return TRUE;
}

SPECIAL(preparation_room)
{
  struct char_data *vict;

  if (cmd)
   return FALSE;

  for (vict = world[ch->in_room].people; vict; vict = vict->next_in_room)
   {
    if(!IS_NPC(vict)){

     if(PRF_FLAGGED(vict, PRF_INFO_START))
        return FALSE;

     if(GET_REMORT(vict) == 0 && GET_LEVEL(vict) == 1)
     {
        send_to_char("The Wardome talk to you, 'I will teleport you to the Mud School...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(26600));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_GORAK && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Goraks...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(511));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_SEA_ELF && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of the Seal Elfs...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(512));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_ELF && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Elfs...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(513));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_ORC && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Orcs...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(514));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_TROLL && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Trolls...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(515));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_VAMPIRE && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Humans...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(516));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_DROW && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Drows...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(517));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_DWARF && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Dwarfs...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(518));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_LIZARDMAN && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Lizardmans...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(519));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_OGRE && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Ogres...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(520));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_GITH && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Giths...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(521));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict) == RACE_GNOME && GET_LEVEL(vict) < LVL_IMMORT){
        send_to_char("The Wardome talk to you, 'I will teleport you to the Temple of Gnomes...'\r\n\r\n", vict);
	char_from_room(vict);
	char_to_room(vict, real_room(522));
	look_at_room(vict, 0);
	return 1;
     }
     if(GET_RACE(vict)  > 11) {  // Racas avancadas
        char_from_room(vict);
        char_to_room(vict, real_room(567));
        look_at_room(vict, 0);
        return 1;
     }
    }
   }
  return 0;
}
#define MSG_ARENA \
"&RThe Wardome&n\r\n" \
"\r\n" \
"&nHere you can open and enjoy de &RWAR&n.\r\n" \
"&WUsage: &Rwardome now&n\r\n" \
"\r\n"

extern int lo_rem;
extern int hi_rem;

SPECIAL(wardome)
{
  extern long arena_pot;

  if (IS_NPC(ch) || !CMD_IS("wardome"))
    return 0;

  if (!*argument) { /* no argument, just display the options. */
    sprintf(buf, MSG_ARENA);
    send_to_char(buf, ch);
    return 1;
  }

  half_chop(argument, buf1, buf2);

  if (in_arena != ARENA_OFF) {
	send_to_char("There is a &BWAR&n running already.\r\n", ch);
	return 1;
  }

	if (!is_number(buf1) || !is_number(buf2))
	{
		send_to_char("Write a remort number please.\r\n", ch);
		return 1;
	}

	lo_rem = atoi(buf1);
	hi_rem = atoi(buf2);

	if(lo_rem > hi_rem)
	{
		send_to_char("Setup the correct remort please.\r\n", ch);
		return 1;
	}

  in_arena = ARENA_START;
  time_to_start = start_time = 5;
  time_left_in_game = 99;
  arena_pot = 0;
  game_length = 99;
  lo_lim = MAX(1, GET_LEVEL(ch) - 15);
  hi_lim = MIN(200, GET_LEVEL(ch) + 15);
  cost_per_lev = 1000;
  start_arena();

  return 1;
}

struct quest_eqs *eqs_quest;
extern int top_qeq_table;
extern struct player_index_element *player_table;
extern struct obj_data *obj_proto;
int find_name(char *name);
char *complete_char(char *string, int num);
void save_qeq_file(void);

SPECIAL(questshop)
{
	struct obj_data *obj;
	obj_rnum r_num;
	int i = 0;

	if (IS_NPC(ch))
		return 0;

	if(CMD_IS("list"))
	{
		strcpy(buf, "&cEquipamentos para Aventureiros, somente itens &Cunicos&c.&n\r\n"
					"&CObjeto&c----------------------------- --- &CPreco &c--------------- &CDono&n\r\n");
		for(i = 0; i < top_qeq_table; i++)
		{
			r_num = real_object(eqs_quest[i].vnum_eq);
			sprintf(buf + strlen(buf), "%s &G%9d &R%20s&n\r\n", complete_char(reprimir(obj_proto[r_num].short_description, 35+(2*conta_cores(obj_proto[r_num].short_description))), 35),
					eqs_quest[i].preco_eq, (eqs_quest[i].dono == 0 ? "Disponivel" : get_name_by_id(eqs_quest[i].dono)));
		}
		send_to_char(buf, ch);
		return 1;
	}
	else if(CMD_IS("buy"))
	{
		if(!*argument)
			return 0;

		for(i = 0; i < top_qeq_table; i++)
		{
			r_num = real_object(eqs_quest[i].vnum_eq);
			if(isname(argument, obj_proto[r_num].name))
			{
				if(eqs_quest[i].dono > 0)
				{
					send_to_char("Este equipamento ja' possui dono.\r\n", ch);
					return 1;
				}
				if(eqs_quest[i].preco_eq > GET_QP(ch))
				{
					send_to_char("Voce nao possui QP suficiente para efetuar a compra.\r\n", ch);
					return 1;
				}
				eqs_quest[i].dono = player_table[find_name(GET_NAME(ch))].id;
				save_qeq_file();

				GET_QP(ch) -= eqs_quest[i].preco_eq;
				obj = read_object(r_num, REAL);
				obj_to_char(obj, ch);
				send_to_char("Negocio fechado. Tenha boas aventuras!\r\n", ch);
				save_char(ch, ch->in_room);
				return 1;
			}
		}
		send_to_char("Nao possuo esse equipamento.\r\n", ch);
		return 1;
	}
	return 0;
}

SPECIAL(black_dragon) // mob numero 3097
{
  struct char_data *vict;

  if (cmd || GET_POS(ch) != POS_FIGHTING)
    return (0);

  vict = FIGHTING(ch);
  if (vict == NULL || (ch->in_room != vict->in_room))
   return (1);                           // para evitar bugs

  damage(ch,vict,number(500,1000),505);  // dragao faz de 500 a 1000 de dano

  vict = FIGHTING(ch);
  if (vict == NULL || (ch->in_room != vict->in_room))
   return (1) ;

  damage(ch,vict,number(500,1000),505); // novamente dragao faz de 500 a 1000 de dano

  return(1);
}

SPECIAL(black_monster) // mob numero 3098
{
  struct char_data *vict;
  int x = 0 ;

  if (cmd || GET_POS(ch) != POS_FIGHTING)
    return (0);

  for (vict = world[real_room(3001)].people; vict; vict = vict->next_in_room)
  {
   if (GET_MOB_VNUM(vict) == 3097)
   {
    x = 1  ;
    break ;
   }
  }

  if(x == 1)
  {
   GET_HIT(ch) = GET_MAX_HIT(ch);
   send_to_room("Black Monster says : I AM INVINCIBLE, INVINCIBLE I SAY!!!!\r\n", ch->in_room);
  }
  else
   send_to_room("Black Monster says : WHAT!! I AM HURT?!\r\n", ch->in_room);

  return (1) ;

}


SPECIAL(helms_guard)//10
{
  if (CMD_IS("north")) {
	  if ((GET_LEVEL(ch) < LVL_ELDER) && (GET_CLAN(ch) != 3)) {
		  send_to_char("You cannot pass here, only &YH&welm&Y'&ws &YD&weep&n can enter.\r\n", ch);
		  return 1;
	  }
  }
  return 0;
}

SPECIAL(army_guard)//7
{
  if (CMD_IS("north")) {
	  if ((GET_LEVEL(ch) < LVL_ELDER) && (GET_CLAN(ch) != 2)) {
		  send_to_char("Only members of &RA&rrmy &cof &BI&bmmortals&n clan may pass here!\r\n", ch);
		  return 1;
	  }
  }
  return 0;
}

SPECIAL(purple_dragons_guard)
{
  if (CMD_IS("north")) {
	  if ((GET_LEVEL(ch) < LVL_ELDER) && (GET_CLAN(ch) != 5)) {
		  send_to_char("You cannot pass here, only &MP&murple &BD&bragons&n can enter.\r\n", ch);
		  return 1;
	  }
  }
  return 0;
}
SPECIAL(sith_guard)//8
{
	if (CMD_IS("north")) {
	  if ((GET_LEVEL(ch) < LVL_ELDER) && (GET_CLAN(ch) != 1)) {
		  send_to_char("You cannot pass here, only &wS&Ri&wt&Rh'&ws &rmembers can enter.\r\n", ch);
		  return 1;
	  }
  }
  return 0;
}

SPECIAL(night_guard)
{
  if (CMD_IS("north"))
  {
	   if ((GET_LEVEL(ch) < LVL_ELDER) && (GET_CLAN(ch) != 6))
	   {
	    send_to_char("You cannot pass here, only &wN&Bi&wg&Bh&wt &RCre&ratu&Rres&n can enter.\r\n", ch);
	    return 1;
	   }
  }
  return 0;
}

#define MSG_RB \
"                        &w- &BWardome &YREBORN &BSystem &w-&n\r\n" \
"With the Powers of Gods here you can upgrade your race reborning \r\n" \
"a new powerfull race. To do This type REBORN <Cap. Letter of Race> or <Name of Race>:\r\n" \
"&w- &RATENTION &w- &wYou Can't change your race, just evoluate the actual.\r\n" \
"\r\n"\
"&b #&y Race        &b Remorts &y Add Attribs&b (*)         &yCost\r\n" \
"&b -&y ---------   &b --------&y -----------&b ---------   &y---------------\r\n" \
"&B A&Y Dunedain    &B R11     &Y +2str,+2wiz &B Hero's Presence &Y %7s gold\r\n" \
"&B B&Y Ancient Drow&B R6      &Y +2wis,+2dex &B  Magic Resistence &Y %7s gold\r\n" \
"&B C&Y Naugrim     &B R3      &Y +2con,+2str &B Super Endurance &Y %7s gold\r\n" \
"&B D&Y High-Elf    &B R6      &Y +2wis,+dex,+2cha &B 2-effect magic &Y %7s gold\r\n" \
"&B E&Y Hill Ogre   &B R3      &Y +2str,+con,+dex &B Extra Damage&Y %7s gold\r\n" \
"&B F&Y Bugbear     &B R3      &Y +str,+con,+2dex &B Super Stamina&Y %7s gold\r\n" \
"&B G&Y Cave Troll  &B R3      &Y +str,+2con,+dex &B Regeneration&Y %7s gold\r\n" \
"&B H&Y Lich        &B R5      &Y +2int,+2con &B Power magic damage &Y %7s gold\r\n" \
"&B I&Y Tinker      &B R3      &Y +2wis,+2con &B Extra MP Regeneration  &Y %7s gold\r\n" \
"&B J&Y Draconian   &B R3      &Y +2str,+4cha &B Secret :)          &Y %7s gold\r\n" \
"&B L&Y High Sea Elf&B R3      &Y +2str,+2int &B Extra summon&Y %7s gold\r\n" \
"&B M&Y Archons     &B R3      &Y +2dex,+2int &B Extra curative power &Y %7s gold&n\r\n" \
"\r\n" \


int aceita_ra(int num1, int mode)
{
  switch (num1)
 {
      case  999:  // lawful good
        if(mode == 1) return 1 ;
        if(mode == 2) return 1 ;
        if(mode == 4) return 1 ;
        return 0 ;
      case  1000:
        if(mode == 1) return 1 ;
        if(mode == 2) return 1 ;
        if(mode == 3) return 1 ;
        return 0 ;
      case  994:
        if(mode == 2) return 1 ;
        if(mode == 3) return 1 ;
        if(mode == 6) return 1 ;
        return 0 ;
      case  3:
        if(mode == 1) return 1 ;
        if(mode == 4) return 1 ;
        if(mode == 7) return 1 ;
        return 0 ;
      case  5:
     if(mode == 4) return 1 ;
        if(mode == 5) return 1 ;
        if(mode == 6) return 1 ;
        return 0 ;
      case  7:
        if(mode == 3) return 1 ;
        if(mode == 6) return 1 ;
        if(mode == 9) return 1 ;
        return 0 ;
      case  -999:
       if(mode == 4) return 1 ;
        if(mode == 7) return 1 ;
        if(mode == 8) return 1 ;
        return 0 ;
      case  -1000:
        if(mode == 7) return 1 ;
        if(mode == 8) return 1 ;
        if(mode == 9) return 1 ;
        return 0 ;
      case  -994:
        if(mode == 6) return 1 ;
        if(mode == 8) return 1 ;
        if(mode == 9) return 1 ;
        return 0 ;
  }
 return 0 ;
}



SPECIAL(religiao)
{
  int mode ;

  if (IS_NPC(ch) || !CMD_IS("religion"))
    return 0;

  skip_spaces(&argument);

  if (!*argument)
  {
   send_to_char("Type religion 0/1/2/3/4/5/6/7/8.\r\n", ch) ;
   return 1 ;
  }


  if (!strcmp(argument, "0")) mode = 0;
  else if (!strcmp(argument, "1")) mode = 1 ;
  else if (!strcmp(argument, "2")) mode = 2;
  else if (!strcmp(argument, "3")) mode = 3;
  else if (!strcmp(argument, "4")) mode = 4;
  else if (!strcmp(argument, "5")) mode = 5;
  else if (!strcmp(argument, "6")) mode = 6;
  else if (!strcmp(argument, "7")) mode = 7;
  else if (!strcmp(argument, "8")) mode = 8;
  else {
    send_to_char("Invalid religion.\r\n", ch);
    return 1;
  }


  if((GET_CON(ch) < 7) && (GET_DEX(ch) < 7))
  {
   send_to_char("You are too weak.\r\n", ch) ;
   return 1;
  }

  if(!aceita_ra(GET_ALIGNMENT(ch), (mode+1)))
  {
     send_to_char("This God will not accept you.\r\n", ch) ;
     return 1 ;
  }


  if((GET_LEVEL(ch) + (GET_REMORT(ch) * 100)) > 100)
  {
   ch->real_abils.con -=4;
   ch->real_abils.dex -=4;
   save_char(ch, NOWHERE);
  }




  switch (mode)
 {
      case  0:
        GET_RELIGION(ch) = 1 ;
        send_to_char("You are now a Justice Guardian of Muir.\r\n", ch) ;
        break ;
      case  1:
        GET_RELIGION(ch) = 2 ;
        send_to_char("You are now a Pain Bearer of Ilmanateur.\r\n", ch) ;
        break ;
      case  2:
        GET_RELIGION(ch) = 3 ;
        send_to_char("You are now a Moon Blade of Selune.\r\n", ch) ;
        break ;
      case  3:
        GET_RELIGION(ch) = 4 ;
        send_to_char("You are now a Law Keeper of Helm.\r\n", ch) ;
        break ;
      case  4:
        GET_RELIGION(ch) = 5 ;
        send_to_char("You are now a Wisdom Seeker of Ohgma.\r\n", ch) ;
        break ;
      case  5:
        GET_RELIGION(ch) = 6 ;
        send_to_char("You are now a Battle Guard of Tempus.\r\n", ch) ;
        break ;
      case  6:
        GET_RELIGION(ch) = 7 ;
        send_to_char("You are now Dread Master of Bane.\r\n", ch) ;
        break ;
      case  7:
        GET_RELIGION(ch) = 8 ;
        send_to_char("You are now a Killer Rose of Pandora.\r\n", ch) ;
        break ;
      case  8:
        GET_RELIGION(ch) = 9 ;
        send_to_char("You are now a Storm Lord of Talos.\r\n", ch) ;
        break ;
  }
 return 1 ;
}




SPECIAL(alinhamento)
{
  int mode ;

  if (IS_NPC(ch) || !CMD_IS("alignment"))
    return 0;

  skip_spaces(&argument);

  if (!*argument)
  {
   send_to_char("Type alignment 0/1/2/3/4/5/6/7/8.\r\n", ch) ;
   return 1 ;
  }


  if (!strcmp(argument, "0")) mode = 0;
  else if (!strcmp(argument, "1")) mode = 1 ;
  else if (!strcmp(argument, "2")) mode = 2;
  else if (!strcmp(argument, "3")) mode = 3;
  else if (!strcmp(argument, "4")) mode = 4;
  else if (!strcmp(argument, "5")) mode = 5;
  else if (!strcmp(argument, "6")) mode = 6;
  else if (!strcmp(argument, "7")) mode = 7;
  else if (!strcmp(argument, "8")) mode = 8;
  else {
    send_to_char("Invalid alignment.\r\n", ch);
    return 1;
  }

  if((GET_CHA(ch) < 5) || (GET_WIS(ch) < 5) || (GET_INT(ch) < 5))
  {
   send_to_char("You are too weak.\r\n", ch) ;
   return 1;
  }

  if((GET_LEVEL(ch) + (GET_REMORT(ch) * 100)) > 100)
  {
   ch->real_abils.cha -=2;
   ch->real_abils.intel -=2;
   ch->real_abils.wis -=2;
   save_char(ch, NOWHERE);
  }
 

  switch (mode)
 {
      case  0:
	GET_ALIGNMENT(ch) = 999 ;
        send_to_char("You are lawful good now.\r\n", ch) ;
        break ;
      case  1:
	GET_ALIGNMENT(ch) = 1000 ;
        send_to_char("You are neutral good now.\r\n", ch) ;
        break ;
      case  2:
	GET_ALIGNMENT(ch) = 994 ;
        send_to_char("You are chaotic good now.\r\n", ch) ;
        break ;
      case  3:
	GET_ALIGNMENT(ch) = 3 ;
        send_to_char("You are lawful neutral now.\r\n", ch) ;
        break ;
      case  4:
	GET_ALIGNMENT(ch) = 5 ;
        send_to_char("You are true neutral now.\r\n", ch) ;
        break ;
      case  5:
	GET_ALIGNMENT(ch) = 7 ;
        send_to_char("You are chaotic neutral now.\r\n", ch) ;
        break ;
      case  6:
	GET_ALIGNMENT(ch) = -999 ;
        send_to_char("You are lawful evil now.\r\n", ch) ;
        break ;
      case  7:
	GET_ALIGNMENT(ch) = -1000 ;
        send_to_char("You are neutral evil now.\r\n", ch) ;
        break ;
      case  8:
	GET_ALIGNMENT(ch) = -994 ;
        send_to_char("You are chaotic evil  now.\r\n", ch) ;
        break ;
 }
 return 1 ;
}


SPECIAL(reborn)
{

                      /* 1        2           3         4        5        6         7           8       9         10        11       12  */
const int money[] = { 5000000,
                      7000000,
                      7000000,
                      7000000,
                      7000000,
                      7000000,
                     12000000,
                      7000000,
                      7000000,
                      7000000,
                      7000000,
                      7000000};


  int mode;

  if (IS_NPC(ch) || !CMD_IS("reborn"))
    return 0;

  skip_spaces(&argument);

  if (!*argument) { /* no argument, just display the options. */
    sprintf(buf, MSG_RB,  add_points(money[0]),
                          add_points(money[1]),
                          add_points(money[2]),
                          add_points(money[3]),
                          add_points(money[4]),
                          add_points(money[5]),
                          add_points(money[6]),
                          add_points(money[7]),
                          add_points(money[8]),
                          add_points(money[9]),
                          add_points(money[10]),
                          add_points(money[11]));
    send_to_char(buf, ch);
    return 1;
  }

  if (!strcmp(argument, "A") || !strcmp(argument, "dunedain"))mode = 0;
  else if (!strcmp(argument, "B") || !strcmp(argument, "ancient drow "))mode = 1;
  else if (!strcmp(argument, "C") || !strcmp(argument, "naugrim"))mode = 2;
  else if (!strcmp(argument, "D") || !strcmp(argument, "high elf "))mode = 3;
  else if (!strcmp(argument, "E") || !strcmp(argument, "hill ogre"))mode = 4;
  else if (!strcmp(argument, "F") || !strcmp(argument, "bugbear"))mode = 5;
  else if (!strcmp(argument, "G") || !strcmp(argument, "cave troll"))mode = 6;
  else if (!strcmp(argument, "H") || !strcmp(argument, "lich "))mode = 7;
  else if (!strcmp(argument, "I") || !strcmp(argument, "tinker "))mode = 8;
  else if (!strcmp(argument, "J") || !strcmp(argument, "draconian "))mode = 9;
  else if (!strcmp(argument, "L") || !strcmp(argument, "high sea elf "))mode = 10;
  else if (!strcmp(argument, "M") || !strcmp(argument, "archons"))mode = 11;
  else {
    send_to_char("Invalid Race to Reborn.\r\n", ch);
    return 1;
  }

  if (GET_GOLD(ch) < money[mode]) {
    send_to_char("You don't have enough money!\r\n", ch);
    return 1;
  }
  if (GET_LEVEL(ch) < 200) {
    send_to_char("This isn't level to Remort!\r\n", ch);
}

  switch (mode) {
    case 0: /* human */

      if (GET_REMORT(ch) < 11){
      	send_to_char("You don't have the necessary remort\r\n", ch);

      } else if (GET_RACE(ch) != RACE_VAMPIRE) {
      	send_to_char("You don't have the necessary race\r\n", ch);

      }	else {
      GET_RACE(ch) =RACE_DUNEDAIN;
      ch->real_abils.str +=2;
      ch->real_abils.wis +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yDUNEDAIN&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
    case 1: /* drow*/
         if (GET_REMORT(ch) < 6){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_DROW) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_ANCI_DROW;
      ch->real_abils.wis +=2;
      ch->real_abils.dex +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yANCIENT DROW&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
    case 2: /* anao */
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_DWARF) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_NAUGRIM;
      ch->real_abils.con +=2;
      ch->real_abils.str +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yNAUGRIM&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
   case 3: /* elf */
        if (GET_REMORT(ch) < 6){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_ELF) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_HIGH_ELF;
      ch->real_abils.dex +=1;
      ch->real_abils.wis +=2;
      ch->real_abils.cha +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yHIGH ELF&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
    case 4: /* Ogro */
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_OGRE) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_HILL_OGRE;
      ch->real_abils.str +=2;
      ch->real_abils.con +=1;
      ch->real_abils.dex +=1;
      send_to_char("&BYou have &YREBORNED&B into a &yHILL OGRE&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
       case 5: /* orc */
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_ORC) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_BUGBEAR;
      ch->real_abils.str +=1;
      ch->real_abils.con +=1;
      ch->real_abils.dex +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yBUGBEAR&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
       case 6: /* troll */
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_TROLL) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_CAVE_TROLL;
      ch->real_abils.str +=1;
      ch->real_abils.dex +=1;
      ch->real_abils.con +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yCAVE TROLL&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
        if (GET_REMORT(ch) < 5){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_GITH) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_LICH;
      ch->real_abils.intel +=2;
      ch->real_abils.con +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yLICH&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
       case 8: /* gnome */
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_GNOME) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_TINKER;
      ch->real_abils.wis +=2;
      ch->real_abils.con +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yTinker&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
       case 9: /* lizardman*/
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_LIZARDMAN) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_DRACONIAN;
      ch->real_abils.str +=2;
      ch->real_abils.cha +=4;
      send_to_char("&BYou have &YREBORNED&B into a &yDRACONIAN&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
       case 10: /* sea Elf */
         if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_SEA_ELF) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_H_SEA_ELF;
      ch->real_abils.str +=2;
      ch->real_abils.intel +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yHIGH SEA ELF&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
     case 11: /* Gorak */
        if (GET_REMORT(ch) < 3){
      	send_to_char("You don't have the necessary remort\r\n", ch);
      } else if (GET_RACE(ch) != RACE_GORAK) {
      	send_to_char("You don't have the necessary race\r\n", ch);
      }	else {
      GET_RACE(ch) =RACE_ARCHONS;
      ch->real_abils.intel +=2;
      ch->real_abils.dex +=2;
      send_to_char("&BYou have &YREBORNED&B into a &yARCHONS&n\r\n", ch);
      GET_GOLD(ch) -= money[mode];
      }
      save_char(ch, NOWHERE);
      break;
  }

  act("The Wardome Gods Reborn $n.", TRUE, ch, 0, FALSE, TO_ROOM);
  return 1;
}

SPECIAL(random_room)
{
  int num = number(1,8);
  if (IS_NPC(ch) ||(!CMD_IS("north") && !CMD_IS("south") && !CMD_IS("east") &&!CMD_IS("west")))
    return 0;
  switch(num)
 {
  case 1 : num = 2701 ; break ;
  case 2 : num = 2702 ; break ;
  case 3 : num = 2703 ; break ;
  case 4 : num = 2705 ; break ;
  case 5 : num = 2707 ; break ;
  case 6 : num = 2708 ; break ;
  case 7 : num = 2710 ; break ;
  case 8 : num = 2712 ; break ;
 }
  char_from_room(ch);
  char_to_room(ch, real_room(num));
  look_at_room(ch, 0);
  send_to_char("\r\n &BYou think the walls are always moving&n \r\n", ch);
  return 1;
}

SPECIAL(espada_fica_azul)
{
	struct char_data *tch;
	short int saida;

	if(!CMD_IS("look"))
		return 0;

	if(!*argument)
		return 0;

    skip_spaces(&argument);

	if(!str_cmp(argument, "sword") || !str_cmp(argument, "maegnas"))
	{
		for (saida = 0; saida < NUM_OF_DIRS; saida++)
		{
			if (!EXIT(ch, saida) || EXIT(ch, saida)->to_room == NOWHERE)
				continue;

			for(tch = world[EXIT(ch, saida)->to_room].people; tch; tch = tch->next_in_room)
				if(GET_RACE(tch) == RACE_ORC)
				{
					send_to_char("&GT&ghe &WS&wword &CM&caegnas &cstarts to glow with a &BB&blue &WL&wight&c.&n\r\n", ch);
					return 1;
				}
		}
	}
	return 0;
}

#define MAX_CABECAS			5

int mobs_vnums[] =
{
	2216,
	2217,
	2218,
	2219,
	2220
};

#define SALA_DAS_CABECAS			2245

short int eh_cabeca(struct char_data *vict)
{
	short int num;

	if(!IS_NPC(vict))
		return (0);

	for(num = 0; num < MAX_CABECAS; num++)
		if(GET_MOB_VNUM(vict) == mobs_vnums[num])
			return (1);
	return (0);
}

short int tem_cabeca(int sala)
{
	short int cabecas = 0;
	struct char_data *vict;

	for (vict = world[sala].people; vict; vict = vict->next_in_room)
		if(eh_cabeca(vict))
			cabecas++;

	return (cabecas);
}

void teleportar_cabecas(struct char_data *ch, int donde)
{
	struct char_data *vict, *drg;

	for (vict = world[donde].people; vict;)
	{
		drg = vict;
		vict = vict->next_in_room;
		if(IS_NPC(drg))
		{
			char_from_room(drg);
			char_to_room(drg, ch->in_room);
		}
	}
}

SPECIAL(tiamat_heads)
{
  struct char_data *vict;
  int numero ;

  switch(GET_MOB_VNUM(ch))
 {
   case 2218 : numero = 504 ; break ; //white
   case 2220 : numero = 502 ; break ; // red
   case 2219 : numero = 505 ; break ; // black
   case 2217 : numero = 506 ; break ; //blue
   default: numero = 503    ; break ; // green
 }

  if (cmd || GET_POS(ch) != POS_FIGHTING)
    return (0);

  vict = FIGHTING(ch);
  if (vict == NULL || (ch->in_room != vict->in_room))
   return (1);

  damage(ch,vict,250,numero);
  return(1);
}

SPECIAL(tiamat2)
{
	short int num;

	if (cmd || !FIGHTING(ch))
		return FALSE;

	if(tem_cabeca(ch->in_room))
        {
         GET_HIT(ch) = GET_MAX_HIT(ch);
         send_to_room("&RTiamat &cseems &Cinvulnerable&W.&n\r\n", ch->in_room);
         return FALSE ;
        }

	else
	{
		num = real_room(SALA_DAS_CABECAS);
		if(tem_cabeca(num) == 5)
		{
			teleportar_cabecas(ch, num);
			send_to_room("&yYou feel a bad feeling, and &Csuddenly &yappears &RFIVE &chuge and scare &yheads from the &Wdarkness&y!&n\r\n", ch->in_room);
			return (1);
		}
	}
	return (0);
}

SPECIAL(oracle)
{

/*
	//extern char *spells[];
        //struct char_data *self;
        int y, c=GET_CLASS(ch);
        
        if (!AWAKE(ch)){
        		send_to_char("Oracle: 'Improving your dreams?!'\r\n",ch);
        		return 0;
        	}
        if (CMD_IS("improve")){
        	one_argument(argument, arg);	
        	}
        	if (!*arg){
        		send_to_char("Oracle: 'what spell/skill do you wanna learn?'\r\n", ch);
                        send_to_char("Oracle: 'use improve<name of skill/spell>'\r\n", ch);
                        return 0; 
                }
                if (GET_GOLD(ch) >= 500000){
                	GET_GOLD(ch) -= 500000;
                }
                else{ 
                	send_to_char("Oracle: 'You need 500.000 coins to improve once'\r\n", ch);
                return 0;
                }
                
                 
        if(((y = find_skill_num(*arg)) == -1) || spell_info[y].min_level[c] > GET_LEVEL(ch)) {
          send_to_char("You can't improve that skill/spell", ch);
          return 0;
        }
    else {
    	improve_skill(ch, y);
} */ return 0 ; 
}

::::::::::::::
spell_parser.c
::::::::::::::
/* ************************************************************************
*   File: spell_parser.c                                Part of CircleMUD *
*  Usage: top-level magic routines; outside points of entry to magic sys. *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "interpreter.h"
#include "spells.h"
#include "handler.h"
#include "comm.h"
#include "db.h"

struct spell_info_type spell_info[TOP_SPELL_DEFINE + 1];

#define SINFO spell_info[spellnum]

extern struct room_data *world;
void improve_skill(struct char_data *ch, int skill);

/* local functions */
void say_spell(struct char_data * ch, int spellnum, struct char_data * tch, struct obj_data * tobj);
void spello(int spl, int max_mana, int min_mana, int mana_change, int minpos, int targets, int violent, int routines);
int mag_manacost(struct char_data * ch, int spellnum);
ACMD(do_cast);
void unused_spell(int spl);
void mag_assign_spells(void);

/*
 * This arrangement is pretty stupid, but the number of skills is limited by
 * the playerfile.  We can arbitrarily increase the number of skills by
 * increasing the space in the playerfile. Meanwhile, this should provide
 * ample slots for skills.
 */

const char *spells[] =
{
/* 000 */  "!RESERVED!",

  /* SPELLS */

/* 001 */  "armor",
/* 002 */  "teleport",
/* 003 */  "bless",
/* 004 */  "blindness",
/* 005 */  "burning hands",
/* 006 */  "call lightning",
/* 007 */  "charm person",
/* 008 */  "chill touch",
/* 009 */  "clone",
/* 010 */  "color spray",
/* 011 */  "control weather",
/* 012 */  "create food",
/* 013 */  "create water",
/* 014 */  "cure blind",
/* 015 */  "cure critic",
/* 016 */  "cure light",
/* 017 */  "curse",
/* 018 */  "detect alignment",
/* 019 */  "detect invisibility",
/* 020 */  "detect magic",
/* 021 */  "detect poison",
/* 022 */  "dispel evil",
/* 023 */  "earthquake",
/* 024 */  "enchant weapon",
/* 025 */  "energy drain",
/* 026 */  "fireball",
/* 027 */  "harm",
/* 028 */  "heal",
/* 029 */  "invisibility",
/* 030 */  "lightning bolt",
/* 031 */  "locate object",
/* 032 */  "magic missile",
/* 033 */  "poison",
/* 034 */  "protection from evil",
/* 035 */  "remove curse",
/* 036 */  "sanctuary",
/* 037 */  "shocking grasp",
/* 038 */  "sleep",
/* 039 */  "strength",
/* 040 */  "summon",
/* 041 */  "ventriloquate",
/* 042 */  "word of recall",
/* 043 */  "remove poison",
/* 044 */  "sense life",
/* 045 */  "animate dead",
/* 046 */  "dispel good",
/* 047 */  "group armor",
/* 048 */  "group heal",
/* 049 */  "group recall",
/* 050 */  "infravision",
/* 051 */  "waterwalk",
/* 052 */  "mana shield",
/* 053 */  "damned curse",
/* 054 */  "refresh",
/* 055 */  "haste",
/* 056 */  "regeneration",
/* 057 */  "petrify muscle",
/* 058 */  "god pact",
/* 059 */  "satan pact",
/* 060 */  "end of world",
/* 061 */  "mental rage", "satanic cure", "fly", "blood thirst", "entangle",
/* 066 */  "fireshield", "fast health", "icestorm", "meteorstorm", "firestorm",
/* 071 */  "force shield", "enhanced armor", "revitalize", "golem", "illusion",
/* 076 */  "wall of fog", "fire wall", "ice wall", "mana sword", "poison weapon",
/* 081 */  "firebolt", "icebolt", "mind sight", "elemental", "grease",
/* 086 */  "cromatic orb", "flame arrow", "slow","eletricstorm","iron skin",
/* 091 */  "platinum skin", "diamond skin", "acid arrow", "minute meteor", "glacial cone",
/* 096 */  "area lightning", "fire spit", "gas spit", "frost spit", "acid spit",
/* 101 */  "lightning spit", "blade barrier", "prismatic sphere", "armageddom", "delayed fireball",
/* 106 */  "friends", "dumbness", "phantom armor", "spectral wings", "holy fury",
/* 111 */  "champion strenght", "holy mace", "death scyth", "simulacrum", "terror",
/* 116 */  "death finger", "engulfing darkness", "banshee aura", "siphon life", "blink",
/* 121 */  "meteor shower", "holy word", "holy shout", "deathdance", "death wave",
/* 126 */  "death ripple", "peace", "protection from fire", "group fly", "wraithform",
/* 131 */  "fear", "minor globe", "major globe", "phantom flame", "sacrifice",
/* 136 */  "skull trap", "ghastly touch", "vampiric touch", "pestilence", "antimagic shell",
/* 141 */  "holy bolt", "dispel neutral", "shillelagh", "magical stone", "command",
/* 146 */  "hold person", "volcano", "geyser", "group bless", "corporal trembling",
/* 151 */  "ice heart", "polteirgeist", "blizzard", "create light", "clairvoyance",
/* 156 */  "create flames", "clairaudience", "winged knife", "enhanced strength", "ego whip",
/* 161 */  "project force", "wrench", "feel light", "balistic attack", "superior invisibility",
/* 166 */  "detonate", "aversion", "psychic ray", "molecular agitation", "empathy",
/* 171 */  "thought shield", "biofeedback", "mental barrier", "inertial barrier", "cell adjustment",
/* 176 */  "concentration", "conviction", "holy shield", "lay on hands", "cure serious",
/* 181 */  "remove fear", "flesh armor", "confusion", "bravery", "rigid thinking",
/* 186 */  "paradise chrysalis", "abutilon", "aura sight", "pain", "displacement",
/* 191 */  "intelectual fortress", "life draining", "body weaponry", "body equilibrium", "adrenaline control",
/* 196 */  "lend health", "combat mind", "psionic blast", "psychic drain", "martial trance",
/* 201 */  "hipnotic suggestion", "astral projection", "ultima", "summon bahamut", "barkskin",
/* 206 */  "call bear", "muir", "ilmanateur", "selune", "helm",
/* 211 */  "talos", "Oghma", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 216 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 221 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 226 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 231 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 236 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 241 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 246 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 251 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 256 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 261 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 266 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 271 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 276 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 281 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 286 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 291 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 296 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",

/* SKILLS */

/* 301 */  "backstab",
/* 302 */  "bash",
/* 303 */  "hide",
/* 304 */  "kick",
/* 305 */  "pick lock",
/* 306 */  "stroke",
/* 307 */  "rescue",
/* 308 */  "sneak",
/* 309 */  "steal",
/* 310 */  "track",
/* 311 */  "combo",
/* 312 */  "shield block",
/* 313 */  "swim", "vitalize health", "vitalize mana",
/* 316 */  "spy", "critical attack",
/* 318 */  "second attack",
/* 319 */  "third attack",
/* 320 */  "fourth attack",
/* 321 */  "scan", "sabre", 
/* 323 */  "hand damage", "white gas", "harakiri", "circle arround",
/* 327 */  "second stab", "parry", "dodge", "tumble", "hit",
/* 332 */  "sting", "whip", "slash", "bite", "bludgeon",
/* 337 */  "crush", "pound", "claw", "maul", "thrash",
/* 342 */  "pierce", "blast", "punch", "stab", "disarm",
/* 347 */  "berzerk", "first aid", "headbash", "escape", "dual wield",
/* 352 */  "meditate", "levitate", "listen", "agility", "kaiser",
/* 357 */  "warshout", "knockout", "throw", "gut", "drown",
/* 362 */  "chop", "kickflip", "whirlwind", "blood ritual", "style pro",
/* 367 */  "sprite", "werewolf", "sucubus", "behemoth", "tyrael",
/* 372 */   "slayer",     /*"slang",*/ "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 377 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 382 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 387 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 392 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 397 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 402 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 407 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 412 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 417 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 422 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 427 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 432 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 437 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 442 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 447 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 452 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 457 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 462 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 467 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 472 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 477 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 482 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 487 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 492 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
/* 497 */  "!UNUSED!", "!UNUSED!", "!UNUSED!", "!UNUSED!",
//    CASO AGENTE UTILIZE OS 500 PRA SKILLS AINDA TEMOS MAIS 100 
//   SOH NAO COLOQUEI PRA NAO DEIXA O FILE MUITO GRANDE AINDA 500 
//   ACHO Q EXAGEREI :P 

/**   OBJECT SPELLS AND NPC SPELLS/SKILLS */

/* 501 */  "identify",                   /* 501 */
/* 502 */  "fire breath",
/* 503 */  "gas breath",
/* 504 */  "frost breath",
/* 505 */  "acid breath",
/* 506 */  "lightning breath",
/* 507 */  "restore mana",

  "\n"                          /* the end */
};


struct syllable {
  const char *org;
  const char *news;
};


struct syllable syls[] = {
  {" ", " "},
  {"ar", "abra"},
  {"ate", "i"},
  {"cau", "kada"},
  {"blind", "nose"},
  {"bur", "mosa"},
  {"cu", "judi"},
  {"de", "oculo"},
  {"dis", "mar"},
  {"ect", "kamina"},
  {"en", "uns"},
  {"gro", "cra"},
  {"light", "dies"},
  {"lo", "hi"},
  {"magi", "kari"},
  {"mon", "bar"},
  {"mor", "zak"},
  {"move", "sido"},
  {"ness", "lacri"},
  {"ning", "illa"},
  {"per", "duda"},
  {"ra", "gru"},
  {"re", "candus"},
  {"son", "sabru"},
  {"tect", "infra"},
  {"tri", "cula"},
  {"ven", "nofo"},
  {"word of", "inset"},
  {"a", "i"}, {"b", "v"}, {"c", "q"}, {"d", "m"}, {"e", "o"}, {"f", "y"}, {"g", "t"},
  {"h", "p"}, {"i", "u"}, {"j", "y"}, {"k", "t"}, {"l", "r"}, {"m", "w"}, {"n", "b"},
  {"o", "a"}, {"p", "s"}, {"q", "d"}, {"r", "f"}, {"s", "g"}, {"t", "h"}, {"u", "e"},
  {"v", "z"}, {"w", "x"}, {"x", "n"}, {"y", "l"}, {"z", "k"}, {"", ""}
};


int mag_manacost(struct char_data * ch, int spellnum)
{
  int mana;

  mana = MAX(SINFO.mana_max - (SINFO.mana_change *
      (GET_LEVEL(ch) - (SINFO.min_level[(int) GET_CLASS(ch)]) == 0 ? GET_LEVEL(ch) : SINFO.min_level[(int) GET_CLASS(ch)])),
//                    (GET_LEVEL(ch) - SINFO.min_level[(int) GET_CLASS(ch)])),
             SINFO.mana_min);

  return mana;
}


/* say_spell erodes buf, buf1, buf2 */

void say_spell(struct char_data * ch, int spellnum, struct char_data * tch,
	            struct obj_data * tobj)
{
  char lbuf[256];

  struct char_data *i;
  int j, ofs = 0;

  *buf = '\0';
  strcpy(lbuf, spells[spellnum]);

  while (*(lbuf + ofs)) {
    for (j = 0; *(syls[j].org); j++) {
      if (!strncmp(syls[j].org, lbuf + ofs, strlen(syls[j].org))) {
	strcat(buf, syls[j].news);
	ofs += strlen(syls[j].org);
      }
    }
  }

  if (tch != NULL && tch->in_room == ch->in_room) {
    if (tch == ch)
      sprintf(lbuf, "$n closes $s eyes and utters the words, '%%s'.");
    else
      sprintf(lbuf, "$n stares at $N and utters the words, '%%s'.");
  } else if (tobj != NULL &&
	     ((tobj->in_room == ch->in_room) || (tobj->carried_by == ch)))
    sprintf(lbuf, "$n stares at $p and utters the words, '%%s'.");
  else
    sprintf(lbuf, "$n utters the words, '%%s'.");

  sprintf(buf1, lbuf, spells[spellnum]);
  sprintf(buf2, lbuf, buf);

  for (i = world[ch->in_room].people; i; i = i->next_in_room) {
    if (i == ch || i == tch || !i->desc || !AWAKE(i))
      continue;
    if (GET_CLASS(ch) == GET_CLASS(i))
      perform_act(buf1, ch, tobj, tch, i);
    else
      perform_act(buf2, ch, tobj, tch, i);
  }

  if (tch != NULL && tch != ch && tch->in_room == ch->in_room) {
/*    sprintf(buf1, "$n stares at you and utters the words, '%s'.",
	    GET_CLASS(ch) == GET_CLASS(tch) ? spells[spellnum] : buf);
    act(buf1, FALSE, ch, NULL, tch, TO_VICT);*/
    sprintf(buf1, "$n stares at you and utters the words, '%s'.",
            (!IS_NPC(tch) && (GET_SKILL(tch, spellnum) > 50)) ? spells[spellnum] : buf);
    act(buf1, FALSE, ch, NULL, tch, TO_VICT);
  }
}

const char *skill_name(int num)
{
  int i = 0;

  if (num <= 0) {
    if (num == -1)
      return "UNUSED";
    else
      return "UNDEFINED";
  }

  while (num && *spells[i] != '\n') {
    num--;
    i++;
  }

  if (*spells[i] != '\n')
    return spells[i];
  else
    return "UNDEFINED";
}

         
int find_skill_num(char *name)
{
  int index = 0, ok;
  char *temp, *temp2;
  char first[256], first2[256];

  while (*spells[++index] != '\n') {
    if (is_abbrev(name, spells[index]))
      return index;

    ok = 1;
    /* It won't be changed, but other uses of this function elsewhere may. */
    temp = any_one_arg((char *)spells[index], first);
    temp2 = any_one_arg(name, first2);
    while (*first && *first2 && ok) {
      if (!is_abbrev(first2, first))
        ok = 0;
      temp = any_one_arg(temp, first);
      temp2 = any_one_arg(temp2, first2);
    }

    if (ok && !*first2)
      return index;
  }

  return -1;
}



/*
 * This function is the very heart of the entire magic system.  All
 * invocations of all types of magic -- objects, spoken and unspoken PC
 * and NPC spells, the works -- all come through this function eventually.
 * This is also the entry point for non-spoken or unrestricted spells.
 * Spellnum 0 is legal but silently ignored here, to make callers simpler.
 */
int call_magic(struct char_data * caster, struct char_data * cvict,
             struct obj_data * ovict, int spellnum, int level, int casttype)
{
  int savetype;

  if (spellnum < 1 || spellnum > TOP_SPELL_DEFINE)
    return 0;

  if (ROOM_FLAGGED(caster->in_room, ROOM_NOMAGIC)) {
    send_to_char("Your magic fizzles out and dies.\r\n", caster);
    act("$n's magic fizzles out and dies.", FALSE, caster, 0, 0, TO_ROOM);
    return 0;
  }
  if (ROOM_FLAGGED(caster->in_room, ROOM_PEACEFUL) &&
      (SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE))) {
    send_to_char("A flash of white light fills the room, dispelling your "
                 "violent magic!\r\n", caster);
    act("White light from no particular source suddenly fills the room, "
        "then vanishes.", FALSE, caster, 0, 0, TO_ROOM);
    return 0;
  }

  if (!IS_NPC(caster) && cvict && !IS_NPC(cvict) &&
      GET_LEVEL(caster) >= LVL_IMMORT && GET_LEVEL(cvict) < LVL_IMMORT) {
    sprintf(buf2, "(GC) %s casts spell '%s' on %s at %s&g",
	    GET_NAME(caster), spells[spellnum], GET_NAME(cvict), world[cvict->in_room].name);
    mudlog(buf2, BRF, MIN(GET_LEVEL(caster)+1, LVL_IMPL), TRUE);
  }
  /* determine the type of saving throw */
  switch (casttype) {
  case CAST_STAFF:
  case CAST_SCROLL:
  case CAST_POTION:
  case CAST_WAND:
    savetype = SAVING_ROD;
    break;
  case CAST_SPELL:
    savetype = SAVING_SPELL;
    break;
  default:
    savetype = SAVING_BREATH;
    break;
  }

  
  if(cvict)
  {
   if(GET_RACE(cvict) == RACE_ANCI_DROW || 
     (GET_RACE(cvict) == RACE_DRACONIAN && number(1,12) == 3))
   {
    if(SINFO.violent) 
    {
     send_to_char("Spell innefective\r\n",caster) ;
     send_to_char("Spell innefective\r\n",cvict) ;
     return 1 ;
    }
   }
  }       
  /*
   * Hm, target could die here.  Wonder if we should move this down lower to
   * give the other spells a chance to go off first? -gg 6/24/98
   */
  if (IS_SET(SINFO.routines, MAG_DAMAGE))
    if (mag_damage(level, caster, cvict, spellnum, savetype) == -1)
      return 1;

  if (IS_SET(SINFO.routines, MAG_AFFECTS))
   {
    mag_affects(level, caster, cvict, spellnum, savetype);
   if(GET_RACE(caster) == RACE_HIGH_ELF || (GET_RACE(caster) == RACE_DRACONIAN && 
number(1,12) == 3))
    mag_affects(level, caster, cvict, spellnum, savetype);
   }   

  if (IS_SET(SINFO.routines, MAG_UNAFFECTS))
    mag_unaffects(level, caster, cvict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_POINTS))
    mag_points(level, caster, cvict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_ALTER_OBJS))
    mag_alter_objs(level, caster, ovict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_GROUPS))
    mag_groups(level, caster, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_MASSES))
    mag_masses(level, caster, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_AREAS))
    mag_areas(level, caster, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_SUMMONS))
    mag_summons(level, caster, ovict, spellnum, savetype);

  if (IS_SET(SINFO.routines, MAG_CREATIONS))
    mag_creations(level, caster, spellnum);

  if (IS_SET(SINFO.routines, MAG_MANUAL))
    switch (spellnum) {
    case SPELL_CHARM:           MANUAL_SPELL(spell_charm); break;
    case SPELL_RIGID_THINKING:  MANUAL_SPELL(spell_rigid_thinking); break;
    case SPELL_CREATE_WATER:    MANUAL_SPELL(spell_create_water); break;
    case SPELL_DETECT_POISON:   MANUAL_SPELL(spell_detect_poison); break;
    case SPELL_ENCHANT_WEAPON:  MANUAL_SPELL(spell_enchant_weapon); break;
    case SPELL_IDENTIFY:        MANUAL_SPELL(spell_identify); break;
    case SPELL_OGHMA :          MANUAL_SPELL(spell_oghma); break;
    case SPELL_LOCATE_OBJECT:   MANUAL_SPELL(spell_locate_object); break;
    case SPELL_SUMMON:          MANUAL_SPELL(spell_summon); break;
    case SPELL_WORD_OF_RECALL:  MANUAL_SPELL(spell_recall); break;
    case SPELL_TELEPORT:        MANUAL_SPELL(spell_teleport); break;
    case SPELL_FARSIGHT:        MANUAL_SPELL(spell_farsight); break;
    case SPELL_CONTROL_WEATHER: MANUAL_SPELL(spell_control_weather); break;
    case SPELL_DEATH_SCYTHE: 	MANUAL_SPELL(spell_death_scythe); break;
    case SPELL_SIMULACRUM: 	MANUAL_SPELL(spell_simulacrum); break;
    case SPELL_PEACE:		MANUAL_SPELL(spell_peace); break;    
    case SPELL_MANA_SWORD:	MANUAL_SPELL(spell_mana_sword); break; 
//    case SPELL_FEAR:		MANUAL_SPELL(spell_fear); break;   
    }

  if (IS_SET(SINFO.routines, MAG_ROOM))
    mag_room(level, caster, spellnum);
    
  return 1;
}

/*
 * mag_objectmagic: This is the entry-point for all magic items.  This should
 * only be called by the 'quaff', 'use', 'recite', etc. routines.
 *
 * For reference, object values 0-3:
 * staff  - [0] level   [1] max charges [2] num charges [3] spell num
 * wand   - [0] level   [1] max charges [2] num charges [3] spell num
 * scroll - [0] level   [1] spell num   [2] spell num   [3] spell num
 * potion - [0] level   [1] spell num   [2] spell num   [3] spell num
 *
 * Staves and wands will default to level 14 if the level is not specified;
 * the DikuMUD format did not specify staff and wand levels in the world
 * files (this is a CircleMUD enhancement).
 */

void mag_objectmagic(struct char_data * ch, struct obj_data * obj,
                          char *argument)
{
  int i, k;
  struct char_data *tch = NULL, *next_tch;
  struct obj_data *tobj = NULL;
  int spellnum;

  one_argument(argument, arg);

  k = generic_find(arg, FIND_CHAR_ROOM | FIND_OBJ_INV | FIND_OBJ_ROOM |
                   FIND_OBJ_EQUIP, ch, &tch, &tobj);

  switch (GET_OBJ_TYPE(obj)) {
  case ITEM_STAFF:
    act("You tap $p three times on the ground.", FALSE, ch, obj, 0, TO_CHAR);
    if (obj->action_description)
      act(obj->action_description, FALSE, ch, obj, 0, TO_ROOM);
    else
      act("$n taps $p three times on the ground.", FALSE, ch, obj, 0, TO_ROOM);

    if (GET_OBJ_VAL(obj, 2) <= 0) {
      act("It seems powerless.", FALSE, ch, obj, 0, TO_CHAR);
      act("Nothing seems to happen.", FALSE, ch, obj, 0, TO_ROOM);
    } else {
      GET_OBJ_VAL(obj, 2)--;
      WAIT_STATE(ch, PULSE_VIOLENCE);
      spellnum = GET_OBJ_VAL(obj, 3);
      if (!IS_SET(SINFO.routines, MAG_AREAS))
       for (tch = world[ch->in_room].people; tch; tch = next_tch) {
         next_tch = tch->next_in_room;
         if (ch == tch)
           continue;
         if (GET_OBJ_VAL(obj, 0))
           call_magic(ch, tch, NULL, GET_OBJ_VAL(obj, 3),
                      GET_OBJ_VAL(obj, 0), CAST_STAFF);
         else
           call_magic(ch, tch, NULL, GET_OBJ_VAL(obj, 3),
                      DEFAULT_STAFF_LVL, CAST_STAFF);
       }
      else
       if (GET_OBJ_VAL(obj, 0))
           call_magic(ch, tch, NULL, GET_OBJ_VAL(obj, 3),
                      GET_OBJ_VAL(obj, 0), CAST_STAFF);
       else
           call_magic(ch, tch, NULL, GET_OBJ_VAL(obj, 3),
                      DEFAULT_STAFF_LVL, CAST_STAFF); 
       
    }
    break;
  case ITEM_WAND:
    if (k == FIND_CHAR_ROOM) {
      if (tch == ch) {
        act("You point $p at yourself.", FALSE, ch, obj, 0, TO_CHAR);
        act("$n points $p at $mself.", FALSE, ch, obj, 0, TO_ROOM);
      } else {
        act("You point $p at $N.", FALSE, ch, obj, tch, TO_CHAR);
        if (obj->action_description != NULL)
          act(obj->action_description, FALSE, ch, obj, tch, TO_ROOM);
        else
          act("$n points $p at $N.", TRUE, ch, obj, tch, TO_ROOM);
      }
    } else if (tobj != NULL) {
      act("You point $p at $P.", FALSE, ch, obj, tobj, TO_CHAR);
      if (obj->action_description != NULL)
        act(obj->action_description, FALSE, ch, obj, tobj, TO_ROOM);
      else
        act("$n points $p at $P.", TRUE, ch, obj, tobj, TO_ROOM);
    } else {
      act("At what should $p be pointed?", FALSE, ch, obj, NULL, TO_CHAR);
      return;
    }

    if (GET_OBJ_VAL(obj, 2) <= 0) {
      act("It seems powerless.", FALSE, ch, obj, 0, TO_CHAR);
      act("Nothing seems to happen.", FALSE, ch, obj, 0, TO_ROOM);
      return;
    }
    GET_OBJ_VAL(obj, 2)--;
    WAIT_STATE(ch, PULSE_VIOLENCE);
    if (GET_OBJ_VAL(obj, 0))
      call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3),
                 GET_OBJ_VAL(obj, 0), CAST_WAND);
    else
      call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, 3),
                 DEFAULT_WAND_LVL, CAST_WAND);
    break;
  case ITEM_SCROLL:
    if (*arg) {
      if (!k) {
        act("There is nothing to here to affect with $p.", FALSE,
            ch, obj, NULL, TO_CHAR);
        return;
      }
    } else
      tch = ch;

    act("You recite $p which dissolves.", TRUE, ch, obj, 0, TO_CHAR);
    if (obj->action_description)
      act(obj->action_description, FALSE, ch, obj, NULL, TO_ROOM);
    else
      act("$n recites $p.", FALSE, ch, obj, NULL, TO_ROOM);

    WAIT_STATE(ch, PULSE_VIOLENCE);
    for (i = 1; i < 4; i++)
      if (!(call_magic(ch, tch, tobj, GET_OBJ_VAL(obj, i),
                       GET_OBJ_VAL(obj, 0), CAST_SCROLL)))
        break;

    if (obj != NULL)
      extract_obj(obj);
    break;
  case ITEM_POTION:
    tch = ch;
    act("You quaff $p.", FALSE, ch, obj, NULL, TO_CHAR);
    if (obj->action_description)
      act(obj->action_description, FALSE, ch, obj, NULL, TO_ROOM);
    else
      act("$n quaffs $p.", TRUE, ch, obj, NULL, TO_ROOM);

    WAIT_STATE(ch, PULSE_VIOLENCE);
    for (i = 1; i < 4; i++)
      if (!(call_magic(ch, ch, NULL, GET_OBJ_VAL(obj, i),
                       GET_OBJ_VAL(obj, 0), CAST_POTION)))
        break;

    if (obj != NULL)
      extract_obj(obj);
    break;
  default:
    log("SYSERR: Unknown object_type %d in mag_objectmagic.",
        GET_OBJ_TYPE(obj));
    break;
  }
}


/*
 * cast_spell is used generically to cast any spoken spell, assuming we
 * already have the target char/obj and spell number.  It checks all
 * restrictions, etc., prints the words, etc.
 *
 * Entry point for NPC casts.  Recommended entry point for spells cast
 * by NPCs via specprocs.
 */

int cast_spell(struct char_data * ch, struct char_data * tch,
                   struct obj_data * tobj, int spellnum)
{
  int result;
  if (spellnum < 0 || spellnum > TOP_SPELL_DEFINE) {
    log("SYSERR: cast_spell trying to call spellnum %d/%d.\n", spellnum,
        TOP_SPELL_DEFINE);
    return 0;
  }
    
  if (GET_POS(ch) < SINFO.min_position) {
    switch (GET_POS(ch)) {
      case POS_SLEEPING:
      send_to_char("You dream about great magical powers.\r\n", ch);
      break;
    case POS_RESTING:
      send_to_char("You cannot concentrate while resting.\r\n", ch);
      break;
    case POS_SITTING:
      send_to_char("You can't do this sitting!\r\n", ch);
      break;
    case POS_FIGHTING:
      send_to_char("Impossible!  You can't concentrate enough!\r\n", ch);
      break;
    default:
      send_to_char("You can't do much of anything like this!\r\n", ch);
      break;
    }
    return 0;
  }
  if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master == tch)) {
    send_to_char("&rYou are afraid you might hurt your master!&n\r\n", ch);
    return 0;
  }
  if ((tch != ch) && IS_SET(SINFO.targets, TAR_SELF_ONLY)) {
    send_to_char("&WYou can only cast this spell upon yourself!&n\r\n", ch);
    return 0;
  }
  if ((tch == ch) && IS_SET(SINFO.targets, TAR_NOT_SELF)) {
    send_to_char("&RYou cannot cast this spell upon yourself!&n\r\n", ch);
    return 0;
  }
  if (IS_SET(SINFO.routines, MAG_GROUPS) && !AFF_FLAGGED(ch, AFF_GROUP)) {
    send_to_char("&WYou can't cast this spell if you're not in a group!&n\r\n",ch);
    return 0;
  }
  if (tch && !(SINFO.violent || IS_SET(SINFO.routines, MAG_DAMAGE)) && !IS_SET(SINFO.routines, MAG_GROUPS)
      && AFF2_FLAGGED(tch, AFF2_TRANSFORM)) {
    send_to_char("&WNo one can be affected by mortal spells while &ctransformed&W!&n\r\n", ch);
    return 0;
  }

  send_to_char(OK, ch);
  say_spell(ch, spellnum, tch, tobj);

  result = call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL);
  if (result != 0)
    improve_skill(ch, spellnum); 
  return (result);
//  return (call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL));
}


/*
 * do_cast is the entry point for PC-casted spells.  It parses the arguments,
 * determines the spell number and finds a target, throws the die to see if
 * the spell can be cast, checks for sufficient mana and subtracts it, and
 * passes control to cast_spell().
 */

ACMD(do_cast)
{
  struct char_data *tch = NULL;
  struct obj_data *tobj = NULL;
  char *s, *t;
  int mana, spellnum, i, target = 0;

  if (IS_NPC(ch))
    return;

  /* get: blank, spell name, target name */
  s = strtok(argument, "'");

  if (s == NULL) {
    send_to_char("Cast what where?\r\n", ch);
    return;
  }
  s = strtok(NULL, "'");
  if (s == NULL) {
    send_to_char("Spell names must be enclosed in the Holy Magic Symbols: '\r\n", ch);
    return;
  }
  t = strtok(NULL, "\0");

  /* spellnum = search_block(s, spells, 0); */
  spellnum = find_skill_num(s);

  if ((spellnum < 1) || (spellnum > MAX_SPELLS)) {
    send_to_char("Cast what?!?\r\n", ch);
    return;
  }
/*if (GET_LEVEL(ch) < SINFO.min_level[(int) GET_CLASS(ch)]) {
    send_to_char("You do not know that spell!\r\n", ch);
    return;
  }*/
  if (GET_SKILL(ch, spellnum) == 0) {
    send_to_char("You are unfamiliar with that spell.\r\n", ch);
    return;
  }
  /* Find the target */
  if (t != NULL) {
    one_argument(strcpy(arg, t), t);
    skip_spaces(&t);
  }
  if (IS_SET(SINFO.targets, TAR_IGNORE)) {
    target = TRUE;
  } else if (t != NULL && *t) {
    if (!target && (IS_SET(SINFO.targets, TAR_CHAR_ROOM))) {
      if ((tch = get_char_room_vis(ch, t)) != NULL)
        target = TRUE;
    }
    if (!target && IS_SET(SINFO.targets, TAR_CHAR_WORLD))
      if ((tch = get_char_vis(ch, t)))
        target = TRUE;

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_INV))
      if ((tobj = get_obj_in_list_vis(ch, t, ch->carrying)))
        target = TRUE;

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_EQUIP)) {
      for (i = 0; !target && i < NUM_WEARS; i++)
        if (GET_EQ(ch, i) && isname(t, GET_EQ(ch, i)->name)) {
          tobj = GET_EQ(ch, i);
          target = TRUE;
        }
    }
    if (!target && IS_SET(SINFO.targets, TAR_OBJ_ROOM))
      if ((tobj = get_obj_in_list_vis(ch, t, world[ch->in_room].contents)))
        target = TRUE;

    if (!target && IS_SET(SINFO.targets, TAR_OBJ_WORLD))
      if ((tobj = get_obj_vis(ch, t)))
        target = TRUE;

  } else {                      /* if target string is empty */
    if (!target && IS_SET(SINFO.targets, TAR_FIGHT_SELF))
      if (FIGHTING(ch) != NULL) {
        tch = ch;
        target = TRUE;
      }
    if (!target && IS_SET(SINFO.targets, TAR_FIGHT_VICT))
      if (FIGHTING(ch) != NULL) {
        tch = FIGHTING(ch);
        target = TRUE;
      }
    /* if no target specified, and the spell isn't violent, default to self */
    if (!target && IS_SET(SINFO.targets, TAR_CHAR_ROOM) &&
        !SINFO.violent) {
      tch = ch;
      target = TRUE;
    }
    if (!target) {
      sprintf(buf, "Upon %s should the spell be cast?\r\n",
         IS_SET(SINFO.targets, TAR_OBJ_ROOM | TAR_OBJ_INV | TAR_OBJ_WORLD) ?
              "what" : "who");
      send_to_char(buf, ch);
      return;
    }
  }

  if (target && (tch == ch) && SINFO.violent) {
    send_to_char("You shouldn't cast that on yourself -- could be bad for your health!\r\n", ch);
    return;
  }

  if (!target) {
    send_to_char("Cannot find the target of your spell!\r\n", ch);
    return;
  }
  mana = mag_manacost(ch, spellnum);
  if ((mana > 0) && (GET_MANA(ch) < mana) && (GET_LEVEL(ch) < LVL_IMMORT)) {
    send_to_char("You haven't the energy to cast that spell!\r\n", ch);
    return;
  }

  /* You throws the dice and you takes your chances.. 101% is total failure */
  if (number(0, 101) > GET_SKILL(ch, spellnum)) {
    WAIT_STATE(ch, PULSE_VIOLENCE);
    if (!tch || !skill_message(0, ch, tch, spellnum))
      send_to_char("You lost your concentration!\r\n", ch);
    if (mana > 0)
      GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - (mana / 2)));
    if (SINFO.violent && tch && IS_NPC(tch))
      hit(tch, ch, TYPE_UNDEFINED);
  } else { /* cast spell returns 1 on success; subtract mana & set waitstate */
    if (cast_spell(ch, tch, tobj, spellnum)) {
      WAIT_STATE(ch, PULSE_VIOLENCE);
      if (mana > 0)
        GET_MANA(ch) = MAX(0, MIN(GET_MAX_MANA(ch), GET_MANA(ch) - mana));


    }
  }
}



void spell_level(int spell, int chclass, int level)
{
  int bad = 0;

  if (spell < 0 || spell > TOP_SPELL_DEFINE) {
    log("SYSERR: attempting assign to illegal spellnum %d/%d", spell, TOP_SPELL_DEFINE);
    return;
  }

  if (chclass < 0 || chclass >= NUM_CLASSES) {
    log("SYSERR: assigning '%s' to illegal class %d/%d.", skill_name(spell),
                chclass, NUM_CLASSES - 1);
    bad = 1;
  }

  if (level < 1 || level > LVL_IMPL) {
    log("SYSERR: assigning '%s' to illegal level %d/%d.", skill_name(spell),
                level, LVL_IMPL);
    bad = 1;
  }

  if (!bad)
    spell_info[spell].min_level[chclass] = level;
}


/* Assign the spells on boot up */
void spello(int spl, int max_mana, int min_mana, int mana_change, int minpos,
                 int targets, int violent, int routines)
{
  int i;

  for (i = 0; i < NUM_CLASSES; i++)
    spell_info[spl].min_level[i] = LVL_ELDER;
  spell_info[spl].mana_max = max_mana;
  spell_info[spl].mana_min = min_mana;
  spell_info[spl].mana_change = mana_change;
  spell_info[spl].min_position = minpos;
  spell_info[spl].targets = targets;
  spell_info[spl].violent = violent;
  spell_info[spl].routines = routines;
}


void unused_spell(int spl)
{
  int i;

  for (i = 0; i < NUM_CLASSES; i++)
    spell_info[spl].min_level[i] = LVL_IMPL + 1;
  spell_info[spl].mana_max = 0;
  spell_info[spl].mana_min = 0;
  spell_info[spl].mana_change = 0;
  spell_info[spl].min_position = 0;
  spell_info[spl].targets = 0;
  spell_info[spl].violent = 0;
  spell_info[spl].routines = 0;
}

#define skillo(skill) spello(skill, 0, 0, 0, 0, 0, 0, 0);


/*
 * Arguments for spello calls:
 *
 * spellnum, maxmana, minmana, manachng, minpos, targets, violent?, routines.
 *
 * spellnum:  Number of the spell.  Usually the symbolic name as defined in
 * spells.h (such as SPELL_HEAL).
 *
 * maxmana :  The maximum mana this spell will take (i.e., the mana it
 * will take when the player first gets the spell).
 *
 * minmana :  The minimum mana this spell will take, no matter how high
 * level the caster is.
 *
 * manachng:  The change in mana for the spell from level to level.  This
 * number should be positive, but represents the reduction in mana cost as
 * the caster's level increases.
 *
 * minpos  :  Minimum position the caster must be in for the spell to work
 * (usually fighting or standing). targets :  A "list" of the valid targets
 * for the spell, joined with bitwise OR ('|').
 *
 * violent :  TRUE or FALSE, depending on if this is considered a violent
 * spell and should not be cast in PEACEFUL rooms or on yourself.  Should be
 * set on any spell that inflicts damage, is considered aggressive (i.e.
 * charm, curse), or is otherwise nasty.
 *
 * routines:  A list of magic routines which are associated with this spell
 * if the spell uses spell templates.  Also joined with bitwise OR ('|').
 *
 * See the CircleMUD documentation for a more detailed description of these
 * fields.
 */

/*
 * NOTE: SPELL LEVELS ARE NO LONGER ASSIGNED HERE AS OF Circle 3.0 bpl9.
 * In order to make this cleaner, as well as to make adding new classes
 * much easier, spell levels are now assigned in class.c.  You only need
 * a spello() call to define a new spell; to decide who gets to use a spell
 * or skill, look in class.c.  -JE 5 Feb 1996
 */

void mag_assign_spells(void)
{
  int i;

  /* Do not change the loop below */
  for (i = 1; i <= TOP_SPELL_DEFINE; i++)
    unused_spell(i);
  /* Do not change the loop above */

  /* Magias de Ataque */

  spello(SPELL_CREATE_LIGHT, 5, 5, 0, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_LIGHTNING_SPIT, 15, 7, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_METEOR_SHOWER, 5, 5, 0, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);
  
  spello(SPELL_FROST_SPIT, 25, 14, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_ACIDARROW, 50, 40, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_FIRE_SPIT, 42, 21, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_PHANTOM_FLAME, 12, 6, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_MINUTE_METEOR, 20, 10, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_CREATE_FLAMES, 20, 10, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_MAGIC_MISSILE, 20, 30, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_WINGED_KNIFE, 50, 40, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_GAS_SPIT, 60, 40, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_GREASE, 15, 15, 0, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_BLADEBARRIER, 50, 15, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_FLAMEARROW, 50, 30, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_ACID_SPIT, 56, 35, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_CORPOR_TREMBLING, 45, 30, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_DEATH_RIPPLE, 50, 25, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_CHILL_TOUCH, 70, 55, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_AFFECTS);

  spello(SPELL_CROMATIC_ORB, 40, 30, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_EGO_WHIP, 50, 40, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_BURNING_HANDS, 100, 60, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_GHASTLY_TOUCH, 112, 100, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_AFFECTS);

  spello(SPELL_PROJECT_FORCE, 160, 140, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_CALL_LIGHTNING, 160, 80, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_VOLCANO, 170, 150, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SHOCKING_GRASP, 200, 190, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_WRENCH, 200, 190, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_COLOR_SPRAY, 240, 200, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_AREA_LIGHTNING, 50, 50, 0, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_DEATH_WAVE, 200, 190, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_BALISTIC_ATTACK, 260, 240, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SHILLELAGH, 260, 240, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_HOLY_MACE, 80, 60, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_PSIONIC_BLAST, 50, 40, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SKULL_TRAP, 60, 60, 0, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_DISPEL_EVIL, 200, 120, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_DISPEL_GOOD, 200, 120, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_DISPEL_NEUTRAL, 200, 120, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_LIGHTNING_BOLT, 300, 280, 0, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_VAMPIRIC_TOUCH, 320, 280, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE | MAG_AFFECTS);

  spello(SPELL_ICE_HEART, 320, 280, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_ICEBOLT, 320, 300, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_EARTHQUAKE, 100, 60, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_MAGICAL_STONE, 340, 300, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_DETONATE, 360, 335, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_GLACIAL_CONE, 380, 300, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_HOLY_SHOUT, 140, 80, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_ELETRICSTORM, 180, 120, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_FIREBOLT, 380, 300, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_PSYCHIC_RAY, 400, 380, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_DEATH_FINGER, 400, 240, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_ICESTORM, 220, 210, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_POLTEIRGEIST, 400, 360, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_HARM, 450, 360, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_GEYSER, 240, 200, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_PRISMATIC_SPHERE, 500, 400, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_HOLY_WORD, 175, 135, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_FIRESTORM, 300, 280, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_MOLEC_AGITATION, 480, 440, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_METEORSTORM, 340, 320 , 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_COMMAND, 530, 400, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_BLIZZARD, 360, 340, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_DELAYED_FIREBALL, 520, 500, 1, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SIPHON_LIFE, 600, 340, 2, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_ARMAGEDDOM, 360, 330, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_END_WORLD, 500, 450, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_FIREBALL, 450, 440, 1, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_HOLY_BOLT, 255, 200, 2, POS_FIGHTING,
        TAR_IGNORE, TRUE, MAG_AREAS);

  spello(SPELL_ULTIMA, 400, 300, 1, POS_FIGHTING,
         TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_DAMAGE);

  spello(SPELL_SUMMON_BAHAMUT, 400, 300, 1, POS_FIGHTING,
	       TAR_IGNORE, TRUE, MAG_AREAS);
 

  spello(SPELL_ENERGY_DRAIN, 300, 200, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_POINTS);

  spello(SPELL_LIFE_DRAINING, 300, 180, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_POINTS);

  spello(SPELL_LEND_HEALTH, 240, 180, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_POINTS);

  spello(SPELL_PSYCHIC_DRAIN, 500, 420, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_POINTS);

  spello(SPELL_ARMOR, 18, 18, 0, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_MUIR, 0, 0, 0, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SELUNE, 0, 0, 0, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_ILMANATEUR, 0, 0, 0, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_BLESS, 60, 30, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_AURA_SIGHT, 80, 25, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_CONVICTION, 70, 50, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_CONCENTRATION, 70, 40, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_BODY_WEAPONRY, 180, 100, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_BODY_EQUILIBRIUM, 200, 120, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_BRAVERY, 350, 200, 5, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_COMBAT_MIND, 250, 150, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_ANTIMAGIC_SHELL, 140, 70, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_MINOR_GLOBE, 100, 50, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_MAJOR_GLOBE, 400, 200, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_BLINDNESS, 60, 20, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS);

  spello(SPELL_FEEL_LIGHT, 80, 40, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS);

  spello(SPELL_CURSE, 80, 50, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV, TRUE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_DETECT_ALIGN, 25, 15, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_INVIS, 30, 10, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_MAGIC, 35, 5, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DETECT_POISON, 15, 5, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);

  spello(SPELL_INFRAVISION, 30, 10, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_INVISIBLE, 60, 30, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_SUP_INVISIBLE, 120, 60, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_POISON, 70, 10, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_NOT_SELF | TAR_OBJ_INV, TRUE, MAG_AFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_PROT_FROM_EVIL, 130, 90, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_SANCTUARY, 210, 130, 5, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SLEEP, 600, 500, 3, POS_STANDING,
        TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_STRENGTH, 40, 30, 1, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_ENHANCED_STRENGTH, 180, 140, 1, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SENSE_LIFE, 70, 50, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_CLAIRAUDIENCE, 100, 80, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_CLAIRVOYANCE, 70, 40, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_WATERWALK, 110, 70, 1, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_HASTE, 220, 160, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_MANA_SHIELD, 150, 100, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DAMNED_CURSE, 130, 105, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS);

  spello(SPELL_PESTILENCE, 260, 210, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS);

  spello(SPELL_GOD_PACT, 250, 100, 5, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_SATAN_PACT, 250, 100, 5, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_MENTAL_RAGE, 600, 500, 10, POS_STANDING,
        TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_HOLD_PERSON, 600, 500, 10, POS_STANDING,
        TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_FLY, 220, 110, 2, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_VULCAN, 300, 200, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_ENTANGLE, 350, 250, 1, POS_STANDING,
        TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_FIRESHIELD, 360, 260, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_ADRENALINE, 420, 280, 2, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_FORCE_SHIELD, 120, 75, 3, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_ENHANCED_ARMOR, 110, 60, 3, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_SLOW, 120, 80, 5, POS_STANDING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_AFFECTS);
        
  spello(SPELL_THOUGHT_SHIELD, 65, 20, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);             

  spello(SPELL_BIOFEEDBACK, 85, 30, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);             

  spello(SPELL_MENTAL_BARRIER, 95, 40, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);             

  spello(SPELL_INERTIAL_BARRIER, 110, 50, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);             

  spello(SPELL_CELL_ADJUSTMENT, 140, 80, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);             

  spello(SPELL_IRON_SKIN, 150, 80, 3, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
        
  spello(SPELL_PLATINUM_SKIN, 220, 150, 3, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
        
  spello(SPELL_DIAMOND_SKIN, 290, 220, 3, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_HOLY_SHIELD, 200, 115, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);
        
  spello(SPELL_PARADI_CHRYSALIS, 500, 200, 7, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_ABUTILON, 450, 200, 7, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_FRIENDS, 70, 85, 3, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_EMPATHY, 75, 50, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_INTEL_FORTRESS, 185, 145, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_ADREN_CONTROL, 215, 165, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DUMBNESS, 50, 15, 3, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_AFFECTS);

  spello(SPELL_PAIN, 85, 40, 2, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_AFFECTS);

  spello(SPELL_DISPLACEMENT, 95, 50, 2, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_AFFECTS);

  spello(SPELL_PHANTOM_ARMOR, 90, 45, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_FLESH_ARMOR, 110, 55, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_SACRIFICE, 50, 25, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_SPECTRAL_WINGS, 150, 100, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_HOLY_FURY, 150, 120, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_CHAMPION_STRENGTH, 200, 130, 4, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_TERROR,  600, 500, 10, POS_FIGHTING,
	TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_AVERSION, 600, 500, 10, POS_FIGHTING,
	TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_CONFUSION,  600,500, 10, POS_FIGHTING,
	TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_ENGULFING_DARKNESS,  40, 15, 1, POS_FIGHTING,
    TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_BANSHEE_AURA, 80, 50, 1, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_BLINK, 50, 35, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_DEATHDANCE, 160, 120, 1, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS | MAG_POINTS);

  spello(SPELL_MARTIAL_TRANCE, 330, 220, 4, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

 spello(SPELL_PROT_FIRE, 20, 10, 2,
	 POS_STANDING, TAR_CHAR_ROOM, FALSE, MAG_AFFECTS);

  spello(SPELL_PETRIFY, 2400, 2000, 20, POS_STANDING,
        TAR_CHAR_ROOM, TRUE, MAG_AFFECTS);

  spello(SPELL_SATANIC_CURE, 200, 180, 3, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

 spello(SPELL_WRAITHFORM, 295, 155, 2, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  spello(SPELL_GROUP_ARMOR, 100, 50, 2, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_GROUP_HEAL, 300, 160, 3, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_GROUP_RECALL, 80, 60, 2, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_GROUPS);

 spello(SPELL_GROUP_FLY, 320, 200, 2, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_GROUP_BLESS, 96, 65, 2, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_GROUPS);

  spello(SPELL_CLONE, 650, 450, 5, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_SUMMONS);

  spello(SPELL_ANIMATE_DEAD, 170, 120, 3, POS_STANDING,
        TAR_OBJ_ROOM, FALSE, MAG_SUMMONS);

  spello(SPELL_GOLEM, 300, 220, 2, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_SUMMONS); /* read one of the  */

  spello(SPELL_ILLUSION, 75, 55, 3, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_SUMMONS); /* read one of the  */

  spello(SPELL_ELEMENTAL, 300, 250, 2, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_SUMMONS);
        
  spello(SPELL_CALL_BEAR, 300, 250, 2, POS_STANDING,
  	TAR_IGNORE, FALSE, MAG_SUMMONS);    

  spello(SPELL_CHARM, 300, 200, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_MANUAL);

  spello(SPELL_CONTROL_WEATHER, 75, 25, 5, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_MANUAL);

  spello(SPELL_CREATE_FOOD, 30, 15, 4, POS_STANDING,
        TAR_IGNORE, FALSE, MAG_CREATIONS);

  spello(SPELL_CREATE_WATER, 30, 15, 4, POS_STANDING,
        TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL);

  spello(SPELL_CURE_LIGHT, 30, 10, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_CURE_CRITIC, 60, 35, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_CURE_SERIOUS, 100, 50, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_HEAL, 150, 80, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_REGENERATION, 280, 200, 3, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_REVITALIZE, 120, 70, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_LAY_ON_HANDS, 130, 85, 4, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_REFRESH, 100, 80, 2, POS_RESTING,
        TAR_CHAR_ROOM, FALSE, MAG_POINTS);

  spello(SPELL_CURE_BLIND, 40, 15, 2, POS_STANDING,
        TAR_CHAR_ROOM, FALSE, MAG_UNAFFECTS);

  spello(SPELL_REMOVE_CURSE, 65, 45, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE,
        MAG_UNAFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_REMOVE_POISON, 60, 50, 2, POS_STANDING,
        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_UNAFFECTS | MAG_ALTER_OBJS);

  spello(SPELL_RIGID_THINKING, 210, 190, 2, POS_FIGHTING,
        TAR_CHAR_ROOM | TAR_NOT_SELF, TRUE, MAG_MANUAL);

  spello(SPELL_WALL_OF_FOG, 130, 90, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_ROOM);

  spello(SPELL_FIREWALL, 110, 65, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_ROOM);

  spello(SPELL_ICEWALL, 170, 115, 3, POS_STANDING,
	TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_ROOM);

  spello(SPELL_ENCHANT_WEAPON, 350, 100, 10, POS_STANDING,
        TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL);

  spello(SPELL_LOCATE_OBJECT, 85, 50, 1, POS_STANDING,
        TAR_OBJ_WORLD, FALSE, MAG_MANUAL);

  spello(SPELL_SUMMON, 225, 150, 3, POS_STANDING,
        TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);

  spello(SPELL_TELEPORT, 275, 135, 3, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_MANUAL);

  spello(SPELL_WORD_OF_RECALL, 35, 20, 2, POS_FIGHTING,
        TAR_CHAR_ROOM, FALSE, MAG_MANUAL);

  spello(SPELL_MANA_SWORD, 350, 250, 10, POS_STANDING,
        TAR_OBJ_INV | TAR_OBJ_EQUIP, FALSE, MAG_MANUAL);

  spello(SPELL_FARSIGHT, 185, 155, 3, POS_STANDING,
        TAR_CHAR_WORLD | TAR_NOT_SELF, FALSE, MAG_MANUAL);

  spello(SPELL_DEATH_SCYTHE, 800, 500, 1, POS_FIGHTING,
   TAR_IGNORE , FALSE, MAG_MANUAL);

  spello(SPELL_SIMULACRUM, 400, 300, 2, POS_STANDING,
   TAR_IGNORE, FALSE, MAG_MANUAL);

 spello(SPELL_PEACE, 90, 50, 0, POS_FIGHTING,
	TAR_CHAR_ROOM | TAR_FIGHT_VICT, TRUE, MAG_MANUAL);

  spello(SPELL_FEAR, 70, 40, 3, POS_FIGHTING,
	TAR_IGNORE, TRUE, MAG_MANUAL);
 
  spello(SPELL_OGHMA, 0, 0, 0, 0,
       TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);
 
  spello(SPELL_BARKSKIN, 50, 15, 1, POS_STANDING,
        TAR_CHAR_ROOM | TAR_SELF_ONLY, FALSE, MAG_AFFECTS);

  /* NON-castable spells should appear here */
  spello(SPELL_IDENTIFY, 0, 0, 0, 0,
        TAR_CHAR_ROOM | TAR_OBJ_INV | TAR_OBJ_ROOM, FALSE, MAG_MANUAL);

  spello(SPELL_RESTORE_MANA, 0, 0, 0, 0,
        TAR_SELF_ONLY, FALSE, MAG_POINTS);


  /*
   * Declaration of skills - this actually doesn't do anything except
   * set it up so that immortals can use these skills by default.  The
   * min level to use the skill for other classes is set up in class.c.
   */

  skillo(SKILL_BACKSTAB);
  skillo(SKILL_BASH);
  skillo(SKILL_HIDE);
  skillo(SKILL_KICK);
  skillo(SKILL_PICK_LOCK);
  skillo(SKILL_STROKE); 
  skillo(SKILL_RESCUE);
  skillo(SKILL_SNEAK);
  skillo(SKILL_STEAL);
  skillo(SKILL_TRACK);
  skillo(SKILL_COMBO);
  skillo(SKILL_SHIELD_BLOCK);

  skillo(SKILL_SWIM);
  skillo(SKILL_VITALIZE_HEALTH);
  skillo(SKILL_VITALIZE_MANA);
  skillo(SKILL_SPY);

  skillo(SKILL_SECOND_ATTACK);
  skillo(SKILL_THIRD_ATTACK);
  skillo(SKILL_FOURTH_ATTACK);
//  skillo(SKILL_FIFTH_ATTACK);
  skillo(SKILL_SCAN);
  skillo(SKILL_SABRE);
  skillo(SKILL_HAND_DAMAGE);
  skillo(SKILL_WHITE_GAS);
  skillo(SKILL_SUICIDE);
  skillo(SKILL_CIRCLE_ARROUND);
  skillo(SKILL_SECOND_STAB);
  skillo(SKILL_PARRY);
  skillo(SKILL_DODGE);
  skillo(SKILL_TUMBLE);
  skillo(SKILL_HIT);
  skillo(SKILL_STING);
  skillo(SKILL_WHIP);
  skillo(SKILL_SLASH);
  skillo(SKILL_BITE);
  skillo(SKILL_BLUDGEON);
  skillo(SKILL_CRUSH);
  skillo(SKILL_POUND);
  skillo(SKILL_CLAW);
  skillo(SKILL_MAUL);
  skillo(SKILL_THRASH);
  skillo(SKILL_PIERCE);
  skillo(SKILL_BLAST);
  skillo(SKILL_PUNCH);
  skillo(SKILL_STAB);
  skillo(SKILL_DISARM);
  skillo(SKILL_BERZERK);
  skillo(SKILL_FIRST_AID);
  skillo(SKILL_HEADBASH);
  skillo(SKILL_ESCAPE);
  skillo(SKILL_DUAL_WIELD);
  skillo(SKILL_MEDITATE);
  skillo(SKILL_LEVITATE);
  skillo(SKILL_LISTEN);
  skillo(SKILL_WARSHOUT);
  skillo(SKILL_KNOCKOUT);
  skillo(SKILL_THROW);
  skillo(SKILL_GUT);
  skillo(SKILL_DROWN);
  skillo(SKILL_CHOP);
  skillo(SKILL_KICKFLIP);
  skillo(SKILL_WHIRLWIND);
  //skillo(SKILL_SLANG)
}

void improve_skill(struct char_data *ch, int skill)
{
  int percent;
  int newpercent;
  char skillbuf[MAX_STRING_LENGTH];

  if(IS_NPC(ch))
     return;

  percent = GET_SKILL(ch, skill);
  if (number(1, 200) > GET_WIS(ch) + GET_INT(ch))
     return;
  if (percent >= 95 || percent <= 0)
     return;
  newpercent = number(3, 5);
  percent += newpercent;
  SET_SKILL(ch, skill, percent);
  if (newpercent >= 4) {
     sprintf(skillbuf, "&GYou feel your %s in &Y%s&G improving.&n\r\n", (skill > MAX_SPELLS ? "skill" : "spell"), spells[skill]);
     send_to_char(skillbuf, ch);
  }
}
::::::::::::::
spells.c
::::::::::::::
/* ************************************************************************
*   File: spells.c                                      Part of CircleMUD *
*  Usage: Implementation of "manual spells".  Circle 2.2 spell compat.    *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "spells.h"
#include "handler.h"
#include "db.h"
#include "constants.h"
#include "screen.h"
#include "buffer.h"
#include "dg_scripts.h"

extern sh_int r_mortal_start_room;
extern int top_of_world;
extern char *spells[];
extern struct room_data *world;
extern struct obj_data *object_list;
extern struct char_data *character_list;
extern struct index_data *obj_index;
extern struct descriptor_data *descriptor_list;
extern struct zone_data *zone_table;

extern int mini_mud;
extern int pk_allowed;

extern struct default_mobile_stats *mob_defaults;
extern struct apply_mod_defaults *apmd;

void clearMemory(struct char_data * ch);
void weight_change_object(struct obj_data * obj, int weight);
void add_follower(struct char_data * ch, struct char_data * leader);
int mag_savingthrow(struct char_data * ch, int type);
void name_to_drinkcon(struct obj_data * obj, int type);
void name_from_drinkcon(struct obj_data * obj);
char *howstat(int percent);
void list_obj_to_char(struct obj_data * list, struct char_data * ch, int mode, int show);
void list_char_to_char(struct char_data * list, struct char_data * ch);

/*
 * Special spells appear below.
 */

ASPELL(spell_create_water)
{
  int water;

  if (ch == NULL || obj == NULL)
    return;

  if (GET_OBJ_TYPE(obj) == ITEM_DRINKCON) {
    if ((GET_OBJ_VAL(obj, 2) != LIQ_WATER) && (GET_OBJ_VAL(obj, 1) != 0)) {
//      name_from_drinkcon(obj);
      GET_OBJ_VAL(obj, 2) = LIQ_SLIME;
      name_to_drinkcon(obj, LIQ_SLIME);
    } else {
      water = MAX(GET_OBJ_VAL(obj, 0) - GET_OBJ_VAL(obj, 1), 0);
      if (water > 0) {
/*        if (GET_OBJ_VAL(obj, 1) >= 0)
          name_from_drinkcon(obj);*/
        GET_OBJ_VAL(obj, 2) = LIQ_WATER;
        GET_OBJ_VAL(obj, 1) += water;
//        name_to_drinkcon(obj, LIQ_WATER);
        weight_change_object(obj, water);
        act("$p is filled.", FALSE, ch, obj, 0, TO_CHAR);
      }
    }
  }
}


ASPELL(spell_recall)
{
  if (victim == NULL || IS_NPC(victim))
    return;

 if (ZONE_FLAGGED(world[victim->in_room].zone, ZONE_NORECALL)) {
   act("A divine force mantains $n in the same place.", TRUE, victim, 0, 0, TO_ROOM);
   act("A divine force mantains you in the same place.", FALSE, ch, 0, 0, TO_CHAR);
 }  
 else { 
  act("$n disappears.", TRUE, victim, 0, 0, TO_ROOM);
  char_from_room(victim);
  char_to_room(victim, r_mortal_start_room);
  act("$n appears in the middle of the room.", TRUE, victim, 0, 0, TO_ROOM);
  look_at_room(victim, 0);
 } 
}

int cant_teleport(int to_room)
{
	if(!ZONE_FLAGGED(world[to_room].zone, ZONE_OPEN) && 
	   !ZONE_FLAGGED(world[to_room].zone, ZONE_CLOSED))
	   return TRUE;
	   
        if(ZONE_FLAGGED(world[to_room].zone, ZONE_NORECALL) ||
           ZONE_FLAGGED(world[to_room].zone, ZONE_NOSUMMON) ||
           ZONE_FLAGGED(world[to_room].zone, ZONE_CLOSED))
           return TRUE;

        if(ROOM_FLAGGED(to_room, ROOM_PRIVATE | ROOM_DEATH | ROOM_NOMAGIC))
           return TRUE;

   return FALSE;
}

ASPELL(spell_teleport)
{
  int to_room;

  if (victim == NULL || IS_NPC(victim))
    return;

  do {
    to_room = number(2, top_of_world);
  } while (cant_teleport(to_room));
         
  act("$n slowly fades out of existence and is gone.",
      FALSE, victim, 0, 0, TO_ROOM);
  char_from_room(victim);
  char_to_room(victim, to_room);
  act("$n slowly fades into existence.", FALSE, victim, 0, 0, TO_ROOM);
  look_at_room(victim, 0);
}

#define SUMMON_FAIL "You failed.\r\n"

ASPELL(spell_summon)
{
  if (ch == NULL || victim == NULL)
    return;

  if ((GET_LEVEL(victim) > MIN(LVL_IMMORT - 1, level + 3)) || (PLR_FLAGGED(victim, PLR_DEAD))) {
    send_to_char(SUMMON_FAIL, ch);
    return;
  }

  if (MOB_FLAGGED(victim, MOB_AGGRESSIVE)) {
    act("As the words escape your lips and $N travels\r\n"
        "through time and space towards you, you realize that $E is\r\n"
        "aggressive and might harm you, so you wisely send $M back.",
        FALSE, ch, 0, victim, TO_CHAR);
    return;
  }
  
   if ((ZONE_FLAGGED(world[ch->in_room].zone, ZONE_NOSUMMON) ||
        ZONE_FLAGGED(world[victim->in_room].zone, ZONE_NOSUMMON)) &&
       (world[ch->in_room].zone != world[victim->in_room].zone)) {
    sprintf(buf, "%s just tried to summon you to: %s.\r\n"
            "%s failed because you are in another dimension.\r\n",
            GET_NAME(ch), world[ch->in_room].name,
            (ch->player.sex == SEX_MALE) ? "He" : "She");
    send_to_char(buf, victim);

    sprintf(buf, "You failed because %s is in another dimension.\r\n",
            GET_NAME(victim));
    send_to_char(buf, ch);

    sprintf(buf, "%s failed summoning %s to %s.",
            GET_NAME(ch), GET_NAME(victim), world[ch->in_room].name);
    mudlog(buf, BRF, LVL_IMMORT, TRUE);
    return;
  }
  
  if (!IS_NPC(victim) && !PRF_FLAGGED(victim, PRF_SUMMONABLE) &&
      !PLR_FLAGGED(victim, PLR_KILLER) && !PLR_FLAGGED(victim, PLR_THIEF)) {
    sprintf(buf, "%s just tried to summon you to: %s.\r\n"
            "%s failed because you have summon protection on.\r\n"
            "Type NOSUMMON to allow other players to summon you.\r\n",
            GET_NAME(ch), world[ch->in_room].name,
            (ch->player.sex == SEX_MALE) ? "He" : "She");
    send_to_char(buf, victim);

    sprintf(buf, "You failed because %s has summon protection on.\r\n",
            GET_NAME(victim));
    send_to_char(buf, ch);

    sprintf(buf, "%s failed summoning %s to %s.",
            GET_NAME(ch), GET_NAME(victim), world[ch->in_room].name);
    mudlog(buf, BRF, LVL_IMMORT, TRUE);
    return;
  }

  if (MOB_FLAGGED(victim, MOB_NOSUMMON) ||
      (IS_NPC(victim) && mag_savingthrow(victim, SAVING_SPELL))) {
    send_to_char(SUMMON_FAIL, ch);
    return;
  }

  act("$n disappears suddenly.", TRUE, victim, 0, 0, TO_ROOM);

  char_from_room(victim);
  char_to_room(victim, ch->in_room);

  act("$n arrives suddenly.", TRUE, victim, 0, 0, TO_ROOM);
  act("$n has summoned you!", FALSE, ch, 0, victim, TO_VICT);
  look_at_room(victim, 0);
}



ASPELL(spell_locate_object)
{
  struct obj_data *i;
  char name[MAX_INPUT_LENGTH];
  int j;

  /*
   * FIXME: This is broken.  The spell parser routines took the argument
   * the player gave to the spell and located an object with that keyword.
   * Since we're passed the object and not the keyword we can only guess
   * at what the player originally meant to search for. -gg
   */
  strcpy(name, fname(obj->name));
  j = level / 2;

  for (i = object_list; i && (j > 0); i = i->next) {
    if (!isname(name, i->name))
      continue;

    if (i->carried_by)
      sprintf(buf, "%s is being carried by %s.\r\n",
              i->short_description, PERS(i->carried_by, ch));
    else if (i->in_room != NOWHERE)
      sprintf(buf, "%s is in %s.\r\n", i->short_description,
              world[i->in_room].name);
    else if (i->in_obj)
      sprintf(buf, "%s is in %s.\r\n", i->short_description,
              i->in_obj->short_description);
    else if (i->worn_by)
      sprintf(buf, "%s is being worn by %s.\r\n",
              i->short_description, PERS(i->worn_by, ch));
    else
      sprintf(buf, "%s's location is uncertain.\r\n",
              i->short_description);

    CAP(buf);
    send_to_char(buf, ch);
    j--;
  }

  if (j == level / 2)
    send_to_char("You sense nothing.\r\n", ch);
}



ASPELL(spell_charm)
{
  struct affected_type af;

  if (victim == NULL || ch == NULL)
    return;

  if (victim == ch)
    send_to_char("You like yourself even better!\r\n", ch);
  else if (!IS_NPC(victim))
    send_to_char("You fail because SUMMON protection is on!\r\n", ch);
  else if (AFF_FLAGGED(victim, AFF_SANCTUARY))
    send_to_char("Your victim is protected by sanctuary!\r\n", ch);
  else if (MOB_FLAGGED(victim, MOB_NOCHARM))
    send_to_char("Your victim resists!\r\n", ch);
  else if (AFF_FLAGGED(ch, AFF_CHARM))
    send_to_char("You can't have any followers of your own!\r\n", ch);
  else if (AFF_FLAGGED(victim, AFF_CHARM) || level < GET_LEVEL(victim))
    send_to_char("You fail.\r\n", ch);
  /* player charming another player - no legal reason for this */
  else if (!pk_allowed && !IS_NPC(victim))
    send_to_char("You fail - shouldn't be doing it anyway.\r\n", ch);
  else if (circle_follow(victim, ch))
    send_to_char("Sorry, following in circles can not be allowed.\r\n", ch);
  else if (!allow_follower(ch, 5))
	send_to_char("You can't have any more followers.\n\r", ch);
  else if (mag_savingthrow(victim, SAVING_PARA))
    send_to_char("Your victim resists!\r\n", ch);
  else if (mag_savingthrow(victim, SAVING_SPELL))
    send_to_char("Your victim resists!\r\n", ch);

  else {
    if (victim->master)
      stop_follower(victim);

    add_follower(victim, ch);

    af.type = SPELL_CHARM;

    if (GET_INT(victim))
      af.duration = 20 * 10 / GET_INT(victim);
    else
      af.duration = 24;

    af.modifier = 0;
    af.location = 0;
    af.bitvector = AFF_CHARM;
    af.bitvector2 = AFF_CHARM;
    af.bitvector3 = AFF_CHARM;
    affect_to_char(victim, &af);

    act("Isn't $n just such a nice fellow?", FALSE, ch, 0, victim, TO_VICT);
    if (IS_NPC(victim)) {
      REMOVE_BIT(MOB_FLAGS(victim), MOB_AGGRESSIVE);
      REMOVE_BIT(MOB_FLAGS(victim), MOB_SPEC);
    }
  }
}


ASPELL(spell_rigid_thinking)
{
  struct affected_type af;

  if (victim == NULL || ch == NULL)
    return;

  if (victim == ch)
    send_to_char("You like yourself even better!\r\n", ch);
  else if (!IS_NPC(victim))
    send_to_char("You fail because SUMMON protection is on!\r\n", ch);
  else if (AFF_FLAGGED(victim, AFF_SANCTUARY))
    send_to_char("Your victim is protected by sanctuary!\r\n", ch);
  else if (MOB_FLAGGED(victim, MOB_NOCHARM))
    send_to_char("Your victim resists!\r\n", ch);
  else if (AFF_FLAGGED(ch, AFF_CHARM))
    send_to_char("You can't have any followers of your own!\r\n", ch);
  else if (AFF_FLAGGED(victim, AFF_CHARM) || level < GET_LEVEL(victim))
    send_to_char("You fail.\r\n", ch);
  /* player charming another player - no legal reason for this */
  else if (!pk_allowed && !IS_NPC(victim))
    send_to_char("You fail - shouldn't be doing it anyway.\r\n", ch);
  else if (circle_follow(victim, ch))
    send_to_char("Sorry, following in circles can not be allowed.\r\n", ch);
  else if (!allow_follower(ch, 5))
	send_to_char("You can't have any more followers.\n\r", ch);
  else if (mag_savingthrow(victim, SAVING_PARA))
    send_to_char("Your victim resists!\r\n", ch);
  else if(mag_savingthrow(victim, SAVING_PARA))
    send_to_char("Your victim resists!\r\n", ch);

  else {
    if (victim->master)
      stop_follower(victim);

    add_follower(victim, ch);

    af.type = SPELL_CHARM;

    if (GET_INT(victim))
      af.duration = 20 * 10 / GET_INT(victim);
    else
      af.duration = 24;

    af.modifier = 0;
    af.location = 0;
    af.bitvector = AFF_CHARM;
    af.bitvector2 = AFF_CHARM;
    af.bitvector3 = AFF_CHARM;
    affect_to_char(victim, &af);

    act("Isn't $n just such a nice fellow?", FALSE, ch, 0, victim, TO_VICT);
    if (IS_NPC(victim)) {
      REMOVE_BIT(MOB_FLAGS(victim), MOB_AGGRESSIVE);
      REMOVE_BIT(MOB_FLAGS(victim), MOB_SPEC);
    }
  }
}


ASPELL(spell_identify)
{
  int i;
  int found;
  int remort, obj_level;
  double peso;
  
  if (obj) {
    send_to_char("You feel informed:\r\n", ch);
    sprintf(buf, "Object '%s', Item type: ", obj->short_description);
    sprinttype(GET_OBJ_TYPE(obj), item_types, buf2);
    strcat(buf, buf2);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);

    if (obj->obj_flags.bitvector) {
      send_to_char("Item will give you following abilities:  ", ch);
      sprintbit(obj->obj_flags.bitvector, affected_bits, buf);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
    }
    send_to_char("Item is: ", ch);
    sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);

    obj_level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
    if ((obj_level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
     obj_level = (LVL_IMMORT - 1);	
     remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
    } 
    else{
       remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
    } 
    peso = GET_OBJ_WEIGHT(obj);
    peso /= 10;
    sprintf(buf, "Weight: %.1fkg, Value: %d, Level: %d, Remorts: %d\r\n",
            peso, GET_OBJ_COST(obj)/*, GET_OBJ_RENT(obj)*/,
            obj_level, remort);
    send_to_char(buf, ch);

    switch (GET_OBJ_TYPE(obj)) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      sprintf(buf, "This %s casts: ", item_types[(int) GET_OBJ_TYPE(obj)]);

      if (GET_OBJ_VAL(obj, 1) >= 1)
        sprintf(buf + strlen(buf), " %s", spells[GET_OBJ_VAL(obj, 1)]);
      if (GET_OBJ_VAL(obj, 2) >= 1)
        sprintf(buf + strlen(buf), " %s", spells[GET_OBJ_VAL(obj, 2)]);
      if (GET_OBJ_VAL(obj, 3) >= 1)
        sprintf(buf + strlen(buf), " %s", spells[GET_OBJ_VAL(obj, 3)]);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      sprintf(buf, "This %s casts: ", item_types[(int) GET_OBJ_TYPE(obj)]);
      sprintf(buf + strlen(buf), " %s\r\n", spells[GET_OBJ_VAL(obj, 3)]);
      sprintf(buf + strlen(buf), "It has %d maximum charge%s and %d remaining.\r\n",
              GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 1) == 1 ? "" : "s",
              GET_OBJ_VAL(obj, 2));
      send_to_char(buf, ch);
      break;
    case ITEM_WEAPON:
      sprintf(buf, "Damage Dice is '%dD%d'", GET_OBJ_VAL(obj, 1),
              GET_OBJ_VAL(obj, 2));
      sprintf(buf + strlen(buf), " for an average per-round damage of %.1f.\r\n",
              (((GET_OBJ_VAL(obj, 2) + 1) / 2.0) * GET_OBJ_VAL(obj, 1)));
      send_to_char(buf, ch);
      break;
    case ITEM_ARMOR:
      sprintf(buf, "AC-apply is %d\r\n", GET_OBJ_VAL(obj, 0));
      send_to_char(buf, ch);
      break;
    }
    found = FALSE;
    for (i = 0; i < MAX_OBJ_AFFECT; i++) {
      if ((obj->affected[i].location != APPLY_NONE) &&
          (obj->affected[i].modifier != 0)) {
        if (!found) {
          send_to_char("Can affect you as :\r\n", ch);
          found = TRUE;
        }
        sprinttype(obj->affected[i].location, apply_types, buf2);
        sprintf(buf, "   Affects: %s By %d\r\n", buf2, obj->affected[i].modifier);
        send_to_char(buf, ch);
      }
    }
  } else if (victim) {          /* victim */
    sprintf(buf, "Name: %s\r\n", GET_NAME(victim));
    send_to_char(buf, ch);
    if (!IS_NPC(victim)) {
      sprintf(buf, "%s is %d years, %d months, %d days and %d hours old.\r\n",
              GET_NAME(victim), age(victim)->year, age(victim)->month,
              age(victim)->day, age(victim)->hours);
      send_to_char(buf, ch);
    }
    sprintf(buf, "Height %d cm, Weight %d pounds\r\n",
            GET_HEIGHT(victim), GET_WEIGHT(victim));
    sprintf(buf + strlen(buf), "Level: %d, Remort: %d, Hit: %d, Mana: %d, Move: %d\r\n",
            GET_LEVEL(victim), GET_REMORT(victim), GET_HIT(victim), GET_MANA(victim), GET_MOVE(victim));
    sprintf(buf + strlen(buf), "AC: %d, Hitroll: %d, Damroll: %d\r\n",
            GET_AC(victim), GET_HITROLL(victim), GET_DAMROLL(victim));
    send_to_char(buf, ch);

  }
}

ASPELL(spell_oghma)
{
  int i;
  int found;
  int remort, obj_level;
  double peso;
  int at2 = 0 ;
  int at3 = 0 ;
  int at4 = 0 ;
  int dam = 0 ; 
  struct obj_data *wielded = GET_EQ(victim, WEAR_WIELD);


  if (obj) {
    send_to_char("You feel informed:\r\n", ch);
    sprintf(buf, "Object '%s', Item type: ", obj->short_description);
    sprinttype(GET_OBJ_TYPE(obj), item_types, buf2);
    strcat(buf, buf2);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);

    if (obj->obj_flags.bitvector) {
      send_to_char("Item will give you following abilities:  ", ch);
      sprintbit(obj->obj_flags.bitvector, affected_bits, buf);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
    }
    send_to_char("Item is: ", ch);
    sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf);
    strcat(buf, "\r\n");
    send_to_char(buf, ch);

    obj_level = (GET_OBJ_LEVEL(obj)-((LVL_IMMORT - 1)*(GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1))));
    if ((obj_level == 0) && (GET_OBJ_LEVEL(obj) > 0)){
     obj_level = (LVL_IMMORT - 1);	
     remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1)) - 1;
    } 
    else{
       remort = (GET_OBJ_LEVEL(obj)/(LVL_IMMORT - 1));
    } 
    peso = GET_OBJ_WEIGHT(obj);
    peso /= 10;
    sprintf(buf, "Weight: %.1fkg, Value: %d, Level: %d, Remorts: %d\r\n",
            peso, GET_OBJ_COST(obj)/*, GET_OBJ_RENT(obj)*/,
            obj_level, remort);
    send_to_char(buf, ch);

    switch (GET_OBJ_TYPE(obj)) {
    case ITEM_SCROLL:
    case ITEM_POTION:
      sprintf(buf, "This %s casts: ", item_types[(int) GET_OBJ_TYPE(obj)]);

      if (GET_OBJ_VAL(obj, 1) >= 1)
        sprintf(buf + strlen(buf), " %s", spells[GET_OBJ_VAL(obj, 1)]);
      if (GET_OBJ_VAL(obj, 2) >= 1)
        sprintf(buf + strlen(buf), " %s", spells[GET_OBJ_VAL(obj, 2)]);
      if (GET_OBJ_VAL(obj, 3) >= 1)
        sprintf(buf + strlen(buf), " %s", spells[GET_OBJ_VAL(obj, 3)]);
      strcat(buf, "\r\n");
      send_to_char(buf, ch);
      break;
    case ITEM_WAND:
    case ITEM_STAFF:
      sprintf(buf, "This %s casts: ", item_types[(int) GET_OBJ_TYPE(obj)]);
      sprintf(buf + strlen(buf), " %s\r\n", spells[GET_OBJ_VAL(obj, 3)]);
      sprintf(buf + strlen(buf), "It has %d maximum charge%s and %d remaining.\r\n",
              GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 1) == 1 ? "" : "s",
              GET_OBJ_VAL(obj, 2));
      send_to_char(buf, ch);
      break;
    case ITEM_WEAPON:
      sprintf(buf, "Damage Dice is '%dD%d'", GET_OBJ_VAL(obj, 1),
              GET_OBJ_VAL(obj, 2));
      sprintf(buf + strlen(buf), " for an average per-round damage of %.1f.\r\n",
              (((GET_OBJ_VAL(obj, 2) + 1) / 2.0) * GET_OBJ_VAL(obj, 1)));
      send_to_char(buf, ch);
      break;
    case ITEM_ARMOR:
      sprintf(buf, "AC-apply is %d\r\n", GET_OBJ_VAL(obj, 0));
      send_to_char(buf, ch);
      break;
    }
    found = FALSE;
    for (i = 0; i < MAX_OBJ_AFFECT; i++) {
      if ((obj->affected[i].location != APPLY_NONE) &&
          (obj->affected[i].modifier != 0)) {
        if (!found) {
          send_to_char("Can affect you as :\r\n", ch);
          found = TRUE;
        }
        sprinttype(obj->affected[i].location, apply_types, buf2);
        sprintf(buf, "   Affects: %s By %d\r\n", buf2, obj->affected[i].modifier);
        send_to_char(buf, ch);
      }
    }
  } else if (victim) {          /* victim */
    sprintf(buf, "Name: %s\r\n", GET_NAME(victim));
    send_to_char(buf, ch);
    if (!IS_NPC(victim)) {
      sprintf(buf, "%s is %d years, %d months, %d days and %d hours old.\r\n",
              GET_NAME(victim), age(victim)->year, age(victim)->month,
              age(victim)->day, age(victim)->hours);
      send_to_char(buf, ch);
    }
    sprintf(buf, "Height %d cm, Weight %d pounds\r\n",
            GET_HEIGHT(victim), GET_WEIGHT(victim));
    sprintf(buf + strlen(buf), "Level: %d, Remort: %d, Hit: %d, Mana: %d, Move: %d\r\n",
            GET_LEVEL(victim), GET_REMORT(victim), GET_HIT(victim), GET_MANA(victim), GET_MOVE(victim));
    sprintf(buf + strlen(buf), "AC: %d, Hitroll: %d, Damroll: %d\r\n",
            GET_AC(victim), GET_HITROLL(victim), GET_DAMROLL(victim));
    send_to_char(buf, ch);

    sprintf(buf, "GOLD: %d, Experience: %d\r\n",
            GET_GOLD(victim), GET_EXP(victim));
    send_to_char(buf, ch);
   
   if(IS_NPC(victim))
   {
    at2 = victim->mob_specials.attack1 ; 
    at3 = victim->mob_specials.attack2 ;
    at4 = victim->mob_specials.attack3 ;
   }
    else
   {
    at2 =  GET_SKILL_LS(victim, SKILL_SECOND_ATTACK);
    at3 =  GET_SKILL_LS(victim, SKILL_THIRD_ATTACK);
    at4 =  GET_SKILL_LS(victim, SKILL_FOURTH_ATTACK);
   } 
  
    sprintf(buf , "ATT2: %d, ATT3: %d, ATT4: %d\r\n",
             at2, at3, at4);
    send_to_char(buf, ch) ; 

    dam = str_app[STRENGTH_APPLY_INDEX(victim)].todam;
    dam += GET_DAMROLL(victim);

    if (wielded && GET_OBJ_TYPE(wielded) == ITEM_WEAPON) {
      dam += ((dice(GET_OBJ_VAL(wielded, 1), GET_OBJ_VAL(wielded, 2))*GET_OBJ_COND(wielded))/100);
    } else {
      if (IS_NPC(victim)) {
        dam += victim->mob_specials.damnodice *
        (victim->mob_specials.damsizedice+1) * 0.5 ; 
      } else {
        dam += number(GET_LEVEL(victim) / 40, GET_LEVEL(victim) / 20);
      }
    }

    if(!IS_NPC(victim)){
       if (!wielded && GET_SKILL(victim, SKILL_HAND_DAMAGE)){
          dam += 1 + (SKILL_HAND_DAMAGE / 50);
       }
    }

    sprintf(buf , "Dano medio aproximado: %d\r\n",
             dam);
    send_to_char(buf, ch) ;
  }
}



ASPELL(spell_enchant_weapon)
{
  int i;

  if (ch == NULL || obj == NULL)
    return;

  if ((GET_OBJ_TYPE(obj) == ITEM_WEAPON) &&
      !OBJ_FLAGGED(obj, ITEM_MAGIC)) {

    for (i = 0; i < MAX_OBJ_AFFECT; i++)
      if (obj->affected[i].location != APPLY_NONE)
        return;

    SET_BIT(GET_OBJ_EXTRA(obj), ITEM_MAGIC);

    obj->affected[0].location = APPLY_HITROLL;
    obj->affected[0].modifier = div(level, 50).quot;

    obj->affected[1].location = APPLY_DAMROLL;
    obj->affected[1].modifier = 1 + div(level, 50).quot;

    if (IS_GOOD(ch)) {
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_ANTI_EVIL);
      act("$p glows blue.", FALSE, ch, obj, 0, TO_CHAR);
    } else if (IS_EVIL(ch)) {
      SET_BIT(GET_OBJ_EXTRA(obj), ITEM_ANTI_GOOD);
      act("$p glows red.", FALSE, ch, obj, 0, TO_CHAR);
    } else {
      act("$p glows yellow.", FALSE, ch, obj, 0, TO_CHAR);
    }
  }
}


ASPELL(spell_detect_poison)
{
  if (victim) {
    if (victim == ch) {
      if (AFF_FLAGGED(victim, AFF_POISON))
        send_to_char("You can sense poison in your blood.\r\n", ch);
      else
        send_to_char("You feel healthy.\r\n", ch);
    } else {
      if (AFF_FLAGGED(victim, AFF_POISON))
        act("You sense that $E is poisoned.", FALSE, ch, 0, victim, TO_CHAR);
      else
        act("You sense that $E is healthy.", FALSE, ch, 0, victim, TO_CHAR);
    }
  }

  if (obj) {
    switch (GET_OBJ_TYPE(obj)) {
    case ITEM_DRINKCON:
    case ITEM_FOUNTAIN:
    case ITEM_FOOD:
      if (GET_OBJ_VAL(obj, 3))
        act("You sense that $p has been contaminated.",FALSE,ch,obj,0,TO_CHAR);
      else
        act("You sense that $p is safe for consumption.", FALSE, ch, obj, 0,
            TO_CHAR);
      break;
    default:
      send_to_char("You sense that it should not be consumed.\r\n", ch);
    }
  }
}
void farsight(struct char_data * ch, struct char_data * vc)
{
  if (!vc->desc)
    return;

  if (IS_DARK(ch->in_room) && !CAN_SEE_IN_DARK(ch)) {
    send_to_char("It is pitch black...\r\n", vc);
    return;
  } else if (AFF_FLAGGED(ch, AFF_BLIND)) {
    send_to_char("You see nothing but infinite darkness...\r\n", vc);
    return;
  }
	if (ROOM_AFFECTED(ch->in_room, RAFF_FOG)) {
		/* NOTE: you might wish to change so that wizards,
		 * or the use of some 'see through fog' makes you see 
		 * through the fog
		 */
		send_to_char("Your view is obscured by a thick fog.\r\n", vc);
		return;
	}

  send_to_char(CCCYN(ch, C_NRM), vc);
  send_to_char(world[ch->in_room].name, vc);

  send_to_char(CCNRM(ch, C_NRM), vc);
  send_to_char("\r\n", vc);

  send_to_char(world[ch->in_room].description, vc);

  if (ROOM_AFFECTED(ch->in_room, RAFF_FIREWALL))
    send_to_char("&RYou see a large &Yfirewall&R here.&n\r\n", vc);
  if (ROOM_AFFECTED(ch->in_room, RAFF_ICEWALL))
    send_to_char("&CYou see a &Bicewall&C here.&n\r\n", vc);

  /* now list characters & objects */
  send_to_char(CCGRN(ch, C_NRM), vc);
  list_obj_to_char(world[ch->in_room].contents, vc, 0, FALSE);
  send_to_char(CCYEL(ch, C_NRM), vc);
  list_char_to_char(world[ch->in_room].people, vc);
  send_to_char(CCNRM(ch, C_NRM), vc);
}

ASPELL(spell_farsight)
{
  if (ch == NULL || victim == NULL)
    return;

  if ((GET_LEVEL(victim) > MIN(LVL_IMMORT - 1, level + 3)) || (PLR_FLAGGED(victim, PLR_DEAD))) {
    send_to_char(SUMMON_FAIL, ch);
    return;
  }

   if ((ZONE_FLAGGED(world[ch->in_room].zone, ZONE_NOSUMMON) ||
        ZONE_FLAGGED(world[victim->in_room].zone, ZONE_NOSUMMON)) &&
       (world[ch->in_room].zone != world[victim->in_room].zone)) {

    sprintf(buf, "You failed because %s is in another dimension.\r\n",
            GET_NAME(victim));
    send_to_char(buf, ch);

    return;
  }

  send_to_char("&CYou concentrate and see the world with other eyes...&n\r\n\r\n", ch);
  farsight(victim, ch);
}

void weather_chang(int modifier)
{
  int diff, change;

  diff = modifier;

  weather_info.change += (dice(1, 4) * diff + dice(2, 6) - dice(2, 6));

  weather_info.change = MIN(weather_info.change, 12);
  weather_info.change = MAX(weather_info.change, -12);

  weather_info.pressure += weather_info.change;

  weather_info.pressure = MIN(weather_info.pressure, 1040);
  weather_info.pressure = MAX(weather_info.pressure, 960);

  change = 0;

  switch (weather_info.sky) {
  case SKY_CLOUDLESS:
    if (weather_info.pressure < 990)
      change = 1;
    else if (weather_info.pressure < 1010)
      if (dice(1, 4) == 1)
        change = 1;
    break;
  case SKY_CLOUDY:
    if (weather_info.pressure < 970)
      change = 2;
    else if (weather_info.pressure < 990) {
      if (dice(1, 4) == 1)
        change = 2;
      else
        change = 0;
    } else if (weather_info.pressure > 1030)
      if (dice(1, 4) == 1)
        change = 3;

    break;
  case SKY_RAINING:
    if (weather_info.pressure < 970) {
      if (dice(1, 4) == 1)
        change = 4;
      else
        change = 0;
    } else if (weather_info.pressure > 1030)
      change = 5;
    else if (weather_info.pressure > 1010)
      if (dice(1, 4) == 1)
        change = 5;

    break;
  case SKY_LIGHTNING:
    if (weather_info.pressure > 1010)
      change = 6;
    else if (weather_info.pressure > 990)
      if (dice(1, 4) == 1)
        change = 6;

    break;
  default:
    change = 0;
    weather_info.sky = SKY_CLOUDLESS;
    break;
  }

  switch (change) {
  case 0:
    break;
  case 1:
    send_to_outdoor("&WThe sky starts to get cloudy.&n\r\n");
    weather_info.sky = SKY_CLOUDY;
    break;
  case 2:
    send_to_outdoor("&cIt starts to rain.&n\r\n");
    weather_info.sky = SKY_RAINING;
    break;
  case 3:
    send_to_outdoor("&wThe clouds disappear.&n\r\n");
    weather_info.sky = SKY_CLOUDLESS;
    break;
  case 4:
    send_to_outdoor("&CLightning starts to show in the sky.&n\r\n");
    weather_info.sky = SKY_LIGHTNING;
    break;
  case 5:
    send_to_outdoor("&cThe rain stops.&n\r\n");
    weather_info.sky = SKY_CLOUDY;
    break;
  case 6:
    send_to_outdoor("&CThe lightning stops.&n\r\n");
    weather_info.sky = SKY_RAINING;
    break;
  default:
    break;
  }
}

ASPELL(spell_control_weather)
{
  int modifier;

  if (ch == NULL)
    return;
     
  send_to_char("You draw upon the strength of your loyalty to Dis, the Elder God!\r\n", ch);
  send_to_room("The heavens stir as the forces of nature are changed!\r\n", ch->in_room);

  /* weather_info.pressure limits are now 940 - 1040 and
     weather_info.change is limited to +/- 12 anyhow */
  modifier = (int) div(GET_LEVEL(ch), 100).quot;

  /* the weather becomes better if the caster is inside and worse if outside */
  if (OUTSIDE(ch)) {
    modifier *= -1;
    send_to_room("A cold arctic wind blows from the north.\r\n", ch->in_room);
  } else {
    send_to_room("A warm wind blows from the south.\r\n", ch->in_room);
  }

  weather_chang(modifier);
}

ASPELL(spell_death_scythe)
{
  obj = read_object(99, VIRTUAL); // !rent
  GET_OBJ_WEIGHT(obj) = 1 ;
  GET_OBJ_VAL(obj, 2) = GET_LEVEL(ch); 
  GET_OBJ_VAL(obj, 1) = 2;  
  REMOVE_BIT(obj->obj_flags.extra_flags, ITEM_ANTI_EVIL);
  GET_OBJ_LEVEL(obj) = (GET_LEVEL(ch)/2); 
  obj_to_char(obj, ch);
  send_to_char("Death sends its scythe to help you.\r\n", ch);
}

#define MANA_COST (GET_MANA(ch));
ASPELL(spell_simulacrum)
{
 struct char_data *mob;

 if (!allow_follower(ch, 3))
 {
  send_to_char("You can't have any more followers.\n\r", ch);
  return;
 }

 if (number(0, 101) < 26)
 {
  send_to_char("You failed.\r\n", ch);
  return;
 }

 mob = read_mobile(29, VIRTUAL);
 GET_LEVEL(mob) = GET_LEVEL(ch);
 GET_MAX_HIT(mob) = (GET_MAX_HIT(ch)/2);
 GET_HITROLL(mob) = (GET_HITROLL(ch)/2);
 GET_DAMROLL(mob) = (GET_DAMROLL(ch)/2);
 GET_AC(mob) = GET_AC(ch);
 GET_CLASS(mob) = -1;
 mob->mob_specials.damsizedice = GET_LEVEL(ch);
 mob->mob_specials.damnodice = 1;
 GET_SEX(mob) = GET_SEX(ch);
 mob->player.name = str_dup(GET_NAME(ch));
 mob->player.short_descr = str_dup(GET_NAME(ch));
 char_to_room(mob, ch->in_room);
 SET_BIT(AFF_FLAGS(mob), AFF_CHARM);
 send_to_char("You make a copy of yourself.\r\n",ch);
 add_follower(mob, ch);
}

ASPELL(spell_peace)
{
   struct char_data *temp;


   act("$n tries to stop the fight.", TRUE, ch, 0, 0, TO_ROOM);
   act("You try to stop the fight.", FALSE, ch, 0, 0, TO_CHAR);

   if (IS_EVIL(ch)) {
	return;
	}
   for (temp = world[ch->in_room].people; temp; temp = temp->next_in_room)
       if (FIGHTING(temp)) {
	  stop_fighting(temp);
	  if (IS_NPC(temp)) {
		clearMemory(temp);
	        }
          if (ch != temp) {
                act("$n stops fighting.", TRUE, temp, 0, 0, TO_ROOM);
                act("You stop fighting.", TRUE, temp, 0, 0, TO_CHAR);
                }
          }
   return;
}

ASPELL(spell_mana_sword)
{
  struct obj_data *tobj;
  
  if (ch == NULL || obj == NULL)
	  return;

  if ((GET_OBJ_TYPE(obj) == ITEM_STAFF) && OBJ_FLAGGED(obj, ITEM_MAGIC)) {
      extract_obj(obj);

      if (!(tobj = read_object(11, VIRTUAL))) {
        send_to_char("I seem to have goofed.\r\n", ch);
        return;
      }
      
      SET_BIT(GET_OBJ_EXTRA(tobj), ITEM_MAGIC);

      sprintf(buf, "mana sword %s", GET_NAME(ch));
      tobj->name = str_dup(buf);
      sprintf(buf, "The mana sword of %s", GET_NAME(ch));
      tobj->short_description = str_dup(buf);
      sprintf(buf, "A sword made with %s's magic powers is lying here.", GET_NAME(ch));
      tobj->description = str_dup(buf);
      tobj->affected[0].location = APPLY_HITROLL;
      tobj->affected[0].modifier = 2 + (level >= 18);
      tobj->affected[1].location = APPLY_DAMROLL;
      tobj->affected[1].modifier = 2 + (level >= 20);
      GET_OBJ_LEVEL(tobj) = GET_LEVEL(ch);
      GET_OBJ_VAL(tobj, 1) = 1;
      GET_OBJ_VAL(tobj, 2) = GET_LEVEL(ch)* 1.4;

      if (IS_GOOD(ch)) {
        SET_BIT(GET_OBJ_EXTRA(tobj), ITEM_ANTI_EVIL);
        act("$p glows blue.", FALSE, ch, tobj, 0, TO_CHAR);
      } else if (IS_EVIL(ch)) {
        SET_BIT(GET_OBJ_EXTRA(tobj), ITEM_ANTI_GOOD);
        act("$p glows red.", FALSE, ch, tobj, 0, TO_CHAR);
      } else {
        act("$p glows yellow.", FALSE, ch, tobj, 0, TO_CHAR);
      }

      obj_to_char(tobj, ch);
      act("$n creates $p.", FALSE, ch, tobj, 0, TO_ROOM);
      act("You create $p.", FALSE, ch, tobj, 0, TO_CHAR);
      load_otrigger(tobj);
  } else
    send_to_char("You cannot turn this equipment into a mana sword.\r\n", ch);
}
::::::::::::::
teleport.c
::::::::::::::
#define __TELEPORT_C__

#include "conf.h"
#include "sysdep.h"

#include "structs.h"
#include "utils.h"
#include "interpreter.h"
#include "handler.h"
#include "comm.h"
#include "teleport.h"
#include "buffer.h"

extern struct index_data *obj_index;
extern struct char_data *character_list;
extern struct room_data *world;
extern int top_of_world;

void die_in_dt(struct char_data * ch);

void TeleportPulseStuff()
{
  ACMD(do_look);
  int real_room(int virtual);

  bool teleportP = FALSE;
  struct char_data *next = NULL, *tmp = NULL, *bk = NULL;
  struct room_data *rm = NULL;
  int troom = 0, i = 0;
  struct obj_data *obj_object, *temp_obj;

  for (i = 0; i < top_of_world; i++) {
      rm = &world[i];
      if (!rm->number || rm->tele == NULL) 
	continue;
      if (rm->number == rm->tele->targ)
	continue;
      if (rm->tele->targ == 0)
	continue;
      if (rm->tele->cnt > 0) {		/* decrement counter */
	rm->tele->cnt -= 1;
      } 
      if (rm->tele->cnt == 0) {		/* reset counter if needed */
	rm->tele->cnt = rm->tele->time;
      } else if (rm->tele->cnt > 1) {   /* jump out if not 1 */
	continue;
      }

      if (real_room(rm->tele->targ) == -1) {
          log("invalid tele->targ");
          continue;
      }

      troom = real_room(rm->tele->targ);

      if (!IS_SET(rm->tele->mask, TELE_OBJ) &&
	  !IS_SET(rm->tele->mask, TELE_NOOBJ) &&
	  !IS_SET(rm->tele->mask, TELE_SKIPOBJ)) {
        obj_object = rm->contents;
        while (obj_object) {
          temp_obj = obj_object->next_content;
          obj_from_room(obj_object);
          obj_to_room(obj_object, troom);
          obj_object = temp_obj;
        }
      }
      temp_obj = NULL;
      bk = 0;

      while (rm->people) { 
	/* work through the list of people */
        /* at first, bk = 0, so this checks for null */
	  tmp = rm->people;

	  if (!tmp || tmp == bk) break;

          bk = tmp;
          if (IS_SET(rm->tele->mask, TELE_NOMOB) && IS_MOB(tmp)) {
		teleportP = FALSE;
		/* don't teleport mobs */
	  } else { /* go ahead and check to teleport */
           if (IS_SET(rm->tele->mask, TELE_OBJ)) {
   		teleportP = FALSE;
		temp_obj = tmp->carrying;
  	        while (!teleportP && temp_obj) {
			if (GET_OBJ_VNUM(temp_obj) == rm->tele->obj)
				teleportP= TRUE;
			temp_obj = temp_obj->next;
		}
	   } else if (IS_SET(rm->tele->mask, TELE_NOOBJ)) {
   	        teleportP = TRUE;
	        temp_obj = tmp->carrying;
	        while (teleportP && temp_obj) {
		if (GET_OBJ_VNUM(temp_obj) == rm->tele->obj)
			teleportP = FALSE;
		temp_obj = temp_obj->next;
   	        }
	   } else {
		teleportP = TRUE;
	   }
	  }
          if (teleportP) {
  	    if (!IS_SET(rm->tele->mask, TELE_NOMSG)) {
		act("$n disappears.", FALSE, tmp, 0, 0, TO_ROOM);
		act("You have a very strange feeling.", FALSE, tmp, 0, 0, TO_CHAR);
  	    }
            char_from_room(tmp); /* the list of people in the room has changed */
            char_to_room(tmp, troom);
  	    if (!IS_SET(rm->tele->mask, TELE_NOMSG)) {
		act("$n appears from out of nowhere.", FALSE, tmp, 0, 0, TO_ROOM);
	    }
            if (IS_SET(rm->tele->mask, TELE_LOOK) && !IS_NPC(tmp)) {
              do_look(tmp, "\0",15, 0);
  	       /*look_at_room(ch, 0);*/
            }

            if (IS_SET(world[troom].room_flags, ROOM_DEATH) && 
		(GET_LEVEL(tmp))  < LVL_IMMORT) {
              if (tmp == next)
                next = tmp->next;
              log_death_trap(tmp);
	      /*death_cry(tmp);*/
	      die_in_dt(tmp);
              continue;
            }
             /* if (dest->sector_type == SECT_AIR) {
              * n2 = tmp->next;
              * if (check_falling(tmp)) {
              *   if (tmp == next)
              *     next = n2;
              * }
              * } hmm.... maybe I should add this as welll*/
	  }
	  /* tmp = tmp->next; */
      }
      if (IS_SET(rm->tele->mask, TELE_RANDOM)) {
            rm->tele->time = number(2,30);
      }
   }
}
::::::::::::::
thread.c
::::::::::::::
/*
 * thread.c - Testing stub for buffer.c
 * Copyright 1997, 1998, George Greer
 * License: public domain
 * Warranty: none at all
 */

#include "conf.h"
#include "sysdep.h"
#include <pthread.h>
#include "structs.h"
#include "buffer.h"
#include "utils.h"

void _thr_main() {}

/* Stubs! */
long random();
void send_to_all(char *t) { printf("%s", t); }
void send_to_char(char *t, struct char_data *ch) { printf("%s", t); }
int MIN(int a, int b) { return a < b ? a : b; }
int MAX(int a, int b) { return a > b ? a : b; }
int number(int from, int to) { return ((random() % (to - from + 1)) + from); }

int circle_shutdown = 0;
int circle_reboot = 0;

void log(const char *str, ...)
{
  time_t ct;
  char *tmstr;

  ct = time(0);
  tmstr = asctime(localtime(&ct));
  *(tmstr + strlen(tmstr) - 1) = '\0';
  fprintf(stdout, "%-15.15s :: %s\n", tmstr + 4, str);
  fflush(stdout);
}

void *thread(void *hi)
{
  FILE *dn;
  int i;
  char *tbuf, backup[128];;

  sleep(1);
  for (i = 0; i < INT_MAX; i++) {
    /* Grab a buffer. */
    tbuf = get_buffer(number(21,3000));

    /* Dump some data in it. */
    strcpy(tbuf, "12345678901234567890");
    sprintf(tbuf, "%d ", i);
    strcpy(backup, tbuf);

    /* Delay */
    dn = fopen("/dev/null", "w");
    fprintf(dn, "%s", tbuf);
    fclose(dn);

    /* Check */
    if (strcmp(backup, tbuf)) { /* different */
      sprintf(backup, "thread on %d: Someone changed my buffer!", i);
      log(backup);
    }

    /* Get rid of the buffer. */
    release_buffer(tbuf);
    if (circle_shutdown)
      return NULL;
  }
  log("thread: done.");
  return NULL;
}

#define NUM_THREADS	60

int main(void)
{
  int i;
  char *mbuf;
  pthread_t thread_id[NUM_THREADS];
  extern ush_int buffer_opt;

  buffer_opt |= (1 << 2);
//  buffer_opt |= (1 << 4);

  log("main: init_buffers();");
  init_buffers();
  sleep(1);

  log("main: starting threads.");
  for (i = 0; i < NUM_THREADS; i++) {
    printf("%d ", i);
    if (pthread_create(&thread_id[i], NULL, thread, NULL) < 0)
      log("thread: Failed thread creation.", i);
  }
  printf("\n");

  sleep(5);

  log("main: waiting...");
  for (i = 0; i < NUM_THREADS; i++)
    pthread_join(thread_id[i], NULL);
  circle_shutdown = 1;
  log("main: done.");

  sleep(5);

  log("main: exit_buffers()");
  exit_buffers();
  return 0;
}
::::::::::::::
utils.c
::::::::::::::
/* ************************************************************************
*   File: utils.c                                       Part of CircleMUD *
*  Usage: various internal functions of a utility nature                  *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "buffer.h"
#include "utils.h"
#include "db.h"
#include "comm.h"
#include "screen.h"
#include "spells.h"
#include "handler.h"
#include <stdarg.h>

extern struct descriptor_data *descriptor_list;
extern struct time_data time_info;
extern struct room_data *world;
extern struct zone_data *zone_table;
extern int top_of_world;

/* local functions */
struct time_info_data *real_time_passed(time_t t2, time_t t1);
struct time_info_data *mud_time_passed(time_t t2, time_t t1);
void die_follower(struct char_data * ch);
void add_follower(struct char_data * ch, struct char_data * leader);
char *make_bar(int val, int max, int len, int cores);
char *stripcr(char *dest, const char *src);
void topten(struct char_data *topch) ;
void topten1(struct char_data *topch) ;
void topten2(struct char_data *topch) ;


void topten1(struct char_data *topch)
{
  int x ; int y ; int z ; int cont ;

  struct toptenlevel
 {
  char nome[30] ;
  int level ;
  long id ;
 } ;


 struct toptenlevel topvetorX[10] ;
 struct toptenlevel topvetor[10] ;
 struct toptenlevel aux ;

 FILE *fl;
 const char *filename = TOPTEN_FILE1 ;

 if(GET_LEVEL(topch) > 200)     // NAO MUDE ESSA LINHA NUNCA!!!!!!!!!!!!!
  return ;                      // imortals e gods nao fazem parte do topten

 if(GET_ARENA_DIED(topch) + GET_ARENA_KILLED(topch) == 0)
  return ;

 cont =  3* GET_ARENA_KILLED(topch) *
 GET_ARENA_KILLED(topch)/(GET_ARENA_DIED(topch)
+GET_ARENA_KILLED(topch)) * GET_ARENA_KILLED(topch)/(GET_ARENA_DIED(topch)
+GET_ARENA_KILLED(topch));


 if(cont == 0)
  return ;

/* A parte a seguir deve ser executada apenas 1 vez. Essa parte eh responsavel
por criar o arquivo inicial. Ela nao deve existir depois que esse
arquivo inicial for criado. Ou seja, apenas execute a parte a seguir
1 vez. Nao se esqueca de entrar no mud pelo menos com 1 player para
esse parte poder ser executada. Qualquer duvida entre em contato com
luigi(lpalma@dc.ufscar.br)

   if (!(fl = fopen(filename, "w")))
   {
    send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
    return;
   }

   topvetorX[0].id = 0  ;
   topvetorX[0].level = 10  ;
   strcpy(topvetorX[0].nome, "Joao0");

   topvetorX[1].id = 0  ;
   topvetorX[1].level = 9  ;
   strcpy(topvetorX[1].nome, "Joao1");

   topvetorX[2].id = 0  ;
   topvetorX[2].level = 8  ;
   strcpy(topvetorX[2].nome, "Joao2");

   topvetorX[3].id = 0  ;
   topvetorX[3].level = 7  ;
   strcpy(topvetorX[3].nome, "Joao3");

   topvetorX[4].id = 0  ;
   topvetorX[4].level = 6  ;
   strcpy(topvetorX[4].nome, "Joao4");

   topvetorX[5].id = 0  ;
   topvetorX[5].level = 5  ;
   strcpy(topvetorX[5].nome, "Joao5");

   topvetorX[6].id = 0 ;
   topvetorX[6].level = 4  ;
   strcpy(topvetorX[6].nome, "Joao6");

   topvetorX[7].id = 0  ;
   topvetorX[7].level = 3  ;
   strcpy(topvetorX[7].nome, "Joao7");

   topvetorX[8].id = 0  ;
   topvetorX[8].level = 2  ;
   strcpy(topvetorX[8].nome, "Joao8");

   topvetorX[9].id = 0  ;
   topvetorX[9].level = 1  ;
   strcpy(topvetorX[9].nome, "Joao9");

 fwrite(topvetorX, sizeof(struct toptenlevel[10]), 1, fl);
 fclose(fl);
  */

  if (!(fl = fopen(filename, "r")))
  {
   send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
   return;
  }

 fread(topvetor, sizeof(struct toptenlevel[10]),1, fl)   ;
 fclose(fl);

 for(x = 0 ; x < 10 ; x++)
 {
  topvetorX[x].id =  topvetor[x].id ;
  topvetorX[x].level =  topvetor[x].level   ;
  strcpy(topvetorX[x].nome,topvetor[x].nome)  ;
 }

 y = 0 ;

 for(x = 0 ; x<10 ; x++)
 {
  if(GET_IDNUM(topch) == topvetorX[x].id )
  {
   topvetorX[x].level = cont;
   y = 1 ;
  }
 }

 if(topvetorX[9].level >=  cont && (y == 0))
 {
  //send_to_char("Weak, too weak.\r\n", topch);
  return;
 }
 else
  //send_to_char("Your data has been refreshed on topten.\r\n", topch);

 if(y == 0)
 {
  topvetorX[9].id = GET_IDNUM(topch) ;
  topvetorX[9].level = cont;
  strcpy(topvetorX[9].nome,GET_NAME(topch));
 }

 z = 1   ;

  while(z == 1)       // ordenacao
 {
  z = 0 ;
  for(x = 0 ; x < 9 ; x++)
  {
   if(topvetorX[x].level < topvetorX[x+1].level)
   {
    aux.level = topvetorX[x].level;
    strcpy(aux.nome, topvetorX[x].nome) ;
    aux.id = topvetorX[x].id;

    topvetorX[x].level = topvetorX[x+1].level;
    strcpy(topvetorX[x].nome, topvetorX[x+1].nome);
    topvetorX[x].id = topvetorX[x+1].id;

    topvetorX[x+1].level = aux.level;
    strcpy(topvetorX[x+1].nome, aux.nome);
    topvetorX[x+1].id = aux.id ;
    z = 1;
   }
  }
 }


 if (!(fl = fopen(filename, "w")))
 {
  send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
  return;
 }

 fwrite(topvetorX, sizeof(struct toptenlevel[10]), 1, fl) ;
 fclose(fl);

}



void topten2(struct char_data *topch)
{
  int x ; int y ; int z ; int cont ;

  struct toptenlevel
 {
  char nome[30] ;
  int level ;
  long id ;
 } ;


 struct toptenlevel topvetorX[10] ;
 struct toptenlevel topvetor[10] ;
 struct toptenlevel aux ;

 FILE *fl;
 const char *filename = TOPTEN_FILE2 ;

 if(GET_LEVEL(topch) > 200)     // NAO MUDE ESSA LINHA NUNCA!!!!!!!!!!!!!
  return ;                      // imortals e gods nao fazem parte do topten

 cont = GET_LEVEL(topch) + GET_REMORT(topch)*200 ;

 if(cont == 0)
  return ;

/* A parte a seguir deve ser executada apenas 1 vez. Essa parte eh responsavel
por criar o arquivo inicial. Ela nao deve existir depois que esse
arquivo inicial for criado. Ou seja, apenas execute a parte a seguir
1 vez. Nao se esqueca de entrar no mud pelo menos com 1 player para
esse parte poder ser executada. Qualquer duvida entre em contato com
luigi(lpalma@dc.ufscar.br)

   if (!(fl = fopen(filename, "w")))
   {
    send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
    return;
   }

   topvetorX[0].id = 0  ;
   topvetorX[0].level = 10  ;
   strcpy(topvetorX[0].nome, "Joao0");

   topvetorX[1].id = 0  ;
   topvetorX[1].level = 9  ;
   strcpy(topvetorX[1].nome, "Joao1");

   topvetorX[2].id = 0  ;
   topvetorX[2].level = 8  ;
   strcpy(topvetorX[2].nome, "Joao2");

   topvetorX[3].id = 0  ;
   topvetorX[3].level = 7  ;
   strcpy(topvetorX[3].nome, "Joao3");

   topvetorX[4].id = 0  ;
   topvetorX[4].level = 6  ;
   strcpy(topvetorX[4].nome, "Joao4");

   topvetorX[5].id = 0  ;
   topvetorX[5].level = 5  ;
   strcpy(topvetorX[5].nome, "Joao5");

   topvetorX[6].id = 0 ;
   topvetorX[6].level = 4  ;
   strcpy(topvetorX[6].nome, "Joao6");

   topvetorX[7].id = 0  ;
   topvetorX[7].level = 3  ;
   strcpy(topvetorX[7].nome, "Joao7");

   topvetorX[8].id = 0  ;
   topvetorX[8].level = 2  ;
   strcpy(topvetorX[8].nome, "Joao8");

   topvetorX[9].id = 0  ;
   topvetorX[9].level = 1  ;
   strcpy(topvetorX[9].nome, "Joao9");

 fwrite(topvetorX, sizeof(struct toptenlevel[10]), 1, fl);
 fclose(fl);
  */

  if (!(fl = fopen(filename, "r")))
  {
   send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
   return;
  }

 fread(topvetor, sizeof(struct toptenlevel[10]),1, fl)   ;
 fclose(fl);

 for(x = 0 ; x < 10 ; x++)
 {
  topvetorX[x].id =  topvetor[x].id ;
  topvetorX[x].level =  topvetor[x].level   ;
  strcpy(topvetorX[x].nome,topvetor[x].nome)  ;
 }

 y = 0 ;

 for(x = 0 ; x<10 ; x++)
 {
  if(GET_IDNUM(topch) == topvetorX[x].id )
  {
   topvetorX[x].level = cont;
   y = 1 ;
  }
 }

 if(topvetorX[9].level >=  cont && (y == 0))
 {
  //send_to_char("Weak, too weak.\r\n", topch);
  return;
 }
 else
  //send_to_char("Your data has been refreshed on topten.\r\n", topch);

 if(y == 0)
 {
  topvetorX[9].id = GET_IDNUM(topch) ;
  topvetorX[9].level = cont;
  strcpy(topvetorX[9].nome,GET_NAME(topch));
 }

 z = 1   ;

  while(z == 1)       // ordenacao
 {
  z = 0 ;
  for(x = 0 ; x < 9 ; x++)
  {
   if(topvetorX[x].level < topvetorX[x+1].level)
   {
    aux.level = topvetorX[x].level;
    strcpy(aux.nome, topvetorX[x].nome) ;
    aux.id = topvetorX[x].id;

    topvetorX[x].level = topvetorX[x+1].level;
    strcpy(topvetorX[x].nome, topvetorX[x+1].nome);
    topvetorX[x].id = topvetorX[x+1].id;

    topvetorX[x+1].level = aux.level;
    strcpy(topvetorX[x+1].nome, aux.nome);
    topvetorX[x+1].id = aux.id ;
    z = 1;
   }
  }
 }


 if (!(fl = fopen(filename, "w")))
 {
  send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
  return;
 }

 fwrite(topvetorX, sizeof(struct toptenlevel[10]), 1, fl) ;
 fclose(fl);

}





void topten(struct char_data *topch)
{
  int x ; int y ; int z ;

  struct toptenlevel
 {
  char nome[30] ;
  int level ;
  long id ;
 } ;


 struct toptenlevel topvetorX[10] ;
 struct toptenlevel topvetor[10] ;
 struct toptenlevel aux ;

 FILE *fl;
 const char *filename = TOPTEN_FILE ;

 if(GET_LEVEL(topch) > 200)     // NAO MUDE ESSA LINHA NUNCA!!!!!!!!!!!!!
  return ;                      // imortals e gods nao fazem parte do
                                //topten

 sprintf(buf, "%s verificado na lista de top ten", GET_NAME(topch));
   mudlog(buf, NRM, LVL_IMMORT, 0);
/* A parte a seguir deve ser executada apenas 1 vez. Essa parte eh
responsavel
por criar o arquivo inicial. Ela nao deve existir depois que esse
arquivo inicial for criado. Ou seja, apenas execute a parte a seguir
1 vez. Nao se esqueca de entrar no mud pelo menos com 1 player para
esse parte poder ser executada. Qualquer duvida entre em contato com
luigi(lpalma@dc.ufscar.br)

   if (!(fl = fopen(filename, "w")))
   {
    send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
    return;
   }

   topvetorX[0].id = 0  ;
   topvetorX[0].level = 10  ;
   strcpy(topvetorX[0].nome, "Joao0");
   topvetorX[1].id = 0  ;
   topvetorX[1].level = 9  ;
   strcpy(topvetorX[1].nome, "Joao1");
   topvetorX[2].id = 0  ;
   topvetorX[2].level = 8  ;
   strcpy(topvetorX[2].nome, "Joao2");

   topvetorX[3].id = 0  ;
   topvetorX[3].level = 7  ;
   strcpy(topvetorX[3].nome, "Joao3");

   topvetorX[4].id = 0  ;
   topvetorX[4].level = 6  ;
   strcpy(topvetorX[4].nome, "Joao4");

   topvetorX[5].id = 0  ;
   topvetorX[5].level = 5  ;
   strcpy(topvetorX[5].nome, "Joao5");

   topvetorX[6].id = 0 ;
   topvetorX[6].level = 4  ;
   strcpy(topvetorX[6].nome, "Joao6");
   topvetorX[7].id = 0  ;
   topvetorX[7].level = 3  ;
   strcpy(topvetorX[7].nome, "Joao7");
   topvetorX[8].id = 0  ;
   topvetorX[8].level = 2  ;
   strcpy(topvetorX[8].nome, "Joao8");
   topvetorX[9].id = 0  ;
   topvetorX[9].level = 1  ;
   strcpy(topvetorX[9].nome, "Joao9");
 fwrite(topvetorX, sizeof(struct toptenlevel[10]), 1, fl);

 fclose(fl);

  */

  if (!(fl = fopen(filename, "r")))
  {
   send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
   return;
  }

 fread(topvetor, sizeof(struct toptenlevel[10]),1, fl)   ;
 fclose(fl);
 for(x = 0 ; x < 10 ; x++)
 {
  topvetorX[x].id =  topvetor[x].id ;
  topvetorX[x].level =  topvetor[x].level   ;
  strcpy(topvetorX[x].nome,topvetor[x].nome)  ;
//  sprintf(buf, "Faz parte do top ten '%d'", topvetorX[x].level);
//  mudlog(buf, NRM, LVL_IMMORT, 0);
//  sprintf(buf, "Faz parte do top ten '%s'", topvetorX[x].nome);
//  mudlog(buf, NRM, LVL_IMMORT, 0);
//  sprintf(buf, "Faz parte do top ten '%5ld'", xx);
//  mudlog(buf, NRM, LVL_IMMORT, 0);
 }



// if(topvetorX[9].level >=  GET_QP(topch))
//  return ;

 y = 0 ;
 for(x = 0 ; x<10 ; x++)
 {
  if(GET_IDNUM(topch) == topvetorX[x].id )
  {
   topvetorX[x].level = GET_QP(topch);
   y = 1 ;
  }
 }

 if(topvetorX[9].level >=  GET_QP(topch) && (y == 0))
 {
  //send_to_char("Weak, too weak.\r\n", topch);
  return;
 }
 else
  //send_to_char("Your data has been refreshed on topten.\r\n", topch);
 if(y == 0)
 {
  topvetorX[9].id = GET_IDNUM(topch) ;
  topvetorX[9].level = GET_QP(topch);
  strcpy(topvetorX[9].nome,GET_NAME(topch));
 }
 z = 1   ;
  while(z == 1)       // ordenacao
 {
  z = 0 ;
  for(x = 0 ; x < 9 ; x++)
  {
   if(topvetorX[x].level < topvetorX[x+1].level)
   {
    aux.level = topvetorX[x].level;
    strcpy(aux.nome, topvetorX[x].nome) ;
    aux.id = topvetorX[x].id;

    topvetorX[x].level = topvetorX[x+1].level;
    strcpy(topvetorX[x].nome, topvetorX[x+1].nome);
    topvetorX[x].id = topvetorX[x+1].id;

    topvetorX[x+1].level = aux.level;
    strcpy(topvetorX[x+1].nome, aux.nome);
    topvetorX[x+1].id = aux.id ;
    z = 1;
   }
  }
 }


 if (!(fl = fopen(filename, "w")))
 {
  send_to_char("Could not open the file. Report to Luigi.\r\n", topch);
  return;
 }

 fwrite(topvetorX, sizeof(struct toptenlevel[10]), 1, fl) ;
 fclose(fl);
// for(x = 0 ; x < 10 ; x++)
// {
//  sprintf(buf, "\r\nFaz parte do top ten '%d' ", topvetorX[x].level);
//  send_to_char(buf, topch);
//  sprintf(buf, "\r\nFaz parte do top ten '%s' ", topvetorX[x].nome);
//  send_to_char(buf, topch);
// }
}




/* adiciona separador de milhar a numeros */
/*
char *add_points(int z_number)
{
  int unidade, milhar, milhao, bilhao, trab;
  char sunidade[3], smilhar[3], smilhao[3];
  char z_temp[MAX_STRING_LENGTH];
  bool neg = FALSE;

  *sunidade = '\0';
  *smilhar = '\0';
  *smilhao = '\0';
  *z_temp = '\0';
  *buf3 = '\0';

  if (z_number < 0) {
    trab = - z_number;
    neg = TRUE;
  }
  else
    trab = z_number;

  if (trab >= 1000000000) {
    bilhao  = trab / 1000000000;
    milhao  = (trab - bilhao * 1000000000) / 1000000;
    milhar  = (trab - bilhao * 1000000000 - milhao * 1000000) / 1000;
    unidade = trab - bilhao * 1000000000 - milhao * 1000000 - milhar * 1000;
    if (milhao < 100) {
      strcpy(smilhao, "0");
      if (milhao < 10) {
        strcpy(smilhao, "00");
      }
    }
    if (milhar < 100) {
      strcpy(smilhar, "0");
      if (milhar < 10) {
        strcpy(smilhar, "00");
      }
    }
    if (unidade < 100) {
      strcpy(sunidade , "0");
      if (unidade < 10) {
        strcpy(sunidade, "00");
      }
    }
    sprintf(z_temp, "%d,%s%d,%s%d,%s%d", bilhao, smilhao, milhao, smilhar, milhar, sunidade, unidade);
  }
  else if (trab >= 1000000) {
    milhao  = trab / 1000000;
    milhar  = (trab - milhao * 1000000) / 1000;
    unidade = trab - milhao * 1000000 - milhar * 1000;
    if (milhar < 100) { strcpy(smilhar, "0"); if (milhar < 10)
      { strcpy(smilhar, "00"); } }
    if (unidade < 100) { strcpy(sunidade , "0"); if (unidade < 10)
      { strcpy(sunidade, "00"); } }
    sprintf(z_temp, "%d,%s%d,%s%d", milhao, smilhar, milhar, sunidade, unidade);
  }
  else if (trab >= 1000) {
    milhar  = trab / 1000;
    unidade = trab - milhar * 1000;
    if (unidade < 100) {
      strcpy(sunidade , "0");
      if (unidade < 10) {
        strcpy(sunidade, "00");
      }
    }
    sprintf(z_temp, "%d,%s%d", milhar, sunidade, unidade);
  }
  else
    sprintf(z_temp, "%d", trab);

  sprintf(buf3, "%s%s", (neg?"-":""), z_temp);
  return (buf3);
}
*/

// by samis
/*
char *add_points(int z_number)
{
 	int x, i = 0;
	bool negativo = 0;
	char buffer[200];

	if(z_number < 0) {
		z_number *= -1;
		negativo = 1;
	}

	sprintf(buffer, "%d", z_number);

 	x = strlen(buffer);

	while((x-=3) > 0)
	{
		i++;
		memmove(buffer + x + 1, buffer + x, i * 3 + i);
		*(buffer + x) = ',';
 	}

	sprintf(buf3, "%s%s", (negativo ? "-" : ""), buffer);

	return(buf3);
}
*/

/* by zaaroth, sem memmove que processa d+ e sem sequencia
demasiada de calculos */
char *add_points(int z_number)
{
	unsigned short int x, z = 0, y = 0;
	char buffer[20];

	sprintf(buffer, "%d", z_number);

	x = strlen(buffer);

	while(z < x)
	{
		*(buf3+z+y) = buffer[z];
		z++;
		if(!((x-z) % 3) && *(buf3+z+y-1) != '-')
		{
			*(buf3+z+y) = ',';
			y++;
		}
	}
	*(buf3+x+y-1) = '\0';

	return(buf3);
}

const char *unidade[] = {
  "",
  "K",
  "M",
  "G",
  "\n"
};

char *convert_num(double var)
{
   int x = 0, y = 0;

   *buf3 = '\0';

   if(var < 0) {
	var *= -1;
	y = TRUE;
   }

   if(var >= 1000000000) {
   	var /= 1000000000;
	x = 3;
   } else if(var >= 1000000) {
   	var /= 1000000;
	x = 2;
   } else if(var >= 1000) {
   	var /= 1000;
	x = 1;
   }

   if(x)
     sprintf(buf2, "%s%.2f%s", (y?"-":""), var, unidade[x]);
   else
     sprintf(buf2, "%s%.0f%s", (y?"-":""), var, unidade[x]);

   return (buf2);
}

/* creates a random number in interval [from;to] */
int number(int from, int to)
{
  /* error checking in case people call number() incorrectly */
  if (from > to) {
    int tmp = from;
    from = to;
    to = tmp;
    log("SYSERR: number() should be called with lowest, then highest. number(%d, %d), not number(%d, %d).", from, to, to, from);
  }

  return ((circle_random() % (to - from + 1)) + from);
}


/* simulates dice roll */
int dice(int number, int size)
{
  int sum = 0;

  if (size <= 0 || number <= 0)
    return 0;

  while (number-- > 0)
    sum += ((circle_random() % size) + 1);

  return sum;
}


int MIN(int a, int b)
{
  return a < b ? a : b;
}


int MAX(int a, int b)
{
  return a > b ? a : b;
}

//#if BUFFER_MEMORY == FALSE
/* Create a duplicate of a string */
/*char *str_dup(const char *source)
{
  char *new_z;

  CREATE(new_z, char, strlen(source) + 1);
  return (strcpy(new_z, source));
}*/
//#endif

int str_cmp(const char *arg1, const char *arg2)
{
  int chk, i;

  if (arg1 == NULL || arg2 == NULL) {
    log("SYSERR: str_cmp() passed a NULL pointer, %p or %p.", arg1, arg2);
    return (0);
  }

  for (i = 0; arg1[i] || arg2[i]; i++)
    if ((chk = LOWER(arg1[i]) - LOWER(arg2[i])) != 0)
      return (chk);	/* not equal */

  return (0);
}

/* strn_cmp: a case-insensitive version of strncmp */
/* returns: 0 if equal, 1 if arg1 > arg2, -1 if arg1 < arg2  */
/* scan 'till found different, end of both, or n reached     */
int strn_cmp(const char *arg1, const char *arg2, int n)
{
  int chk, i;

  if (arg1 == NULL || arg2 == NULL) {
    log("SYSERR: strn_cmp() passed a NULL pointer, %p or %p.", arg1, arg2);
    return (0);
  }

  for (i = 0; (arg1[i] || arg2[i]) && (n > 0); i++, n--)
    if ((chk = LOWER(arg1[i]) - LOWER(arg2[i])) != 0)
      return (chk);	/* not equal */

  return (0);
}


/* log a death trap hit */
void log_death_trap(struct char_data * ch)
{
  char buf[150];

  sprintf(buf, "%s hit death trap #%d (%s)", GET_NAME(ch),
          GET_ROOM_VNUM(IN_ROOM(ch)), world[ch->in_room].name);
  mudlog(buf, BRF, LVL_IMMORT, TRUE);
}

/*
 * New variable argument log() function.  Works the same as the old for
 * previously written code but is very nice for new code.
 */
void basic_mud_log(const char *format, ...)
{
  va_list args;
  time_t ct = time(0);
  char *time_s = asctime(localtime(&ct));

  if (logfile == NULL) {
    puts("SYSERR: Using log() before stream was initialized!");
    return;
  }

  if (format == NULL)
    format = "SYSERR: log() received a NULL format.";

  time_s[strlen(time_s) - 1] = '\0';

  fprintf(logfile, "%-15.15s :: ", time_s + 4);

  va_start(args, format);
  vfprintf(logfile, format, args);
  va_end(args);

  fprintf(logfile, "\n");
  fflush(logfile);
}


/* the "touch" command, essentially. */
int touch(const char *path)
{
  FILE *fl;

  if (!(fl = fopen(path, "a"))) {
    log("SYSERR: %s: %s", path, strerror(errno));
    return (-1);
  } else {
    fclose(fl);
    return (0);
  }
}


/*
 * mudlog -- log mud messages to a file & to online imm's syslogs
 * based on syslog by Fen Jul 3, 1992
 */
void mudlog(const char *str, int type, int level, int file)
{
  char buf[MAX_STRING_LENGTH], tp;
  struct descriptor_data *i;

  if (str == NULL)
    return;	/* eh, oh well. */
  if (file)
    log("%s", str);
  if (level < 0)
    return;

  sprintf(buf, "[ %s ]\r\n", str);

  for (i = descriptor_list; i; i = i->next) {
    if (STATE(i) != CON_PLAYING || IS_NPC(i->character)) /* switch */
      continue;
    if (GET_LEVEL(i->character) < level)
      continue;
    if (PLR_FLAGGED(i->character, PLR_WRITING))
      continue;
    tp = ((PRF_FLAGGED(i->character, PRF_LOG1) ? 1 : 0) +
	  (PRF_FLAGGED(i->character, PRF_LOG2) ? 2 : 0));
    if (tp < type)
      continue;

    send_to_char(CCGRN(i->character, C_NRM), i->character);
    send_to_char(buf, i->character);
    send_to_char(CCNRM(i->character, C_NRM), i->character);
  }
}


void sprintbit(long bitvector, const char *names[], char *result)
{
  long nr;

  *result = '\0';

  if (bitvector < 0) {
    strcpy(result, "<INVALID BITVECTOR>");
    return;
  }
  for (nr = 0; bitvector; bitvector >>= 1) {
    if (IS_SET(bitvector, 1)) {
      if (*names[nr] != '\n') {
        strcat(result, names[nr]);
        strcat(result, " ");
      } else
        strcat(result, "UNDEFINED ");
    }
    if (*names[nr] != '\n')
      nr++;
  }

  if (!*result)
    strcpy(result, "NOBITS ");
}



void sprinttype(int type, const char *names[], char *result)
{
  int nr = 0;

  while (type && *names[nr] != '\n') {
    type--;
    nr++;
  }

  if (*names[nr] != '\n')
    strcpy(result, names[nr]);
  else
    strcpy(result, "UNDEFINED");
}


/* Calculate the REAL time passed over the last t2-t1 centuries (secs) */
struct time_info_data *real_time_passed(time_t t2, time_t t1)
{
  long secs;
  static struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_REAL_HOUR) % 24; /* 0..23 hours */
  secs -= SECS_PER_REAL_HOUR * now.hours;

  now.day = (secs / SECS_PER_REAL_DAY); /* 0..34 days  */
  secs -= SECS_PER_REAL_DAY * now.day;

  now.month = -1;
  now.year = -1;

  return &now;
}



/* Calculate the MUD time passed over the last t2-t1 centuries (secs) */
struct time_info_data *mud_time_passed(time_t t2, time_t t1)
{
  long secs;
  static struct time_info_data now;

  secs = (long) (t2 - t1);

  now.hours = (secs / SECS_PER_MUD_HOUR) % 24;  /* 0..23 hours */
  secs -= SECS_PER_MUD_HOUR * now.hours;

  now.day = (secs / SECS_PER_MUD_DAY) % 35;     /* 0..34 days  */
  secs -= SECS_PER_MUD_DAY * now.day;

  now.month = (secs / SECS_PER_MUD_MONTH) % 17; /* 0..16 months */
  secs -= SECS_PER_MUD_MONTH * now.month;

  now.year = (secs / SECS_PER_MUD_YEAR);        /* 0..XX? years */

  return &now;
}



struct time_info_data *age(struct char_data * ch)
{
  static struct time_info_data player_age;

  player_age = *mud_time_passed(time(0), ch->player.time.birth);

  player_age.year += 17;        /* All players start at 17 */

  return &player_age;
}


/* Check if making CH follow VICTIM will create an illegal */
/* Follow "Loop/circle"                                    */
bool circle_follow(struct char_data * ch, struct char_data * victim)
{
  struct char_data *k;

  for (k = victim; k; k = k->master) {
    if (k == ch)
      return TRUE;
  }

  return FALSE;
}



/* Called when stop following persons, or stopping charm */
/* This will NOT do if a character quits/dies!!          */
void stop_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  if (ch->master == NULL) {
    core_dump();
    return;
  }

  if (AFF_FLAGGED(ch, AFF_CHARM)) {
    act("You realize that $N is a jerk!", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n realizes that $N is a jerk!", FALSE, ch, 0, ch->master, TO_NOTVICT);
    act("$n hates your guts!", FALSE, ch, 0, ch->master, TO_VICT);
    if (affected_by_spell(ch, SPELL_CHARM))
      affect_from_char(ch, SPELL_CHARM);
  } else {
    act("You stop following $N.", FALSE, ch, 0, ch->master, TO_CHAR);
    act("$n stops following $N.", TRUE, ch, 0, ch->master, TO_NOTVICT);
    act("$n stops following you.", TRUE, ch, 0, ch->master, TO_VICT);
  }

  if (ch->master->followers->follower == ch) {  /* Head of follower-list? */
    k = ch->master->followers;
    ch->master->followers = k->next;
    free(k);
  } else {                      /* locate follower who is not head of list */
    for (k = ch->master->followers; k->next->follower != ch; k = k->next);

    j = k->next;
    k->next = j->next;
    free(j);
  }

  ch->master = NULL;
  REMOVE_BIT(AFF_FLAGS(ch), AFF_CHARM | AFF_GROUP);
}



/* Called when a character that follows/is followed dies */
void die_follower(struct char_data * ch)
{
  struct follow_type *j, *k;

  if (ch->master)
    stop_follower(ch);

  for (k = ch->followers; k; k = j) {
    j = k->next;
    stop_follower(k->follower);
  }
}



/* Do NOT call this before having checked if a circle of followers */
/* will arise. CH will follow leader                               */
void add_follower(struct char_data * ch, struct char_data * leader)
{
  struct follow_type *k;

  if (ch->master) {
    core_dump();
    return;
  }

  ch->master = leader;

  CREATE(k, struct follow_type, 1);

  k->follower = ch;
  k->next = leader->followers;
  leader->followers = k;

  act("You now follow $N.", FALSE, ch, 0, leader, TO_CHAR);
  if (CAN_SEE(leader, ch))
    act("$n starts following you.", TRUE, ch, 0, leader, TO_VICT);
  act("$n starts to follow $N.", TRUE, ch, 0, leader, TO_NOTVICT);
}

/*
 * get_line reads the next non-blank line off of the input stream.
 * The newline character is removed from the input.  Lines which begin
 * with '*' are considered to be comments.
 *
 * Returns the number of lines advanced in the file.
 */
int get_line(FILE *fl, char *buf)
{
  char temp[256];
  int lines = 0;
  int sl;

  do {
    if (!fgets(temp, 256, fl))
      return (0);
    lines++;
  } while (*temp == '*' || *temp == '\n');

  /* Last line of file doesn't always have a \n, but it should. */
  sl = strlen(temp);
  if (sl > 0 && temp[sl - 1] == '\n')
    temp[sl - 1] = '\0';

  strcpy(buf, temp);
  return (lines);
}

int get_filename(char *orig_name, char *filename, int mode)
{
  const char *prefix, *middle, *suffix;
  char name[64], *ptr;

  switch (mode) {
  case CRASH_FILE:
    prefix = LIB_PLROBJS;
    suffix = SUF_OBJS;
    break;
  case ETEXT_FILE:
    prefix = LIB_PLRTEXT;
    suffix = SUF_TEXT;
    break;
  case ALIAS_FILE:
    prefix = LIB_ALIAS;
    suffix = SUF_ALIAS;
    break;
  default:
    return 0;
  }

  if (!*orig_name)
    return 0;

  strcpy(name, orig_name);
  for (ptr = name; *ptr; ptr++)
    *ptr = LOWER(*ptr);

  switch (LOWER(*name)) {
  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':
    middle = "A-E";
    break;
  case 'f':  case 'g':  case 'h':  case 'i':  case 'j':
    middle = "F-J";
    break;
  case 'k':  case 'l':  case 'm':  case 'n':  case 'o':
    middle = "K-O";
    break;
  case 'p':  case 'q':  case 'r':  case 's':  case 't':
    middle = "P-T";
    break;
  case 'u':  case 'v':  case 'w':  case 'x':  case 'y':  case 'z':
    middle = "U-Z";
    break;
  default:
    middle = "ZZZ";
    break;
  }

  sprintf(filename, "%s%s"SLASH"%s.%s", prefix, middle, name, suffix);
  return 1;
}


/* string manipulation fucntion originally by Darren Wilson */
/* (wilson@shark.cc.cc.ca.us) improved and bug fixed by Chris (zero@cnw.com) */
/* completely re-written again by M. Scott 10/15/96 (scottm@workcommn.net), */
/* substitute appearances of 'pattern' with 'replacement' in string */
/* and return the # of replacements */
int replace_str(char **string, char *pattern, char *replacement, int rep_all,
                int max_size) {
   char *replace_buffer = NULL;
   char *flow, *jetsam, temp;
   int len, i;

   if ((strlen(*string) - strlen(pattern)) + strlen(replacement) > max_size)
     return -1;

   CREATE(replace_buffer, char, max_size);
   i = 0;
   jetsam = *string;
   flow = *string;
   *replace_buffer = '\0';
   if (rep_all) {
      while ((flow = (char *)strstr(flow, pattern)) != NULL) {
         i++;
         temp = *flow;
         *flow = '\0';
         if ((strlen(replace_buffer) + strlen(jetsam) + strlen(replacement)) > max_size) {
            i = -1;
            break;
         }
         strcat(replace_buffer, jetsam);
         strcat(replace_buffer, replacement);
         *flow = temp;
         flow += strlen(pattern);
         jetsam = flow;
      }
      strcat(replace_buffer, jetsam);
   }
   else {
      if ((flow = (char *)strstr(*string, pattern)) != NULL) {
         i++;
         flow += strlen(pattern);
         len = ((char *)flow - (char *)*string) - strlen(pattern);

         strncpy(replace_buffer, *string, len);
         strcat(replace_buffer, replacement);
         strcat(replace_buffer, flow);
      }
   }
   if (i == 0) return 0;
   if (i > 0) {
      RECREATE(*string, char, strlen(replace_buffer) + 3);
      strcpy(*string, replace_buffer);
   }
   free(replace_buffer);
   return i;
}


/* re-formats message type formatted char * */
/* (for strings edited with d->str) (mostly olc and mail)     */
void format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen) {
   int total_chars, cap_next = TRUE, cap_next_next = FALSE;
   char *flow, *start = NULL, temp;
   /* warning: do not edit messages with max_str's of over this value */
   char formated[MAX_STRING_LENGTH];

   flow   = *ptr_string;
   if (!flow) return;

   if (IS_SET(mode, FORMAT_INDENT)) {
      strcpy(formated, "   ");
      total_chars = 3;
   }
   else {
      *formated = '\0';
      total_chars = 0;
   }

   while (*flow != '\0') {
      while ((*flow == '\n') ||
             (*flow == '\r') ||
             (*flow == '\f') ||
             (*flow == '\t') ||
             (*flow == '\v') ||
             (*flow == ' ')) flow++;

      if (*flow != '\0') {

         start = flow++;
         while ((*flow != '\0') &&
                (*flow != '\n') &&
                (*flow != '\r') &&
                (*flow != '\f') &&
                (*flow != '\t') &&
                (*flow != '\v') &&
                (*flow != ' ') &&
                (*flow != '.') &&
                (*flow != '?') &&
                (*flow != '!')) flow++;

         if (cap_next_next) {
            cap_next_next = FALSE;
            cap_next = TRUE;
         }

         /* this is so that if we stopped on a sentance .. we move off the sentance delim. */
         while ((*flow == '.') || (*flow == '!') || (*flow == '?')) {
            cap_next_next = TRUE;
            flow++;
         }

         temp = *flow;
         *flow = '\0';

         if ((total_chars + strlen(start) + 1) > 79) {
            strcat(formated, "\r\n");
            total_chars = 0;
         }

         if (!cap_next) {
            if (total_chars > 0) {
               strcat(formated, " ");
               total_chars++;
            }
         }
         else {
            cap_next = FALSE;
            *start = UPPER(*start);
         }

         total_chars += strlen(start);
         strcat(formated, start);

         *flow = temp;
      }

      if (cap_next_next) {
         if ((total_chars + 3) > 79) {
            strcat(formated, "\r\n");
            total_chars = 0;
         }
         else {
            strcat(formated, "  ");
            total_chars += 2;
         }
      }
   }
   strcat(formated, "\r\n");

   if (strlen(formated) > maxlen) formated[maxlen] = '\0';
   RECREATE(*ptr_string, char, MIN(maxlen, strlen(formated)+3));
   strcpy(*ptr_string, formated);
}
int num_pc_in_room(struct room_data *room)
{
  int i = 0;
  struct char_data *ch;

  for (ch = room->people; ch != NULL; ch = ch->next_in_room)
    if (!IS_NPC(ch))
      i++;

  return i;
}

/*
char *make_bar(int val, int max, int len, int cores)
{
	short int i;

	*buf2 = '[';
	*(buf2+len+1) = ']';
	*(buf2+len+2) = '\0';

	if (max <= 0)
	 max = 1;

	i = ((val*len)/max);

	for(; len > 0; len--)
		*(buf2+len) = (i >= len ? '>' : ' ');

	return(buf2);
}
*/

char *insere_cor(char *onde, char *oque, short int cores)
{
	char cor[10];

	if(!cores)
		return(onde);

	strcpy(cor, oque);

	oque = cor;

	for(; *oque; oque++)
		*(onde++) = *oque;

	return(onde);
}

char *corbarra[] = {
	KBBLU,
	KBCYN,
	KBGRN,
	KBYEL,
	KBRED,
	KNRM
};

char *make_bar(int val, int max, int len, int cores)
{
	char *buffer;
	int lenbkp, i;

	buffer = buf2;

	if (max <= 0)
		max = 1;

	i = ((val*len)/max);

	buffer = insere_cor(buffer, KBWHT, cores);
	*(buffer++) = '[';

	for(lenbkp = 0; lenbkp < len; lenbkp++)
	{
		if(i >= lenbkp)
		{
			if(!((5*(len-lenbkp)) % len))
				buffer = insere_cor(buffer, corbarra[((5*(len-lenbkp))/len)-1], cores);
			*(buffer++) = '>';
		}
		else
			*(buffer++) = ' ';
	}
	buffer = insere_cor(buffer, KBWHT, cores);
	*(buffer++) = ']';
	buffer = insere_cor(buffer, KNRM, cores);

	*buffer = '\0';

	return(buf2);
}

char *make_mbar(int min, int val, int max, int len, int cores)
{
  unsigned int i, n;
  char barra[MAX_INPUT_LENGTH];

    strcpy(barra, "&W[&r");

    i = len-(((max-val) * len) / (max+(min < 0 ? -min : min)));
    for (n = 0; n <= len; n++){
      if(n == len/2)
		strcat(barra, "&w:&b");
      else {
	if(n == i){
	  if(i > len/2)
		strcat(barra, "&B|&b");
	  else if(i < len/2)
		strcat(barra, "&R|&r");
	} else
		strcat(barra, "-");
      }
    }
    strcat(barra, "&W]&n");
    strcpy(buf2, barra);
    return (buf2);
}
/*
char *reprimir(char *palavra, char *vemde, int num)
{
    char *bkp;
    sh_int limit = 0;

    if(strlen(vemde) <= num)
      bkp = vemde;
    else {
      bkp = palavra;
	*palavra++ = *vemde;
	while(*vemde++ && limit++ < (num-4))
	     *(palavra++) = *vemde;
	*palavra++ = '.';
	*palavra++ = '.';
	*palavra++ = '.';
      *palavra = 0;
    }
    return(bkp);
}
*/

// samis
char *reprimir(char *vemde, int num)
{
    strcpy(buf2, vemde);

    if(strlen(buf2) > num)
    {

    	*(buf2 + num - 3) = '.';
    	*(buf2 + num - 2) = '.';
    	*(buf2 + num - 1) = '.';
    	*(buf2 + num) = '\0';
    }

    return (buf2);
}

/* strips \r's from line */
char *stripcr(char *dest, const char *src) {
   int i, length;
   char *temp;

   if (!dest || !src) return NULL;
   temp = &dest[0];
   length = strlen(src);
   for (i = 0; *src && (i < length); i++, src++)
     if (*src != '\r') *(temp++) = *src;
   *temp = '\0';
   return dest;
}

/* Check if the character doesn't have too many followers already */
int allow_follower(struct char_data *ch, int max_fol)
{
  struct follow_type *f;
  int fol = 1;
  max_fol = 2;

 if(GET_CHA(ch) >= 18) max_fol++;
 if(GET_RACE(ch) == RACE_H_SEA_ELF) max_fol++ ;

  for (f = ch->followers; f; f = f->next)
    if(IS_NPC(f->follower))
      fol++;

  return (fol > max_fol ? 0 : 1);
}

void manda_som(char *som, struct char_data *ch)
{
  	if (!PRF2_FLAGGED(ch, PRF2_WDPROTOCOL))
	   return;

	sprintf(buf2, "\x1B[play:%s]", som);
	send_to_char(buf2, ch);

}
/*
int GET_CLASS_REMORT(struct char_data *ch, int i)
{
	if(ch->player_specials)
		return (ch->player_specials->saved.rskills[i][0])
	return(0);
}

int GET_RSKILL(struct char_data *ch, int i, int num)
{
	num++;
	if(ch->player_specials)
		return (ch->player_specials->saved.rskills[i][num])
	return(0);
}
*/

/*
 * This function (derived from basic fork(); abort(); idea by Erwin S.
 * Andreasen) causes your MUD to dump core (assuming you can) but
 * continue running.  The core dump will allow post-mortem debugging
 * that is less severe than assert();  Don't call this directly as
 * core_dump_unix() but as simply 'core_dump()' so that it will be
 * excluded from systems not supporting them. (e.g. Windows '95).
 *
 * XXX: Wonder if flushing streams includes sockets?
 */


void core_dump_real(const char *who, ush_int line)
{
  log("SYSERR: Assertion failed at %s:%d!", who, line);
/*
#if defined(CIRCLE_UNIX)
  // These would be duplicated otherwise...
  fflush(stdout);
  fflush(stderr);
  fflush(logfile);


   // Kill the child so the debugger or script doesn't think the MUD
   // crashed.  The 'autorun' script would otherwise run it again.

  if (fork() == 0)
    abort();
#endif*/
}
::::::::::::::
weather.c
::::::::::::::
 /* ************************************************************************
*   File: weather.c                                     Part of CircleMUD *
*  Usage: functions handling time and the weather                         *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "handler.h"
#include "interpreter.h"
#include "db.h"
#include "buffer.h"

extern struct time_info_data time_info;

void weather_and_time(int mode);
void another_hour(int mode);
void weather_change(void);


void weather_and_time(int mode)
{
  another_hour(mode);
  if (mode)
    weather_change();
}


void another_hour(int mode)
{
  time_info.hours++;

  if (mode) {
    switch (time_info.hours) {
    case 5:
      weather_info.sunlight = SUN_RISE;
      send_to_outdoor("&YThe sun rises in the east.&n\r\n");
      break;
    case 6:
      weather_info.sunlight = SUN_LIGHT;
      send_to_outdoor("&YThe day has begun.&n\r\n");
      break;
    case 21:
      weather_info.sunlight = SUN_SET;
      send_to_outdoor("&yThe sun slowly disappears in the west.&n\r\n");
      break;
    case 22:
      weather_info.sunlight = SUN_DARK;
      send_to_outdoor("&WThe night has begun.&n\r\n");
      break;
    default:
      break;
    }
  }
  if (time_info.hours > 23) {   /* Changed by HHS due to bug ??? */
    time_info.hours -= 24;
    time_info.day++;

    if (time_info.day > 34) {
      time_info.day = 0;
      time_info.month++;

      if (time_info.month > 16) {
        time_info.month = 0;
        time_info.year++;
      }
    }
  }
}


void weather_change(void)
{
  int diff, change;
  if ((time_info.month >= 9) && (time_info.month <= 16))
    diff = (weather_info.pressure > 985 ? -2 : 2);
  else
    diff = (weather_info.pressure > 1015 ? -2 : 2);

  weather_info.change += (dice(1, 4) * diff + dice(2, 6) - dice(2, 6));

  weather_info.change = MIN(weather_info.change, 12);
  weather_info.change = MAX(weather_info.change, -12);

  weather_info.pressure += weather_info.change;

  weather_info.pressure = MIN(weather_info.pressure, 1040);
  weather_info.pressure = MAX(weather_info.pressure, 960);

  change = 0;

  switch (weather_info.sky) {
  case SKY_CLOUDLESS:
    if (weather_info.pressure < 990)
      change = 1;
    else if (weather_info.pressure < 1010)
      if (dice(1, 4) == 1)
        change = 1;
    break;
  case SKY_CLOUDY:
    if (weather_info.pressure < 970)
      change = 2;
    else if (weather_info.pressure < 990) {
      if (dice(1, 4) == 1)
        change = 2;
      else
        change = 0;
    } else if (weather_info.pressure > 1030)
      if (dice(1, 4) == 1)
        change = 3;

    break;
  case SKY_RAINING:
    if (weather_info.pressure < 970) {
      if (dice(1, 4) == 1)
        change = 4;
      else
        change = 0;
    } else if (weather_info.pressure > 1030)
      change = 5;
    else if (weather_info.pressure > 1010)
      if (dice(1, 4) == 1)
        change = 5;

    break;
  case SKY_LIGHTNING:
    if (weather_info.pressure > 1010)
      change = 6;
    else if (weather_info.pressure > 990)
      if (dice(1, 4) == 1)
        change = 6;

    break;
  default:
    change = 0;
    weather_info.sky = SKY_CLOUDLESS;
    break;
  }

  switch (change) {
  case 0:
    break;
  case 1:
    send_to_outdoor("&WThe sky starts to get cloudy.&n\r\n");
    weather_info.sky = SKY_CLOUDY;
    break;
  case 2:
    send_to_outdoor("&cIt starts to rain.&n\r\n");
    weather_info.sky = SKY_RAINING;
    break;
  case 3:
    send_to_outdoor("&wThe clouds disappear.&n\r\n");
    weather_info.sky = SKY_CLOUDLESS;
    break;
  case 4:
    send_to_outdoor("&CLightning starts to show in the sky.&n\r\n");
    weather_info.sky = SKY_LIGHTNING;
    break;
  case 5:
    send_to_outdoor("&cThe rain stops.&n\r\n");
    weather_info.sky = SKY_CLOUDY;
    break;
  case 6:
    send_to_outdoor("&CThe lightning stops.&n\r\n");
    weather_info.sky = SKY_RAINING;
    break;
  default:
    break;
  }
}
::::::::::::::
winddragon.c
::::::::::::::
/* ************************************************************************
*   File:winddragon.c                                  Part of CircleMUD  *
*  Usage: implementation of rooms to dragons                              *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#include "conf.h"
#include "sysdep.h"


#include "structs.h"
#include "utils.h"
#include "comm.h"
#include "interpreter.h"
#include "handler.h"
#include "db.h"
#include "spells.h"
#include "dg_scripts.h"
#include "winddragon.h"
#include "buffer.h"

extern struct descriptor_data *descriptor_list;

const sh_int to_fly_rooms [NUM_ROOMS + 1] =               
   /* air room #1     air room #2     air room #3       final room */
   { 11004,              11005,          11006,              11002};
   


void dragon_upd()
{
  int k, conectado;
  struct char_data *mob;
  struct descriptor_data *d, *next_d;
  
   for(k=0;k <= NUM_DRAGONS;k++)
    if (vet_dragons[k] == 1){
     conectado=0;
     for (d = descriptor_list; d; d = next_d) {
      	next_d = d->next;
      	if ((buf_dragon_indo[k].player->desc) &&
      	   (d->descriptor == buf_dragon_indo[k].player->desc->descriptor))
      	 conectado = 1;
      }	  
      if (conectado){       
       act("The dragon fly in the clouds carring you.", FALSE, buf_dragon_indo[k].player, 0, 0, TO_CHAR);
       act("The dragon fly in the clouds carring $n.", TRUE, buf_dragon_indo[k].player, 0, 0, TO_NOTVICT);
       char_from_room(buf_dragon_indo[k].player);
       buf_dragon_indo[k].room++;
       char_to_room(buf_dragon_indo[k].player, real_room(to_fly_rooms[buf_dragon_indo[k].room]));
       look_at_room(buf_dragon_indo[k].player, 0);
       if (buf_dragon_indo[k].room == 3){
        act("The dragon down and leave you safe.", TRUE, buf_dragon_indo[k].player, 0, 0, TO_CHAR);
        act("A dragon comes from the sky and leave $n safe.", TRUE, buf_dragon_indo[k].player, 0, 0, TO_NOTVICT);	
        send_to_room("The dragon fly to the sky and vanish in the clouds.\n\r", real_room(to_fly_rooms[NUM_ROOMS]));        
        vet_dragons[k] = 0;
        mob = read_mobile(real_mobile(DRAGON_VNUM), REAL);
        char_to_room(mob, real_room(DRAGONROOM_INI));
        send_to_room("A Dragon comes from sky.\n\r", real_room(DRAGONROOM_INI));
       }
       else{
        act("$n comes from clouds mounting a winged dragon.", TRUE, buf_dragon_indo[k].player, 0, 0, TO_NOTVICT);	
       }           
     }//desc
     else{
     /* conectado=0;
      for (d = descriptor_list; d; d = next_d) {
      	next_d = d->next;
      	if ((buf_dragon_indo[k].player->desc) &&
      	   (d->descriptor == buf_dragon_indo[k].player->desc->descriptor))
      	 conectado = 1;
      }
      */	  
      if (!buf_dragon_indo[k].player->desc){
       char_from_room(buf_dragon_indo[k].player);
       char_to_room(buf_dragon_indo[k].player, real_room(to_fly_rooms[NUM_ROOMS]));
       act("A dragon comes from the sky and leave $n safe.", TRUE, buf_dragon_indo[k].player, 0, 0, TO_NOTVICT);	
       send_to_room("The dragon fly to the sky and vanish in the clouds.\n\r", real_room(to_fly_rooms[NUM_ROOMS]));        
      }
      vet_dragons[k] = 0;      
      mob = read_mobile(real_mobile(DRAGON_VNUM), REAL);
      char_to_room(mob, real_room(DRAGONROOM_INI));
      send_to_room("A Dragon comes from sky.\n\r", real_room(DRAGONROOM_INI));
     }          
   }//==1   
}
::::::::::::::
zedit.c
::::::::::::::
/************************************************************************
 *  OasisOLC - zedit.c                                          v1.5    *
 *                                                                      *
 *  Copyright 1996 Harvey Gilpin.                                       *
 ************************************************************************/

#include "conf.h"
#include "sysdep.h"
#include "structs.h"
#include "buffer.h"
#include "comm.h"
#include "utils.h"
#include "db.h"
#include "olc.h"

/*
 * Turn on zedit debugging.  Please mail log results to greerga@van.ml.org
 * This will attempt to find the problem with replacing other zedit commands
 * when you add unrelated ones.
 */
#if 0
#define DEBUG   1
#endif

/*-------------------------------------------------------------------*/

/*
 * External data structures.
 */
extern struct zone_data *zone_table;
extern struct room_data *world;
extern int top_of_zone_table;
extern struct char_data *mob_proto;
extern struct index_data *mob_index;
extern struct obj_data *obj_proto;
extern struct index_data *obj_index;
extern char *equipment_types[];
extern char *dirs[];
extern const char *zone_bits[];
 
 
/*-------------------------------------------------------------------*/

/*
 * Function prototypes.
 */
void zedit_disp_menu(struct descriptor_data *d);
void zedit_setup(struct descriptor_data *d, int room_num);
void add_cmd_to_list(struct reset_com **list, struct reset_com *newcmd, int pos);
void remove_cmd_from_list(struct reset_com **list, int pos);
void delete_command(struct descriptor_data *d, int pos);
int new_command(struct descriptor_data *d, int pos);
int start_change_command(struct descriptor_data *d, int pos);
void zedit_disp_comtype(struct descriptor_data *d);
void zedit_disp_arg1(struct descriptor_data *d);
void zedit_disp_arg2(struct descriptor_data *d);
void zedit_disp_arg3(struct descriptor_data *d);
void zedit_save_internally(struct descriptor_data *d);
void zedit_save_to_disk(int zone_num);
void zedit_create_index(int znum, char *type);
void zedit_new_zone(struct char_data *ch, int vzone_num);
void zedit_disp_flag_menu(struct descriptor_data *d);

/*-------------------------------------------------------------------*/

/*
 * Nasty internal macros to clean up the code.
 */
#define ZCMD            (zone_table[OLC_ZNUM(d)].cmd[subcmd])
#define MYCMD           (OLC_ZONE(d)->cmd[subcmd])
#define OLC_CMD(d)      (OLC_ZONE(d)->cmd[OLC_VAL(d)])

/*-------------------------------------------------------------------*/

/*
 * Utility functions.
 */

/*-------------------------------------------------------------------*/

void zedit_setup(struct descriptor_data *d, int room_num)
{
  struct zone_data *zone;
  int subcmd = 0, count = 0, cmd_room = -1;

  /*
   * Allocate one scratch zone structure.  
   */
  CREATE(zone, struct zone_data, 1);

  /*
   * Copy all the zone header information over.
   */
  zone->name = str_dup(zone_table[OLC_ZNUM(d)].name);
  zone->lifespan = zone_table[OLC_ZNUM(d)].lifespan;
  zone->top = zone_table[OLC_ZNUM(d)].top;
  zone->reset_mode = zone_table[OLC_ZNUM(d)].reset_mode;
  zone->zone_flags = zone_table[OLC_ZNUM(d)].zone_flags;
  /*
   * The remaining fields are used as a 'has been modified' flag  
   */
  zone->number = 0;     /* Header information has changed.      */
  zone->age = 0;        /* The commands have changed.           */

  /*
   * Start the reset command list with a terminator.
   */
  CREATE(zone->cmd, struct reset_com, 1);
  zone->cmd[0].command = 'S';

  /*
   * Add all entries in zone_table that relate to this room.
   */
  while (ZCMD.command != 'S') {
    switch (ZCMD.command) {
    case 'M':
    case 'O':
      cmd_room = ZCMD.arg3;
      break;
    case 'D':
    case 'R':
      cmd_room = ZCMD.arg1;
      break;
    default:
      break;
    }
    if (cmd_room == room_num) {
#if defined(DEBUG)
      log("zedit_setup called add_cmd_to_list.");
#endif
      add_cmd_to_list(&(zone->cmd), &ZCMD, count);
      count++;
    }
    subcmd++;
  }

  OLC_ZONE(d) = zone;
  /*
   * Display main menu.
   */
  zedit_disp_menu(d);
}

/*-------------------------------------------------------------------*/

/*
 * Create a new zone.
 */

void zedit_new_zone(struct char_data *ch, int vzone_num)
{
  FILE *fp;
  struct zone_data *new_table;
  int i, room;

  if (vzone_num < 0) {
    send_to_char("You can't make negative zones.\r\n", ch);
    return;
  } else if (vzone_num > 326) {
    send_to_char("326 is the highest zone allowed.\r\n", ch);
    return;
  }

  /*
   * Make sure the zone does not exist.
   */
  room = vzone_num * 100;
  for (i = 0; i <= top_of_zone_table; i++)
    if ((zone_table[i].number * 100 <= room) && (zone_table[i].top >= room)) {
      send_to_char("A zone already covers that area.\r\n", ch);
      return;
    }

  /*
   * Create the zone file.
   */
  sprintf(buf, "%s/%d.zon", ZON_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new zone file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write zone file.\r\n", ch);
    return;
  }
  fprintf(fp, "#%d\nNew Zone~\n%d 30 2\nS\n$\n", vzone_num,
                                                (vzone_num * 100) + 99);
  fclose(fp);

  /*
   * Create the room file.
   */
  sprintf(buf, "%s/%d.wld", WLD_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new world file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write world file.\r\n", ch);
    return;
  }
  fprintf(fp, "#%d\nThe Beginning~\nNot much here.\n~\n%d 0 0\nS\n$\n",
                  vzone_num * 100, vzone_num);
  fclose(fp);

  /*
   * Create the mobile file.
   */
  sprintf(buf, "%s/%d.mob", MOB_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new mob file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write mobile file.\r\n", ch);
    return;
  }
  fprintf(fp, "$\n");
  fclose(fp);

  /*
   * Create the object file.
   */
  sprintf(buf, "%s/%d.obj", OBJ_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new obj file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write object file.\r\n", ch);
    return;
  }
  fprintf(fp, "$\n");
  fclose(fp);

  /*
   * Create the shop file.
   */
  sprintf(buf, "%s/%d.shp", SHP_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new shop file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write shop file.\r\n", ch);
    return;
  }
  fprintf(fp, "$~\n");
  fclose(fp);

  /*
   * Create the trigger file.
   */
  sprintf(buf, "%s/%d.trg", TRG_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new trigger file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write trigger file.\r\n", ch);
    return;
  }
  fprintf(fp, "$~\n");
  fclose(fp);

  /*
   * Create the quest file.
   */
  sprintf(buf, "%s/%d.qst", QST_PREFIX, vzone_num);
  if (!(fp = fopen(buf, "w"))) {
    mudlog("SYSERR: OLC: Can't write new quest file", BRF, LVL_OLC_FULL, TRUE);
    send_to_char("Could not write quest file.\r\n", ch);
    return;
  }
  fprintf(fp, "$~\n");
  fclose(fp);
  
  /*
   * Update index files.
   */
  zedit_create_index(vzone_num, "zon");
  zedit_create_index(vzone_num, "wld");
  zedit_create_index(vzone_num, "mob");
  zedit_create_index(vzone_num, "obj");
  zedit_create_index(vzone_num, "shp");
  zedit_create_index(vzone_num, "trg");
//  zedit_create_index(vzone_num, "qst");
    
  /*
   * Make a new zone in memory. This was the source of all the zedit new
   * crashes reported to the CircleMUD list. It was happily overwriting
   * the stack.  This new loop by Andrew Helm fixes that problem and is
   * more understandable at the same time.
   *
   * The variable is 'top_of_zone_table_table + 2' because we need record 0
   * through top_of_zone (top_of_zone_table + 1 items) and a new one which
   * makes it top_of_zone_table + 2 elements large.
   */
  CREATE(new_table, struct zone_data, top_of_zone_table + 2);
  new_table[top_of_zone_table + 1].number = 32000;

  if (vzone_num > zone_table[top_of_zone_table].number) {
    /*
     * We're adding to the end of the zone table, copy all of the current
     * top_of_zone_table + 1 items over and set write point to before the
     * the last record for the for() loop below.
     */
    memcpy(new_table, zone_table, (sizeof (struct zone_data) * (top_of_zone_table + 1)));
    i = top_of_zone_table + 1;
  } else
    /*
     * Copy over all the zones that are before this zone.
     */
    for (i = 0; vzone_num > zone_table[i].number; i++)
      new_table[i] = zone_table[i];

  /*
   * Ok, insert the new zone here.
   */  
  new_table[i].name = str_dup("New Zone");
  new_table[i].number = vzone_num;
  new_table[i].top = (vzone_num * 100) + 99;
  new_table[i].lifespan = 30;
  new_table[i].age = 0;
  new_table[i].reset_mode = 2;
  new_table[i].zone_flags = 0;
  
  /*
   * No zone commands, just terminate it with an 'S'
   */
  CREATE(new_table[i].cmd, struct reset_com, 1);
  new_table[i].cmd[0].command = 'S';

  /*
   * Copy remaining zones into the table one higher, unless of course we
   * are appending to the end in which case this loop will not be used.
   */
  for (; i <= top_of_zone_table; i++)
    new_table[i + 1] = zone_table[i];

  /*
   * Look Ma, no memory leak!
   */
  free(zone_table);
  zone_table = new_table;
  top_of_zone_table++;

  /*
   * Previously, creating a new zone while invisible gave you away.
   * That quirk has been fixed with the MAX() statement.
   */
  sprintf(buf, "OLC: %s creates new zone #%d", GET_NAME(ch), vzone_num);
  mudlog(buf, BRF, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE);
  send_to_char("Zone created successfully.\r\n", ch);

  return;
}

/*-------------------------------------------------------------------*/

void zedit_create_index(int znum, char *type)
{
  FILE *newfile, *oldfile;
  char new_name[32], old_name[32], *prefix;
  int num, found = FALSE;

  switch (*type) {
  case 'z':
    prefix = ZON_PREFIX;
    break;
  case 'w':
    prefix = WLD_PREFIX;
    break;
  case 'o':
    prefix = OBJ_PREFIX;
    break;
  case 'm':
    prefix = MOB_PREFIX;
    break;
  case 's':
    prefix = SHP_PREFIX;
    break;
  case 't':
    prefix = TRG_PREFIX;
    break;
  default:
    /*
     * Caller messed up  
     */
    return;
  }

  sprintf(old_name, "%s/index", prefix);
  sprintf(new_name, "%s/newindex", prefix);

  if (!(oldfile = fopen(old_name, "r"))) {
    sprintf(buf, "SYSERR: OLC: Failed to open %s", buf);
    mudlog(buf, BRF, LVL_OLC_FULL, TRUE);
    return;
  } else if (!(newfile = fopen(new_name, "w"))) {
    sprintf(buf, "SYSERR: OLC: Failed to open %s", buf);
    mudlog(buf, BRF, LVL_OLC_FULL, TRUE);
    return;
  }

  /*
   * Index contents must be in order: search through the old file for the
   * right place, insert the new file, then copy the rest over. 
   */
  sprintf(buf1, "%d.%s", znum, type);
  while (get_line(oldfile, buf)) {
    if (*buf == '$') {
      fprintf(newfile, "%s\n$\n", (!found ? buf1 : ""));
      break;
    } else if (!found) {
      sscanf(buf, "%d", &num);
      if (num > znum) {
        found = TRUE;
        fprintf(newfile, "%s\n", buf1);
      }
    }
    fprintf(newfile, "%s\n", buf);
  }

  fclose(newfile);
  fclose(oldfile);
  /*
   * Out with the old, in with the new.
   */
  remove(old_name);
  rename(new_name, old_name);
}

/*-------------------------------------------------------------------*/

/*
 * Save all the information in the player's temporary buffer back into
 * the current zone table.
 */
void zedit_save_internally(struct descriptor_data *d)
{
  int subcmd = 0, cmd_room = -2, room_num = real_room(OLC_NUM(d));

  /*
   * Delete all entries in zone_table that relate to this room so we
   * can add all the ones we have in their place.
   */
  while (ZCMD.command != 'S') {
    switch (ZCMD.command) {
    case 'M':
    case 'O':
      cmd_room = ZCMD.arg3;
      break;
    case 'D':
    case 'R':
      cmd_room = ZCMD.arg1;
      break;
    default:
      break;
    }
    if (cmd_room == room_num) {
#if defined(DEBUG)
      log("zedit_save_internally called remove_cmd_from_list.");
#endif
      remove_cmd_from_list(&(zone_table[OLC_ZNUM(d)].cmd), subcmd);
    } else
      subcmd++;
  }

  /*
   * Now add all the entries in the players descriptor list  
   */
  subcmd = 0;
  while (MYCMD.command != 'S') {
#if defined(DEBUG)
    log("zedit_save_internally called add_cmd_to_list.");
#endif
    add_cmd_to_list(&(zone_table[OLC_ZNUM(d)].cmd), &MYCMD, subcmd);
    subcmd++;
  }

  /*
   * Finally, if zone headers have been changed, copy over  
   */
  if (OLC_ZONE(d)->number) {
    free(zone_table[OLC_ZNUM(d)].name);
    zone_table[OLC_ZNUM(d)].name = str_dup(OLC_ZONE(d)->name);
    zone_table[OLC_ZNUM(d)].top = OLC_ZONE(d)->top;
    zone_table[OLC_ZNUM(d)].reset_mode = OLC_ZONE(d)->reset_mode;
    zone_table[OLC_ZNUM(d)].lifespan = OLC_ZONE(d)->lifespan;
    zone_table[OLC_ZNUM(d)].zone_flags = OLC_ZONE(d)->zone_flags;
  }
  olc_add_to_save_list(zone_table[OLC_ZNUM(d)].number, OLC_SAVE_ZONE);
}

/*-------------------------------------------------------------------*/

/*
 * Save all the zone_table for this zone to disk.  This function now
 * writes simple comments in the form of (<name>) to each record.  A
 * header for each field is also there.
 */
#undef ZCMD
#define ZCMD    (zone_table[zone_num].cmd[subcmd])
void zedit_save_to_disk(int zone_num)
{
  int subcmd, arg1 = -1, arg2 = -1, arg3 = -1;
  char fname[64];
  const char *comment = NULL;
  FILE *zfile;

  sprintf(fname, "%s/%d.new", ZON_PREFIX, zone_table[zone_num].number);
  if (!(zfile = fopen(fname, "w"))) {
    sprintf(buf, "SYSERR: OLC: zedit_save_to_disk:  Can't write zone %d.",
            zone_table[zone_num].number);
    mudlog(buf, BRF, LVL_BUILDER, TRUE);
    return;
  }
  
  fprintf(zfile,"@Version: %d\n",CUR_ZONE_VERSION);

  /*
   * Print zone header to file  
   */
    fprintf(zfile, "#%d\n" "%s~\n" "%d %d %d %d\n",    
          zone_table[zone_num].number,
          (zone_table[zone_num].name && *zone_table[zone_num].name)
                ? zone_table[zone_num].name : "undefined",
          zone_table[zone_num].top,
          zone_table[zone_num].lifespan,
          zone_table[zone_num].reset_mode,
          zone_table[zone_num].zone_flags
          );

#if defined(ZEDIT_HELP_IN_FILE)
  fprintf(zfile,"* Field #1    Field #3   Field #4  Field #5\n"
                "* M (Mobile)  Mob-Vnum   Wld-Max   Room-Vnum\n"
                "* O (Object)  Obj-Vnum   Wld-Max   Room-Vnum\n"
                "* G (Give)    Obj-Vnum   Wld-Max   Unused\n"
                "* E (Equip)   Obj-Vnum   Wld-Max   EQ-Position\n"
                "* P (Put)     Obj-Vnum   Wld-Max   Target-Obj-Vnum\n"
                "* D (Door)    Room-Vnum  Door-Dir  Door-State\n"
                "* R (Remove)  Room-Vnum  Obj-Vnum  Unused\n"
  );
#endif

  for (subcmd = 0; ZCMD.command != 'S'; subcmd++) {
    switch (ZCMD.command) {
    case 'M':
      arg1 = mob_index[ZCMD.arg1].vnum;
      arg2 = ZCMD.arg2;
      arg3 = world[ZCMD.arg3].number;
      comment = mob_proto[ZCMD.arg1].player.short_descr;
      break;
    case 'O':
      arg1 = obj_index[ZCMD.arg1].vnum;
      arg2 = ZCMD.arg2;
      arg3 = world[ZCMD.arg3].number;
      comment = obj_proto[ZCMD.arg1].short_description;
      break;
    case 'G':
      arg1 = obj_index[ZCMD.arg1].vnum;
      arg2 = ZCMD.arg2;
      arg3 = -1;
      comment = obj_proto[ZCMD.arg1].short_description;
      break;
    case 'E':
      arg1 = obj_index[ZCMD.arg1].vnum;
      arg2 = ZCMD.arg2;
      arg3 = ZCMD.arg3;
      comment = obj_proto[ZCMD.arg1].short_description;
      break;
    case 'P':
      arg1 = obj_index[ZCMD.arg1].vnum;
      arg2 = ZCMD.arg2;
      arg3 = obj_index[ZCMD.arg3].vnum;
      comment = obj_proto[ZCMD.arg1].short_description;
      break;
    case 'D':
      arg1 = world[ZCMD.arg1].number;
      arg2 = ZCMD.arg2;
      arg3 = ZCMD.arg3;
      comment = world[ZCMD.arg1].name;
      break;
    case 'R':
      arg1 = world[ZCMD.arg1].number;
      arg2 = obj_index[ZCMD.arg2].vnum;
      comment = obj_proto[ZCMD.arg2].short_description;
      arg3 = -1;
      break;
    case '*':
      /*
       * Invalid commands are replaced with '*' - Ignore them.
       */
      continue;
    default:
      sprintf(buf, "SYSERR: OLC: z_save_to_disk(): Unknown cmd '%c' - NOT saving", ZCMD.command);
      mudlog(buf, BRF, LVL_BUILDER, TRUE);
      continue;
    }
    fprintf(zfile, "%c %d %d %d %d \t(%s)\n",
            ZCMD.command, ZCMD.if_flag, arg1, arg2, arg3, comment);
  }
  fprintf(zfile, "S\n$\n");
  fclose(zfile);
  sprintf(buf2, "%s/%d.zon", ZON_PREFIX, zone_table[zone_num].number);
  /*
   * We're fubar'd if we crash between the two lines below.
   */
  remove(buf2);
  rename(fname, buf2);

  olc_remove_from_save_list(zone_table[zone_num].number, OLC_SAVE_ZONE);
}

/*-------------------------------------------------------------------*/

/*
 * Some common code to count the number of comands in the list.
 */
int count_commands(struct reset_com *list)
{
  int count = 0;

  while (list[count].command != 'S')
    count++;

  return count;
}

/*-------------------------------------------------------------------*/

/*
 * Adds a new reset command into a list.  Takes a pointer to the list
 * so that it may play with the memory locations.
 */
void add_cmd_to_list(struct reset_com **list, struct reset_com *newcmd, int pos)
{
  int count, i, l;
  struct reset_com *newlist;

  /*
   * Count number of commands (not including terminator).
   */
  count = count_commands(*list);

  /*
   * Value is +2 for the terminator and new field to add.
   */
  CREATE(newlist, struct reset_com, count + 2);

  /*
   * Even tighter loop to copy the old list and insert a new command.
   */
  for (i = 0, l = 0; i <= count; i++) {
    newlist[i] = ((i == pos) ? *newcmd : (*list)[l++]);
#if defined(DEBUG)
    sprintf(buf, "add_cmd_to_list: added %c %d %d %d %d",
                newlist[i].command, newlist[i].arg1, newlist[i].arg2,
                newlist[i].arg3, newlist[i].line);
    log(buf);
#endif
  }

  /*
   * Add terminator, then insert new list.
   */
  newlist[count + 1].command = 'S';
  free(*list);
  *list = newlist;
}

/*-------------------------------------------------------------------*/

/*
 * Remove a reset command from a list.  Takes a pointer to the list
 * so that it may play with the memory locations.
 */
void remove_cmd_from_list(struct reset_com **list, int pos)
{
  int count, i, l;
  struct reset_com *newlist;

  /*
   * Count number of commands (not including terminator)  
   */
  count = count_commands(*list);

  /*
   * Value is 'count' because we didn't include the terminator above
   * but since we're deleting one thing anyway we want one less.
   */
  CREATE(newlist, struct reset_com, count);

  /*
   * Even tighter loop to copy old list and skip unwanted command.
   */
  for (i = 0, l = 0; i < count; i++) {
    if (i != pos) {
#if defined(DEBUG)
      sprintf(buf, "remove_cmd_from_list: kept %c %d %d %d %d",
                (*list)[i].command, (*list)[i].arg1, (*list)[i].arg2,
                (*list)[i].arg3, (*list)[i].line);
#endif
      newlist[l++] = (*list)[i];
    }
#if defined(DEBUG)
    else
      sprintf(buf, "remove_cmd_from_list: deleted %c %d %d %d %d",
                (*list)[i].command, (*list)[i].arg1, (*list)[i].arg2,
                (*list)[i].arg3, (*list)[i].line);
    log(buf);
#endif
  }
  /*
   * Add the terminator, then insert the new list.
   */
  newlist[count - 1].command = 'S';
  free(*list);
  *list = newlist;
}

/*-------------------------------------------------------------------*/

/*
 * Error check user input and then add new (blank) command  
 */
int new_command(struct descriptor_data *d, int pos)
{
  int subcmd = 0;
  struct reset_com *new_com;

  /*
   * Error check to ensure users hasn't given too large an index  
   */
  while (MYCMD.command != 'S')
    subcmd++;

  if ((pos > subcmd) || (pos < 0))
    return 0;

  /*
   * Ok, let's add a new (blank) command 
   */
  CREATE(new_com, struct reset_com, 1);
  new_com->command = 'N';
#if defined(DEBUG)
  log("new_command called add_cmd_to_list.");
#endif
  add_cmd_to_list(&OLC_ZONE(d)->cmd, new_com, pos);
  return 1;
}

/*-------------------------------------------------------------------*/
/*
 * Error check user input and then remove command  
 */

void delete_command(struct descriptor_data *d, int pos)
{
  int subcmd = 0;

  /*
   * Error check to ensure users hasn't given too large an index  
   */
  while (MYCMD.command != 'S')
    subcmd++;

  if ((pos >= subcmd) || (pos < 0))
    return;

  /*
   * Ok, let's zap it  
   */
#if defined(DEBUG)
  log("delete_command called remove_cmd_from_list.");
#endif
  remove_cmd_from_list(&OLC_ZONE(d)->cmd, pos);
}

/*-------------------------------------------------------------------*/
/*
 * Error check user input and then setup change  
 */

int start_change_command(struct descriptor_data *d, int pos)
{
  int subcmd = 0;

  /*
   * Error check to ensure users hasn't given too large an index  
   */
  while (MYCMD.command != 'S')
    subcmd++;

  if ((pos >= subcmd) || (pos < 0))
    return 0;

  /*
   * Ok, let's get editing  
   */
  OLC_VAL(d) = pos;
  return 1;
}

/**************************************************************************
 Menu functions 
 **************************************************************************/

/*
 * the main menu 
 */
void zedit_disp_menu(struct descriptor_data *d)
{
  int subcmd = 0, room, counter = 0;

  get_char_cols(d->character);
  room = real_room(OLC_NUM(d));
  
  sprintbit((long)OLC_ZONE(d)->zone_flags, zone_bits, buf1);

  /*
   * Menu header  
   */
  sprintf(buf,
#if defined(CLEAR_SCREEN)
          "[H[J"
#endif
          "Room number: %s%d%s          Room zone: %s%d\r\n"
          "%sZ%s) Zone name   : %s%s\r\n"
          "%sL%s) Lifespan    : %s%d minutes\r\n"
          "%sT%s) Top of zone : %s%d\r\n"
          "%sR%s) Reset Mode  : %s%s\r\n"
          "%sF%s) Zone Flags  : %s%s%s\r\n"
          "[Command list]\r\n",

          cyn, OLC_NUM(d), nrm,
          cyn, zone_table[OLC_ZNUM(d)].number,
        grn, nrm, yel, OLC_ZONE(d)->name ? OLC_ZONE(d)->name : "<NONE!>",
          grn, nrm, yel, OLC_ZONE(d)->lifespan,
          grn, nrm, yel, OLC_ZONE(d)->top,
          grn, nrm, yel, OLC_ZONE(d)->reset_mode ?
          ((OLC_ZONE(d)->reset_mode == 1) ?
           "Reset when no players are in zone." :
           "Normal reset.") :
           "Never reset",
           grn, nrm, yel, buf1, nrm
          );

  /*
   * Print the commands for this room into display buffer.
   */
  while (MYCMD.command != 'S') {
    /*
     * Translate what the command means.
     */
    switch (MYCMD.command) {
    case 'M':
      sprintf(buf2, "%sLoad %s [%s%d%s], Max : %d",
              MYCMD.if_flag ? " then " : "",
              mob_proto[MYCMD.arg1].player.short_descr,
              cyn, mob_index[MYCMD.arg1].vnum, yel,
              MYCMD.arg2
              );
      break;
    case 'G':
      sprintf(buf2, "%sGive it %s [%s%d%s], Max : %d",
              MYCMD.if_flag ? " then " : "",
              obj_proto[MYCMD.arg1].short_description,
              cyn, obj_index[MYCMD.arg1].vnum, yel,
              MYCMD.arg2
              );
      break;
    case 'O':
      sprintf(buf2, "%sLoad %s [%s%d%s], Max : %d",
              MYCMD.if_flag ? " then " : "",
              obj_proto[MYCMD.arg1].short_description,
              cyn, obj_index[MYCMD.arg1].vnum, yel,
              MYCMD.arg2
              );
      break;
    case 'E':
      sprintf(buf2, "%sEquip with %s [%s%d%s], %s, Max : %d",
              MYCMD.if_flag ? " then " : "",
              obj_proto[MYCMD.arg1].short_description,
              cyn, obj_index[MYCMD.arg1].vnum, yel,
              equipment_types[MYCMD.arg3],
              MYCMD.arg2
              );
      break;
    case 'P':
      sprintf(buf2, "%sPut %s [%s%d%s] in %s [%s%d%s], Max : %d",
              MYCMD.if_flag ? " then " : "",
              obj_proto[MYCMD.arg1].short_description,
              cyn, obj_index[MYCMD.arg1].vnum, yel,
              obj_proto[MYCMD.arg3].short_description,
              cyn, obj_index[MYCMD.arg3].vnum, yel,
              MYCMD.arg2
              );
      break;
    case 'R':
      sprintf(buf2, "%sRemove %s [%s%d%s] from room.",
              MYCMD.if_flag ? " then " : "",
              obj_proto[MYCMD.arg2].short_description,
              cyn, obj_index[MYCMD.arg2].vnum, yel
              );
      break;
    case 'D':
      sprintf(buf2, "%sSet door %s as %s.",
              MYCMD.if_flag ? " then " : "",
              dirs[MYCMD.arg2],
              MYCMD.arg3 ? ((MYCMD.arg3 == 1) ? "closed" : "locked") : "open"
              );
      break;
    default:
      strcpy(buf2, "<Unknown Command>");
      break;
    }
    /*
     * Build the display buffer for this command  
     */
    sprintf(buf1, "%s%d - %s%s\r\n", nrm, counter++, yel, buf2);
    strcat(buf, buf1);
    subcmd++;
  }
  /*
   * Finish off menu  
   */
  sprintf(buf1,
          "%s%d - <END OF LIST>\r\n"
          "%sN%s) New command.\r\n"
          "%sE%s) Edit a command.\r\n"
          "%sD%s) Delete a command.\r\n"
          "%sQ%s) Quit\r\nEnter your choice : ",
          nrm, counter, grn, nrm, grn, nrm, grn, nrm, grn, nrm
          );

  strcat(buf, buf1);
  send_to_char(buf, d->character);

  OLC_MODE(d) = ZEDIT_MAIN_MENU;
}

/*-------------------------------------------------------------------*/

/*
 * Print the command type menu and setup response catch. 
 */
void zedit_disp_comtype(struct descriptor_data *d)
{
  get_char_cols(d->character);
  sprintf(buf,
#if defined(CLEAR_SCREEN)
        "[H[J"
#endif
        "%sM%s) Load Mobile to room             %sO%s) Load Object to room\r\n"
        "%sE%s) Equip mobile with object        %sG%s) Give an object to a mobile\r\n"
        "%sP%s) Put object in another object    %sD%s) Open/Close/Lock a Door\r\n"
        "%sR%s) Remove an object from the room\r\n"
        "What sort of command will this be? : ",
        grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm,
        grn, nrm, grn, nrm
        );
  send_to_char(buf, d->character);
  OLC_MODE(d) = ZEDIT_COMMAND_TYPE;
}

/*-------------------------------------------------------------------*/

/*
 * Print the appropriate message for the command type for arg1 and set
 * up the input catch clause  
 */
void zedit_disp_arg1(struct descriptor_data *d)
{
  switch (OLC_CMD(d).command) {
  case 'M':
    send_to_char("Input mob's vnum : ", d->character);
    OLC_MODE(d) = ZEDIT_ARG1;
    break;
  case 'O':
  case 'E':
  case 'P':
  case 'G':
    send_to_char("Input object vnum : ", d->character);
    OLC_MODE(d) = ZEDIT_ARG1;
    break;
  case 'D':
  case 'R':
    /*
     * Arg1 for these is the room number, skip to arg2  
     */
    OLC_CMD(d).arg1 = real_room(OLC_NUM(d));
    zedit_disp_arg2(d);
    break;
  default:
    /*
     * We should never get here  .
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: zedit_disp_arg1(): Help!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    return;
  }
}

/*-------------------------------------------------------------------*/

/*
 * Print the appropriate message for the command type for arg2 and set
 * up the input catch clause.
 */
void zedit_disp_arg2(struct descriptor_data *d)
{
  int i = 0;

  switch (OLC_CMD(d).command) {
  case 'M':
  case 'O':
  case 'E':
  case 'P':
  case 'G':
    send_to_char("Input the maximum number that can exist on the mud : ", d->character);
    break;
  case 'D':
    while (*dirs[i] != '\n') {
      sprintf(buf, "%d) Exit %s.\r\n", i, dirs[i]);
      send_to_char(buf, d->character);
      i++;
    }
    send_to_char("Enter exit number for door : ", d->character);
    break;
  case 'R':
    send_to_char("Input object's vnum : ", d->character);
    break;
  default:
    /*
     * We should never get here, but just in case...
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: zedit_disp_arg2(): Help!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    return;
  }
  OLC_MODE(d) = ZEDIT_ARG2;
}

/*-------------------------------------------------------------------*/

/*
 * Print the appropriate message for the command type for arg3 and set
 * up the input catch clause.
 */
void zedit_disp_arg3(struct descriptor_data *d)
{
  int i = 0;

  switch (OLC_CMD(d).command) {
  case 'E':
    while (*equipment_types[i] != '\n') {
      sprintf(buf, "%2d) %26.26s %2d) %26.26s\r\n", i,
           equipment_types[i], i + 1, (*equipment_types[i + 1] != '\n') ?
              equipment_types[i + 1] : "");
      send_to_char(buf, d->character);
      if (*equipment_types[i + 1] != '\n')
        i += 2;
      else
        break;
    }
    send_to_char("Location to equip : ", d->character);
    break;
  case 'P':
    send_to_char("Vnum of the container : ", d->character);
    break;
  case 'D':
    send_to_char("0)  Door open\r\n"
                 "1)  Door closed\r\n"
                 "2)  Door locked\r\n"
                 "Enter state of the door : ", d->character);
    break;
  case 'M':
  case 'O':
  case 'R':
  case 'G':
  default:
    /*
     * We should never get here, just in case.
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: zedit_disp_arg3(): Help!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    return;
  }
  OLC_MODE(d) = ZEDIT_ARG3;
}

/**************************************************************************
  The GARGANTAUN event handler
 **************************************************************************/

void zedit_parse(struct descriptor_data *d, char *arg)
{
  int pos, number, i = 0;

  switch (OLC_MODE(d)) {
/*-------------------------------------------------------------------*/
  case ZEDIT_CONFIRM_SAVESTRING:
    switch (*arg) {
    case 'y':
    case 'Y':
      /*
       * Save the zone in memory, hiding invisible people.
       */
      send_to_char("Saving zone info in memory.\r\n", d->character);
      zedit_save_internally(d);
      sprintf(buf, "OLC: %s edits zone info for room %d.",
                GET_NAME(d->character), OLC_NUM(d));
      mudlog(buf, CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE);
      /* FALL THROUGH */
    case 'n':
    case 'N':
      cleanup_olc(d, CLEANUP_ALL);
      break;
    default:
      send_to_char("Invalid choice!\r\n", d->character);
      send_to_char("Do you wish to save the zone info? : ", d->character);
      break;
    }
    break;
   /* End of ZEDIT_CONFIRM_SAVESTRING */

/*-------------------------------------------------------------------*/
  case ZEDIT_MAIN_MENU:
    switch (*arg) {
    case 'q':
    case 'Q':
      if (OLC_ZONE(d)->age || OLC_ZONE(d)->number) {
        send_to_char("Do you wish to save the changes to the zone info? (y/n) : ", d->character);
        OLC_MODE(d) = ZEDIT_CONFIRM_SAVESTRING;
      } else {
        send_to_char("No changes made.\r\n", d->character);
        cleanup_olc(d, CLEANUP_ALL);
      }
      break;
    case 'n':
    case 'N':
      /*
       * New entry.
       */
      send_to_char("What number in the list should the new command be? : ", d->character);
      OLC_MODE(d) = ZEDIT_NEW_ENTRY;
      break;
    case 'e':
    case 'E':
      /*
       * Change an entry.
       */
      send_to_char("Which command do you wish to change? : ", d->character);
      OLC_MODE(d) = ZEDIT_CHANGE_ENTRY;
      break;
    case 'd':
    case 'D':
      /*
       * Delete an entry.
       */
      send_to_char("Which command do you wish to delete? : ", d->character);
      OLC_MODE(d) = ZEDIT_DELETE_ENTRY;
      break;
    case 'z':
    case 'Z':
      /*
       * Edit zone name.
       */
      send_to_char("Enter new zone name : ", d->character);
      OLC_MODE(d) = ZEDIT_ZONE_NAME;
      break;
    case 't':
    case 'T':
      /*
       * Edit top of zone.
       */
      if (GET_LEVEL(d->character) < LVL_OLC_FULL)
        zedit_disp_menu(d);
      else {
        send_to_char("Enter new top of zone : ", d->character);
        OLC_MODE(d) = ZEDIT_ZONE_TOP;
      }
      break;
    case 'l':
    case 'L':
      /*
       * Edit zone lifespan.
       */
      send_to_char("Enter new zone lifespan : ", d->character);
      OLC_MODE(d) = ZEDIT_ZONE_LIFE;
      break;
    case 'r':
    case 'R':
      /*
       * Edit zone reset mode.
       */
      send_to_char("\r\n"
                   "0) Never reset\r\n"
                   "1) Reset only when no players in zone\r\n"
                   "2) Normal reset\r\n"
                   "Enter new zone reset type : ", d->character);
      OLC_MODE(d) = ZEDIT_ZONE_RESET;
      break;
    case 'f':
    case 'F':
      zedit_disp_flag_menu(d);
      break;  
    default:
      zedit_disp_menu(d);
      break;
    }
    break;
    /* End of ZEDIT_MAIN_MENU */

/*-------------------------------------------------------------------*/
  case ZEDIT_NEW_ENTRY:
    /*
     * Get the line number and insert the new line.
     */
    pos = atoi(arg);
    if (isdigit(*arg) && new_command(d, pos)) {
      if (start_change_command(d, pos)) {
        zedit_disp_comtype(d);
        OLC_ZONE(d)->age = 1;
      }
    } else
      zedit_disp_menu(d);
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_DELETE_ENTRY:
    /*
     * Get the line number and delete the line.
     */
    pos = atoi(arg);
    if (isdigit(*arg)) {
      delete_command(d, pos);
      OLC_ZONE(d)->age = 1;
    }
    zedit_disp_menu(d);
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_CHANGE_ENTRY:
    /*
     * Parse the input for which line to edit, and goto next quiz.
     */
    pos = atoi(arg);
    if (isdigit(*arg) && start_change_command(d, pos)) {
      zedit_disp_comtype(d);
      OLC_ZONE(d)->age = 1;
    } else
      zedit_disp_menu(d);
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_COMMAND_TYPE:
    /*
     * Parse the input for which type of command this is, and goto next
     * quiz.
     */
    OLC_CMD(d).command = toupper(*arg);
    if (!OLC_CMD(d).command || (strchr("MOPEDGR", OLC_CMD(d).command) == NULL)) {
      send_to_char("Invalid choice, try again : ", d->character);
    } else {
      if (OLC_VAL(d)) { /* If there was a previous command. */
        send_to_char("Is this command dependent on the success of the previous one? (y/n)\r\n", d->character);
        OLC_MODE(d) = ZEDIT_IF_FLAG;
      } else {  /* 'if-flag' not appropriate. */
        OLC_CMD(d).if_flag = 0;
        zedit_disp_arg1(d);
      }
    }
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_IF_FLAG:
    /*
     * Parse the input for the if flag, and goto next quiz.
     */
    switch (*arg) {
    case 'y':
    case 'Y':
      OLC_CMD(d).if_flag = 1;
      break;
    case 'n':
    case 'N':
      OLC_CMD(d).if_flag = 0;
      break;
    default:
      send_to_char("Try again : ", d->character);
      return;
    }
    zedit_disp_arg1(d);
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ARG1:
    /*
     * Parse the input for arg1, and goto next quiz.
     */
    if (!isdigit(*arg)) {
      send_to_char("Must be a numeric value, try again : ", d->character);
      return;
    }
    switch (OLC_CMD(d).command) {
    case 'M':
      if ((pos = real_mobile(atoi(arg))) >= 0) {
        OLC_CMD(d).arg1 = pos;
        zedit_disp_arg2(d);
      } else
        send_to_char("That mobile does not exist, try again : ", d->character);
      break;
    case 'O':
    case 'P':
    case 'E':
    case 'G':
      if ((pos = real_object(atoi(arg))) >= 0) {
        OLC_CMD(d).arg1 = pos;
        zedit_disp_arg2(d);
      } else
        send_to_char("That object does not exist, try again : ", d->character);
      break;
    case 'D':
    case 'R':
    default:
      /*
       * We should never get here.
       */
      cleanup_olc(d, CLEANUP_ALL);
      mudlog("SYSERR: OLC: zedit_parse(): case ARG1: Ack!", BRF, LVL_BUILDER, TRUE);
      send_to_char("Oops...\r\n", d->character);
      break;
    }
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ARG2:
    /*
     * Parse the input for arg2, and goto next quiz.
     */
    if (!isdigit(*arg)) {
      send_to_char("Must be a numeric value, try again : ", d->character);
      return;
    }
    switch (OLC_CMD(d).command) {
    case 'M':
    case 'O':
      OLC_CMD(d).arg2 = atoi(arg);
      OLC_CMD(d).arg3 = real_room(OLC_NUM(d));
      zedit_disp_menu(d);
      break;
    case 'G':
      OLC_CMD(d).arg2 = atoi(arg);
      zedit_disp_menu(d);
      break;
    case 'P':
    case 'E':
      OLC_CMD(d).arg2 = atoi(arg);
      zedit_disp_arg3(d);
      break;
    case 'D':
      pos = atoi(arg);
      /*
       * Count directions.
       */
      while (*dirs[i] != '\n')
        i++;
      if ((pos < 0) || (pos > i))
        send_to_char("Try again : ", d->character);
      else {
        OLC_CMD(d).arg2 = pos;
        zedit_disp_arg3(d);
      }
      break;
    case 'R':
      if ((pos = real_object(atoi(arg))) >= 0) {
        OLC_CMD(d).arg2 = pos;
        zedit_disp_menu(d);
      } else
        send_to_char("That object does not exist, try again : ", d->character);
      break;
    default:
      /*
       * We should never get here, but just in case...
       */
      cleanup_olc(d, CLEANUP_ALL);
      mudlog("SYSERR: OLC: zedit_parse(): case ARG2: Ack!", BRF, LVL_BUILDER, TRUE);
      send_to_char("Oops...\r\n", d->character);
      break;
    }
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ARG3:
    /*
     * Parse the input for arg3, and go back to main menu.
     */
    if (!isdigit(*arg)) {
      send_to_char("Must be a numeric value, try again : ", d->character);
      return;
    }
    switch (OLC_CMD(d).command) {
    case 'E':
      pos = atoi(arg);
      /*
       * Count number of wear positions.  We could use NUM_WEARS, this is
       * more reliable.
       */
      while (*equipment_types[i] != '\n')
        i++;
      if ((pos < 0) || (pos > i))
        send_to_char("Try again : ", d->character);
      else {
        OLC_CMD(d).arg3 = pos;
        zedit_disp_menu(d);
      }
      break;
    case 'P':
      if ((pos = real_object(atoi(arg))) >= 0) {
        OLC_CMD(d).arg3 = pos;
        zedit_disp_menu(d);
      } else
        send_to_char("That object does not exist, try again : ", d->character);
      break;
    case 'D':
      pos = atoi(arg);
      if ((pos < 0) || (pos > 2))
        send_to_char("Try again : ", d->character);
      else {
        OLC_CMD(d).arg3 = pos;
        zedit_disp_menu(d);
      }
      break;
    case 'M':
    case 'O':
    case 'G':
    case 'R':
    default:
      /*
       * We should never get here, but just in case...
       */
      cleanup_olc(d, CLEANUP_ALL);
      mudlog("SYSERR: OLC: zedit_parse(): case ARG3: Ack!", BRF, LVL_BUILDER, TRUE);
      send_to_char("Oops...\r\n", d->character);
      break;
    }
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ZONE_NAME:
    /*
     * Add new name and return to main menu.
     */
    if (OLC_ZONE(d)->name)
      free(OLC_ZONE(d)->name);
    else
      log("SYSERR: OLC: ZEDIT_ZONE_NAME: no name to free!");
    OLC_ZONE(d)->name = str_dup(arg);
    OLC_ZONE(d)->number = 1;
    zedit_disp_menu(d);
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ZONE_RESET:
    /*
     * Parse and add new reset_mode and return to main menu.
     */
    pos = atoi(arg);
    if (!isdigit(*arg) || (pos < 0) || (pos > 2))
      send_to_char("Try again (0-2) : ", d->character);
    else {
      OLC_ZONE(d)->reset_mode = pos;
      OLC_ZONE(d)->number = 1;
      zedit_disp_menu(d);
    }
    break;

/* --------------------------------------------------------------- */
  case ZEDIT_ZONE_FLAGS:

    number = atoi(arg);
    if ((number < 0) || (number > NUM_ZONE_FLAGS)) {
      send_to_char("That is not a valid choice!\r\n", d->character);
      zedit_disp_flag_menu(d);
      }
    else
      if (number == 0) {
      zedit_disp_menu(d); 
       break; 
       }
    else {
      TOGGLE_BIT(OLC_ZONE(d)->zone_flags, 1 << (number - 1));
      OLC_ZONE(d)->number = 1;
      zedit_disp_flag_menu(d);
    }
    return;
  break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ZONE_LIFE:
    /*
     * Parse and add new lifespan and return to main menu.
     */
    pos = atoi(arg);
    if (!isdigit(*arg) || (pos < 0) || (pos > 240))
      send_to_char("Try again (0-240) : ", d->character);
    else {
      OLC_ZONE(d)->lifespan = pos;
      OLC_ZONE(d)->number = 1;
      zedit_disp_menu(d);
    }
    break;

/*-------------------------------------------------------------------*/
  case ZEDIT_ZONE_TOP:
    /*
     * Parse and add new top room in zone and return to main menu.
     */
    if (OLC_ZNUM(d) == top_of_zone_table)
      OLC_ZONE(d)->top = MAX(OLC_ZNUM(d) * 100, MIN(32000, atoi(arg)));
    else
      OLC_ZONE(d)->top = MAX(OLC_ZNUM(d) * 100, MIN(zone_table[OLC_ZNUM(d) + 1].number * 100, atoi(arg)));
    zedit_disp_menu(d);
    break;

/*-------------------------------------------------------------------*/
  default:
    /*
     * We should never get here, but just in case...
     */
    cleanup_olc(d, CLEANUP_ALL);
    mudlog("SYSERR: OLC: zedit_parse(): Reached default case!", BRF, LVL_BUILDER, TRUE);
    send_to_char("Oops...\r\n", d->character);
    break;
  }
}


void zedit_disp_flag_menu(struct descriptor_data *d)
{
  int counter, columns = 0;

  get_char_cols(d->character);
#if defined(CLEAR_SCREEN)
sprintf(buf, "%c[H%c[J", 27, 27);
send_to_char(buf, d->character);
#endif
  for (counter = 0; counter < NUM_ZONE_FLAGS; counter++) {
    sprintf(buf, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
		zone_bits[counter], !(++columns % 2) ? "\r\n" : "");
    send_to_char(buf, d->character);
  }
  sprintbit(OLC_ZONE(d)->zone_flags, zone_bits, buf1);
  sprintf(buf, "\r\nZone flags: %s%s%s\r\n"
	  "Enter zone flags, 0 to quit : ", cyn, buf1, nrm);
  send_to_char(buf, d->character);
  OLC_MODE(d) = ZEDIT_ZONE_FLAGS;
}

/*
 * End of parse_zedit()  
 */
