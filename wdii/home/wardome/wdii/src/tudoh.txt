::::::::::::::
auction.h
::::::::::::::

struct item_auction {
	struct obj_data *obj;
	struct char_data *dono;
	struct char_data *comprador;
	int preco;
	int ultimo_preco;
	short int tempo;
};

struct item_auction *auc;
short int num_aucs = 0;

void auction_update(void);

::::::::::::::
boards.h
::::::::::::::
/* ************************************************************************
*   File: boards.h                                      Part of CircleMUD *
*  Usage: header file for bulletin boards                                 *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define NUM_OF_BOARDS           16       /* change if needed! */
#define MAX_BOARD_MESSAGES      60      /* arbitrary -- change if needed */
#define MAX_MESSAGE_LENGTH      4096    /* arbitrary -- change if needed */

#define INDEX_SIZE         ((NUM_OF_BOARDS*MAX_BOARD_MESSAGES) + 5)

#define BOARD_MAGIC     1048575 /* arbitrary number - see modify.c */

struct board_msginfo {
   int  slot_num;     /* pos of message in "master index" */
   char *heading;     /* pointer to message's heading */
   int  level;        /* level of poster */
   int  heading_len;  /* size of header (for file write) */
   int  message_len;  /* size of message text (for file write) */
};

struct board_info_type {
   int  vnum;           /* vnum of this board */
   int  read_lvl;       /* min level to read messages on this board */
   int  write_lvl;      /* min level to write messages on this board */
   int  remove_lvl;     /* min level to remove messages from this board */
   char filename[50];   /* file to save this board to */
   int  rnum;           /* rnum of this board */
};

#define BOARD_VNUM(i) (board_info[i].vnum)
#define READ_LVL(i) (board_info[i].read_lvl)
#define WRITE_LVL(i) (board_info[i].write_lvl)
#define REMOVE_LVL(i) (board_info[i].remove_lvl)
#define FILENAME(i) (board_info[i].filename)
#define BOARD_RNUM(i) (board_info[i].rnum)

#define NEW_MSG_INDEX(i) (msg_index[i][num_of_msgs[i]])
#define MSG_HEADING(i, j) (msg_index[i][j].heading)
#define MSG_SLOTNUM(i, j) (msg_index[i][j].slot_num)
#define MSG_LEVEL(i, j) (msg_index[i][j].level)

int     Board_display_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
int     Board_show_board(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
int     Board_remove_msg(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
int     Board_write_message(int board_type, struct char_data *ch, char *arg, struct obj_data *board);
void    Board_save_board(int board_type);
void    Board_load_board(int board_type);
void    Board_reset_board(int board_num);
::::::::::::::
buffer.h
::::::::::::::
#if !defined(__BUFFER_H__)
#define __BUFFER_H__

/*
 * CONFIGURABLES (aka, The place to shoot your own foot.) :)
 * ---------------------------------------------------------
 */

/*
 * 1 = use buffer system for all memory allocations using CREATE().
 * 0 = use standard calloc/realloc in the CREATE() macro.
 *
 * The advantage to using the buffer system is that it will keep track of
 * all your allocations and warn if one of the malloc buffers is overflowed.
 * You can also view every allocation, what file and line it was allocated
 * from, and how large it was.  This would be useful to detect a memory leak.
 * Using this option, stock CircleMUD bpl12 takes 1.8 seconds to boot on my
 * Pentium 133, and 1.6 seconds to boot without it.
 */
#define BUFFER_MEMORY	1

/*
 * 1 = Include original CircleMUD buffers too.
 * 0 = Use only new buffer system.
 *
 * This will helpfully point out all your existing global buffer uses if you
 * decide to convert to all buffer system.
 */
#define USE_CIRCLE_BUFFERS      1

/*
 * -----------------------------------------------------
 * No tweakables below! See 'buffer.c' for more options.
 * -----------------------------------------------------
 */

/*
 * Handle GCC-isms.
 */
#if !defined(__GNUC__)
#define __attribute__(x)
#define __FUNCTION__	__FILE__
#endif

/*
 * These macros neatly pass the required information without breaking the
 * rest of the code.  The 'get_buffer()' code should be used for a temporary
 * memory chunk such as the current CircleMUD 'buf,' 'buf1,' and 'buf2'
 * variables.  Remember to use 'release_buffer()' to give up the requested
 * buffer when finished with it.  'release_my_buffers()' may be used in
 * functions with a lot of return statements but it is _not_ encouraged.
 * 'get_memory()' and 'release_memory()' should only be used for memory that
 * you always want handled here regardless of BUFFER_MEMORY.
 */
#define get_buffer(a)		acquire_buffer((a), BT_STACK, NULL, __FUNCTION__, __LINE__)
#define get_memory(a)		acquire_buffer((a), BT_MALLOC, NULL, __FUNCTION__, __LINE__)
#define release_buffer(a)	do { detach_buffer((a), BT_STACK, __FUNCTION__, __LINE__); (a) = NULL; } while(0)
#define release_memory(a)	do { detach_buffer((a), BT_MALLOC, __FUNCTION__, __LINE__); (a) = NULL; } while(0)
#define release_my_buffers()	detach_my_buffers(__FUNCTION__, __LINE__)

/*
 * Types for the memory to allocate.  It should never be necessary to use
 * these definitions directly.
 */
#define BT_STACK	0	/* Stack type memory.			*/
#define BT_PERSIST	1	/* A buffer that doesn't time out.	*/
#define BT_MALLOC	2	/* A malloc() memory tracker.		*/

/*
 * Check for released and timed out buffers every 5 seconds.  This can be
 * be arbitrarily changed.
 */
#define PULSE_BUFFER	(5 RL_SEC)

/*
 * Public functions for outside use.
 */
#if 0 /* BUFFER_SNPRINTF */
buffer *str_cpy(buffer *d, buffer*s);
int bprintf(buffer *buf, const char *format, ...);
#endif
#if BUFFER_MEMORY
void *debug_calloc(size_t number, size_t size, const char *var, const char *func, int line);
void *debug_realloc(void *ptr, size_t size, const char *var, const char *func, int line);
void debug_free(void *ptr, const char *func, ush_int line);
char *debug_str_dup(const char *txt, const char *var, const char *func, ush_int line);
void really_free(void *ptr);
#endif
void init_buffers(void);
void exit_buffers(void);
void release_all_buffers(void);
struct buf_data *detach_buffer(char *data, byte type, const char *func, const int line_n);
void detach_my_buffers(const char *func, const int line_n);
char *acquire_buffer(size_t size, int type, const char *var, const char *who, ush_int line);
void show_buffers(struct char_data *ch, int buffer_type, int display_type);
extern int buffer_cache_stat[];
#define BUFFER_CACHE_HITS	0
#define BUFFER_CACHE_MISSES	1

#endif
::::::::::::::
buffer_i.h
::::::::::::::
#if !defined(__BUFFER_I_H__)
#define __BUFFER_I_H__

struct buf_data {
  byte magic;		/* Have we been trashed?		*/
#if BUFFER_THREADED
  byte locked;		/* Don't touch this item, we're locked.	*/
#endif
  byte type;		/* What type of buffer are we?		*/
  ush_int line;         /* What source code line is using this. */
  size_t req_size;	/* How much did the function request?	*/
  union {
    sh_long life;	/* An idle counter to free unused ones.	(B) */
    const char *var;	/* Name of variable allocated to.	(M) */
  } var_life;
  size_t size;          /* How large is this buffer?		*/
  const char *who;      /* Name of the function using this.     */
  char *data;           /* The buffer passed back to functions. */
  struct buf_data *next;	/* Next structure.		*/
};

/*
 * The union support.
 */
#define life	var_life.life
#define var	var_life.var

#endif
::::::::::::::
buffer_opt.h
::::::::::::::
#if !defined(__BUFFER_OPT_H__)
#define __BUFFER_OPT_H__

/*
 * CONFIGURABLES (aka, The place to shoot your own foot.) :)
 * ---------------------------------------------------------
 */

/*
 * Check for released and timed out buffers every 5 seconds.  This can be
 * be arbitrarily changed, but be careful of the lease life warning in buffer.c
 */
#define PULSE_BUFFER    (5 RL_SEC)

/*
 * 1 = use buffer system for all memory allocations using CREATE().
 * 0 = use standard calloc/realloc in the CREATE() macro.
 *
 * The advantage to using the buffer system is that it will keep track of
 * all your allocations and warn if one of the malloc buffers is overflowed.
 * You can also view every allocation, what file and line it was allocated
 * from, and how large it was.  This would be useful to detect a memory leak.
 * Using this option, stock CircleMUD bpl12 takes 1.8 seconds to boot on my
 * Pentium 133, and 1.6 seconds to boot without it.
 *
 * NOTE: If you use this option with BUFFER_SNPRINTF, you'll have to use
 *	the buffer copy/cat routines for CREATE() memory also...
 */
#define BUFFER_MEMORY		1

/*
 * 1 = Include original CircleMUD buffers too.
 * 0 = Use only new buffer system.
 *
 * This will blatantly point out all your existing global buffer uses if you
 * decide to convert to all buffer system.
 */
#define USE_CIRCLE_BUFFERS	0

/*
 * 1 = Return the buffer structure to the functions.
 * 0 = Return a 'char *' just like malloc() does.
 *
 * Useful for automatic length checking through snprintf().
 *
 * NOTE: This option has even more ramifications with BUFFER_MEMORY, see above.
 */
#define BUFFER_SNPRINTF		0

/*
 * 1 = Enable multithreaded support.  You _must_ have POSIX threads for this!
 *     (Also please note that since CircleMUD currently isn't thread-safe,
 *      this hasn't been very well tested except via the thread.c program.)
 * 0 = Use the standard heartbeat() method of freeing the buffers.
 */
#define BUFFER_THREADED         0

/*
 * --------------------------------
 * See 'buffer.c' for more options.
 * --------------------------------
 */

/*
 * We need these for structs.h, but can't include it in buffer.h because that
 * file needs the 'byte' from structs.h...sigh.
 *
 * buffer.h needs 'byte' from structs.h which would need 'buffer' from buffer.h
 */
#if BUFFER_SNPRINTF == 0
typedef char    buffer;
#else
struct buf_data;
typedef struct buf_data       buffer;
#endif

#endif
::::::::::::::
clan.h
::::::::::::::
//header

void carregar_clans(void);
void abrir_clan(char *clan_arq, short int numero);
void salvar_clan(short int num_clan);
void aceitar_membro(char *argumento, struct char_data *ch);
void posicoes_clan(char *argumento, struct char_data *ch);
void alterar_nomes_pos(char *argumento, struct char_data *ch);
void muda_pos_comando(char *argumento, struct char_data *ch);
void promover_membro(char *argumento, struct char_data *ch);
void rebaixar_membro(char *argumento, struct char_data *ch);
void expulsar_membro(char *argumento, struct char_data *ch);
void falar_clan(char *argumento, struct char_data *ch);
void membros_clan(char *argumento, struct char_data *ch);
void depositar_clan(char *argumento, struct char_data *ch);
void sacar_clan(char *argumento, struct char_data *ch);
void guerra_clan (char *argumento, struct char_data *ch);
void status_clan(char *argumento, struct char_data *ch);
void aceitar_guerra(char *argumento, struct char_data *ch);
void recusar_guerra(char *argumento, struct char_data *ch);
void serender_guerra(char *argumento, struct char_data *ch);
void custo_guerra(char *argumento, struct char_data *ch);
void custo_clan(void);
void alianca_clan(char *argumento, struct char_data *ch);
void claim_zone(struct char_data *ch, struct obj_data *obj);
void clan_mob(char *argumento, struct char_data *ch);
void mensagem_mob(struct char_data *ch);

int posicao_clan(short int num_clan);
int qto_poder(struct char_data *ch);
short int tem_permissao(struct char_data *ch, short int comando);
short int remove_do_clan(struct char_data *ch);


#define CLAN_GOD		LVL_IMPL

#define MAX_MEMBROS		20
#define MAX_POSICOES		10

//comandos
#define CONVOCAR		0
#define NUMPOSICOES		1
#define ALTERANOMEPOS		2
#define MUDAPOSCOMANDO		3
#define PROMOVER		4
#define REBAIXAR		5
#define EXPULSAR		6
#define FALAR			7
#define MEMBROS			8
#define DEPOSITAR		9
#define SACAR			10
#define GUERRA			11	
#define STATUS			12
#define ACEITAR			13
#define RECUSAR			14
#define SERENDER		15
#define CUSTO			16
#define ALIANCA			17

#define NUM_COMANDOS		18

struct estrutura_clan {
	short int clan_num;
	short int numero_clans;
	short int numero_posicoes;
	short int numero_membros;
	short int pos_comando[NUM_COMANDOS];
	char nome_clan[500];
	char pos_nome[MAX_POSICOES][50];
	long membros[MAX_MEMBROS];
	int grana;
	int poder;
	int em_guerra;
	int alianca;
	int pkvit;
	int pkder;
 	int preco;
 	int rendicoes;
 	int recusas;
 	int tempo;
 	int raided;
 	int seen;
 	int desafiando;
 	int desafiado;
 	int religion;
 	int points;
 	
};

struct estrutura_clan *clans;

::::::::::::::
comm.h
::::::::::::::
/* ************************************************************************
*   File: comm.h                                        Part of CircleMUD *
*  Usage: header file: prototypes of public communication functions       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define NUM_RESERVED_DESCS      8

#define COPYOVER_FILE "copyover.dat"

/* comm.c */
void    send_to_all(const char *messg);
void    send_to_char(const char *messg, struct char_data *ch);
void    send_to_room(const char *messg, int room);
void    send_to_outdoor(const char *messg);
void    perform_to_all(const char *messg, struct char_data *ch);
void    close_socket(struct descriptor_data *d);
void    brag(struct char_data *ch, struct char_data *victim);//mob avacalhador

void	perform_act(const char *orig, struct char_data *ch,
		struct obj_data *obj, const void *vict_obj, const struct char_data *to);

void    act(const char *str, int hide_invisible, struct char_data *ch,
                struct obj_data *obj, const void *vict_obj, int type);

#define TO_ROOM         1
#define TO_VICT         2
#define TO_NOTVICT      3
#define TO_CHAR         4
#define TO_GMOTE	5
#define TO_SLEEP        128     /* to char, even if sleeping */

int     write_to_descriptor(socket_t desc,const  char *txt);
void    write_to_q(const char *txt, struct txt_q *queue, int aliased);
void    write_to_output(const char *txt, struct descriptor_data *d);
void    page_string(struct descriptor_data *d, char *str, int keep_internal);

#define SEND_TO_Q(messg, desc)  write_to_output((messg), desc)

#define USING_SMALL(d)  ((d)->output == (d)->small_outbuf)
#define USING_LARGE(d)  ((d)->output == (d)->large_outbuf)

typedef RETSIGTYPE sigfunc(int);

int pulse;	/* pulled out for teleport */
::::::::::::::
conf.h
::::::::::::::
/* src/conf.h.  Generated automatically by configure.  */
/* src/conf.h.in.  Generated automatically from configure.in by autoheader.  */

/* Define to empty if the keyword does not work.  */
/* #undef const */

/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
#define HAVE_SYS_WAIT_H 1

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef pid_t */

/* Define as the return type of signal handlers (int or void).  */
#define RETSIGTYPE void

/* Define to `unsigned' if <sys/types.h> doesn't define.  */
/* #undef size_t */

/* Define if you have the ANSI C header files.  */
#define STDC_HEADERS 1

/* Define if you can safely include both <sys/time.h> and <time.h>.  */
#define TIME_WITH_SYS_TIME 1

/* Define if we're compiling CircleMUD under any type of UNIX system.  */
#define CIRCLE_UNIX 1

/* Define if the system is capable of using crypt() to encrypt.  */
#define CIRCLE_CRYPT 1

/* Define if we don't have proper support for the system's crypt().  */
/* #undef HAVE_UNSAFE_CRYPT */

/* Define is the system has struct in_addr.  */
#define HAVE_STRUCT_IN_ADDR 1

/* Define to `int' if <sys/socket.h> doesn't define.  */
#define socklen_t int

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef ssize_t */

/* Define if you have the inet_addr function.  */
#define HAVE_INET_ADDR 1

/* Define if you have the inet_aton function.  */
#define HAVE_INET_ATON 1

/* Define if you have the <arpa/inet.h> header file.  */
#define HAVE_ARPA_INET_H 1

/* Define if you have the <arpa/telnet.h> header file.  */
#define HAVE_ARPA_TELNET_H 1

/* Define if you have the <assert.h> header file.  */
#define HAVE_ASSERT_H 1

/* Define if you have the <crypt.h> header file.  */
/* #undef HAVE_CRYPT_H */

/* Define if you have the <errno.h> header file.  */
#define HAVE_ERRNO_H 1

/* Define if you have the <fcntl.h> header file.  */
#define HAVE_FCNTL_H 1

/* Define if you have the <limits.h> header file.  */
#define HAVE_LIMITS_H 1

/* Define if you have the <memory.h> header file.  */
#define HAVE_MEMORY_H 1

/* Define if you have the <net/errno.h> header file.  */
/* #undef HAVE_NET_ERRNO_H */

/* Define if you have the <netdb.h> header file.  */
#define HAVE_NETDB_H 1

/* Define if you have the <netinet/in.h> header file.  */
#define HAVE_NETINET_IN_H 1

/* Define if you have the <signal.h> header file.  */
#define HAVE_SIGNAL_H 1

/* Define if you have the <string.h> header file.  */
#define HAVE_STRING_H 1

/* Define if you have the <strings.h> header file.  */
#define HAVE_STRINGS_H 1

/* Define if you have the <sys/fcntl.h> header file.  */
#define HAVE_SYS_FCNTL_H 1

/* Define if you have the <sys/resource.h> header file.  */
#define HAVE_SYS_RESOURCE_H 1

/* Define if you have the <sys/select.h> header file.  */
#define HAVE_SYS_SELECT_H 1

/* Define if you have the <sys/socket.h> header file.  */
#define HAVE_SYS_SOCKET_H 1

/* Define if you have the <sys/stat.h> header file.  */
#define HAVE_SYS_STAT_H 1

/* Define if you have the <sys/time.h> header file.  */
#define HAVE_SYS_TIME_H 1

/* Define if you have the <sys/types.h> header file.  */
#define HAVE_SYS_TYPES_H 1

/* Define if you have the <sys/uio.h> header file.  */
#define HAVE_SYS_UIO_H 1

/* Define if you have the <unistd.h> header file.  */
#define HAVE_UNISTD_H 1

/* Define if you have the malloc library (-lmalloc).  */
/* #undef HAVE_LIBMALLOC */
::::::::::::::
constants.h
::::::::::::::
extern const char *circlemud_version;
extern const char *dirs[];
extern const char *room_bits[];
extern const char *exit_bits[];
extern const char *sector_types[];
extern const char *genders[];
extern const char *position_types[];
extern const char *player_bits[];
extern const char *action_bits[];
extern const char *preference_bits[];
extern const char *preference2_bits[];
extern const char *affected_bits[];
extern const char *affected2_bits[];
extern const char *affected3_bits[];
extern const char *connected_types[];
extern const char *where[];
extern const char *equipment_types[];
extern const char *item_types[];
extern const char *wear_bits[];
extern const char *extra_bits[];
extern const char *apply_types[];
extern const char *container_bits[];
extern const char *drinks[];
extern const char *drinknames[];
extern const int drink_aff[][3];
extern const char *color_liquid[];
extern const char *fullness[];
extern const struct str_app_type str_app[];
extern const struct dex_skill_type dex_app_skill[];
extern const struct dex_app_type dex_app[];
extern const struct con_app_type con_app[];
extern const struct int_app_type int_app[];
extern const struct wis_app_type wis_app[];
extern const char *spell_wear_off_msg[];
extern const char *npc_class_types[];
extern const int rev_dir[];
extern const int movement_loss[];
extern const char *weekdays[];
extern const char *month_name[];
extern const char *teleport_bits[];
extern const char *pc_clsl_types[];
extern const char *room_affections[];
extern const char *class_types[];
extern const char *race_types[];
::::::::::::::
db.h
::::::::::::::
/* ************************************************************************
*   File: db.h                                          Part of CircleMUD *
*  Usage: header file for database handling                               *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/* arbitrary constants used by index_boot() (must be unique) */
#define DB_BOOT_WLD     0
#define DB_BOOT_MOB     1
#define DB_BOOT_OBJ     2
#define DB_BOOT_ZON     3
#define DB_BOOT_SHP     4
#define DB_BOOT_HLP     5
#define DB_BOOT_TRG	6
#define DB_BOOT_QST     7

#if defined(CIRCLE_MACINTOSH)
#define LIB_WORLD       ":world:"
#define LIB_TEXT        ":text:"
#define LIB_TEXT_HELP   ":text:help:"
#define LIB_MISC        ":misc:"
#define LIB_ETC         ":etc:"
#define LIB_PLRTEXT     ":plrtext:"
#define LIB_PLROBJS     ":plrobjs:"
#define LIB_HOUSE       ":house:"
#define SLASH           ":"
#elif defined(CIRCLE_AMIGA) || defined(CIRCLE_UNIX) || defined(CIRCLE_WINDOWS) || defined(CIRCLE_ACORN)
#define LIB_WORLD       "world/"
#define LIB_TEXT        "text/"
#define LIB_TEXT_HELP   "text/help/"
#define LIB_MISC        "misc/"
#define LIB_ETC         "etc/"
#define LIB_PLRTEXT     "plrtext/"
#define LIB_OBJS        "objs/"
#define LIB_PLROBJS     "plrobjs/"
#define LIB_HOUSE       "house/"
#define LIB_ALIAS       "alias/"
#define SLASH           "/"
#endif

#define SUF_OBJS        "objs"
#define SUF_TEXT        "text"
#define SUF_ALIAS       "alias"

#if defined(CIRCLE_AMIGA)
#define FASTBOOT_FILE   "/.fastboot"    /* autorun: boot without sleep  */
#define KILLSCRIPT_FILE "/.killscript"  /* autorun: shut mud down       */
#define PAUSE_FILE      "/pause"        /* autorun: don't restart mud   */
#elif defined(CIRCLE_MACINTOSH)
#define FASTBOOT_FILE   "::.fastboot"   /* autorun: boot without sleep  */
#define KILLSCRIPT_FILE "::.killscript" /* autorun: shut mud down       */
#define PAUSE_FILE      "::pause"       /* autorun: don't restart mud   */
#else
#define FASTBOOT_FILE   "../.fastboot"  /* autorun: boot without sleep  */
#define KILLSCRIPT_FILE "../.killscript"/* autorun: shut mud down       */
#define PAUSE_FILE      "../pause"      /* autorun: don't restart mud   */
#endif

/* names of various files and directories */
#define INDEX_FILE      "index"         /* index of world files         */
#define MINDEX_FILE     "index.mini"    /* ... and for mini-mud-mode    */
#define WLD_PREFIX      LIB_WORLD"wld"SLASH     /* room definitions     */
#define MOB_PREFIX      LIB_WORLD"mob"SLASH     /* monster prototypes   */
#define OBJ_PREFIX      LIB_WORLD"obj"SLASH     /* object prototypes    */
#define ZON_PREFIX      LIB_WORLD"zon"SLASH     /* zon defs & command tables */
#define SHP_PREFIX      LIB_WORLD"shp"SLASH     /* shop definitions     */
#define HLP_PREFIX      LIB_TEXT"help"SLASH     /* for HELP <keyword>   */
#define TRG_PREFIX	LIB_WORLD"trg"SLASH	/* trg definitions	*/
#define QST_PREFIX	LIB_WORLD"qst"SLASH     /* Quests               */
#define HELP_FILE	LIB_TEXT_HELP"help.hlp"	/* default file for help*/

#define CREDITS_FILE    LIB_TEXT"credits"/* for the 'credits' command   */
#define NEWS_FILE       LIB_TEXT"news"  /* for the 'news' command       */
#define MOTD_FILE       LIB_TEXT"motd"  /* messages of the day / mortal */
#define IMOTD_FILE      LIB_TEXT"imotd" /* messages of the day / immort */
#define HELP_PAGE_FILE  LIB_TEXT_HELP"screen" /* for HELP <CR>          */
#define INFO_FILE       LIB_TEXT"info"          /* for INFO             */
#define WIZLIST_FILE    LIB_TEXT"wizlist"       /* for WIZLIST          */
#define IMMLIST_FILE    LIB_TEXT"immlist"       /* for IMMLIST          */
#define BACKGROUND_FILE LIB_TEXT"background"/* for the background story */
#define POLICIES_FILE   LIB_TEXT"policies" /* player policies/rules     */
#define HANDBOOK_FILE   LIB_TEXT"handbook" /* handbook for new immorts  */

#define IDEA_FILE       LIB_MISC"ideas" /* for the 'idea'-command       */
#define TYPO_FILE       LIB_MISC"typos" /*         'typo'               */
#define BUG_FILE        LIB_MISC"bugs"  /*         'bug'                */
#define MESS_FILE       LIB_MISC"messages" /* damage messages           */
#define SOCMESS_FILE    LIB_MISC"socials" /* messgs for social acts     */
#define XNAME_FILE      LIB_MISC"xnames" /* invalid name substrings     */

#define PLAYER_FILE     LIB_ETC"players" /* the player database         */
#define MAIL_FILE       LIB_ETC"plrmail" /* for the mudmail system      */
#define BAN_FILE        LIB_ETC"badsites" /* for the siteban system     */
#define HCONTROL_FILE   LIB_ETC"hcontrol"  /* for the house system      */
#define CLAN_FILE       LIB_ETC"clans"    /* armazenador dos clans */
#define TOPTEN_FILE     LIB_MISC"topten" //topten quest
#define TOPTEN_FILE1    LIB_MISC"topten1"
#define TOPTEN_FILE2    LIB_MISC"topten2"

#define HOUSES_FILE     LIB_MISC"houses.mud" // Fenix - WHS

/* ascii pfiles file defines */
#define PLR_PREFIX	"pfiles"
#define PLR_INDEX_FILE	"pfiles"SLASH"plr_index"

/* change these if you want to put all files in the same directory (or if
   you just like big file names
*/
#define PLR_SUFFIX	""

/* new bitvector data for use in player_index_element */
#define PINDEX_DELETED		(1 << 0)	/* deleted player	*/
#define PINDEX_NODELETE		(1 << 1)	/* protected player	*/
#define PINDEX_SELFDELETE	(1 << 2)	/* player is selfdeleting*/


/* public procedures in db.c */
void    boot_db(void);
int     create_entry(char *name);
void    zone_update(void);
int     real_room(int vnum);
char    *fread_string(FILE *fl, char *error);
long    get_id_by_name(char *name);
char    *get_name_by_id(long id);

int	load_char(char *name, struct char_data *ch);
void    save_char(struct char_data *ch, sh_int load_room);
void    init_char(struct char_data *ch);
struct char_data* create_char(void);
struct char_data *read_mobile(int nr, int type);
int     real_mobile(int vnum);
int     vnum_mobile(char *searchname, struct char_data *ch);
void    clear_char(struct char_data *ch);
void    reset_char(struct char_data *ch);
void    free_char(struct char_data *ch);
void	save_player_index(void);
void    read_message_from_file(void);
void    write_message_to_file(void);

void    vwear_object(int wearpos, struct char_data * ch);
struct  obj_data *create_obj(void);
void    clear_object(struct obj_data *obj);
void    free_obj(struct obj_data *obj);
int     real_object(int vnum);
struct obj_data *read_object(int nr, int type);
int     vnum_object(char *searchname, struct char_data *ch);

extern int teleport_on;

#define REAL 0
#define VIRTUAL 1

/* structure for the reset commands */
struct reset_com {
   char command;   /* current command                      */

   bool if_flag;        /* if TRUE: exe only if preceding exe'd */
   int  arg1;           /*                                      */
   int  arg2;           /* Arguments to the command             */
   int  arg3;           /*                                      */
   int line;            /* line number this command appears on  */

   /*
        *  Commands:              *
        *  'M': Read a mobile     *
        *  'O': Read an object    *
        *  'G': Give obj to mob   *
        *  'P': Put obj in obj    *
        *  'G': Obj to char       *
        *  'E': Obj to char equip *
        *  'D': Set state of door *
   */
};



/* zone definition structure. for the 'zone-table'   */
struct zone_data {
   char *name;              /* name of this zone                  */
   int  lifespan;           /* how long between resets (minutes)  */
   int  age;                /* current age of this zone (minutes) */
   int  top;                /* upper limit for rooms in this zone */

   int  reset_mode;         /* conditions for reset (see below)   */
   int  number;             /* virtual number of this zone        */
   struct reset_com *cmd;   /* command table for reset            */
   int  zone_flags;        /* for zone flags                     */
   int owner;


   /*
        *  Reset mode:                              *
        *  0: Don't reset, and don't update age.    *
        *  1: Reset if no PC's are located in zone. *
        *  2: Just reset.                           *
   */
};



/* for queueing zones for update   */
struct reset_q_element {
   int  zone_to_reset;            /* ref to zone_data */
   struct reset_q_element *next;
};



/* structure for the update queue     */
struct reset_q_type {
   struct reset_q_element *head;
   struct reset_q_element *tail;
};


/* Added level, flags, and last, primarily for pfile autocleaning.  You
   can also use them to keep online statistics, and can add race, class,
   etc if you like.
*/
struct player_index_element {
   char *name;
   long id;
   int level;
   int flags;
   time_t last;
};


struct help_index_element {
//   char *keyword;
   char	*keywords;
   char *entry;
//   int duplicate;
   int min_level;
};

struct quest_eqs {
	int vnum_eq;
	int preco_eq;
	int dono;
};

/* don't change these */
#define BAN_NOT         0
#define BAN_NEW         1
#define BAN_SELECT      2
#define BAN_ALL         3

#define BANNED_SITE_LENGTH    50
struct ban_list_element {
   char site[BANNED_SITE_LENGTH+1];
   int  type;
   time_t date;
   char name[MAX_NAME_LENGTH+1];
   struct ban_list_element *next;
};


/* global buffering system */

#ifdef __DB_C__
char    buf[MAX_STRING_LENGTH];
char    buf1[MAX_STRING_LENGTH];
char    buf2[MAX_STRING_LENGTH];
char    buf3[MAX_STRING_LENGTH];
char    arg[MAX_STRING_LENGTH];
#else
extern struct player_special_data dummy_mob;
extern char     buf[MAX_STRING_LENGTH];
extern char     buf1[MAX_STRING_LENGTH];
extern char     buf2[MAX_STRING_LENGTH];
extern char     buf3[MAX_STRING_LENGTH];
extern char     arg[MAX_STRING_LENGTH];
#endif

#ifndef __CONFIG_C__
extern char     *OK;
extern char     *NOPERSON;
extern char     *NOEFFECT;
#endif

#define CUR_WORLD_VERSION 1
#define CUR_ZONE_VERSION 2
::::::::::::::
dg_event.h
::::::::::::::
/*
** how often will heartbeat() call our event function?
*/
#define PULSE_DG_EVENT 1


/*
** macro used to prototype the callback function for an event
*/
#define EVENT(function) void (function)(void *info)


/*
** define event related structures
*/
struct event_info {
  int time_remaining;
  EVENT(*func);
  void *info;
  struct event_info *next;  
};


/*
** prototype event functions
*/
struct event_info *add_event(int time, EVENT(*func), void *info);
void remove_event(struct event_info *event);
void process_events(void);
::::::::::::::
dg_olc.h
::::::::::::::
/*
** dg_olc.h: this header file is used in extending Oasis style OLC for
** dg-scripts onto a CircleMUD that already has dg-scripts (as released
** by Mark Heilpern on 1/1/98) implemented.
*/
#include "dg_scripts.h"


/* prototype exported functions from dg_olc.c */
void script_copy(void *dst, void *src, int type);
void script_save_to_disk(FILE *fp, void *item, int type);
void dg_olc_script_free(struct descriptor_data *d);
void dg_olc_script_copy(struct descriptor_data *d);
void dg_script_menu(struct descriptor_data *d);
int dg_script_edit_parse(struct descriptor_data *d, char *arg);

/* define the largest set of commands for as trigger */
#define MAX_CMD_LENGTH 16384 /* 16k should be plenty and then some */



#define NUM_TRIG_TYPE_FLAGS		15


/*
 * Submodes of TRIGEDIT connectedness.
 */
#define TRIGEDIT_MAIN_MENU              0
#define TRIGEDIT_TRIGTYPE               1
#define TRIGEDIT_CONFIRM_SAVESTRING	2
#define TRIGEDIT_NAME			3
#define TRIGEDIT_INTENDED		4
#define TRIGEDIT_TYPES			5
#define TRIGEDIT_COMMANDS		6
#define TRIGEDIT_NARG			7
#define TRIGEDIT_ARGUMENT		8



#define OLC_SCRIPT_EDIT		    82766
#define SCRIPT_MAIN_MENU		0
#define SCRIPT_NEW_TRIGGER		1
#define SCRIPT_DEL_TRIGGER		2


#define OLC_SCRIPT_EDIT_MODE(d)	((d)->olc->script_mode)	/* parse input mode */
#define OLC_SCRIPT(d)           ((d)->olc->script)	/* script editing   */
#define OLC_ITEM_TYPE(d)	((d)->olc->item_type)	/* mob/obj/room     */
::::::::::::::
dg_scripts.h
::::::::::::::
/**************************************************************************
*  File: scripts.h                                                        *
*  Usage: header file for script structures and contstants, and           *
*         function prototypes for scripts.c                               *
*                                                                         *
*                                                                         *
*  $Author: egreen $
*  $Date: 1996/09/24 03:48:42 $
*  $Revision: 3.6 $
**************************************************************************/

#define DG_SCRIPT_VERSION "DG Scripts Version 0.99 Patch Level 5a    8/98" 



#define    MOB_TRIGGER   0
#define    OBJ_TRIGGER   1
#define    WLD_TRIGGER   2

#define DG_NO_TRIG         256     /* don't check act trigger   */


/* mob trigger types */
#define MTRIG_GLOBAL           (1 << 0)      /* check even if zone empty   */
#define MTRIG_RANDOM           (1 << 1)      /* checked randomly           */
#define MTRIG_COMMAND          (1 << 2)	     /* character types a command  */
#define MTRIG_SPEECH           (1 << 3)	     /* a char says a word/phrase  */
#define MTRIG_ACT              (1 << 4)      /* word or phrase sent to act */
#define MTRIG_DEATH            (1 << 5)      /* character dies             */
#define MTRIG_GREET            (1 << 6)      /* something enters room seen */
#define MTRIG_GREET_ALL        (1 << 7)      /* anything enters room       */
#define MTRIG_ENTRY            (1 << 8)      /* the mob enters a room      */
#define MTRIG_RECEIVE          (1 << 9)      /* character is given obj     */
#define MTRIG_FIGHT            (1 << 10)     /* each pulse while fighting  */
#define MTRIG_HITPRCNT         (1 << 11)     /* fighting and below some hp */
#define MTRIG_BRIBE	       (1 << 12)     /* coins are given to mob     */
#define MTRIG_LOAD             (1 << 13)     /* the mob is loaded          */
#define MTRIG_MEMORY           (1 << 14)     /* mob see's someone remembered */

/* obj trigger types */
#define OTRIG_GLOBAL           (1 << 0)	     /* unused                     */
#define OTRIG_RANDOM           (1 << 1)	     /* checked randomly           */
#define OTRIG_COMMAND          (1 << 2)      /* character types a command  */

#define OTRIG_TIMER            (1 << 5)     /* item's timer expires       */
#define OTRIG_GET              (1 << 6)     /* item is picked up          */
#define OTRIG_DROP             (1 << 7)     /* character trys to drop obj */
#define OTRIG_GIVE             (1 << 8)     /* character trys to give obj */
#define OTRIG_WEAR             (1 << 9)     /* character trys to wear obj */
#define OTRIG_REMOVE           (1 << 11)    /* character trys to remove obj */

#define OTRIG_LOAD             (1 << 13)    /* the object is loaded       */

/* wld trigger types */
#define WTRIG_GLOBAL           (1 << 0)      /* check even if zone empty   */
#define WTRIG_RANDOM           (1 << 1)	     /* checked randomly           */
#define WTRIG_COMMAND          (1 << 2)	     /* character types a command  */
#define WTRIG_SPEECH           (1 << 3)      /* a char says word/phrase    */

#define WTRIG_RESET            (1 << 5)      /* zone has been reset        */
#define WTRIG_ENTER            (1 << 6)	     /* character enters room      */
#define WTRIG_DROP             (1 << 7)      /* something dropped in room  */


/* obj command trigger types */
#define OCMD_EQUIP             (1 << 0)	     /* obj must be in char's equip */
#define OCMD_INVEN             (1 << 1)	     /* obj must be in char's inven */
#define OCMD_ROOM              (1 << 2)	     /* obj must be in char's room  */

#define TRIG_NEW                0	     /* trigger starts from top  */
#define TRIG_RESTART            1	     /* trigger restarting       */


/*
 * These are slightly off of PULSE_MOBILE so
 * everything isnt happening at the same time 
 */
#define PULSE_DG_SCRIPT         (13 RL_SEC)


#define MAX_SCRIPT_DEPTH      50          /* maximum depth triggers can
					     recurse into each other */


/* one line of the trigger */
struct cmdlist_element {
  char *cmd;				/* one line of a trigger */
  struct cmdlist_element *original;
  struct cmdlist_element *next;
};

struct trig_var_data {
  char *name;				/* name of variable  */
  char *value;				/* value of variable */
  long context;				/* 0: global context */
  
  struct trig_var_data *next;
};

/* structure for triggers */
struct trig_data {
    sh_int nr;		                /* trigger's rnum                  */
    byte attach_type;			/* mob/obj/wld intentions          */
    byte data_type;		        /* type of game_data for trig      */
    char *name;			        /* name of trigger                 */
    long trigger_type;			/* type of trigger (for bitvector) */
    struct cmdlist_element *cmdlist;	/* top of command list             */
    struct cmdlist_element *curr_state;	/* ptr to current line of trigger  */
    int narg;				/* numerical argument              */
    char *arglist;			/* argument list                   */
    int depth;				/* depth into nest ifs/whiles/etc  */
    int loops;				/* loop iteration counter          */
    struct event_info *wait_event;	/* event to pause the trigger      */
    ubyte purged;			/* trigger is set to be purged     */
    struct trig_var_data *var_list;	/* list of local vars for trigger  */
    
    struct trig_data *next;  
    struct trig_data *next_in_world;    /* next in the global trigger list */
};


/* a complete script (composed of several triggers) */
struct script_data {
  long types;				/* bitvector of trigger types */
  struct trig_data *trig_list;	/* list of triggers           */
  struct trig_var_data *global_vars;	/* list of global variables   */
  ubyte purged;				/* script is set to be purged */
  long context;				/* current context for statics */
  struct memory_data *memory;		/* for memory triggers */

  struct script_data *next;		/* used for purged_scripts    */
};

/* used for actor memory triggers */
struct script_memory {
  long id;				/* id of who to remember */
  char *cmd;				/* command, or NULL for generic */
  struct script_memory *next;
};


/* function prototypes from triggers.c */
void act_mtrigger(struct char_data *ch, char *str, struct char_data *actor,
         struct char_data *victim, struct obj_data *object,
         struct obj_data *target, char *arg);  
void speech_mtrigger(struct char_data *actor, char *str);
void speech_wtrigger(struct char_data *actor, char *str);
void greet_memory_mtrigger(struct char_data *ch);
int greet_mtrigger(struct char_data *actor, int dir);
int entry_mtrigger(struct char_data *ch);
void entry_memory_mtrigger(struct char_data *ch);
int enter_wtrigger(struct room_data *room, struct char_data *actor, int dir);
int drop_otrigger(struct obj_data *obj, struct char_data *actor);
void timer_otrigger(struct obj_data *obj);
int get_otrigger(struct obj_data *obj, struct char_data *actor);
int drop_wtrigger(struct obj_data *obj, struct char_data *actor);
int give_otrigger(struct obj_data *obj, struct char_data *actor,
         struct char_data *victim);
int receive_mtrigger(struct char_data *ch, struct char_data *actor,
         struct obj_data *obj);
void bribe_mtrigger(struct char_data *ch, struct char_data *actor,
         int amount);
int wear_otrigger(struct obj_data *obj, struct char_data *actor, int where);
int remove_otrigger(struct obj_data *obj, struct char_data *actor);
int command_mtrigger(struct char_data *actor, char *cmd, char *argument);
int command_otrigger(struct char_data *actor, char *cmd, char *argument);
int command_wtrigger(struct char_data *actor, char *cmd, char *argument);
int death_mtrigger(struct char_data *ch, struct char_data *actor);
void fight_mtrigger(struct char_data *ch);
void hitprcnt_mtrigger(struct char_data *ch);

void random_mtrigger(struct char_data *ch);
void random_otrigger(struct obj_data *obj);
void random_wtrigger(struct room_data *ch);
void reset_wtrigger(struct room_data *ch);

void load_mtrigger(struct char_data *ch);
void load_otrigger(struct obj_data *obj);

/* function prototypes from scripts.c */
void script_trigger_check(void);
void add_trigger(struct script_data *sc, struct trig_data *t, int loc);

void do_stat_trigger(struct char_data *ch, struct trig_data *trig);
void do_sstat_room(struct char_data * ch);
void do_sstat_object(struct char_data * ch, struct obj_data * j);
void do_sstat_character(struct char_data * ch, struct char_data * k);

void script_log(char *msg);
void dg_read_trigger(FILE *fp, void *i, int type);
void dg_obj_trigger(char *line, struct obj_data *obj);
void assign_triggers(void *i, int type);
void parse_trigger(FILE *trig_f, int nr);
int real_trigger(int vnum);
void extract_script(struct script_data *sc);
void extract_script_mem(struct script_memory *sc);


/* Macros for scripts */

#define UID_CHAR   '\x1b'

#define GET_TRIG_NAME(t)          ((t)->name)
#define GET_TRIG_RNUM(t)          ((t)->nr)
#define GET_TRIG_VNUM(t)	  (trig_index[(t)->nr]->vnum)
#define GET_TRIG_TYPE(t)          ((t)->trigger_type)
#define GET_TRIG_DATA_TYPE(t)	  ((t)->data_type)
#define GET_TRIG_NARG(t)          ((t)->narg)
#define GET_TRIG_ARG(t)           ((t)->arglist)
#define GET_TRIG_VARS(t)	  ((t)->var_list)
#define GET_TRIG_WAIT(t)	  ((t)->wait_event)
#define GET_TRIG_DEPTH(t)         ((t)->depth)
#define GET_TRIG_LOOPS(t)         ((t)->loops)

/* player id's: 0 to ROOM_ID_BASE - 1            */
/* room id's: ROOM_ID_BASE to MOBOBJ_ID_BASE - 1 */
/* mob/object id's: MOBOBJ_ID_BASE and higher    */
#define ROOM_ID_BASE    50000
#define MOBOBJ_ID_BASE	200000

#define SCRIPT(o)		  ((o)->script)
#define SCRIPT_MEM(c)             ((c)->memory)

#define SCRIPT_TYPES(s)		  ((s)->types)				  
#define TRIGGERS(s)		  ((s)->trig_list)

#define GET_SHORT(ch)    ((ch)->player.short_descr)


#define SCRIPT_CHECK(go, type)   (SCRIPT(go) && \
				  IS_SET(SCRIPT_TYPES(SCRIPT(go)), type))
#define TRIGGER_CHECK(t, type)   (IS_SET(GET_TRIG_TYPE(t), type) && \
				  !GET_TRIG_DEPTH(t))

#define ADD_UID_VAR(buf, trig, go, name, context) { \
		         sprintf(buf, "%c%ld", UID_CHAR, GET_ID(go)); \
                         add_var(&GET_TRIG_VARS(trig), name, buf, context); }




/* typedefs that the dg functions rely on */
typedef struct index_data index_data;
typedef struct room_data room_data;
typedef struct obj_data obj_data;
typedef struct trig_data trig_data;
typedef struct char_data char_data;
::::::::::::::
diskio.h
::::::::::::::
/*
	diskio.h	Fast file buffering

	Version 1.2b	This is beta software.  Use at your own risk.
*/

#ifndef _DISKIO_H_
#define _DISKIO_H_

#define FB_READ		(1 << 0)	/* read from disk	*/
#define FB_WRITE	(1 << 1)	/* write to disk	*/
#define FB_APPEND	(1 << 2)	/* write with append	*/

#define FB_STARTSIZE	4192	/* 4k starting buffer for writes */

#ifndef IS_SET
#define IS_SET(flag, bits)	((flag) & (bits))
#endif

#ifndef TRUE
#define TRUE	1
#endif

#ifndef FALSE
#define FALSE	0
#endif

typedef struct {
  char *buf;		/* start of buffer			*/
  char *ptr;		/* current location pointer		*/
  int size;		/* size in bytes of buffer		*/
  int flags;		/* read/write/append, future expansion	*/
  char *name;		/* filename (for delayed writing)	*/
} FBFILE;

void	tag_argument(char *argument, char *tag);
int	fbgetline(FBFILE *fbfl, char *line);
FBFILE	*fbopen(char *fname, int mode);
int	fbclose(FBFILE *fbfl);
int	fbprintf(FBFILE *fbfl, const char *format, ...);
void	fbrewind(FBFILE *fbfl);
int	fbcat(char *fromfilename, FBFILE *tofile);
char	*fbgetstring(FBFILE *fl);

#endif
::::::::::::::
fbi.h
::::::::::::::
/***************************************************************************
 * File: fbi.h                                       a part of DungeonMUD  *
 *                                                                         *
 * Description: Header file to be used for the FBI system                  *
 *                                                                         *
 * By Archangel(Paulo Mello) Implementor of DungeonMUD                     *
 ***************************************************************************/

#define FBI_AGENT		1
#define FBI_SARGE		2
#define FBI_CAPTAIN		3

#define MAX_CAPTAINS		1
#define MAX_SARGE		3
#define MAX_AGENTS		6
::::::::::::::
gc.h
::::::::::::::
/* 
 * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
 * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.
 * Copyright 1996 by Silicon Graphics.  All rights reserved.
 *
 * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
 * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
 *
 * Permission is hereby granted to use or copy this program
 * for any purpose,  provided the above notices are retained on all copies.
 * Permission to modify the code and to distribute modified code is granted,
 * provided the above notices are retained, and a notice that the code was
 * modified is included with the above copyright notice.
 */

/*
 * Note that this defines a large number of tuning hooks, which can
 * safely be ignored in nearly all cases.  For normal use it suffices
 * to call only GC_MALLOC and perhaps GC_REALLOC.
 * For better performance, also look at GC_MALLOC_ATOMIC, and
 * GC_enable_incremental.  If you need an action to be performed
 * immediately before an object is collected, look at GC_register_finalizer.
 * If you are using Solaris threads, look at the end of this file.
 * Everything else is best ignored unless you encounter performance
 * problems.
 */
 
#ifndef _GC_H

# define _GC_H
# define __GC
# include <stddef.h>

#if defined(__CYGWIN32__) && defined(GC_USE_DLL)
#include "libgc_globals.h"
#endif

#if defined(_MSC_VER) && defined(_DLL)
# ifdef GC_BUILD
#   define GC_API __declspec(dllexport)
# else
#   define GC_API __declspec(dllimport)
# endif
#endif

#if defined(__WATCOMC__) && defined(GC_DLL)
# ifdef GC_BUILD
#   define GC_API extern __declspec(dllexport)
# else
#   define GC_API extern __declspec(dllimport)
# endif
#endif

#ifndef GC_API
#define GC_API extern
#endif

# if defined(__STDC__) || defined(__cplusplus)
#   define GC_PROTO(args) args
    typedef void * GC_PTR;
# else
#   define GC_PROTO(args) ()
    typedef char * GC_PTR;
#  endif

# ifdef __cplusplus
    extern "C" {
# endif


/* Define word and signed_word to be unsigned and signed types of the 	*/
/* size as char * or void *.  There seems to be no way to do this	*/
/* even semi-portably.  The following is probably no better/worse 	*/
/* than almost anything else.						*/
/* The ANSI standard suggests that size_t and ptr_diff_t might be 	*/
/* better choices.  But those appear to have incorrect definitions	*/
/* on may systems.  Notably "typedef int size_t" seems to be both	*/
/* frequent and WRONG.							*/
typedef unsigned long GC_word;
typedef long GC_signed_word;

/* Public read-only variables */

GC_API GC_word GC_gc_no;/* Counter incremented per collection.  	*/
			/* Includes empty GCs at startup.		*/
			

/* Public R/W variables */

GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));
			/* When there is insufficient memory to satisfy */
			/* an allocation request, we return		*/
			/* (*GC_oom_fn)().  By default this just	*/
			/* returns 0.					*/
			/* If it returns, it must return 0 or a valid	*/
			/* pointer to a previously allocated heap 	*/
			/* object.					*/

GC_API int GC_quiet;	/* Disable statistics output.  Only matters if	*/
			/* collector has been compiled with statistics	*/
			/* enabled.  This involves a performance cost,	*/
			/* and is thus not the default.			*/

GC_API int GC_dont_gc;	/* Dont collect unless explicitly requested, e.g. */
			/* because it's not safe.			  */

GC_API int GC_dont_expand;
			/* Dont expand heap unless explicitly requested */
			/* or forced to.				*/

GC_API int GC_full_freq;    /* Number of partial collections between	*/
			    /* full collections.  Matters only if	*/
			    /* GC_incremental is set.			*/
			
GC_API GC_word GC_non_gc_bytes;
			/* Bytes not considered candidates for collection. */
			/* Used only to control scheduling of collections. */

GC_API GC_word GC_free_space_divisor;
			/* We try to make sure that we allocate at 	*/
			/* least N/GC_free_space_divisor bytes between	*/
			/* collections, where N is the heap size plus	*/
			/* a rough estimate of the root set size.	*/
			/* Initially, GC_free_space_divisor = 4.	*/
			/* Increasing its value will use less space	*/
			/* but more collection time.  Decreasing it	*/
			/* will appreciably decrease collection time	*/
			/* at the expense of space.			*/
			/* GC_free_space_divisor = 1 will effectively	*/
			/* disable collections.				*/

GC_API GC_word GC_max_retries;
			/* The maximum number of GCs attempted before	*/
			/* reporting out of memory after heap		*/
			/* expansion fails.  Initially 0.		*/
			

GC_API char *GC_stackbottom;	/* Cool end of user stack.		*/
				/* May be set in the client prior to	*/
				/* calling any GC_ routines.  This	*/
				/* avoids some overhead, and 		*/
				/* potentially some signals that can 	*/
				/* confuse debuggers.  Otherwise the	*/
				/* collector attempts to set it 	*/
				/* automatically.			*/
				/* For multithreaded code, this is the	*/
				/* cold end of the stack for the	*/
				/* primordial thread.			*/
				
/* Public procedures */
/*
 * general purpose allocation routines, with roughly malloc calling conv.
 * The atomic versions promise that no relevant pointers are contained
 * in the object.  The nonatomic versions guarantee that the new object
 * is cleared.  GC_malloc_stubborn promises that no changes to the object
 * will occur after GC_end_stubborn_change has been called on the
 * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object
 * that is scanned for pointers to collectable objects, but is not itself
 * collectable.  GC_malloc_uncollectable and GC_free called on the resulting
 * object implicitly update GC_non_gc_bytes appropriately.
 */
GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));
GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));
GC_API GC_PTR GC_malloc_uncollectable GC_PROTO((size_t size_in_bytes));
GC_API GC_PTR GC_malloc_stubborn GC_PROTO((size_t size_in_bytes));

/* The following is only defined if the library has been suitably	*/
/* compiled:								*/
GC_API GC_PTR GC_malloc_atomic_uncollectable GC_PROTO((size_t size_in_bytes));

/* Explicitly deallocate an object.  Dangerous if used incorrectly.     */
/* Requires a pointer to the base of an object.				*/
/* If the argument is stubborn, it should not be changeable when freed. */
/* An object should not be enable for finalization when it is 		*/
/* explicitly deallocated.						*/
/* GC_free(0) is a no-op, as required by ANSI C for free.		*/
GC_API void GC_free GC_PROTO((GC_PTR object_addr));

/*
 * Stubborn objects may be changed only if the collector is explicitly informed.
 * The collector is implicitly informed of coming change when such
 * an object is first allocated.  The following routines inform the
 * collector that an object will no longer be changed, or that it will
 * once again be changed.  Only nonNIL pointer stores into the object
 * are considered to be changes.  The argument to GC_end_stubborn_change
 * must be exacly the value returned by GC_malloc_stubborn or passed to
 * GC_change_stubborn.  (In the second case it may be an interior pointer
 * within 512 bytes of the beginning of the objects.)
 * There is a performance penalty for allowing more than
 * one stubborn object to be changed at once, but it is acceptable to
 * do so.  The same applies to dropping stubborn objects that are still
 * changeable.
 */
GC_API void GC_change_stubborn GC_PROTO((GC_PTR));
GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));

/* Return a pointer to the base (lowest address) of an object given	*/
/* a pointer to a location within the object.				*/
/* Return 0 if displaced_pointer doesn't point to within a valid	*/
/* object.								*/
GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));

/* Given a pointer to the base of an object, return its size in bytes.	*/
/* The returned size may be slightly larger than what was originally	*/
/* requested.								*/
GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));

/* For compatibility with C library.  This is occasionally faster than	*/
/* a malloc followed by a bcopy.  But if you rely on that, either here	*/
/* or with the standard C library, your code is broken.  In my		*/
/* opinion, it shouldn't have been invented, but now we're stuck. -HB	*/
/* The resulting object has the same kind as the original.		*/
/* If the argument is stubborn, the result will have changes enabled.	*/
/* It is an error to have changes enabled for the original object.	*/
/* Follows ANSI comventions for NULL old_object.			*/
GC_API GC_PTR GC_realloc
	GC_PROTO((GC_PTR old_object, size_t new_size_in_bytes));
				   
/* Explicitly increase the heap size.	*/
/* Returns 0 on failure, 1 on success.  */
GC_API int GC_expand_hp GC_PROTO((size_t number_of_bytes));

/* Limit the heap size to n bytes.  Useful when you're debugging, 	*/
/* especially on systems that don't handle running out of memory well.	*/
/* n == 0 ==> unbounded.  This is the default.				*/
GC_API void GC_set_max_heap_size GC_PROTO((GC_word n));

/* Inform the collector that a certain section of statically allocated	*/
/* memory contains no pointers to garbage collected memory.  Thus it 	*/
/* need not be scanned.  This is sometimes important if the application */
/* maps large read/write files into the address space, which could be	*/
/* mistaken for dynamic library data segments on some systems.		*/
GC_API void GC_exclude_static_roots GC_PROTO((GC_PTR start, GC_PTR finish));

/* Clear the set of root segments.  Wizards only. */
GC_API void GC_clear_roots GC_PROTO((void));

/* Add a root segment.  Wizards only. */
GC_API void GC_add_roots GC_PROTO((char * low_address,
				   char * high_address_plus_1));

/* Add a displacement to the set of those considered valid by the	*/
/* collector.  GC_register_displacement(n) means that if p was returned */
/* by GC_malloc, then (char *)p + n will be considered to be a valid	*/
/* pointer to n.  N must be small and less than the size of p.		*/
/* (All pointers to the interior of objects from the stack are		*/
/* considered valid in any case.  This applies to heap objects and	*/
/* static data.)							*/
/* Preferably, this should be called before any other GC procedures.	*/
/* Calling it later adds to the probability of excess memory		*/
/* retention.								*/
/* This is a no-op if the collector was compiled with recognition of	*/
/* arbitrary interior pointers enabled, which is now the default.	*/
GC_API void GC_register_displacement GC_PROTO((GC_word n));

/* The following version should be used if any debugging allocation is	*/
/* being done.								*/
GC_API void GC_debug_register_displacement GC_PROTO((GC_word n));

/* Explicitly trigger a full, world-stop collection. 	*/
GC_API void GC_gcollect GC_PROTO((void));

/* Trigger a full world-stopped collection.  Abort the collection if 	*/
/* and when stop_func returns a nonzero value.  Stop_func will be 	*/
/* called frequently, and should be reasonably fast.  This works even	*/
/* if virtual dirty bits, and hence incremental collection is not 	*/
/* available for this architecture.  Collections can be aborted faster	*/
/* than normal pause times for incremental collection.  However,	*/
/* aborted collections do no useful work; the next collection needs	*/
/* to start from the beginning.						*/
/* Return 0 if the collection was aborted, 1 if it succeeded.		*/
typedef int (* GC_stop_func) GC_PROTO((void));
GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));

/* Return the number of bytes in the heap.  Excludes collector private	*/
/* data structures.  Includes empty blocks and fragmentation loss.	*/
/* Includes some pages that were allocated but never written.		*/
GC_API size_t GC_get_heap_size GC_PROTO((void));

/* Return the number of bytes allocated since the last collection.	*/
GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));

/* Enable incremental/generational collection.	*/
/* Not advisable unless dirty bits are 		*/
/* available or most heap objects are		*/
/* pointerfree(atomic) or immutable.		*/
/* Don't use in leak finding mode.		*/
/* Ignored if GC_dont_gc is true.		*/
GC_API void GC_enable_incremental GC_PROTO((void));

/* Perform some garbage collection work, if appropriate.	*/
/* Return 0 if there is no more work to be done.		*/
/* Typically performs an amount of work corresponding roughly	*/
/* to marking from one page.  May do more work if further	*/
/* progress requires it, e.g. if incremental collection is	*/
/* disabled.  It is reasonable to call this in a wait loop	*/
/* until it returns 0.						*/
GC_API int GC_collect_a_little GC_PROTO((void));

/* Allocate an object of size lb bytes.  The client guarantees that	*/
/* as long as the object is live, it will be referenced by a pointer	*/
/* that points to somewhere within the first 256 bytes of the object.	*/
/* (This should normally be declared volatile to prevent the compiler	*/
/* from invalidating this assertion.)  This routine is only useful	*/
/* if a large array is being allocated.  It reduces the chance of 	*/
/* accidentally retaining such an array as a result of scanning an	*/
/* integer that happens to be an address inside the array.  (Actually,	*/
/* it reduces the chance of the allocator not finding space for such	*/
/* an array, since it will try hard to avoid introducing such a false	*/
/* reference.)  On a SunOS 4.X or MS Windows system this is recommended */
/* for arrays likely to be larger than 100K or so.  For other systems,	*/
/* or if the collector is not configured to recognize all interior	*/
/* pointers, the threshold is normally much higher.			*/
GC_API GC_PTR GC_malloc_ignore_off_page GC_PROTO((size_t lb));
GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));

#if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720
#   define GC_ADD_CALLER
#   define GC_RETURN_ADDR (GC_word)__return_address
#endif

#ifdef GC_ADD_CALLER
#  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__
#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int
#else
#  define GC_EXTRAS __FILE__, __LINE__
#  define GC_EXTRA_PARAMS char * descr_string, int descr_int
#endif

/* Debugging (annotated) allocation.  GC_gcollect will check 		*/
/* objects allocated in this way for overwrites, etc.			*/
GC_API GC_PTR GC_debug_malloc
	GC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));
GC_API GC_PTR GC_debug_malloc_atomic
	GC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));
GC_API GC_PTR GC_debug_malloc_uncollectable
	GC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));
GC_API GC_PTR GC_debug_malloc_stubborn
	GC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));
GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));
GC_API GC_PTR GC_debug_realloc
	GC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,
  		  GC_EXTRA_PARAMS));
  			 	 
GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));
GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));
# ifdef GC_DEBUG
#   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)
#   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)
#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \
							GC_EXTRAS)
#   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)
#   define GC_FREE(p) GC_debug_free(p)
#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \
	GC_debug_register_finalizer(p, f, d, of, od)
#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \
	GC_debug_register_finalizer_ignore_self(p, f, d, of, od)
#   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);
#   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)
#   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)
#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \
	GC_general_register_disappearing_link(link, GC_base(obj))
#   define GC_REGISTER_DISPLACEMENT(n) GC_debug_register_displacement(n)
# else
#   define GC_MALLOC(sz) GC_malloc(sz)
#   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)
#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)
#   define GC_REALLOC(old, sz) GC_realloc(old, sz)
#   define GC_FREE(p) GC_free(p)
#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \
	GC_register_finalizer(p, f, d, of, od)
#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \
	GC_register_finalizer_ignore_self(p, f, d, of, od)
#   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)
#   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)
#   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)
#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \
	GC_general_register_disappearing_link(link, obj)
#   define GC_REGISTER_DISPLACEMENT(n) GC_register_displacement(n)
# endif
/* The following are included because they are often convenient, and	*/
/* reduce the chance for a misspecifed size argument.  But calls may	*/
/* expand to something syntactically incorrect if t is a complicated	*/
/* type expression.  							*/
# define GC_NEW(t) (t *)GC_MALLOC(sizeof (t))
# define GC_NEW_ATOMIC(t) (t *)GC_MALLOC_ATOMIC(sizeof (t))
# define GC_NEW_STUBBORN(t) (t *)GC_MALLOC_STUBBORN(sizeof (t))
# define GC_NEW_UNCOLLECTABLE(t) (t *)GC_MALLOC_UNCOLLECTABLE(sizeof (t))

/* Finalization.  Some of these primitives are grossly unsafe.		*/
/* The idea is to make them both cheap, and sufficient to build		*/
/* a safer layer, closer to PCedar finalization.			*/
/* The interface represents my conclusions from a long discussion	*/
/* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, 		*/
/* Christian Jacobi, and Russ Atkinson.  It's not perfect, and		*/
/* probably nobody else agrees with it.	    Hans-J. Boehm  3/13/92	*/
typedef void (*GC_finalization_proc)
  	GC_PROTO((GC_PTR obj, GC_PTR client_data));

GC_API void GC_register_finalizer
    	GC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,
		  GC_finalization_proc *ofn, GC_PTR *ocd));
GC_API void GC_debug_register_finalizer
    	GC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,
		  GC_finalization_proc *ofn, GC_PTR *ocd));
	/* When obj is no longer accessible, invoke		*/
	/* (*fn)(obj, cd).  If a and b are inaccessible, and	*/
	/* a points to b (after disappearing links have been	*/
	/* made to disappear), then only a will be		*/
	/* finalized.  (If this does not create any new		*/
	/* pointers to b, then b will be finalized after the	*/
	/* next collection.)  Any finalizable object that	*/
	/* is reachable from itself by following one or more	*/
	/* pointers will not be finalized (or collected).	*/
	/* Thus cycles involving finalizable objects should	*/
	/* be avoided, or broken by disappearing links.		*/
	/* All but the last finalizer registered for an object  */
	/* is ignored.						*/
	/* Finalization may be removed by passing 0 as fn.	*/
	/* Finalizers are implicitly unregistered just before   */
	/* they are invoked.					*/
	/* The old finalizer and client data are stored in	*/
	/* *ofn and *ocd.					*/ 
	/* Fn is never invoked on an accessible object,		*/
	/* provided hidden pointers are converted to real 	*/
	/* pointers only if the allocation lock is held, and	*/
	/* such conversions are not performed by finalization	*/
	/* routines.						*/
	/* If GC_register_finalizer is aborted as a result of	*/
	/* a signal, the object may be left with no		*/
	/* finalization, even if neither the old nor new	*/
	/* finalizer were NULL.					*/
	/* Obj should be the nonNULL starting address of an 	*/
	/* object allocated by GC_malloc or friends.		*/
	/* Note that any garbage collectable object referenced	*/
	/* by cd will be considered accessible until the	*/
	/* finalizer is invoked.				*/

/* Another versions of the above follow.  It ignores		*/
/* self-cycles, i.e. pointers from a finalizable object to	*/
/* itself.  There is a stylistic argument that this is wrong,	*/
/* but it's unavoidable for C++, since the compiler may		*/
/* silently introduce these.  It's also benign in that specific	*/
/* case.							*/
GC_API void GC_register_finalizer_ignore_self
	GC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,
		  GC_finalization_proc *ofn, GC_PTR *ocd));
GC_API void GC_debug_register_finalizer_ignore_self
	GC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,
		  GC_finalization_proc *ofn, GC_PTR *ocd));

/* The following routine may be used to break cycles between	*/
/* finalizable objects, thus causing cyclic finalizable		*/
/* objects to be finalized in the correct order.  Standard	*/
/* use involves calling GC_register_disappearing_link(&p),	*/
/* where p is a pointer that is not followed by finalization	*/
/* code, and should not be considered in determining 		*/
/* finalization order.						*/
GC_API int GC_register_disappearing_link GC_PROTO((GC_PTR * /* link */));
	/* Link should point to a field of a heap allocated 	*/
	/* object obj.  *link will be cleared when obj is	*/
	/* found to be inaccessible.  This happens BEFORE any	*/
	/* finalization code is invoked, and BEFORE any		*/
	/* decisions about finalization order are made.		*/
	/* This is useful in telling the finalizer that 	*/
	/* some pointers are not essential for proper		*/
	/* finalization.  This may avoid finalization cycles.	*/
	/* Note that obj may be resurrected by another		*/
	/* finalizer, and thus the clearing of *link may	*/
	/* be visible to non-finalization code.  		*/
	/* There's an argument that an arbitrary action should  */
	/* be allowed here, instead of just clearing a pointer. */
	/* But this causes problems if that action alters, or 	*/
	/* examines connectivity.				*/
	/* Returns 1 if link was already registered, 0		*/
	/* otherwise.						*/
	/* Only exists for backward compatibility.  See below:	*/
	
GC_API int GC_general_register_disappearing_link
	GC_PROTO((GC_PTR * /* link */, GC_PTR obj));
	/* A slight generalization of the above. *link is	*/
	/* cleared when obj first becomes inaccessible.  This	*/
	/* can be used to implement weak pointers easily and	*/
	/* safely. Typically link will point to a location	*/
	/* holding a disguised pointer to obj.  (A pointer 	*/
	/* inside an "atomic" object is effectively  		*/
	/* disguised.)   In this way soft			*/
	/* pointers are broken before any object		*/
	/* reachable from them are finalized.  Each link	*/
	/* May be registered only once, i.e. with one obj	*/
	/* value.  This was added after a long email discussion */
	/* with John Ellis.					*/
	/* Obj must be a pointer to the first word of an object */
	/* we allocated.  It is unsafe to explicitly deallocate */
	/* the object containing link.  Explicitly deallocating */
	/* obj may or may not cause link to eventually be	*/
	/* cleared.						*/
GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));
	/* Returns 0 if link was not actually registered.	*/
	/* Undoes a registration by either of the above two	*/
	/* routines.						*/

/* Auxiliary fns to make finalization work correctly with displaced	*/
/* pointers introduced by the debugging allocators.			*/
GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));
GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));

GC_API int GC_invoke_finalizers GC_PROTO((void));
	/* Run finalizers for all objects that are ready to	*/
	/* be finalized.  Return the number of finalizers	*/
	/* that were run.  Normally this is also called		*/
	/* implicitly during some allocations.	If		*/
	/* FINALIZE_ON_DEMAND is defined, it must be called	*/
	/* explicitly.						*/

/* GC_set_warn_proc can be used to redirect or filter warning messages.	*/
/* p may not be a NULL pointer.						*/
typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));
GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));
    /* Returns old warning procedure.	*/
	
/* The following is intended to be used by a higher level	*/
/* (e.g. cedar-like) finalization facility.  It is expected	*/
/* that finalization code will arrange for hidden pointers to	*/
/* disappear.  Otherwise objects can be accessed after they	*/
/* have been collected.						*/
/* Note that putting pointers in atomic objects or in 		*/
/* nonpointer slots of "typed" objects is equivalent to 	*/
/* disguising them in this way, and may have other advantages.	*/
# if defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)
    typedef GC_word GC_hidden_pointer;
#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))
#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))
    /* Converting a hidden pointer to a real pointer requires verifying	*/
    /* that the object still exists.  This involves acquiring the  	*/
    /* allocator lock to avoid a race with the collector.		*/
# endif /* I_HIDE_POINTERS */

typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));
GC_API GC_PTR GC_call_with_alloc_lock
        	GC_PROTO((GC_fn_type fn, GC_PTR client_data));

/* Check that p and q point to the same object.  		*/
/* Fail conspicuously if they don't.				*/
/* Returns the first argument.  				*/
/* Succeeds if neither p nor q points to the heap.		*/
/* May succeed if both p and q point to between heap objects.	*/
GC_API GC_PTR GC_same_obj GC_PROTO((GC_PTR p, GC_PTR q));

/* Checked pointer pre- and post- increment operations.  Note that	*/
/* the second argument is in units of bytes, not multiples of the	*/
/* object size.  This should either be invoked from a macro, or the	*/
/* call should be automatically generated.				*/
GC_API GC_PTR GC_pre_incr GC_PROTO((GC_PTR *p, size_t how_much));
GC_API GC_PTR GC_post_incr GC_PROTO((GC_PTR *p, size_t how_much));

/* Check that p is visible						*/
/* to the collector as a possibly pointer containing location.		*/
/* If it isn't fail conspicuously.					*/
/* Returns the argument in all cases.  May erroneously succeed		*/
/* in hard cases.  (This is intended for debugging use with		*/
/* untyped allocations.  The idea is that it should be possible, though	*/
/* slow, to add such a call to all indirect pointer stores.)		*/
/* Currently useless for multithreaded worlds.				*/
GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));

/* Check that if p is a pointer to a heap page, then it points to	*/
/* a valid displacement within a heap object.				*/
/* Fail conspicuously if this property does not hold.			*/
/* Uninteresting with ALL_INTERIOR_POINTERS.				*/
/* Always returns its argument.						*/
GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR	p));

/* Safer, but slow, pointer addition.  Probably useful mainly with 	*/
/* a preprocessor.  Useful only for heap pointers.			*/
#ifdef GC_DEBUG
#   define GC_PTR_ADD3(x, n, type_of_result) \
	((type_of_result)GC_same_obj((x)+(n), (x)))
#   define GC_PRE_INCR3(x, n, type_of_result) \
	((type_of_result)GC_pre_incr(&(x), (n)*sizeof(*x))
#   define GC_POST_INCR2(x, type_of_result) \
	((type_of_result)GC_post_incr(&(x), sizeof(*x))
#   ifdef __GNUC__
#       define GC_PTR_ADD(x, n) \
	    GC_PTR_ADD3(x, n, typeof(x))
#   define GC_PRE_INCR(x, n) \
	    GC_PRE_INCR3(x, n, typeof(x))
#   define GC_POST_INCR(x, n) \
	    GC_POST_INCR3(x, typeof(x))
#   else
	/* We can't do this right without typeof, which ANSI	*/
	/* decided was not sufficiently useful.  Repeatedly	*/
	/* mentioning the arguments seems too dangerous to be	*/
	/* useful.  So does not casting the result.		*/
#   	define GC_PTR_ADD(x, n) ((x)+(n))
#   endif
#else	/* !GC_DEBUG */
#   define GC_PTR_ADD3(x, n, type_of_result) ((x)+(n))
#   define GC_PTR_ADD(x, n) ((x)+(n))
#   define GC_PRE_INCR3(x, n, type_of_result) ((x) += (n))
#   define GC_PRE_INCR(x, n) ((x) += (n))
#   define GC_POST_INCR2(x, n, type_of_result) ((x)++)
#   define GC_POST_INCR(x, n) ((x)++)
#endif

/* Safer assignment of a pointer to a nonstack location.	*/
#ifdef GC_DEBUG
# ifdef __STDC__
#   define GC_PTR_STORE(p, q) \
	(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))
# else
#   define GC_PTR_STORE(p, q) \
	(*(char **)GC_is_visible(p) = GC_is_valid_displacement(q))
# endif
#else /* !GC_DEBUG */
#   define GC_PTR_STORE(p, q) *((p) = (q))
#endif

/* Fynctions called to report pointer checking errors */
GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));

GC_API void (*GC_is_valid_displacement_print_proc)
	GC_PROTO((GC_PTR p));

GC_API void (*GC_is_visible_print_proc)
	GC_PROTO((GC_PTR p));

#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)
#   define SOLARIS_THREADS
#endif

#ifdef SOLARIS_THREADS
/* We need to intercept calls to many of the threads primitives, so 	*/
/* that we can locate thread stacks and stop the world.			*/
/* Note also that the collector cannot see thread specific data.	*/
/* Thread specific data should generally consist of pointers to		*/
/* uncollectable objects, which are deallocated using the destructor	*/
/* facility in thr_keycreate.						*/
# include <thread.h>
# include <signal.h>
  int GC_thr_create(void *stack_base, size_t stack_size,
                    void *(*start_routine)(void *), void *arg, long flags,
                    thread_t *new_thread);
  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);
  int GC_thr_suspend(thread_t target_thread);
  int GC_thr_continue(thread_t target_thread);
  void * GC_dlopen(const char *path, int mode);

# ifdef _SOLARIS_PTHREADS
#   include <pthread.h>
    extern int GC_pthread_create(pthread_t *new_thread,
    			         const pthread_attr_t *attr,
          			 void * (*thread_execp)(void *), void *arg);
    extern int GC_pthread_join(pthread_t wait_for, void **status);

#   undef thread_t

#   define pthread_join GC_pthread_join
#   define pthread_create GC_pthread_create
#endif

# define thr_create GC_thr_create
# define thr_join GC_thr_join
# define thr_suspend GC_thr_suspend
# define thr_continue GC_thr_continue
# define dlopen GC_dlopen

# endif /* SOLARIS_THREADS */


#if defined(IRIX_THREADS) || defined(LINUX_THREADS)
/* We treat these similarly. */
# include <pthread.h>
# include <signal.h>

  int GC_pthread_create(pthread_t *new_thread,
                        const pthread_attr_t *attr,
		        void *(*start_routine)(void *), void *arg);
  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);
  int GC_pthread_join(pthread_t thread, void **retval);

# define pthread_create GC_pthread_create
# define pthread_sigmask GC_pthread_sigmask
# define pthread_join GC_pthread_join

#endif /* IRIX_THREADS || LINUX_THREADS */

# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \
	defined(IRIX_THREADS) || defined(LINUX_THREADS) || \
	defined(IRIX_JDK_THREADS)
   	/* Any flavor of threads except SRC_M3.	*/
/* This returns a list of objects, linked through their first		*/
/* word.  Its use can greatly reduce lock contention problems, since	*/
/* the allocation lock can be acquired and released many fewer times.	*/
GC_PTR GC_malloc_many(size_t lb);
#define GC_NEXT(p) (*(GC_PTR *)(p)) 	/* Retrieve the next element	*/
					/* in returned list.		*/
extern void GC_thr_init();	/* Needed for Solaris/X86	*/

#endif /* THREADS && !SRC_M3 */

/*
 * If you are planning on putting
 * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()
 * from the statically loaded program section.
 * This circumvents a Solaris 2.X (X<=4) linker bug.
 */
#if defined(sparc) || defined(__sparc)
#   define GC_INIT() { extern end, etext; \
		       GC_noop(&end, &etext); }
#else
# if defined(__CYGWIN32__) && defined(GC_USE_DLL)
    /*
     * Similarly gnu-win32 DLLs need explicit initialization
     */
#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }
# else
#   define GC_INIT()
# endif
#endif

#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \
     || defined(_WIN32)
  /* win32S may not free all resources on process exit.  */
  /* This explicitly deallocates the heap.		 */
    GC_API void GC_win32_free_heap ();
#endif

#ifdef __cplusplus
    }  /* end of extern "C" */
#endif

#endif /* _GC_H */
::::::::::::::
handler.h
::::::::::::::
/* ************************************************************************
*   File: handler.h                                     Part of CircleMUD *
*  Usage: header file: prototypes of handling and utility functions       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/* handling the affected-structures */
void    affect_total(struct char_data *ch);
void    affect_modify(struct char_data *ch, byte loc, int mod, long bitv, long bitv2, long bitv3, bool add);
void    affect_to_char(struct char_data *ch, struct affected_type *af);
void    affect_remove(struct char_data *ch, struct affected_type *af);
void    affect_from_char(struct char_data *ch, int type);
bool    affected_by_spell(struct char_data *ch, int type);
void    affect_join(struct char_data *ch, struct affected_type *af,
bool add_dur, bool avg_dur, bool add_mod, bool avg_mod);


/* utility */
char *money_desc(int amount);
struct obj_data *create_money(int amount);
int     isname(const char *str, const char *namelist);
int     is_name(const char *str, const char *namelist);
int     exact_isname(const char *str, const char *namelist);
char    *fname(char *namelist);
int     get_number(char **name);

/* ******** objects *********** */

void    obj_to_char(struct obj_data *object, struct char_data *ch);
void    obj_from_char(struct obj_data *object);

void    equip_char(struct char_data *ch, struct obj_data *obj, int pos);
struct obj_data *unequip_char(struct char_data *ch, int pos);
int	invalid_align(struct char_data *ch, struct obj_data *obj);

struct obj_data *get_obj_in_list(char *name, struct obj_data *list);
struct obj_data *get_obj_in_list_num(int num, struct obj_data *list);
struct obj_data *get_obj(char *name);
struct obj_data *get_obj_num(obj_rnum nr);

void    obj_to_room(struct obj_data *object, room_rnum room);
void    obj_from_room(struct obj_data *object);
void    obj_to_obj(struct obj_data *obj, struct obj_data *obj_to);
void    obj_from_obj(struct obj_data *obj);
void    object_list_new_owner(struct obj_data *list, struct char_data *ch);

void    extract_obj(struct obj_data *obj);

/* ******* characters ********* */

struct char_data *get_char_room(char *name, room_rnum room);
struct char_data *get_char_num(mob_rnum nr);
struct char_data *get_char(char *name);

void    char_from_room(struct char_data *ch);
void    char_to_room(struct char_data *ch, room_rnum room);
void    extract_char(struct char_data *ch);

/* find if character can see */
struct char_data *get_char_room_vis(struct char_data *ch, char *name);
struct char_data *get_player_vis(struct char_data *ch, char *name, int inroom);
struct char_data *get_char_vis(struct char_data *ch, char *name);
struct obj_data *get_obj_in_list_vis(struct char_data *ch, char *name,
struct obj_data *list);
struct obj_data *get_obj_vis(struct char_data *ch, char *name);
struct obj_data *get_object_in_equip_vis(struct char_data *ch,
char *arg, struct obj_data *equipment[], int *j);

void make_summary(struct char_data * ch);

/* find all dots */

int     find_all_dots(char *arg);

#define FIND_INDIV      0
#define FIND_ALL        1
#define FIND_ALLDOT     2


/* Generic Find */

int     generic_find(char *arg, int bitvector, struct char_data *ch,
struct char_data **tar_ch, struct obj_data **tar_obj);

#define FIND_CHAR_ROOM     1
#define FIND_CHAR_WORLD    2
#define FIND_OBJ_INV       4
#define FIND_OBJ_ROOM      8
#define FIND_OBJ_WORLD    16
#define FIND_OBJ_EQUIP    32


/* prototypes from crash save system */

int     Crash_get_filename(char *orig_name, char *filename);
int     Crash_delete_file(char *name);
int     Crash_delete_crashfile(struct char_data *ch);
int     Crash_clean_file(char *name);
void    Crash_listrent(struct char_data *ch, char *name);
int     Crash_load(struct char_data *ch);
void    Crash_crashsave(struct char_data *ch);
void    Crash_idlesave(struct char_data *ch);
void    Crash_save_all(void);

/* prototypes from fight.c */
void    set_fighting(struct char_data *ch, struct char_data *victim);
void    stop_fighting(struct char_data *ch);
void    stop_follower(struct char_data *ch);
void    hit(struct char_data *ch, struct char_data *victim, int type);
void    forget(struct char_data *ch, struct char_data *victim);
void    remember(struct char_data *ch, struct char_data *victim);
int     damage(struct char_data *ch, struct char_data *victim, int dam, int attacktype);
int     skill_message(int dam, struct char_data *ch, struct char_data *vict,
                      int attacktype);
::::::::::::::
house.h
::::::::::::::
#define MAX_HOUSES	100
#define MAX_GUESTS	10

#define HOUSE_PRIVATE	0


struct house_control_rec {
   room_vnum vnum;		/* vnum of this house		*/
   room_vnum atrium;		/* vnum of atrium		*/
   sh_int exit_num;		/* direction of house's exit	*/
   time_t built_on;		/* date this house was built	*/
   int mode;			/* mode of ownership		*/
   long owner;			/* idnum of house's owner	*/
   int num_of_guests;		/* how many guests for house	*/
   long guests[MAX_GUESTS];	/* idnums of house's guests	*/
   time_t last_payment;		/* date of last house payment   */
   long spare0;
   long spare1;
   long spare2;
   long spare3;
   long spare4;
   long spare5;
   long spare6;
   long spare7;
};



   
#define TOROOM(room, dir) (world[room].dir_option[dir] ? \
			    world[room].dir_option[dir]->to_room : NOWHERE)

void	House_listrent(struct char_data *ch, room_vnum vnum);
void	House_boot(void);
void	House_save_all(void);
int	House_can_enter(struct char_data *ch, room_vnum house);
void	House_crashsave(room_vnum vnum);
void	House_list_guests(struct char_data *ch, int i, int quiet);
::::::::::::::
interpreter.h
::::::::::::::
/* ************************************************************************
*   File: interpreter.h                                 Part of CircleMUD *
*  Usage: header file: public procs, macro defs, subcommand defines       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


#define ACMD(name)  \
   void name(struct char_data *ch, char *argument, int cmd, int subcmd)

ACMD(do_move);

#define CMD_NAME (complete_cmd_info[cmd].command)
#define CMD_IS(cmd_name) (!strcmp(cmd_name, complete_cmd_info[cmd].command))
#define IS_MOVE(cmdnum) (complete_cmd_info[cmdnum].command_pointer == do_move)

void    command_interpreter(struct char_data *ch, char *argument);
int     search_block(char *arg, const char **list, int exact);
int	search_block_case(char *arg, char **list, bool exact);
char    lower( char c );
char    *one_argument(char *argument, char *first_arg);
char    *one_word(char *argument, char *first_arg);
char    *any_one_arg(char *argument, char *first_arg);
char    *two_arguments(char *argument, char *first_arg, char *second_arg);
int     fill_word(char *argument);
void    half_chop(char *string, char *arg1, char *arg2);
void    nanny(struct descriptor_data *d, char *arg);
int     is_abbrev(const char *arg1, const char *arg2);
int     is_number(const char *str);
int     find_command(const char *command);
void    skip_spaces(char **string);
char    *delete_doubledollar(char *string);

/* for compatibility with 2.20: */
#define argument_interpreter(a, b, c) two_arguments(a, b, c)


struct command_info {
   const char *command;
   char *sort_as;
   byte minimum_position;
   void (*command_pointer)
           (struct char_data *ch, char * argument, int cmd, int subcmd);
   sh_int minimum_level;
   int  subcmd;
};

/*
 * Necessary for CMD_IS macro.  Borland needs the structure defined first
 * so it has been moved down here.
 */
#ifndef __INTERPRETER_C__
extern struct command_info *complete_cmd_info;
#endif


struct alias {
  char *alias;
  char *replacement;
  int type;
  struct alias *next;
};

#define ALIAS_SIMPLE    0
#define ALIAS_COMPLEX   1

#define ALIAS_SEP_CHAR  ';'
#define ALIAS_VAR_CHAR  '$'
#define ALIAS_GLOB_CHAR '*'

/*
 * SUBCOMMANDS
 *   You can define these however you want to, and the definitions of the
 *   subcommands are independent from function to function.
 */

/* directions */
#define SCMD_NORTH      1
#define SCMD_EAST       2
#define SCMD_SOUTH      3
#define SCMD_WEST       4
#define SCMD_UP         5
#define SCMD_DOWN       6

/* do_gen_ps */
#define SCMD_INFO       0
#define SCMD_HANDBOOK   1 
#define SCMD_CREDITS    2
#define SCMD_NEWS       3
#define SCMD_WIZLIST    4
#define SCMD_POLICIES   5
#define SCMD_VERSION    6
#define SCMD_IMMLIST    7
#define SCMD_MOTD       8
#define SCMD_IMOTD      9
#define SCMD_CLEAR      10
#define SCMD_WHOAMI     11

/* do_gen_tog */
#define SCMD_NOSUMMON   0
#define SCMD_NOHASSLE   1
#define SCMD_BRIEF      2
#define SCMD_COMPACT    3
#define SCMD_NOTELL     4
#define SCMD_NOAUCTION  5
#define SCMD_DEAF       6
#define SCMD_NOGOSSIP   7
#define SCMD_NOGRATZ    8
#define SCMD_NOCHAT     9
#define SCMD_NOWIZ      10
#define SCMD_QUEST      11
#define SCMD_CROSSDOORS 12
#define SCMD_NOREPEAT   13
#define SCMD_HOLYLIGHT  14
#define SCMD_SLOWNS     15
#define SCMD_AUTOEXIT   16
#define SCMD_AUTOLOOT   17
#define SCMD_AUTOGOLD   18
#define SCMD_AUTOSPLIT  19
#define SCMD_AFK        20
#define SCMD_AUTOASSIST 21
#define SCMD_WDPROTOCOL 22
#define SCMD_MAP	    23
#define SCMD_NOREPLY	24
#define SCMD_HOUSE_RECALL 25
#define SCMD_NONEWBIE   26
#define SCMD_NOTIPS   27
#define SCMD_MSP        28

/* do_wizutil */
#define SCMD_REROLL     0
#define SCMD_PARDON     1
#define SCMD_NOTITLE    2
#define SCMD_SQUELCH    3
#define SCMD_FREEZE     4
#define SCMD_THAW       5
#define SCMD_UNAFFECT   6

/* do_spec_com */
#define SCMD_WHISPER    0
#define SCMD_ASK        1

/* do_gen_com */
#define SCMD_HOLLER     0
#define SCMD_SHOUT      1
#define SCMD_GOSSIP     2
#define SCMD_AUCTION    3
#define SCMD_GRATZ      4
#define SCMD_GMOTE	5
#define SCMD_CHAT	6
#define SCMD_NEWBIE     7

/* do_shutdown */
#define SCMD_SHUTDOW    0
#define SCMD_SHUTDOWN   1

/* do_quit */
#define SCMD_QUI        0
#define SCMD_QUIT       1

/* do_date */
#define SCMD_DATE       0
#define SCMD_UPTIME     1

/* do_commands */
#define SCMD_COMMANDS   0
#define SCMD_SOCIALS    1
#define SCMD_WIZHELP    2

/* do_drop */
#define SCMD_DROP       0
#define SCMD_JUNK       1
#define SCMD_DONATE     2

/* do_gen_write */
#define SCMD_BUG        0
#define SCMD_TYPO       1
#define SCMD_IDEA       2

/* do_look */
#define SCMD_LOOK       0
#define SCMD_READ       1

/* do_qcomm */
#define SCMD_QSAY       0
#define SCMD_QECHO      1

/* do_pour */
#define SCMD_POUR       0
#define SCMD_FILL       1

/* do_poof */
#define SCMD_POOFIN     0
#define SCMD_POOFOUT    1

/* do_hit */
#define SCMD_HIT        0
#define SCMD_MURDER     1

/* do_eat */
#define SCMD_EAT        0
#define SCMD_TASTE      1
#define SCMD_DRINK      2
#define SCMD_SIP        3

/* do_use */
#define SCMD_USE        0
#define SCMD_QUAFF      1
#define SCMD_RECITE     2
#define SCMD_STUDY      3

/* do_echo */
#define SCMD_ECHO       0
#define SCMD_EMOTE      1

/* do_gen_door */
#define SCMD_OPEN       0
#define SCMD_CLOSE      1
#define SCMD_UNLOCK     2
#define SCMD_LOCK       3
#define SCMD_PICK       4

/*. do_olc .*/
#define SCMD_OLC_REDIT     0
#define SCMD_OLC_OEDIT     1
#define SCMD_OLC_ZEDIT     2
#define SCMD_OLC_MEDIT     3
#define SCMD_OLC_SEDIT     4
#define SCMD_OLC_HEDIT	   5
#define SCMD_OLC_AEDIT	   6
#define SCMD_OLC_TRIGEDIT  7
#define SCMD_OLC_QEDIT     8
#define SCMD_OLC_SAVEINFO  9


/* do_liblist */
#define SCMD_RLIST 0
#define SCMD_OLIST 1
#define SCMD_MLIST 2
#define SCMD_ZLIST 3
#define SCMD_ELIST 4
#define SCMD_DLIST 5
#define SCMD_LLIST 6
#define SCMD_VLIST 7

::::::::::::::
mail.h
::::::::::::::
/* ************************************************************************
*   File: mail.h                                        Part of CircleMUD *
*  Usage: header file for mail system                                     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/******* MUD MAIL SYSTEM HEADER FILE *********************
 ***     written by Jeremy Elson (jelson@cs.jhu.edu)   ***
 ********************************************************/

/* INSTALLATION INSTRUCTIONS in MAIL.C */

/* You can modify the following constants to fit your own MUD.  */

/* minimum level a player must be to send mail  */
#define MIN_MAIL_LEVEL 2

/* # of gold coins required to send mail        */
#define STAMP_PRICE 150

/* Maximum size of mail in bytes (arbitrary)    */
#define MAX_MAIL_SIZE 4096

/* size of mail file allocation blocks          */
#define BLOCK_SIZE 100

/*
 * NOTE:  Make sure that your block size is big enough -- if not,
 * HEADER_BLOCK_DATASIZE will end up negative.  This is a bad thing.
 * Check the define below to make sure it is >0 when choosing values
 * for NAME_SIZE and BLOCK_SIZE.  100 is a nice round number for
 * BLOCK_SIZE and is the default ... why bother trying to change it
 * anyway?
 *
 * The mail system will always allocate disk space in chunks of size
 * BLOCK_SIZE.
 */

/* USER CHANGABLE DEFINES ABOVE **
***************************************************************************
**   DON'T TOUCH DEFINES BELOW  */

int     scan_file(void);
int     has_mail(long recipient);
void    store_mail(long to, long from, char *message_pointer);
char    *read_delete(long recipient);


#define HEADER_BLOCK  -1
#define LAST_BLOCK    -2
#define DELETED_BLOCK -3

/*
 * note: next_block is part of header_blk in a data block; we can't combine
 * them here because we have to be able to differentiate a data block from a
 * header block when booting mail system.
 */

struct header_data_type {
   long next_block;             /* if header block, link to next block  */
   long from;                   /* idnum of the mail's sender           */
   long to;                     /* idnum of mail's recipient            */
   time_t mail_time;            /* when was the letter mailed?          */
};

/* size of the data part of a header block */
#define HEADER_BLOCK_DATASIZE \
        (BLOCK_SIZE - sizeof(long) - sizeof(struct header_data_type) - sizeof(char))

/* size of the data part of a data block */
#define DATA_BLOCK_DATASIZE (BLOCK_SIZE - sizeof(long) - sizeof(char))

/* note that an extra space is allowed in all string fields for the
   terminating null character.  */

struct header_block_type_d {
   long block_type;             /* is this a header or data block?      */
   struct header_data_type header_data; /* other header data            */
   char txt[HEADER_BLOCK_DATASIZE+1]; /* actual text plus 1 for null    */
};

struct data_block_type_d {
   long block_type;             /* -1 if header block, -2 if last data block
                                   in mail, otherwise a link to the next */
   char txt[DATA_BLOCK_DATASIZE+1]; /* actual text plus 1 for null      */
};

typedef struct header_block_type_d header_block_type;
typedef struct data_block_type_d data_block_type;

struct position_list_type_d {
   long position;
   struct position_list_type_d *next;
};

typedef struct position_list_type_d position_list_type;

struct mail_index_type_d {
   long recipient;                      /* who is this mail for?        */
   position_list_type *list_start;      /* list of mail positions       */
   struct mail_index_type_d *next;      /* link to next one             */
};

typedef struct mail_index_type_d mail_index_type;
::::::::::::::
masters.h
::::::::::::::
/* File: Masters.h				**
** Usado para os Comandos basicos de Discipulos **
** Implementado por Taerom e Zhantar            **
** Inicio do Projeto: 04/07/03                  */

void criacao(struct descriptor_data *d, char *arg);
void criacao_new(struct descriptor_data *d, char *arg);
void nome_maiusculo(char *saida, char *entrada);
void verifica(struct descriptor_data *d);
void ganha_rp(struct char_data *ch);
void list_skills(struct char_data *ch);

int prac_params[4][NUM_CLASSES];

extern char *pc_class_types[];
extern char *pc_race_types[];
extern int check_remort_sk;
extern struct int_app_type int_app[];
extern int spell_sort_info[MAX_SKILLS+1];
extern char *spells[];
extern struct spell_info_type spell_info[];


ACMD(do_master);
SPECIAL(master);


 #define LEARNED_LEVEL	        0 // % known which is considered "learned"/
 #define MAX_PER_PRAC		1 // max percent gain in skill per practice 
 #define MIN_PER_PRAC		2 // min percent gain in skill per practice 
 
 #define SPELL	0
 #define SKILL	1
 
 #define LEARNED(ch) (prac_params[LEARNED_LEVEL][(int)GET_CLASS(ch)])
 #define MINGAIN(ch) (prac_params[MIN_PER_PRAC][(int)GET_CLASS(ch)])
 #define MAXGAIN(ch) (prac_params[MAX_PER_PRAC][(int)GET_CLASS(ch)])
 
 #define MENU \
"&YW&yE&YL&yC&YO&YM&yE&Y &yT&YO&y &YW&yA&YR&yM&YA&yS&YT&yE&YR&y G&YU&yI&YL&yD&n\r\n" \
"\r\n" \
"&yHere you can learn new &Yskills &yor &Yspells.&n\r\n" \
"&yType &Ypractice &y<&Yskill&y/&Yspell&y> to learn.\r\n" \
"\r\n" \
"&yYou can learn the following &Yskill&y/&Yspell:&n\r\n" \
"&Y[&yCost&Y] &Y[&yName&Y]              &Y[&yCost&Y] &Y[&yName&Y]              &Y[&yCost&Y] &Y[&yName&Y]&n\r\n" \

int prac_params[4][NUM_CLASSES] = {

  { 10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10,  10   },	/* learned level */
  { 15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15	},	/* max per practice */
  { 25,	 25,  25,  25,	25,  25,  25,  25,  25,	 25,  25,  25   },	/* min per practice */
  {  1,   0,   1,   0,   1,   1,   0,   1,   1,   0,   1,   0   },	/* prac name */
};




::::::::::::::
olc.h
::::::::::::::
/************************************************************************
 * OasisOLC - olc.h						v1.5	*
 *									*
 * Copyright 1996 Harvey Gilpin.					*
 ************************************************************************/

/*
 * If you don't want a short explanation of each field in your zone files,
 * change the number below to a 0 instead of a 1.
 */
#if 0
#define ZEDIT_HELP_IN_FILE
#endif

/*
 * If you want to clear the screen before certain Oasis menus, set to 1.
 */
#if 0
#define CLEAR_SCREEN	1
#endif

/*
 * Set this to 1 to enable MobProg support.
 */
#if 0
#define OASIS_MPROG	1
#endif

/*
 * Macros, defines, structs and globals for the OLC suite.
 */

#define NUM_ZONE_FLAGS		5
#define NUM_ROOM_FLAGS          24
#define NUM_ROOM_SECTORS        10

#define NUM_MOB_FLAGS           22
#define NUM_AFF_FLAGS           40
#define NUM_ATTACK_TYPES        15

#define NUM_ITEM_TYPES          25
#define NUM_ITEM_FLAGS          40
#define NUM_ITEM_WEARS          18
#define NUM_APPLIES             25
#define NUM_LIQ_TYPES           16
#define NUM_POSITIONS           15
//#define NUM_SPELLS              57

#define NUM_GENDERS             3
#define NUM_SHOP_FLAGS          2
#define NUM_TRADERS             7

/*
 * Define this to how many MobProg scripts you have.
 */
#define NUM_PROGS		12

/*
 * Aedit Permissions # - set <char> olc 999
 */


#define LVL_BUILDER             LVL_DEMIGOD
#define LVL_OLC_FULL            LVL_GOD

#define TRIGEDIT_PERMISSION	-2
#define HEDIT_PERMISSION	-3
#define AEDIT_PERMISSION	-4
#define QEDIT_PERMISSION	-5

/*
 * Utilities exported from olc.c.
 */
void strip_string(char *);
void cleanup_olc(struct descriptor_data *d, byte cleanup_type);
void get_char_cols(struct char_data *ch);
void olc_add_to_save_list(int zone, byte type);
void olc_remove_from_save_list(int zone, byte type);

/*
 * OLC structures.
 */

struct olc_data {
  int mode;
  int zone_num;
  int number;
  int value;
  int owner;
  int total_mprogs;
  struct char_data *mob;
  struct room_data *room;
  struct obj_data *obj;
  struct zone_data *zone;
  struct shop_data *shop;
  struct extra_descr_data *desc;
  struct aq_data *quest;
  struct help_index_element *help;
#if defined(OASIS_MPROG)
  struct mob_prog_data *mprog;
  struct mob_prog_data *mprogl;
#endif
  struct trig_data *trig;
  int script_mode;
  int trigger_position;
  int item_type;
  struct trig_proto_list *script;
  struct social_messg *action;
  char *storage; /* for holding commands etc.. */
};

struct olc_save_info {
  int zone;
  char type;
  struct olc_save_info *next;
};

/*
 * Exported globals.
 */
#ifdef _OASIS_OLC_
char *nrm, *grn, *cyn, *yel;
struct olc_save_info *olc_save_list = NULL;
#else
extern char *nrm, *grn, *cyn, *yel;
extern struct olc_save_info *olc_save_list;
#endif

/*
 * Descriptor access macros.
 */
#define OLC_MODE(d) 	((d)->olc->mode)	/* Parse input mode.	*/
#define OLC_NUM(d) 	((d)->olc->number)	/* Room/Obj VNUM.	*/
#define OLC_VAL(d) 	((d)->olc->value)	/* Scratch variable.	*/
#define OLC_ZNUM(d) 	((d)->olc->zone_num)	/* Real zone number.	*/
#define OLC_ROOM(d) ((d)->olc->room) /* Room structure. */
#define OLC_OBJ(d) 	((d)->olc->obj)		/* Object structure.	*/
#define OLC_ZONE(d)     ((d)->olc->zone)	/* Zone structure.	*/
#define OLC_MOB(d)	((d)->olc->mob)		/* Mob structure.	*/
#define OLC_SHOP(d) 	((d)->olc->shop)	/* Shop structure.	*/
#define OLC_DESC(d) 	((d)->olc->desc)	/* Extra description.	*/
#define OLC_HELP(d)	((d)->olc->help)	/* help entries		*/
#define OLC_QUEST(d)    ((d)->olc->quest)	/* Quest structure      */
#ifdef OASIS_MPROG
#define OLC_MPROG(d)	((d)->olc->mprog)	/* Temporary MobProg.	*/
#define OLC_MPROGL(d)	((d)->olc->mprogl)	/* MobProg list.	*/
#define OLC_MTOTAL(d)	((d)->olc->total_mprogs)/* Total mprog number.	*/
#endif
#define OLC_TRIG(d)     ((d)->olc->trig)        /* Trigger structure.   */
#define OLC_STORAGE(d)  ((d)->olc->storage)     /* For command storage  */
#define OLC_ACTION(d)   ((d)->olc->action)      /* Action structure     */

/*
 * Other macros.
 */
#define OLC_EXIT(d)	(OLC_ROOM(d)->dir_option[OLC_VAL(d)])
#define GET_OLC_ZONE(c)	((c)->player_specials->saved.olc_zone)

/*
 * Cleanup types.
 */
#define CLEANUP_ALL		(byte)	1	/* Free the whole lot.	*/
#define CLEANUP_STRUCTS 	(byte)	2	/* Don't free strings.	*/

/*
 * Add/Remove save list types.
 */
#define OLC_SAVE_ROOM		(byte)	0
#define OLC_SAVE_OBJ		(byte)	1
#define OLC_SAVE_ZONE		(byte)	2
#define OLC_SAVE_MOB		(byte)	3
#define OLC_SAVE_SHOP		(byte)	4
#define OLC_SAVE_HELP		(byte)	5
#define OLC_SAVE_ACTION		(byte)	6
#define OLC_SAVE_QUEST		(byte)  7

/*
 * Submodes of OEDIT connectedness.
 */
#define OEDIT_MAIN_MENU              	1
#define OEDIT_EDIT_NAMELIST          	2
#define OEDIT_SHORTDESC              	3
#define OEDIT_LONGDESC               	4
#define OEDIT_ACTDESC                	5
#define OEDIT_TYPE                   	6
#define OEDIT_EXTRAS                 	7
#define OEDIT_WEAR                  	8
#define OEDIT_WEIGHT                	9
#define OEDIT_COST                  	10
#define OEDIT_COSTPERDAY            	11
#define OEDIT_TIMER                 	12
#define OEDIT_VALUE_1               	13
#define OEDIT_VALUE_2               	14
#define OEDIT_VALUE_3               	15
#define OEDIT_VALUE_4               	16
#define OEDIT_APPLY                 	17
#define OEDIT_APPLYMOD              	18
#define OEDIT_EXTRADESC_KEY         	19
#define OEDIT_CONFIRM_SAVEDB        	20
#define OEDIT_CONFIRM_SAVESTRING    	21
#define OEDIT_PROMPT_APPLY          	22
#define OEDIT_EXTRADESC_DESCRIPTION 	23
#define OEDIT_EXTRADESC_MENU        	24
#define OEDIT_OBJ_LEVEL                 25
#define OEDIT_PERM                      26
#define OEDIT_OBJ_CONDITION             27
#define OEDIT_OBJ_REMORT                28

/*
 * Submodes of REDIT connectedness.
 */
#define REDIT_MAIN_MENU 		1
#define REDIT_NAME 			2
#define REDIT_DESC 			3
#define REDIT_FLAGS 			4
#define REDIT_SECTOR 			5
#define REDIT_EXIT_MENU 		6
#define REDIT_CONFIRM_SAVEDB 		7
#define REDIT_CONFIRM_SAVESTRING 	8
#define REDIT_EXIT_NUMBER 		9
#define REDIT_EXIT_DESCRIPTION 		10
#define REDIT_EXIT_KEYWORD 		11
#define REDIT_EXIT_KEY 			12
#define REDIT_EXIT_DOORFLAGS 		13
#define REDIT_EXTRADESC_MENU 		14
#define REDIT_EXTRADESC_KEY 		15
#define REDIT_EXTRADESC_DESCRIPTION 	16
#define REDIT_TELEPORT_TARGET		17
#define REDIT_TELEPORT_FREQ		18
#define REDIT_TELEPORT_OBJ		19
#define REDIT_TELEPORT_MENU		20
/*
 * Submodes of ZEDIT connectedness.
 */
#define ZEDIT_MAIN_MENU              	0
#define ZEDIT_DELETE_ENTRY		1
#define ZEDIT_NEW_ENTRY			2
#define ZEDIT_CHANGE_ENTRY		3
#define ZEDIT_COMMAND_TYPE		4
#define ZEDIT_IF_FLAG			5
#define ZEDIT_ARG1			6
#define ZEDIT_ARG2			7
#define ZEDIT_ARG3			8
#define ZEDIT_ARG4                      9
#define ZEDIT_ZONE_NAME			10
#define ZEDIT_ZONE_LIFE			11
#define ZEDIT_ZONE_TOP			12
#define ZEDIT_ZONE_RESET		13
#define ZEDIT_CONFIRM_SAVESTRING	14
#define ZEDIT_ZONE_BUILDERS		15
#define ZEDIT_PROB                      16
#define ZEDIT_PROB2                     17
#define ZEDIT_ZONE_FLAGS		18
#define ZEDIT_ZONE_OWNER                19

/*
 * Submodes of MEDIT connectedness.
 */
#define MEDIT_MAIN_MENU              	0
#define MEDIT_ALIAS			1
#define MEDIT_S_DESC			2
#define MEDIT_L_DESC			3
#define MEDIT_D_DESC			4
#define MEDIT_NPC_FLAGS			5
#define MEDIT_AFF_FLAGS			6
#define MEDIT_CONFIRM_SAVESTRING	7
/*
 * Numerical responses.
 */
#define MEDIT_NUMERICAL_RESPONSE	10
#define MEDIT_SEX			11
#define MEDIT_HITROLL			12
#define MEDIT_DAMROLL			13
#define MEDIT_NDD			14
#define MEDIT_SDD			15
#define MEDIT_NUM_HP_DICE		16
#define MEDIT_SIZE_HP_DICE		17
#define MEDIT_ADD_HP			18
#define MEDIT_AC			19
#define MEDIT_EXP			20
#define MEDIT_GOLD			21
#define MEDIT_POS			22
#define MEDIT_DEFAULT_POS		23
#define MEDIT_ATTACK			24
#define MEDIT_LEVEL			25
#define MEDIT_ALIGNMENT			26
#define MEDIT_ATTACK1                   27
#define MEDIT_ATTACK2                   28
#define MEDIT_ATTACK3                   29
#if defined(OASIS_MPROG)
#define MEDIT_MPROG                     30
#define MEDIT_CHANGE_MPROG              31
#define MEDIT_MPROG_COMLIST             32
#define MEDIT_MPROG_ARGS                33
#define MEDIT_MPROG_TYPE                34
#define MEDIT_PURGE_MPROG               35
#endif
#define MEDIT_REMORT                    36
#define MEDIT_CLASS                     37
#define MEDIT_RACE                      38

/*
 * Submodes of SEDIT connectedness.
 */
#define SEDIT_MAIN_MENU              	0
#define SEDIT_CONFIRM_SAVESTRING	1
#define SEDIT_NOITEM1			2
#define SEDIT_NOITEM2			3
#define SEDIT_NOCASH1			4
#define SEDIT_NOCASH2			5
#define SEDIT_NOBUY			6
#define SEDIT_BUY			7
#define SEDIT_SELL			8
#define SEDIT_PRODUCTS_MENU		11
#define SEDIT_ROOMS_MENU		12
#define SEDIT_NAMELIST_MENU		13
#define SEDIT_NAMELIST			14
/*
 * Numerical responses.
 */
#define SEDIT_NUMERICAL_RESPONSE	20
#define SEDIT_OPEN1			21
#define SEDIT_OPEN2			22
#define SEDIT_CLOSE1			23
#define SEDIT_CLOSE2			24
#define SEDIT_KEEPER			25
#define SEDIT_BUY_PROFIT		26
#define SEDIT_SELL_PROFIT		27
#define SEDIT_TYPE_MENU			29
#define SEDIT_DELETE_TYPE		30
#define SEDIT_DELETE_PRODUCT		31
#define SEDIT_NEW_PRODUCT		32
#define SEDIT_DELETE_ROOM		33
#define SEDIT_NEW_ROOM			34
#define SEDIT_SHOP_FLAGS		35
#define SEDIT_NOTRADE			36

/*
 * Limit information.
 */
#define MAX_ROOM_NAME	75
#define MAX_MOB_NAME	50
#define MAX_OBJ_NAME	50
#define MAX_QUEST_NAME	70
#define MAX_QUEST_INFO  1024
#define MAX_QUEST_ENDING 1024
#define MAX_ROOM_DESC	1024
#define MAX_EXIT_DESC	256
#define MAX_EXTRA_DESC  512
#define MAX_MOB_DESC	512
#define MAX_OBJ_DESC	512
#define MAX_HELP_KEYWORDS	75
#define MAX_HELP_ENTRY		8192

#define HEDIT_MAIN_MENU			0
#define HEDIT_ENTRY			1
#define HEDIT_MIN_LEVEL			2
#define HEDIT_KEYWORDS			3
#define HEDIT_CONFIRM_SAVESTRING 	4

/* #define HEDIT_LIST		1 */	/* define to log saves		*/

/* Submodes of AEDIT connectedness	*/
#define AEDIT_CONFIRM_SAVESTRING	0
#define AEDIT_CONFIRM_EDIT		1
#define AEDIT_CONFIRM_ADD		2
#define AEDIT_MAIN_MENU			3
#define AEDIT_ACTION_NAME		4
#define AEDIT_SORT_AS			5
#define AEDIT_MIN_CHAR_POS		6
#define AEDIT_MIN_VICT_POS		7
#define AEDIT_HIDDEN_FLAG		8
#define AEDIT_MIN_CHAR_LEVEL		9
#define AEDIT_NOVICT_CHAR		10
#define AEDIT_NOVICT_OTHERS		11
#define AEDIT_VICT_CHAR_FOUND		12
#define AEDIT_VICT_OTHERS_FOUND		13
#define AEDIT_VICT_VICT_FOUND		14
#define AEDIT_VICT_NOT_FOUND		15
#define AEDIT_SELF_CHAR			16
#define AEDIT_SELF_OTHERS		17
#define AEDIT_VICT_CHAR_BODY_FOUND     	18
#define AEDIT_VICT_OTHERS_BODY_FOUND   	19
#define AEDIT_VICT_VICT_BODY_FOUND     	20
#define AEDIT_OBJ_CHAR_FOUND		21
#define AEDIT_OBJ_OTHERS_FOUND		22

/*. Quest editor . */
#define QEDIT_MAIN_MENU                 0
#define QEDIT_CONFIRM_SAVESTRING        1
#define QEDIT_NAME                      2
#define QEDIT_DESC                      3
#define QEDIT_INFO			4
#define QEDIT_ENDING			5
#define QEDIT_QUESTMASTER               6
#define QEDIT_TYPE                      7
#define QEDIT_FLAGS                     8
#define QEDIT_TARGET                    9
#define QEDIT_REWARD_TYPE               10
#define QEDIT_REWARD                    11
#define QEDIT_NEXT			12
#define QEDIT_VALUE_0			13
#define QEDIT_VALUE_1			14
#define QEDIT_VALUE_2			15
#define QEDIT_VALUE_3			16
#define QEDIT_MIN_LEVEL			17
#define QEDIT_MAX_LEVEL			18
::::::::::::::
pfdefaults.h
::::::::::::::
#ifndef _PFDEFAULTS_H_
#define _PFDEFAULTS_H_

/*
  ascii pfile variable defaults

  WARNING:  Do not change the values below if you've got existing ascii
  player files you don't want to screw up.  See the documentation
  included in the ascii pfiles distribution for more information.
*/

#define PFDEF_SEX		0
#define PFDEF_CLASS		0
#define PFDEF_LEVEL		0
#define PFDEF_HOMETOWN		0
#define PFDEF_HEIGHT		0
#define PFDEF_WEIGHT		0
#define PFDEF_ALIGNMENT		0
#define PFDEF_PLRFLAGS		0
#define PFDEF_AFFFLAGS		0
#define PFDEF_SAVETHROW		0
#define PFDEF_LOADROOM		0
#define PFDEF_INVISLEV		0
#define PFDEF_FREEZELEV		0
#define PFDEF_WIMPLEV		0
#define PFDEF_CONDITION		0
#define PFDEF_BADPWS		0
#define PFDEF_PREFFLAGS		0
#define PFDEF_PRACTICES		0
#define PFDEF_GOLD		0
#define PFDEF_BANK		0
#define PFDEF_EXP		0
#define PFDEF_HITROLL		0
#define PFDEF_DAMROLL		0
#define PFDEF_AC		0
#define PFDEF_STR		0
#define PFDEF_STRADD		0
#define PFDEF_DEX		0
#define PFDEF_INT		0
#define PFDEF_WIS		0
#define PFDEF_CON		0
#define PFDEF_CHA		0
#define PFDEF_HIT		0
#define PFDEF_MAXHIT		0
#define PFDEF_MANA		0
#define PFDEF_MAXMANA		0
#define PFDEF_MOVE		0
#define PFDEF_MAXMOVE		0
#define PFDEF_HUNGER		0
#define PFDEF_THIRST		0
#define PFDEF_DRUNK		0
#define PFDEF_WD		0

#endif
::::::::::::::
quest.h
::::::::::::::
/*****************************************************************/
/*                      World of GreyHawk                        */
/*      Begun in 1998, originally based on Circle3.0 and others  */
/* File:                                                         */
/* Purpose:                                                      */
/*****************************************************************/

/* Aquest related defines ********************************************* */

#define AQ_UNDEFINED	-1	/* (R) Quest unavailable  */
#define AQ_OBJECT	 0	/* Player must retreive object  */
#define AQ_ROOM		 1	/* Player must reach room */
#define AQ_MOB_FIND	 2	/* Player must find mob           */
#define AQ_MOB_KILL	 3	/* Player must kill mob           */
#define AQ_MOB_SAVE	 4	/* Player must save mob           */
#define AQ_RETURN_OBJ	 5	/* Player gives object to val0  */

#define NUM_AQ_TYPES	 6

#define REWARD_EXP	 0
#define REWARD_OBJ	 1
#define REWARD_GOLD	 2
#define REWARD_QP	 3

#define NUM_REWARD_TYPES 4

/* AQ Flags (much room for expansion) ********************************* */
#define AQ_REPEATABLE	(1 << 0)	/* Quest can be repeated =(       */

#define NUM_AQ_FLAGS	1

/* Main quest struct */
struct aq_data {
  int virtual;			/* Virtual nr of the quest              */
  int mob_vnum;			/* Vnum of the questmaster offering     */
  char *short_desc;		/* For qlist and the sort               */
  char *desc;			/* Description of the quest             */
  char *info;			/* Long help for quest                  */
  char *ending;			/* Ending displayed                     */
  long flags;			/* Flags (repeatable, etc               */
  int type;			/* Quest type                           */
  int target;			/* Target value                         */
  int reward_type;		/* Is the reward a treasure, gold, exp? */
  int reward;			/* vnum, gold, exp			*/
  int value[4];			/* Expansion values                     */
  sh_int next_quest;		/* Link to next quest, -1 is end        */
  int complete;
  sh_int min_level;
  sh_int max_level;
  int id;
};

void list_quests(struct char_data *ch, int questmaster);
void generic_complete_quest(struct char_data *ch);
void autoquest_trigger_check(struct char_data *ch, struct char_data *vict,
			     struct obj_data *object, int type);
int real_quest(int vnum);
int is_complete(int vnum);
int find_quest_by_qmnum(int qm, int num);
void add_completed_quest(struct char_data * ch, int num);
SPECIAL(questmaster);
::::::::::::::
screen.h
::::::::::::::
/* ************************************************************************
*   File: screen.h                                      Part of CircleMUD *
*  Usage: header file with ANSI color codes for online color              *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define KNRM  "\x1B[0;0m"

#define KBLK  "\x1B[0;30m"
#define KRED  "\x1B[0;31m"
#define KGRN  "\x1B[0;32m"
#define KYEL  "\x1B[0;33m"
#define KBLU  "\x1B[0;34m"
#define KMAG  "\x1B[0;35m"
#define KCYN  "\x1B[0;36m"
#define KWHT  "\x1B[0;37m"

#define KBBLK  "\x1B[1;30m"
#define KBRED  "\x1B[1;31m"
#define KBGRN  "\x1B[1;32m"
#define KBYEL  "\x1B[1;33m"
#define KBBLU  "\x1B[1;34m"
#define KBMAG  "\x1B[1;35m"
#define KBCYN  "\x1B[1;36m"
#define KBWHT  "\x1B[1;37m"

#define KUND  "\033[4m"
#define KCLR  "\033[2J"
#define KDAR  "\033[2m"
#define FLASH  "\x1B[5m"


#define KNUL  ""

// conditional color.  pass it a pointer to a char_data and a color level. 
#define C_OFF   0
#define C_SPR   1
#define C_NRM   2
#define C_CMP   3
#define _clrlevel(ch) (!IS_NPC(ch) ? (PRF_FLAGGED((ch), PRF_COLOR_1) ? 1 : 0) + \
                       (PRF_FLAGGED((ch), PRF_COLOR_2) ? 2 : 0) : 0)
#define clr(ch,lvl) (_clrlevel(ch) >= (lvl))
#define CCNRM(ch,lvl)  (clr((ch),(lvl))?KNRM:KNUL)
//cor fraca	
#define CCBLK(ch,lvl)  (clr((ch),(lvl))?KBLK:KNUL)
#define CCRED(ch,lvl)  (clr((ch),(lvl))?KRED:KNUL)
#define CCGRN(ch,lvl)  (clr((ch),(lvl))?KGRN:KNUL)
#define CCYEL(ch,lvl)  (clr((ch),(lvl))?KYEL:KNUL)
#define CCBLU(ch,lvl)  (clr((ch),(lvl))?KBLU:KNUL)
#define CCMAG(ch,lvl)  (clr((ch),(lvl))?KMAG:KNUL)
#define CCCYN(ch,lvl)  (clr((ch),(lvl))?KCYN:KNUL)
#define CCWHT(ch,lvl)  (clr((ch),(lvl))?KWHT:KNUL)
#define CCUND(ch,lvl)  (clr((ch),(lvl))?KUND:KNUL)
#define CCCLR(ch,lvl)  (clr((ch),(lvl))?KCLR:KNUL)
#define CCDAR(ch,lvl)  (clr((ch),(lvl))?KDAR:KNUL)
#define CFLASH(ch,lvl)  (clr((ch),(lvl))?FLASH:KNUL)

//cor forte
#define CCBBLK(ch,lvl)  (clr((ch),(lvl))?KBBLK:KNUL)
#define CCBRED(ch,lvl)  (clr((ch),(lvl))?KBRED:KNUL)
#define CCBGRN(ch,lvl)  (clr((ch),(lvl))?KBGRN:KNUL)
#define CCBYEL(ch,lvl)  (clr((ch),(lvl))?KBYEL:KNUL)
#define CCBBLU(ch,lvl)  (clr((ch),(lvl))?KBBLU:KNUL)
#define CCBMAG(ch,lvl)  (clr((ch),(lvl))?KBMAG:KNUL)
#define CCBCYN(ch,lvl)  (clr((ch),(lvl))?KBCYN:KNUL)
#define CCBWHT(ch,lvl)  (clr((ch),(lvl))?KBWHT:KNUL)




#define COLOR_LEV(ch) (_clrlevel(ch))

//cores fracas
#define QNRM CCNRM(ch,C_SPR)
#define QRED CCRED(ch,C_SPR)
#define QGRN CCGRN(ch,C_SPR)
#define QYEL CCYEL(ch,C_SPR)
#define QBLU CCBLU(ch,C_SPR)
#define QMAG CCMAG(ch,C_SPR)
#define QCYN CCCYN(ch,C_SPR)
#define QWHT CCWHT(ch,C_SPR)
#define QUND CCUND(ch,C_SPR)//underline
#define QDAR CCDAR(ch,C_SPR)


//cores fortes
#define QQRED CCBRED(ch,C_SPR)
#define QQGRN CCBGRN(ch,C_SPR)
#define QQYEL CCBYEL(ch,C_SPR)
#define QQBLU CCBBLU(ch,C_SPR)
#define QQMAG CCBMAG(ch,C_SPR)
#define QQCYN CCBCYN(ch,C_SPR)
#define QQWHT CCBWHT(ch,C_SPR)
#define QCLR CCBLN(ch,C_SPR)

//cores background
#define QBBLK CCBBLK(ch,C_SPR)
#define QBRED CCBRED(ch,C_SPR)
#define QBGRN CCBGRN(ch,C_SPR)
#define QBYEL CCBYEL(ch,C_SPR)
#define QBBLU CCBBLU(ch,C_SPR)
#define QBMAG CCBMAG(ch,C_SPR)
#define QBCYN CCBCYN(ch,C_SPR)
#define QBWHT CCBWHT(ch,C_SPR)

#define QFBLK CCFBLK(ch,C_SPR)
#define QFRED CCFRED(ch,C_SPR)
#define QFGRN CCFGRN(ch,C_SPR)
#define QFYEL CCFYEL(ch,C_SPR)
#define QFBLU CCFBLU(ch,C_SPR)
#define QFMAG CCFMAG(ch,C_SPR)
#define QFCYN CCFCYN(ch,C_SPR)
#define QFWHT CCFWHT(ch,C_SPR)

#define MAX_CORES		21 // maximo de cores nos codigos &

extern char *letra_cor[];
extern const char *codigo_cor[];
extern int conta_cores(const char *texto);
/*
#define KNRM  "\033[0m"
#define KRED  "\033[31m"
#define KGRN  "\033[32m"
#define KYEL  "\033[33m"
#define KBLU  "\033[34m"
#define KMAG  "\033[35m"
#define KCYN  "\033[36m"
#define KWHT  "\033[37m"
#define KBLK  "\033[30m"
#define KBLD  "\033[1m"
#define KBLN  "\033[5m"
#define KNUL  ""
#define KCLR  "\033[2J"
#define KUND  "\033[4m"
#define KDAR  "\033[2m"

#define KBRED  "\033[41m"
#define KBGRN  "\033[42m"
#define KBYEL  "\033[43m"
#define KBBLU  "\033[44m"
#define KBMAG  "\033[45m"
#define KBCYN  "\033[46m"
#define KBWHT  "\033[47m"
#define KBBLK  "\033[40m"

 conditional color.  pass it a pointer to a char_data and a color level. 
#define C_OFF   0
#define C_SPR   1
#define C_NRM   2
#define C_CMP   3
#define _clrlevel(ch) ((PRF_FLAGGED((ch), PRF_COLOR_1) ? 1 : 0) + \
                       (PRF_FLAGGED((ch), PRF_COLOR_2) ? 2 : 0))
#define clr(ch,lvl) (_clrlevel(ch) >= (lvl))
#define CCNRM(ch,lvl)  (clr((ch),(lvl))?KNRM:KNUL)
#define CCBLK(ch,lvl)  (clr((ch),(lvl))?KBLK:KNUL)
#define CCRED(ch,lvl)  (clr((ch),(lvl))?KRED:KNUL)
#define CCGRN(ch,lvl)  (clr((ch),(lvl))?KGRN:KNUL)
#define CCYEL(ch,lvl)  (clr((ch),(lvl))?KYEL:KNUL)
#define CCBLU(ch,lvl)  (clr((ch),(lvl))?KBLU:KNUL)
#define CCMAG(ch,lvl)  (clr((ch),(lvl))?KMAG:KNUL)
#define CCCYN(ch,lvl)  (clr((ch),(lvl))?KCYN:KNUL)
#define CCWHT(ch,lvl)  (clr((ch),(lvl))?KWHT:KNUL)
#define CCBLD(ch,lvl)  (clr((ch),(lvl))?KBLD:KNUL)
#define CCBLN(ch,lvl)  (clr((ch),(lvl))?KBLN:KNUL)
#define CCCLR(ch,lvl)  (clr((ch),(lvl))?KCLR:KNUL)
#define CCUND(ch,lvl)  (clr((ch),(lvl))?KUND:KNUL)
#define CCDAR(ch,lvl)  (clr((ch),(lvl))?KDAR:KNUL)

#define CCBBLK(ch,lvl)  (clr((ch),(lvl))?KBBLK:KNUL)
#define CCBRED(ch,lvl)  (clr((ch),(lvl))?KBRED:KNUL)
#define CCBGRN(ch,lvl)  (clr((ch),(lvl))?KBGRN:KNUL)
#define CCBYEL(ch,lvl)  (clr((ch),(lvl))?KBYEL:KNUL)
#define CCBBLU(ch,lvl)  (clr((ch),(lvl))?KBBLU:KNUL)
#define CCBMAG(ch,lvl)  (clr((ch),(lvl))?KBMAG:KNUL)
#define CCBCYN(ch,lvl)  (clr((ch),(lvl))?KBCYN:KNUL)
#define CCBWHT(ch,lvl)  (clr((ch),(lvl))?KBWHT:KNUL)

#define COLOR_LEV(ch) (_clrlevel(ch))

#define QNRM CCNRM(ch,C_SPR)
#define QBLK CCBLK(ch,C_SPR)
#define QRED CCRED(ch,C_SPR)
#define QGRN CCGRN(ch,C_SPR)
#define QYEL CCYEL(ch,C_SPR)
#define QBLU CCBLU(ch,C_SPR)
#define QMAG CCMAG(ch,C_SPR)
#define QCYN CCCYN(ch,C_SPR)
#define QWHT CCWHT(ch,C_SPR)
#define QBLD CCBLD(ch,C_SPR)
#define QBLN CCBLN(ch,C_SPR)
#define QCLR CCBLN(ch,C_SPR)
#define QUND CCUND(ch,C_SPR)
#define QDAR CCDAR(ch,C_SPR)
#define QBBLK CCBBLK(ch,C_SPR)
#define QBRED CCBRED(ch,C_SPR)
#define QBGRN CCBGRN(ch,C_SPR)
#define QBYEL CCBYEL(ch,C_SPR)
#define QBBLU CCBBLU(ch,C_SPR)
#define QBMAG CCBMAG(ch,C_SPR)
#define QBCYN CCBCYN(ch,C_SPR)
#define QBWHT CCBWHT(ch,C_SPR)

 
How to use it:

Wherever whenever you feel like adding some color (for those who have
colorlevel >= NORMAL) you just do something like this:

&1Red&0 &4Blue&0 and so on.. Works in room_descs, gossips, tells, you name it.

Here's a list of the color-codes:

0 Normal attributes
1 red
2 green
3 yellow
4 blue
5 magenta
6 cyan
7 white
8 bold
9 black

u underline
d dark
b bright
R red bground
G green brgound
B Blue bground
Y yellow brgound
M magenta bground
C Cyan bground
W white bground
S black bground (S as in Svart (swedish))
& the character &

Anything other than these characters, will produce nothing.
*/
::::::::::::::
shop.h
::::::::::::::
/* ************************************************************************
*   File: shop.h                                        Part of CircleMUD *
*  Usage: shop file definitions, structures, constants                    *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */


struct shop_buy_data {
   int type;
   char *keywords;
} ;

#define BUY_TYPE(i)             ((i).type)
#define BUY_WORD(i)             ((i).keywords)


struct shop_data {
   int   vnum;                  /* Virtual number of this shop          */
   int  *producing;             /* Which item to produce (virtual)      */
   float profit_buy;            /* Factor to multiply cost with         */
   float profit_sell;           /* Factor to multiply cost with         */
   struct shop_buy_data *type;  /* Which items to trade                 */
   char *no_such_item1;         /* Message if keeper hasn't got an item */
   char *no_such_item2;         /* Message if player hasn't got an item */
   char *missing_cash1;         /* Message if keeper hasn't got cash    */
   char *missing_cash2;         /* Message if player hasn't got cash    */
   char *do_not_buy;            /* If keeper dosn't buy such things     */
   char *message_buy;           /* Message when player buys item        */
   char *message_sell;          /* Message when player sells item       */
   int   temper1;               /* How does keeper react if no money    */
   int   bitvector;             /* Can attack? Use bank? Cast here?     */
   int   keeper;                /* The mobil who owns the shop (virtual)*/
   int   with_who;              /* Who does the shop trade with?        */
   int  *in_room;               /* Where is the shop?                   */
   int   open1, open2;          /* When does the shop open?             */
   int   close1, close2;        /* When does the shop close?            */
   int   bankAccount;           /* Store all gold over 15000 (disabled) */
   int   lastsort;              /* How many items are sorted in inven?  */
   SPECIAL (*func);             /* Secondary spec_proc for shopkeeper   */
};


#define MAX_TRADE       5       /* List maximums for compatibility      */
#define MAX_PROD        5       /*      with shops before v3.0          */
#define VERSION3_TAG    "v3.0"  /* The file has v3.0 shops in it!       */
#define MAX_SHOP_OBJ    100     /* "Soft" maximum for list maximums     */


/* Pretty general macros that could be used elsewhere */
#define IS_GOD(ch)              (!IS_NPC(ch) && (GET_LEVEL(ch) >= LVL_GOD))
#define GET_OBJ_NUM(obj)        (obj->item_number)
#define END_OF(buffer)          ((buffer) + strlen((buffer)))


/* Possible states for objects trying to be sold */
#define OBJECT_DEAD             0
#define OBJECT_NOTOK            1
#define OBJECT_OK               2
#define OBJECT_NOVAL            3


/* Types of lists to read */
#define LIST_PRODUCE            0
#define LIST_TRADE              1
#define LIST_ROOM               2


/* Whom will we not trade with (bitvector for SHOP_TRADE_WITH()) */
#define TRADE_NOGOOD            1
#define TRADE_NOEVIL            2
#define TRADE_NONEUTRAL         4
#define TRADE_NOMAGIC_USER      8
#define TRADE_NOCLERIC          16
#define TRADE_NOTHIEF           32
#define TRADE_NOWARRIOR         64


struct stack_data {
   int data[100];
   int len;
} ;

#define S_DATA(stack, index)    ((stack)->data[(index)])
#define S_LEN(stack)            ((stack)->len)


/* Which expression type we are now parsing */
#define OPER_OPEN_PAREN         0
#define OPER_CLOSE_PAREN        1
#define OPER_OR                 2
#define OPER_AND                3
#define OPER_NOT                4
#define MAX_OPER                4


#define SHOP_NUM(i)             (shop_index[(i)].vnum)
#define SHOP_KEEPER(i)          (shop_index[(i)].keeper)
#define SHOP_OPEN1(i)           (shop_index[(i)].open1)
#define SHOP_CLOSE1(i)          (shop_index[(i)].close1)
#define SHOP_OPEN2(i)           (shop_index[(i)].open2)
#define SHOP_CLOSE2(i)          (shop_index[(i)].close2)
#define SHOP_ROOM(i, num)       (shop_index[(i)].in_room[(num)])
#define SHOP_BUYTYPE(i, num)    (BUY_TYPE(shop_index[(i)].type[(num)]))
#define SHOP_BUYWORD(i, num)    (BUY_WORD(shop_index[(i)].type[(num)]))
#define SHOP_PRODUCT(i, num)    (shop_index[(i)].producing[(num)])
#define SHOP_BANK(i)            (shop_index[(i)].bankAccount)
#define SHOP_BROKE_TEMPER(i)    (shop_index[(i)].temper1)
#define SHOP_BITVECTOR(i)       (shop_index[(i)].bitvector)
#define SHOP_TRADE_WITH(i)      (shop_index[(i)].with_who)
#define SHOP_SORT(i)            (shop_index[(i)].lastsort)
#define SHOP_BUYPROFIT(i)       (shop_index[(i)].profit_buy)
#define SHOP_SELLPROFIT(i)      (shop_index[(i)].profit_sell)
#define SHOP_FUNC(i)            (shop_index[(i)].func)

#define NOTRADE_GOOD(i)         (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NOGOOD))
#define NOTRADE_EVIL(i)         (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NOEVIL))
#define NOTRADE_NEUTRAL(i)      (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NONEUTRAL))
#define NOTRADE_MAGIC_USER(i)   (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NOMAGIC_USER))
#define NOTRADE_CLERIC(i)       (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NOCLERIC))
#define NOTRADE_THIEF(i)        (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NOTHIEF))
#define NOTRADE_WARRIOR(i)      (IS_SET(SHOP_TRADE_WITH((i)), TRADE_NOWARRIOR))



#define WILL_START_FIGHT        1
#define WILL_BANK_MONEY         2

#define SHOP_KILL_CHARS(i)      (IS_SET(SHOP_BITVECTOR(i), WILL_START_FIGHT))
#define SHOP_USES_BANK(i)       (IS_SET(SHOP_BITVECTOR(i), WILL_BANK_MONEY))


#define MIN_OUTSIDE_BANK        5000
#define MAX_OUTSIDE_BANK        15000

#define MSG_NOT_OPEN_YET        "Come back later!"
#define MSG_NOT_REOPEN_YET      "Sorry, we have closed, but come back later."
#define MSG_CLOSED_FOR_DAY      "Sorry, come back tomorrow."
#define MSG_NO_STEAL_HERE       "$n is a bloody thief!"
#define MSG_NO_SEE_CHAR         "I don't trade with someone I can't see!"
#define MSG_NO_SELL_ALIGN       "Get out of here before I call the guards!"
#define MSG_NO_SELL_CLASS       "We don't serve your kind here!"
#define MSG_NO_USED_WANDSTAFF   "I don't buy used up wands or staves!"
#define MSG_CANT_KILL_KEEPER    "Get out of here before I call the guards!"
::::::::::::::
spells.h
::::::::::::::
/* ************************************************************************
*   File: spells.h                                      Part of CircleMUD *
*  Usage: header file: constants and fn prototypes for spell system       *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

#define DEFAULT_STAFF_LVL       12
#define DEFAULT_WAND_LVL        12

#define CAST_UNDEFINED  -1
#define CAST_SPELL      0
#define CAST_POTION     1
#define CAST_WAND       2
#define CAST_STAFF      3
#define CAST_SCROLL     4

#define MAG_DAMAGE      (1 << 0)
#define MAG_AFFECTS     (1 << 1)
#define MAG_UNAFFECTS   (1 << 2)
#define MAG_POINTS      (1 << 3)
#define MAG_ALTER_OBJS  (1 << 4)
#define MAG_GROUPS      (1 << 5)
#define MAG_MASSES      (1 << 6)
#define MAG_AREAS       (1 << 7)
#define MAG_SUMMONS     (1 << 8)
#define MAG_CREATIONS   (1 << 9)
#define MAG_MANUAL      (1 << 10)
#define MAG_ROOM        (1 << 11)

#define TYPE_UNDEFINED               -1
#define SPELL_RESERVED_DBC            0  /* SKILL NUMBER ZERO -- RESERVED */

/* PLAYER SPELLS -- Numbered from 1 to MAX_SPELLS */

#define SPELL_ARMOR                   1 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_TELEPORT                2 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_BLESS                   3 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_BLINDNESS               4 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_BURNING_HANDS           5 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CALL_LIGHTNING          6 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CHARM                   7 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CHILL_TOUCH             8 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CLONE                   9 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_COLOR_SPRAY            10 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CONTROL_WEATHER        11 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CREATE_FOOD            12 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CREATE_WATER           13 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CURE_BLIND             14 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CURE_CRITIC            15 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CURE_LIGHT             16 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_CURSE                  17 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DETECT_ALIGN           18 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DETECT_INVIS           19 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DETECT_MAGIC           20 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DETECT_POISON          21 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DISPEL_EVIL            22 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_EARTHQUAKE             23 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_ENCHANT_WEAPON         24 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_ENERGY_DRAIN           25 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_FIREBALL               26 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_HARM                   27 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_HEAL                   28 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_INVISIBLE              29 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_LIGHTNING_BOLT         30 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_LOCATE_OBJECT          31 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_MAGIC_MISSILE          32 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_POISON                 33 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_PROT_FROM_EVIL         34 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_REMOVE_CURSE           35 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SANCTUARY              36 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SHOCKING_GRASP         37 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SLEEP                  38 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_STRENGTH               39 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SUMMON                 40 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_VENTRILOQUATE          41 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_WORD_OF_RECALL         42 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_REMOVE_POISON          43 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SENSE_LIFE             44 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_ANIMATE_DEAD           45 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DISPEL_GOOD            46 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_GROUP_ARMOR            47 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_GROUP_HEAL             48 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_GROUP_RECALL           49 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_INFRAVISION            50 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_WATERWALK              51 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_MANA_SHIELD            52 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_DAMNED_CURSE           53 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_REFRESH                54 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_HASTE                  55 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_REGENERATION           56 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_PETRIFY		     57 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_GOD_PACT		     58 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SATAN_PACT	     59 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_END_WORLD		     60 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_MENTAL_RAGE	     61 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_SATANIC_CURE	     62 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_FLY		     63 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_VULCAN		     64 /* Reserved Skill[] DO NOT CHANGE */
#define SPELL_ENTANGLE               65
#define SPELL_FIRESHIELD             66
#define SPELL_ADRENALINE             67
#define SPELL_ICESTORM               68
#define SPELL_METEORSTORM            69
#define SPELL_FIRESTORM              70
#define SPELL_FORCE_SHIELD           71
#define SPELL_ENHANCED_ARMOR         72
#define SPELL_REVITALIZE             73
#define SPELL_GOLEM                  74
#define SPELL_ILLUSION               75
#define SPELL_WALL_OF_FOG            76
#define SPELL_FIREWALL		     77
#define SPELL_ICEWALL		     78
#define SPELL_MANA_SWORD	     79
#define SPELL_POISON_WEAPON	     80
#define SPELL_FIREBOLT		     81
#define SPELL_ICEBOLT		     82
#define SPELL_FARSIGHT		     83
#define SPELL_ELEMENTAL		     84
/* Last New Spells */ //TAEROM
#define SPELL_GREASE		     85
#define SPELL_CROMATIC_ORB	     86		
#define SPELL_FLAMEARROW	     87
#define SPELL_SLOW		     88
#define SPELL_ELETRICSTORM           89
#define SPELL_IRON_SKIN              90
#define SPELL_PLATINUM_SKIN          91
#define SPELL_DIAMOND_SKIN           92
#define SPELL_ACIDARROW		     93
#define SPELL_MINUTE_METEOR          94
#define SPELL_GLACIAL_CONE           95
#define SPELL_AREA_LIGHTNING         96
#define SPELL_FIRE_SPIT              97
#define SPELL_GAS_SPIT               98
#define SPELL_FROST_SPIT             99
#define SPELL_ACID_SPIT             100
#define SPELL_LIGHTNING_SPIT        101
#define SPELL_BLADEBARRIER          102
#define SPELL_PRISMATIC_SPHERE      103
#define SPELL_ARMAGEDDOM	    104
#define SPELL_DELAYED_FIREBALL      105
#define SPELL_FRIENDS		    106
//20/10/2001
#define SPELL_DUMBNESS              107 //sorcerer
#define SPELL_PHANTOM_ARMOR         108 //necromancer
#define SPELL_SPECTRAL_WINGS        109 //psci e necro
#define SPELL_HOLY_FURY             110 //paladino
#define SPELL_CHAMPION_STRENGTH     111 //paladino
#define SPELL_HOLY_MACE             112 //paladino
#define SPELL_DEATH_SCYTHE          113 //necro
#define SPELL_SIMULACRUM            114 
#define SPELL_TERROR                115
#define SPELL_DEATH_FINGER          116
#define SPELL_ENGULFING_DARKNESS    117
#define SPELL_BANSHEE_AURA          118
#define SPELL_SIPHON_LIFE           119
//27/10/2001
#define SPELL_BLINK		    120
#define SPELL_METEOR_SHOWER	    121
#define SPELL_HOLY_WORD	            122
#define SPELL_HOLY_SHOUT            123
#define SPELL_DEATHDANCE            124
#define SPELL_DEATH_RIPPLE	    125
#define SPELL_DEATH_WAVE            126
#define SPELL_PEACE		    127
#define SPELL_PROT_FIRE             128
#define SPELL_GROUP_FLY             129
#define SPELL_WRAITHFORM            130
#define SPELL_FEAR		    131
/* KELEMVOR and KARL 16/11/01 */
#define SPELL_MINOR_GLOBE           132 
#define SPELL_MAJOR_GLOBE           133  
#define SPELL_PHANTOM_FLAME         134 
#define SPELL_SACRIFICE             135 
#define SPELL_SKULL_TRAP            136 
#define SPELL_GHASTLY_TOUCH         137 
#define SPELL_VAMPIRIC_TOUCH        138 
#define SPELL_PESTILENCE            139 
#define SPELL_ANTIMAGIC_SHELL       140 
#define SPELL_HOLY_BOLT             141 
#define SPELL_DISPEL_NEUTRAL        142 
#define SPELL_SHILLELAGH            143 
#define SPELL_MAGICAL_STONE         144 
#define SPELL_COMMAND               145 
#define SPELL_HOLD_PERSON           146 
#define SPELL_VOLCANO               147 
#define SPELL_GEYSER                148 
#define SPELL_GROUP_BLESS           149 
#define SPELL_CORPOR_TREMBLING      150 
#define SPELL_ICE_HEART             151 
#define SPELL_POLTEIRGEIST          152 
#define SPELL_BLIZZARD              153 
#define SPELL_CREATE_LIGHT          154 
#define SPELL_CLAIRVOYANCE          155 
#define SPELL_CREATE_FLAMES         156 
#define SPELL_CLAIRAUDIENCE         157 
#define SPELL_WINGED_KNIFE          158 
#define SPELL_ENHANCED_STRENGTH     159 
#define SPELL_EGO_WHIP              160 
#define SPELL_PROJECT_FORCE         161 
#define SPELL_WRENCH                162 
#define SPELL_FEEL_LIGHT            163 
#define SPELL_BALISTIC_ATTACK       164 
#define SPELL_SUP_INVISIBLE         165 
#define SPELL_DETONATE              166 
#define SPELL_AVERSION              167 
#define SPELL_PSYCHIC_RAY           168 
#define SPELL_MOLEC_AGITATION       169 
#define SPELL_EMPATHY               170 
#define SPELL_THOUGHT_SHIELD        171 
#define SPELL_BIOFEEDBACK           172 
#define SPELL_MENTAL_BARRIER        173 
#define SPELL_INERTIAL_BARRIER      174 
#define SPELL_CELL_ADJUSTMENT       175 
#define SPELL_CONCENTRATION         176 
#define SPELL_CONVICTION            177 
#define SPELL_HOLY_SHIELD           178 
#define SPELL_LAY_ON_HANDS          179
#define SPELL_CURE_SERIOUS          180
#define SPELL_REMOVE_FEAR           181  /* Falta Fazer */
#define SPELL_FLESH_ARMOR           182 
#define SPELL_CONFUSION             183 
#define SPELL_BRAVERY               184 
#define SPELL_RIGID_THINKING        185 /* Falta Fazer --> Igual Charm */
#define SPELL_PARADI_CHRYSALIS      186 
#define SPELL_ABUTILON              187 
#define SPELL_AURA_SIGHT            188 
#define SPELL_PAIN                  189 
#define SPELL_DISPLACEMENT          190 
#define SPELL_INTEL_FORTRESS        191 
#define SPELL_LIFE_DRAINING         192 
#define SPELL_BODY_WEAPONRY         193 
#define SPELL_BODY_EQUILIBRIUM      194 
#define SPELL_ADREN_CONTROL         195 
#define SPELL_LEND_HEALTH           196 
#define SPELL_COMBAT_MIND           197 
#define SPELL_PSIONIC_BLAST         198 
#define SPELL_PSYCHIC_DRAIN         199 
#define SPELL_MARTIAL_TRANCE        200 
#define SPELL_POST_HYPNOT_SUGG      201 /* Falta Fazer --> Igual Charm */
#define SPELL_ASTRAL_PROJECTION     202 /* Falta Fazer --> Igual Clone */
#define SPELL_ULTIMA                203
#define SPELL_SUMMON_BAHAMUT        204
#define SPELL_BARKSKIN              205 
#define SPELL_CALL_BEAR             206
#define SPELL_MUIR                  207 // religiao  
#define SPELL_ILMANATEUR            208 
#define SPELL_SELUNE                209 
#define SPELL_HELM                  210 
#define SPELL_TALOS                 211 
#define SPELL_OGHMA                 212 
#define SPELL_TEMPUS                213

/* Insert new spells here, up to MAX_SPELLS */
#define MAX_SPELLS                  300

/* PLAYER SKILLS - Numbered from MAX_SPELLS+1 to MAX_SKILLS */
#define SKILL_BACKSTAB              301 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_BASH                  302 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_HIDE                  303 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_KICK                  304 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_PICK_LOCK             305 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_STROKE                306 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_RESCUE                307 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SNEAK                 308 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_STEAL                 309 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_TRACK                 310 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_COMBO                 311 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SHIELD_BLOCK          312 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SWIM                  313
#define SKILL_VITALIZE_HEALTH       314
#define SKILL_VITALIZE_MANA         315
#define SKILL_SPY		    316
#define SKILL_CRITICAL_ATTACK       317
#define SKILL_SECOND_ATTACK         318 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_THIRD_ATTACK          319 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_FOURTH_ATTACK         320 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SCAN                  321 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SABRE                 322 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_HAND_DAMAGE           323 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_WHITE_GAS             324 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SUICIDE               325 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_CIRCLE_ARROUND        326 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_SECOND_STAB           327 /* Reserved Skill[] DO NOT CHANGE */
#define SKILL_PARRY                 328
#define SKILL_DODGE                 329
#define SKILL_TUMBLE                330
#define SKILL_HIT                   331
#define SKILL_STING                 332
#define SKILL_WHIP                  333
#define SKILL_SLASH                 334
#define SKILL_BITE                  335
#define SKILL_BLUDGEON              336
#define SKILL_CRUSH                 337
#define SKILL_POUND                 338
#define SKILL_CLAW                  339
#define SKILL_MAUL                  340
#define SKILL_THRASH                341
#define SKILL_PIERCE                342
#define SKILL_BLAST                 343
#define SKILL_PUNCH                 344
#define SKILL_STAB                  345
#define SKILL_DISARM                346
#define SKILL_BERZERK               347
#define SKILL_FIRST_AID             348
#define SKILL_HEADBASH              349
#define SKILL_ESCAPE                350
#define SKILL_DUAL_WIELD            351
#define SKILL_MEDITATE              352
#define SKILL_LEVITATE              353
#define SKILL_LISTEN                354
#define SKILL_AGILITY               355
#define SKILL_KAISER		    356
#define SKILL_WARSHOUT		    357
#define SKILL_KNOCKOUT              358
#define SKILL_THROW		    359
#define SKILL_GUT                   360
#define SKILL_DROWN		    361	
#define SKILL_CHOP                  362
#define SKILL_KICKFLIP              363
#define SKILL_WHIRLWIND             364
#define SKILL_BLOOD_RITUAL          365
#define SKILL_STYLE_PRO		    366
#define SKILL_SPRITE		    367
#define SKILL_WEREWOLF		    368
#define SKILL_SUCUBUS		    369
#define SKILL_BEHEMOTH		    370
#define SKILL_TYRAEL  		    371
#define SKILL_SLAYER		    372
#define SKILL_IMPROVED_BERZERK      373
#define SKILL_POWER_KICK           374 


//#define SKILL_SLANG                 373

//#define SKILL_BOW               145
//#define SKILL_SLING             146
//#define SKILL_CROSSBOW          147
//#define SKILL_SECOND_ATTACK	148 /* Second attack (DAK) */
//#define SKILL_THIRD_ATTACK	149 /* Third attack (DAK)  */
//#define SKILL_DISARM		150
//#define SKILL_SPRING            151 /* Ability to create springs */
//#define SKILL_FORAGE            152 /* Forage for food */
//#define SKILL_FISSION		153 /* Ability to turn object into energy */
//#define SKILL_EXAMINE		154 /* Ability of using examination unit */
//#define SKILL_HAND_TO_HAND	155 /* Hand 2 hand combat                */
//#define SKILL_UNARMED_COMBAT	156 /* Unarmed combat */
//#define SKILL_TRAP_AWARE	157 /* Trap aware */
//#define SKILL_PARRY		158 /* Can parry attacks */
//#define SKILL_RETREAT		159 /* The art of retreat */
//#define SKILL_PATHFINDING	160 /* The skill of pathfinding */

/* New skills may be added here up to MAX_SKILLS (500) */

/*
 *  NON-PLAYER AND OBJECT SPELLS AND SKILLS
 *  The practice levels for the spells and skills below are _not_ recorded
 *  in the playerfile; therefore, the intended use is for spells and skills
 *  associated with objects (such as SPELL_IDENTIFY used with scrolls of
 *  identify) or non-players (such as NPC-only spells).
 */

#define SPELL_IDENTIFY               501
#define SPELL_FIRE_BREATH            502
#define SPELL_GAS_BREATH             503
#define SPELL_FROST_BREATH           504
#define SPELL_ACID_BREATH            505
#define SPELL_LIGHTNING_BREATH       506
#define SPELL_RESTORE_MANA           507

#define TRUE_TOP_SPELL_DEFINE        507
#define TOP_SPELL_DEFINE             599
/* NEW NPC/OBJECT SPELLS can be inserted here up to 699 */


/* WEAPON ATTACK TYPES */

#define TYPE_HIT                     600
#define TYPE_STING                   601
#define TYPE_WHIP                    602
#define TYPE_SLASH                   603
#define TYPE_BITE                    604
#define TYPE_BLUDGEON                605
#define TYPE_CRUSH                   606
#define TYPE_POUND                   607
#define TYPE_CLAW                    608
#define TYPE_MAUL                    609
#define TYPE_THRASH                  610
#define TYPE_PIERCE                  611
#define TYPE_BLAST                   612
#define TYPE_PUNCH                   613
#define TYPE_STAB                    614

/* new attack types can be added here - up to TYPE_SUFFERING */
#define TYPE_SUFFERING               699



#define SAVING_PARA   0
#define SAVING_ROD    1
#define SAVING_PETRI  2
#define SAVING_BREATH 3
#define SAVING_SPELL  4


#define TAR_IGNORE        1
#define TAR_CHAR_ROOM     2
#define TAR_CHAR_WORLD    4
#define TAR_FIGHT_SELF    8
#define TAR_FIGHT_VICT   16
#define TAR_SELF_ONLY    32 /* Only a check, use with i.e. TAR_CHAR_ROOM */
#define TAR_NOT_SELF     64 /* Only a check, use with i.e. TAR_CHAR_ROOM */
#define TAR_OBJ_INV     128
#define TAR_OBJ_ROOM    256
#define TAR_OBJ_WORLD   512
#define TAR_OBJ_EQUIP  1024

struct spell_info_type {
   byte min_position;   /* Position for caster   */
   int mana_min;        /* Min amount of mana used by a spell (highest lev) */
   int mana_max;        /* Max amount of mana used by a spell (lowest lev) */
   int mana_change;     /* Change in mana used by spell from lev to lev */

   int min_level[NUM_CLASSES];
   int routines;
   byte violent;
   int targets;         /* See below for use with TAR_XXX  */
};

/* Possible Targets:

   bit 0 : IGNORE TARGET
   bit 1 : PC/NPC in room
   bit 2 : PC/NPC in world
   bit 3 : Object held
   bit 4 : Object in inventory
   bit 5 : Object in room
   bit 6 : Object in world
   bit 7 : If fighting, and no argument, select tar_char as self
   bit 8 : If fighting, and no argument, select tar_char as victim (fighting)
   bit 9 : If no argument, select self, if argument check that it IS self.

*/

#define SPELL_TYPE_SPELL   0
#define SPELL_TYPE_POTION  1
#define SPELL_TYPE_WAND    2
#define SPELL_TYPE_STAFF   3
#define SPELL_TYPE_SCROLL  4


/* Attacktypes with grammar */

struct attack_hit_type {
   const char   *singular;
   const char   *plural;
};


#define ASPELL(spellname) \
void    spellname(int level, struct char_data *ch, \
                  struct char_data *victim, struct obj_data *obj)

#define MANUAL_SPELL(spellname) spellname(level, caster, cvict, ovict);

ASPELL(spell_create_water);
ASPELL(spell_recall);
ASPELL(spell_teleport);
ASPELL(spell_summon);
ASPELL(spell_locate_object);
ASPELL(spell_charm);
ASPELL(spell_rigid_thinking);
ASPELL(spell_information);
ASPELL(spell_identify);
ASPELL(spell_enchant_weapon);
ASPELL(spell_detect_poison);
ASPELL(spell_farsight);
ASPELL(spell_control_weather);
ASPELL(spell_death_scythe);
ASPELL(spell_simulacrum);
ASPELL(spell_peace);
ASPELL(spell_mana_sword);
ASPELL(spell_fear);
ASPELL(spell_oghma) ; 

/* basic magic calling functions */

int find_skill_num(char *name);

int mag_damage(int level, struct char_data *ch, struct char_data *victim,
  int spellnum, int savetype);

void mag_affects(int level, struct char_data *ch, struct char_data *victim,
  int spellnum, int savetype);

void mag_groups(int level, struct char_data *ch, int spellnum, int savetype);

void mag_masses(int level, struct char_data *ch, int spellnum, int savetype);

void mag_areas(int level, struct char_data *ch, int spellnum, int savetype);

void mag_summons(int level, struct char_data *ch, struct obj_data *obj,
 int spellnum, int savetype);

void mag_points(int level, struct char_data *ch, struct char_data *victim,
 int spellnum, int savetype);

void mag_unaffects(int level, struct char_data *ch, struct char_data *victim,
  int spellnum, int type);

void mag_alter_objs(int level, struct char_data *ch, struct obj_data *obj,
  int spellnum, int type);

void mag_creations(int level, struct char_data *ch, int spellnum);

void mag_room(int level, struct char_data * ch, int spellnum);

int     call_magic(struct char_data *caster, struct char_data *cvict,
  struct obj_data *ovict, int spellnum, int level, int casttype);

void    mag_objectmagic(struct char_data *ch, struct obj_data *obj,
                        char *argument);

int     cast_spell(struct char_data *ch, struct char_data *tch,
  struct obj_data *tobj, int spellnum);


/* other prototypes */
void spell_level(int spell, int chclass, int level);
void init_spell_levels(void);
const char *skill_name(int num);
void improve_skill(struct char_data *ch, int skill);
::::::::::::::
structs.h
::::::::::::::
/* ************************************************************************
*   File: structs.h                                     Part of CircleMUD *
*  Usage: header file for central structures and contstants               *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/*#include "buffer_opt.h"*/		/* Catch-22 otherwise. */

/*
 * Intended use of this macro is to allow external packages to work with
 * a variety of CircleMUD versions without modifications.  For instance,
 * an IS_CORPSE() macro was introduced in pl13.  Any future code add-ons
 * could take into account the CircleMUD version and supply their own
 * definition for the macro if used on an older version of CircleMUD.
 * You are supposed to compare this with the macro CIRCLEMUD_VERSION()
 * in utils.h.  See there for usage.
 */
#define _CIRCLEMUD      0x03000D /* Major/Minor/Patchlevel - MMmmPP */

/*
 * If you want equipment to be automatically equipped to the same place
 * it was when players rented, set the define below to 1.  Please note
 * that this will require erasing or converting all of your rent files.
 * And of course, you have to recompile everything.  We need this feature
 * for CircleMUD 3.0 to be complete but we refuse to break binary file
 * compatibility.
 */
#define USE_AUTOEQ	1	/* TRUE/FALSE aren't defined yet. */

/* preamble *************************************************************/

#define NOWHERE    -1    /* nil reference for room-database     */
#define NOTHING    -1    /* nil reference for objects           */
#define NOBODY     -1    /* nil reference for mobiles           */

#define SPECIAL(name) \
   int (name)(struct char_data *ch, void *me, int cmd, char *argument)


/* house drop */
#define MAX_DROP_HOUSE		40

/* pk level */
#define PK_MIN_LEVEL		10

/* misc editor defines **************************************************/

/* format modes for format_text */
#define FORMAT_INDENT           (1 << 0)


/* room-related defines *************************************************/


/* The cardinal directions: used as index to room_data.dir_option[] */
#define NORTH          0
#define EAST           1
#define SOUTH          2
#define WEST           3
#define UP             4
#define DOWN           5


/* Room flags: used in room_data.room_flags */
/* WARNING: In the world files, NEVER set the bits marked "R" ("Reserved") */
#define ROOM_DARK               (1 << 0)   /* Dark                      */
#define ROOM_DEATH              (1 << 1)   /* Death trap                */
#define ROOM_NOMOB              (1 << 2)   /* MOBs not allowed          */
#define ROOM_INDOORS            (1 << 3)   /* Indoors                   */
#define ROOM_PEACEFUL           (1 << 4)   /* Violence not allowed      */
#define ROOM_SOUNDPROOF         (1 << 5)   /* Shouts, gossip blocked    */
#define ROOM_NOTRACK            (1 << 6)   /* Track won't go through    */
#define ROOM_NOMAGIC            (1 << 7)   /* Magic not allowed         */
#define ROOM_TUNNEL             (1 << 8)   /* room for only 1 pers      */
#define ROOM_PRIVATE            (1 << 9)   /* Can't teleport in         */
#define ROOM_GODROOM            (1 << 10)  /* LVL_GOD+ only allowed     */
#define ROOM_HOUSE              (1 << 11)  /* (R) Room is a house       */
#define ROOM_HOUSE_CRASH        (1 << 12)  /* (R) House needs saving    */
#define ROOM_ATRIUM             (1 << 13)  /* (R) The door to a house   */
#define ROOM_OLC                (1 << 14)  /* (R) Modifyable/!compress  */
#define ROOM_BFS_MARK           (1 << 15)  /* (R) breath-first srch mrk */
#define ROOM_ARENA              (1 << 16)
#define ROOM_CHALLENGE          (1 << 17)
#define ROOM_LEARN              (1 << 18)
#define ROOM_TELEPORT           (1 << 19)
#define ROOM_GOOD_REGEN			(1 << 20)  /* Good Regen Room */
#define ROOM_NO_REGEN_MANA      (1 << 21)  /* !Regen Mana Room */
#define ROOM_NO_REGEN_HIT       (1 << 22)  /* !Regen Hit Room */
#define ROOM_DONATION			(1 << 23)

/* Zone info: Used in zone_data.zone_flags */
#define ZONE_OPEN              (1 << 0)
#define ZONE_CLOSED            (1 << 1)
#define ZONE_NORECALL          (1 << 2)
#define ZONE_NOSUMMON          (1 << 3)
#define ZONE_REMORT_ONLY       (1 << 4)


/* Exit info: used in room_data.dir_option.exit_info */
#define EX_ISDOOR               (1 << 0)   /* Exit is a door            */
#define EX_CLOSED               (1 << 1)   /* The door is closed        */
#define EX_LOCKED               (1 << 2)   /* The door is locked        */
#define EX_PICKPROOF            (1 << 3)   /* Lock can't be picked      */
//#define EX_HIDDEN		(1 << 4)   /* portas escondidas 	*/

/* Sector types: used in room_data.sector_type */
#define SECT_INSIDE          0             /* Indoors                   */
#define SECT_CITY            1             /* In a city                 */
#define SECT_FIELD           2             /* In a field                */
#define SECT_FOREST          3             /* In a forest               */
#define SECT_HILLS           4             /* In the hills              */
#define SECT_MOUNTAIN        5             /* On a mountain             */
#define SECT_WATER_SWIM      6             /* Swimmable water           */
#define SECT_WATER_NOSWIM    7             /* Water - need a boat       */
#define SECT_UNDERWATER      8             /* Underwater                */
#define SECT_FLYING          9             /* Wheee!                    */


/* char and mob-related defines *****************************************/


#define MAX_REMORT 	  20

/* PC classes */
#define CLASS_UNDEFINED   -1
#define CLASS_MAGIC_USER   0
#define CLASS_CLERIC       1
#define CLASS_THIEF        2
#define CLASS_WARRIOR      3
#define CLASS_NECROMANCER  4
#define CLASS_PALADIN      5
#define CLASS_NINJA        6
#define CLASS_RANGER       7
#define CLASS_PSIONICIST   8
#define CLASS_WARLOCK      9
#define CLASS_BARBARIAN   10
#define CLASS_SORCERER    11

#define NUM_CLASSES       12  /* This must be the number of classes!! */

/* PC races */
#define RACE_UNDEFINED   -1
#define RACE_VAMPIRE      0
#define RACE_DROW	  1
#define RACE_DWARF	  2
#define RACE_ELF	  3
#define RACE_OGRE	  4
#define RACE_ORC	  5
#define RACE_TROLL	  6
#define RACE_GITH	  7
#define RACE_GNOME	  8
#define RACE_LIZARDMAN	  9
#define RACE_SEA_ELF	 10
#define RACE_GORAK	 11
#define RACE_DUNEDAIN    12
#define RACE_ANCI_DROW   13
#define RACE_NAUGRIM     14
#define RACE_HIGH_ELF    15
#define RACE_HILL_OGRE   16
#define RACE_BUGBEAR     17
#define RACE_CAVE_TROLL  18
#define RACE_LICH        19
#define RACE_TINKER      20
#define RACE_DRACONIAN   21
#define RACE_H_SEA_ELF   22
#define RACE_ARCHONS     23

#define NUM_RACES        24

/* NPC classes */
#define CLASS_OTHER       0
#define CLASS_UNDEAD      1
#define CLASS_DRAGON      2
#define CLASS_DEMON       3
#define CLASS_SPIRIT      4
#define CLASS_ANIMAL      5
#define CLASS_HUMAN       6
#define CLASS_GIANT       7

#define NUM_NPC_CLASSES   8  /* This must be the numbrer of classes!! */

/* Sex */
#define SEX_NEUTRAL   0
#define SEX_MALE      1
#define SEX_FEMALE    2


/* Positions */
#define POS_DEAD       0        /* dead                 */
#define POS_MORTALLYW  1        /* mortally wounded     */
#define POS_INCAP      2        /* incapacitated        */
#define POS_STUNNED    3        /* stunned              */
#define POS_SLEEPING   4        /* sleeping             */
#define POS_RESTING    5        /* resting              */
#define POS_SITTING    6        /* sitting              */
#define POS_FIGHTING   7        /* fighting             */
#define POS_STANDING   8        /* standing             */

/* Player flags: used by char_data.char_specials.act */
#define PLR_KILLER      (1 << 0)   /* Player is a player-killer         */
#define PLR_THIEF       (1 << 1)   /* Player is a player-thief          */
#define PLR_FROZEN      (1 << 2)   /* Player is frozen                  */
#define PLR_DONTSET     (1 << 3)   /* Don't EVER set (ISNPC bit)        */
#define PLR_WRITING     (1 << 4)   /* Player writing (board/mail/olc)   */
#define PLR_MAILING     (1 << 5)   /* Player is writing mail            */
#define PLR_CRASH       (1 << 6)   /* Player needs to be crash-saved    */
#define PLR_SITEOK      (1 << 7)   /* Player has been site-cleared      */
#define PLR_NOSHOUT     (1 << 8)   /* Player not allowed to shout/goss  */
#define PLR_NOTITLE     (1 << 9)   /* Player not allowed to set title   */
#define PLR_DELETED     (1 << 10)  /* Player deleted - space reusable   */
#define PLR_LOADROOM    (1 << 11)  /* Player uses nonstandard loadroom  */
#define PLR_NOWIZLIST   (1 << 12)  /* Player shouldn't be on wizlist    */
#define PLR_NODELETE    (1 << 13)  /* Player shouldn't be deleted       */
#define PLR_INVSTART    (1 << 14)  /* Player should enter game wizinvis */
#define PLR_CRYO        (1 << 15)  /* Player is cryo-saved (purge prog) */
#define PLR_DEAD	(1 << 16)
#define PLR_NOPK	(1 << 17)
#define PLR_MEDITATE	(1 << 18)
#define PLR_MESSAGING   (1 << 19)  /* Player is writing the message of day  */
#define PLR_GLAD_BET_QP (1 << 20)  /* Player is fighting in pit for qps */
#define PLR_GLAD_BET_GOLD (1 << 21)/* Player is fighting in pit for gold */
#define PLR_BANNED      (1 << 22)
#define PLR_MSP          (1 << 23) //toca som
/* Mobile flags: used by char_data.char_specials.act */
#define MOB_SPEC         (1 << 0)  /* Mob has a callable spec-proc      */
#define MOB_SENTINEL     (1 << 1)  /* Mob should not move               */
#define MOB_SCAVENGER    (1 << 2)  /* Mob picks up stuff on the ground  */
#define MOB_ISNPC        (1 << 3)  /* (R) Automatically set on all Mobs */
#define MOB_AWARE        (1 << 4)  /* Mob can't be backstabbed          */
#define MOB_AGGRESSIVE   (1 << 5)  /* Mob hits players in the room      */
#define MOB_STAY_ZONE    (1 << 6)  /* Mob shouldn't wander out of zone  */
#define MOB_WIMPY        (1 << 7)  /* Mob flees if severely injured     */
#define MOB_AGGR_EVIL    (1 << 8)  /* auto attack evil PC's             */
#define MOB_AGGR_GOOD    (1 << 9)  /* auto attack good PC's             */
#define MOB_AGGR_NEUTRAL (1 << 10) /* auto attack neutral PC's          */
#define MOB_MEMORY       (1 << 11) /* remember attackers if attacked    */
#define MOB_HELPER       (1 << 12) /* attack PCs fighting other NPCs    */
#define MOB_NOCHARM      (1 << 13) /* Mob can't be charmed              */
#define MOB_NOSUMMON     (1 << 14) /* Mob can't be summoned             */
#define MOB_NOSLEEP      (1 << 15) /* Mob can't be slept                */
#define MOB_NOBASH       (1 << 16) /* Mob can't be bashed (e.g. trees)  */
#define MOB_NOBLIND      (1 << 17) /* Mob can't be blinded              */
#define MOB_NOENTANGLE   (1 << 18) /* Mob can't be entangled            */
#define MOB_CLAN	 (1 << 19)
#define MOB_NOSTEAL	 (1 << 20)
#define MOB_NODISARM	 (1 << 21)

/* Preference flags: used by char_data.player_specials.pref */
#define PRF_BRIEF       (1 << 0)  /* Room descs won't normally be shown */
#define PRF_COMPACT     (1 << 1)  /* No extra CRLF pair before prompts  */
#define PRF_DEAF        (1 << 2)  /* Can't hear shouts                  */
#define PRF_NOTELL      (1 << 3)  /* Can't receive tells                */
#define PRF_DISPHP      (1 << 4)  /* Display hit points in prompt       */
#define PRF_DISPMANA    (1 << 5)  /* Display mana points in prompt      */
#define PRF_DISPMOVE    (1 << 6)  /* Display move points in prompt      */
#define PRF_AUTOEXIT    (1 << 7)  /* Display exits in a room            */
#define PRF_NOHASSLE    (1 << 8)  /* Aggr mobs won't attack             */
#define PRF_QUEST       (1 << 9)  /* On quest                           */
#define PRF_SUMMONABLE  (1 << 10) /* Can be summoned                    */
#define PRF_NOREPEAT    (1 << 11) /* No repetition of comm commands     */
#define PRF_HOLYLIGHT   (1 << 12) /* Can see in dark                    */
#define PRF_COLOR_1     (1 << 13) /* Color (low bit)                    */
#define PRF_COLOR_2     (1 << 14) /* Color (high bit)                   */
#define PRF_NOWIZ       (1 << 15) /* Can't hear wizline                 */
#define PRF_LOG1        (1 << 16) /* On-line System Log (low bit)       */
#define PRF_LOG2        (1 << 17) /* On-line System Log (high bit)      */
#define PRF_NOAUCT      (1 << 18) /* Can't hear auction channel         */
#define PRF_NOGOSS      (1 << 19) /* Can't hear gossip channel          */
#define PRF_NOGRATZ     (1 << 20) /* Can't hear grats channel           */
#define PRF_DISPMAX     (1 << 21) /* Display maxhit, maxmana and maxmove*/
#define PRF_CROSSDOORS  (1 << 22) /* Cross doors without opening them   */
#define PRF_AUTOLOOT    (1 << 23) /* Auto get all from corpses          */
#define PRF_AUTOGOLD    (1 << 24) /* Auto get gold from corpses         */
#define PRF_AUTOSPLIT   (1 << 25) /* Auto split gold between group      */
#define PRF_AFK         (1 << 26) /* Away from keyboard                 */
#define PRF_AUTOASSIST  (1 << 27) /* autoassist 		        */
#define PRF_INFO_START  (1 << 28) /* to type info when the player enter */
#define PRF_DISPMENT    (1 << 29) /* Display mental points in prompt    */
#define PRF_NOCHAT      (1 << 30) /* Can't hear chat channel            */

/* Preference flags: used by char_data.player_specials.pref2 */
#define PRF2_DISPEXP       (1 << 0)
#define PRF2_WDPROTOCOL    (1 << 1)
#define PRF2_MAP           (1 << 2)
#define PRF2_NOREPEAT	   (1 << 3)
#define PRF2_HOUSE_RECALL  (1 << 4) /* Recall to the house instead of temple - Fenix - WHS */
#define PRF2_CLAN_SEMFALAR (1 << 5)
#define PRF2_NOTIPS        (1 << 6)
#define PRF2_NONEWBIE      (1 << 7) /* cant hear newbie channel */
//#define PRF2_MSP	   (1 << 8)
/* Affect bits: used in char_data.char_specials.saved.affected_by */
/* WARNING: In the world files, NEVER set the bits marked "R" ("Reserved") */
#define AFF_BLIND             (1 << 0)     /* (R) Char is blind         */
#define AFF_INVISIBLE         (1 << 1)     /* Char is invisible         */
#define AFF_DETECT_ALIGN      (1 << 2)     /* Char is sensitive to align*/
#define AFF_DETECT_INVIS      (1 << 3)     /* Char can see invis chars  */
#define AFF_DETECT_MAGIC      (1 << 4)     /* Char is sensitive to magic*/
#define AFF_SENSE_LIFE        (1 << 5)     /* Char can sense hidden life*/
#define AFF_WATERWALK         (1 << 6)     /* Char can walk on water    */
#define AFF_SANCTUARY         (1 << 7)     /* Char protected by sanct.  */
#define AFF_GROUP             (1 << 8)     /* (R) Char is grouped       */
#define AFF_CURSE             (1 << 9)     /* Char is cursed            */
#define AFF_INFRAVISION       (1 << 10)    /* Char can see in dark      */
#define AFF_POISON            (1 << 11)    /* (R) Char is poisoned      */
#define AFF_PROTECT_EVIL      (1 << 12)    /* Char protected from evil  */
#define AFF_PROTECT_GOOD      (1 << 13)    /* Char protected from good  */

// protection form good e evil nao estao sendo usados em nenhum lugar, mudar
// a vontade


#define AFF_SLEEP             (1 << 14)    /* (R) Char magically asleep */
#define AFF_NOTRACK           (1 << 15)    /* Char can't be tracked     */
#define AFF_MANA_SHIELD       (1 << 16)    /* Char lose mana instead hp */
#define AFF_DAMNED_CURSE      (1 << 17)    /* Char is extremely cursed  */
#define AFF_SNEAK             (1 << 18)    /* Char can move quietly     */
#define AFF_HIDE              (1 << 19)    /* Char is hidden            */
#define AFF_HASTE             (1 << 20)    /* One more attack           */
#define AFF_CHARM             (1 << 21)    /* Char is charmed           */
#define AFF_HOLDED	      (1 << 22)    /* char is holded		*/
#define AFF_SATAN	      (1 << 23)    /* char is protected by satan*/
#define AFF_GOD		      (1 << 24)    /* char is protected by god  */
#define AFF_REGEN	      (1 << 25)
#define AFF_FLY		      (1 << 26)
#define AFF_GAS               (1 << 27)
#define AFF_TANGLED           (1 << 28)    /* (R) Char is tangled       */
#define AFF_FIRESHIELD        (1 << 29)
#define AFF_BERZERK           (1 << 30)
/* limite de campo estourado. */

/* Affect bits: used in char_data.char_specials.saved.affected_by */
/* WARNING: In the world files, NEVER set the bits marked "R" ("Reserved") */
#define AFF2_TRANSFORM		(1 << 0)   /* transformation flag */
#define AFF2_WARSHOUT		(1 << 1)   /* warshout flag */
#define AFF2_TERROR             (1 << 2)   /* Terror Flag */
#define AFF2_BANSHEE            (1 << 3)   /* Banshe Aura */
#define AFF2_BLINK              (1 << 4)   /* Blink */
#define AFF2_DEATHDANCE         (1 << 5)   /* deathdance */
#define AFF2_PROT_FIRE          (1 << 6)   /* protection from fire*/
#define AFF2_PASSDOOR           (1 << 7)   /* protection from fire*/
#define AFF2_MORALE             (1 << 8)   /* morale */
#define AFF2_SLOW		(1 << 9) /* slow */
#define AFF2_MUIR1              (1 << 10) //religiao
#define AFF2_TEMPUS             (1 << 11) 
#define AFF2_ILMANATEUR1        (1 << 12) 
#define AFF2_SELUNE             (1 << 13) 
#define AFF2_FIREMOB             (1 << 14) 
#define AFF2_WATERMOB             (1 << 15) 
//#define AFF2_EARTHMOB             (1 << 16) 
//#define AFF2_WINDMOB             (1 << 17) 
/* Affect bits: used in char_data.char_specials.saved.affected_by */
/* WARNING: In the world files, NEVER set the bits marked "R" ("Reserved") */
#define AFF3_UNUSED		(1 << 0)

/* Room affections */
#define RAFF_FOG	      (1 << 0)
#define RAFF_FIREWALL	      (1 << 1)
#define RAFF_ICEWALL	      (1 << 2)

/* Modes of connectedness: used by descriptor_data.state */
#define CON_PLAYING      0              /* Playing - Nominal state      */
#define CON_CLOSE        1              /* Disconnecting                */
#define CON_GET_NAME     2              /* By what name ..?             */
#define CON_NAME_CNFRM   3              /* Did I get that right, x?     */
#define CON_PASSWORD     4              /* Password:                    */
#define CON_NEWPASSWD    5              /* Give me a password for x     */
#define CON_CNFPASSWD    6              /* Please retype password:      */
#define CON_QSEX         7              /* Sex?                         */
#define CON_QCLASS       8              /* Class?                       */
#define CON_RMOTD        9              /* PRESS RETURN after MOTD      */
#define CON_MENU         10             /* Your choice: (main menu)     */
#define CON_EXDESC       11             /* Enter a new description:     */
#define CON_CHPWD_GETOLD 12             /* Changing passwd: get old     */
#define CON_CHPWD_GETNEW 13             /* Changing passwd: get new     */
#define CON_CHPWD_VRFY   14             /* Verify new password          */
#define CON_DELCNF1      15             /* Delete confirmation 1        */
#define CON_DELCNF2      16             /* Delete confirmation 2        */
#define CON_DISCONNECT   17             /* In-game disconnection        */
#define CON_OEDIT        18             /*. OLC mode - object edit      */
#define CON_REDIT        19             /*. OLC mode - room edit        */
#define CON_ZEDIT        20             /*. OLC mode - zone info edit   */
#define CON_MEDIT        21             /*. OLC mode - mobile edit      */
#define CON_SEDIT        22             /*. OLC mode - shop edit        */
#define CON_HEDIT	 23		/*. OLC mode - help edit       .*/
#define CON_QRACE        24             /* Race?                        */
#define CON_WHOISDESC    25             /* WHOISDESC                    */
#define CON_TERMINAL	 26
#define CON_TEXTED	 27
#define CON_AEDIT	 28		/*. OLC mode - action edit     .*/
#define CON_SUMMARY      29
#define CON_TRIGEDIT     30		/*. OLC mode - trigger edit    .*/
#define CON_QEDIT	 31		/*. OLC mode - quest edit      . */
#define CON_CHOOSE_PK	 32		/*. OLC mode - quest edit      . */
#define CON_QCONFIRMRACE 33             /*  Comfirm Race? */
#define CON_QCONFIRMCLAS 34             /*  Comfirm Race? */
#define CON_MASTER       35 		/*  Master System. Taerom */
#define CON_NEWMASTER    36		/*  Master System. Taerom */


/* Character equipment positions: used as index for char_data.equipment[] */
/* NOTE: Don't confuse these constants with the ITEM_ bitvectors
   which control the valid places you can wear a piece of equipment */
#define WEAR_LIGHT      0
#define WEAR_FINGER_R   1
#define WEAR_FINGER_L   2
#define WEAR_NECK_1     3
#define WEAR_NECK_2     4
#define WEAR_BODY       5
#define WEAR_HEAD       6
#define WEAR_LEGS       7
#define WEAR_FEET       8
#define WEAR_HANDS      9
#define WEAR_ARMS      10
#define WEAR_SHIELD    11
#define WEAR_ABOUT     12
#define WEAR_WAIST     13
#define WEAR_WRIST_R   14
#define WEAR_WRIST_L   15
#define WEAR_WIELD     16
#define WEAR_HOLD      17
#define WEAR_DWIELD    18
#define WEAR_EAR_R     19
#define WEAR_EAR_L     20
#define WEAR_FACE      21
#define WEAR_FLOAT     22

#define NUM_WEARS      23       /* This must be the # of eq positions!! */


/* object-related defines ********************************************/


/* Item types: used by obj_data.obj_flags.type_flag */
#define ITEM_LIGHT      1               /* Item is a light source       */
#define ITEM_SCROLL     2               /* Item is a scroll             */
#define ITEM_WAND       3               /* Item is a wand               */
#define ITEM_STAFF      4               /* Item is a staff              */
#define ITEM_WEAPON     5               /* Item is a weapon             */
#define ITEM_FIREWEAPON 6               /* Unimplemented                */
#define ITEM_MISSILE    7               /* Unimplemented                */
#define ITEM_TREASURE   8               /* Item is a treasure, not gold */
#define ITEM_ARMOR      9               /* Item is armor                */
#define ITEM_POTION    10               /* Item is a potion             */
#define ITEM_WORN      11               /* Unimplemented                */
#define ITEM_OTHER     12               /* Misc object                  */
#define ITEM_TRASH     13               /* Trash - shopkeeps won't buy  */
#define ITEM_TRAP      14               /* Unimplemented                */
#define ITEM_CONTAINER 15               /* Item is a container          */
#define ITEM_NOTE      16               /* Item is note                 */
#define ITEM_DRINKCON  17               /* Item is a drink container    */
#define ITEM_KEY       18               /* Item is a key                */
#define ITEM_FOOD      19               /* Item is food                 */
#define ITEM_MONEY     20               /* Item is money (gold)         */
#define ITEM_PEN       21               /* Item is a pen                */
#define ITEM_BOAT      22               /* Item is a boat               */
#define ITEM_FOUNTAIN  23               /* Item is a fountain           */
#define ITEM_SPELLBOOK 24               // Livro de spell

/* Take/Wear flags: used by obj_data.obj_flags.wear_flags */
#define ITEM_WEAR_TAKE          (1 << 0)  /* Item can be takes          */
#define ITEM_WEAR_FINGER        (1 << 1)  /* Can be worn on finger      */
#define ITEM_WEAR_NECK          (1 << 2)  /* Can be worn around neck    */
#define ITEM_WEAR_BODY          (1 << 3)  /* Can be worn on body        */
#define ITEM_WEAR_HEAD          (1 << 4)  /* Can be worn on head        */
#define ITEM_WEAR_LEGS          (1 << 5)  /* Can be worn on legs        */
#define ITEM_WEAR_FEET          (1 << 6)  /* Can be worn on feet        */
#define ITEM_WEAR_HANDS         (1 << 7)  /* Can be worn on hands       */
#define ITEM_WEAR_ARMS          (1 << 8)  /* Can be worn on arms        */
#define ITEM_WEAR_SHIELD        (1 << 9)  /* Can be used as a shield    */
#define ITEM_WEAR_ABOUT         (1 << 10) /* Can be worn about body     */
#define ITEM_WEAR_WAIST         (1 << 11) /* Can be worn around waist   */
#define ITEM_WEAR_WRIST         (1 << 12) /* Can be worn on wrist       */
#define ITEM_WEAR_WIELD         (1 << 13) /* Can be wielded             */
#define ITEM_WEAR_HOLD          (1 << 14) /* Can be held                */
#define ITEM_WEAR_EAR           (1 << 15)
#define ITEM_WEAR_FACE          (1 << 16)
#define ITEM_WEAR_FLOAT         (1 << 17)

/* Extra object flags: used by obj_data.obj_flags.extra_flags */
#define ITEM_GLOW             (1 << 0)     /* Item is glowing              */
#define ITEM_HUM              (1 << 1)     /* Item is humming              */
#define ITEM_NORENT           (1 << 2)     /* Item cannot be rented        */
#define ITEM_NODONATE         (1 << 3)     /* Item cannot be donated       */
#define ITEM_NOINVIS          (1 << 4)     /* Item cannot be made invis    */
#define ITEM_INVISIBLE        (1 << 5)     /* Item is invisible            */
#define ITEM_MAGIC            (1 << 6)     /* Item is magical              */
#define ITEM_NODROP           (1 << 7)     /* Item is cursed: can't drop   */
#define ITEM_BLESS            (1 << 8)     /* Item is blessed              */
#define ITEM_ANTI_GOOD        (1 << 9)     /* Not usable by good people    */
#define ITEM_ANTI_EVIL        (1 << 10)    /* Not usable by evil people    */
#define ITEM_ANTI_NEUTRAL     (1 << 11)    /* Not usable by neutral people */
#define ITEM_ANTI_SORCERER    (1 << 12)    /* Not usable by mages          */
#define ITEM_ANTI_CLERIC      (1 << 13)    /* Not usable by clerics        */
#define ITEM_ANTI_THIEF       (1 << 14)    /* Not usable by thieves        */
#define ITEM_ANTI_WARRIOR     (1 << 15)    /* Not usable by warriors       */
#define ITEM_NOSELL           (1 << 16)    /* Shopkeepers won't touch it   */
#define ITEM_ANTI_NECROMANCER (1 << 17)    /* Not usable by necromancers   */
#define ITEM_ANTI_PALADIN     (1 << 18)    /* Not usable by paladins       */
#define ITEM_ANTI_NINJA       (1 << 19)    /* Not usable by ninja          */
#define ITEM_ANTI_RANGER      (1 << 20)    /* Not usable by ranger         */
#define ITEM_ANTI_PSIONICIST  (1 << 21)    /* Not usable by psionicist     */
#define ITEM_ANTI_WARLOCK     (1 << 22)    /* Not usable by warlock        */
#define ITEM_ANTI_SHAMAN      (1 << 23)    /* Not usable by sorcerer       */
#define ITEM_ANTI_BARBARIAN   (1 << 24)    /* Not usable by barbarian      */
#define ITEM_ANTI_VAMPIRE     (1 << 25)
#define ITEM_ANTI_DROW        (1 << 26)
#define ITEM_ANTI_DWARF       (1 << 27)
#define ITEM_ANTI_ELF         (1 << 28) 
#define ITEM_ANTI_OGRE        (1 << 29)
#define ITEM_FIRE	      (1 << 30)	
#define ITEM_ANTI_TROLL       (1 << 31)
#define ITEM_ANTI_GITH        (1 << 32)
#define ITEM_ANTI_GNOME       (1 << 33)
#define ITEM_ANTI_LIZARDMAN   (1 << 34)
#define ITEM_ANTI_SEA_ELF     (1 << 35)
#define ITEM_ANTI_ORC         (1 << 36)
#define ITEM_ANTI_GORAK       (1 << 37)
#define ITEM_ANTI_MAGIC_USER  (1 << 38)
#define ITEM_QUEST             (1 << 39)//adicionado por ultimo


/* Modifier constants used with obj affects ('A' fields) */
#define APPLY_NONE              0       /* No effect                    */
#define APPLY_STR               1       /* Apply to strength            */
#define APPLY_DEX               2       /* Apply to dexterity           */
#define APPLY_INT               3       /* Apply to constitution        */
#define APPLY_WIS               4       /* Apply to wisdom              */
#define APPLY_CON               5       /* Apply to constitution        */
#define APPLY_CHA               6       /* Apply to charisma            */
#define APPLY_CLASS             7       /* Reserved                     */
#define APPLY_LEVEL             8       /* Reserved                     */
#define APPLY_AGE               9       /* Apply to age                 */
#define APPLY_CHAR_WEIGHT      10       /* Apply to weight              */
#define APPLY_CHAR_HEIGHT      11       /* Apply to height              */
#define APPLY_MANA             12       /* Apply to max mana            */
#define APPLY_HIT              13       /* Apply to max hit points      */
#define APPLY_MOVE             14       /* Apply to max move points     */
#define APPLY_GOLD             15       /* Reserved                     */
#define APPLY_EXP              16       /* Reserved                     */
#define APPLY_AC               17       /* Apply to Armor Class         */
#define APPLY_HITROLL          18       /* Apply to hitroll             */
#define APPLY_DAMROLL          19       /* Apply to damage roll         */
#define APPLY_SAVING_PARA      20       /* Apply to save throw: paralz  */
#define APPLY_SAVING_ROD       21       /* Apply to save throw: rods    */
#define APPLY_SAVING_PETRI     22       /* Apply to save throw: petrif  */
#define APPLY_SAVING_BREATH    23       /* Apply to save throw: breath  */
#define APPLY_SAVING_SPELL     24       /* Apply to save throw: spells  */


/* Container flags - value[1] */
#define CONT_CLOSEABLE      (1 << 0)    /* Container can be closed      */
#define CONT_PICKPROOF      (1 << 1)    /* Container is pickproof       */
#define CONT_CLOSED         (1 << 2)    /* Container is closed          */
#define CONT_LOCKED         (1 << 3)    /* Container is locked          */


/* Some different kind of liquids for use in values of drink containers */
#define LIQ_WATER      0
#define LIQ_BEER       1
#define LIQ_WINE       2
#define LIQ_ALE        3
#define LIQ_DARKALE    4
#define LIQ_WHISKY     5
#define LIQ_LEMONADE   6
#define LIQ_FIREBRT    7
#define LIQ_LOCALSPC   8
#define LIQ_SLIME      9
#define LIQ_MILK       10
#define LIQ_TEA        11
#define LIQ_COFFE      12
#define LIQ_BLOOD      13
#define LIQ_SALTWATER  14
#define LIQ_CLEARWATER 15


/* other miscellaneous defines *******************************************/


/* Player conditions */
#define DRUNK        0
#define FULL         1
#define THIRST       2


/* Sun state for weather_data */
#define SUN_DARK        0
#define SUN_RISE        1
#define SUN_LIGHT       2
#define SUN_SET         3


/* Sky conditions for weather_data */
#define SKY_CLOUDLESS   0
#define SKY_CLOUDY      1
#define SKY_RAINING     2
#define SKY_LIGHTNING   3


/* Rent codes */
#define RENT_UNDEF      0
#define RENT_CRASH      1
#define RENT_RENTED     2
#define RENT_CRYO       3
#define RENT_FORCED     4
#define RENT_TIMEDOUT   5


/* other #defined constants **********************************************/

/*
 * **DO**NOT** blindly change the number of levels in your MUD merely by
 * changing these numbers and without changing the rest of the code to match.
 * Other changes throughout the code are required.  See coding.doc for
 * details.
 *
 * LVL_IMPL should always be the HIGHEST possible immortal level, and
 * LVL_IMMORT should always be the LOWEST immortal level.  The number of
 * mortal levels will always be LVL_IMMORT - 1.
 */
#define LVL_IMPL        210
#define LVL_SUBIMPL     209
#define LVL_MJGOD	208 // Supreme Coder
#define LVL_SUPGOD      207 // Major Builder
#define LVL_GRGOD       206 // Coder
#define LVL_GOD         205 // Builder
#define LVL_DEMIGOD	204 // Helper
#define LVL_LORD	203
#define LVL_ELDER       202
#define LVL_IMMORT      201

/* Level of the 'freeze' command */
#define LVL_FREEZE      LVL_GRGOD

/* Level of the 'remort' command */
#define LVL_GOREMORT    LVL_IMMORT

/* Level of some commands */
#define LVL_ROOMFLAGS   LVL_ELDER
#define LVL_NEWBIE      10
#define LVL_NEWBIE_WARN 8

#define NUM_OF_DIRS     6       /* number of directions in a room (nsewud) */
#define MAGIC_NUMBER    (0x06)  /* Arbitrary number that won't be in a string */

#define OPT_USEC        100000  /* 10 passes per second */
#define PASSES_PER_SEC  (1000000 / OPT_USEC)
#define RL_SEC          * PASSES_PER_SEC

#define PULSE_ZONE      (10 RL_SEC)
#define PULSE_MOBILE    (10 RL_SEC)
#define PULSE_VIOLENCE  (2 RL_SEC)

/* Variables for the output buffering system */
#define MAX_SOCK_BUF            (12 * 1024) /* Size of kernel's sock buf   */
#define MAX_PROMPT_LENGTH       340         /* Max length of prompt        */
#define GARBAGE_SPACE           32          /* Space for **OVERFLOW** etc  */
#define SMALL_BUFSIZE           1024        /* Static output buffer size   */
/* Max amount of output that can be buffered */
#define LARGE_BUFSIZE      (MAX_SOCK_BUF - GARBAGE_SPACE - MAX_PROMPT_LENGTH)

/*
 * --- WARNING ---
 * If you are using a BSD-derived UNIX with MD5 passwords, you _must_
 * make MAX_PWD_LENGTH larger.  A length of 20 should be good. If
 * you leave it at the default value of 10, then any character with
 * a name longer than about 5 characters will be able to log in with
 * _any_ password.  This has not (yet) been changed to ensure pfile
 * compatibility for those unaffected.
 */
#define HISTORY_SIZE            5   /* Keep last 5 commands. */
#define MAX_STRING_LENGTH   65536
#define MAX_INPUT_LENGTH      256   /* Max length per *line* of input */
#define MAX_RAW_INPUT_LENGTH  512   /* Max size of *raw* input */
#define MAX_MESSAGES           60
#define MAX_NAME_LENGTH        12   /* Used in char_file_u *DO*NOT*CHANGE* */
/* ** MAX_PWD_LENGTH changed from 10 to 30 for ascii test - Sam ** */
#define MAX_PWD_LENGTH	       30  /* Used in char_file_u *DO*NOT*CHANGE* */
#define MAX_TITLE_LENGTH       25   /* Used in char_file_u *DO*NOT*CHANGE* */
#define HOST_LENGTH            30   /* Used in char_file_u *DO*NOT*CHANGE* */
#define EXDSCR_LENGTH        3072   /* Used in char_file_u *DO*NOT*CHANGE* */
#define MAX_TONGUE              3   /* Used in char_file_u *DO*NOT*CHANGE* */
#define MAX_SKILLS            500   /* Used in char_file_u *DO*NOT*CHANGE* */
#define MAX_AFFECT             31  /* Used in char_file_u *DO*NOT*CHANGE* */
#define MAX_OBJ_AFFECT          6   /* Used in obj_file_elem *DO*NOT*CHANGE* */
#define MAX_EMAIL_LENGTH       60   /* Used in char_file_u *DO*NOT*CHANGE* */
#define MAX_RSKILLS             5   /* Used in char_file_u *DO*NOT*CHANGE* */

/**********************************************************************
* Structures                                                          *
**********************************************************************/


typedef signed char             sbyte;
typedef unsigned char           ubyte;
typedef signed short int        sh_int;
typedef unsigned short int      ush_int;
typedef signed long		sh_long;
typedef unsigned long		ush_long;

#if !defined(__cplusplus)       /* Anyone know a portable method? */
typedef char                    bool;
#endif

#ifndef CIRCLE_WINDOWS
typedef char                    byte;
#endif

typedef sh_int  room_vnum;      /* A room's vnum type */
typedef sh_int  obj_vnum;       /* An object's vnum type */
typedef sh_int  mob_vnum;       /* A mob's vnum type */

typedef sh_int  room_rnum;      /* A room's real (internal) number type */
typedef sh_int  obj_rnum;       /* An object's real (internal) num type */
typedef sh_int  mob_rnum;       /* A mobile's real (internal) num type */


/* Extra description: used in objects, mobiles, and rooms */
struct extra_descr_data {
   char *keyword;                 /* Keyword in look/examine          */
   char *description;             /* What to see                      */
   struct extra_descr_data *next; /* Next in list                     */
};


/* object-related structures ******************************************/


/* object flags; used in obj_data */
struct obj_flag_data {
   int  value[4];       /* Values of the item (see list)    */
   byte type_flag;      /* Type of item                     */
   int  wear_flags;     /* Where you can wear it            */
   int  extra_flags;    /* If it hums, glows, etc.          */
   int  weight;         /* Weigt what else                  */
   int  cost;           /* Value when sold (gp.)            */
   int  cost_per_day;   /* Cost to keep pr. real day        */
   int  timer;          /* Timer for object                 */
   int  obj_level;      /* Minumum Level for object         */
   long bitvector;      /* To set chars bits                */
   int  cond;           /* condiction of the obj            */
};


/* Used in obj_file_elem *DO*NOT*CHANGE* */
struct obj_affected_type {
   byte location;      /* Which ability to change (APPLY_XXX) */
   sbyte modifier;     /* How much it changes by              */
};


/* ================== Memory Structure for Objects ================== */
struct obj_data {
   obj_vnum item_number;        /* Where in data-base                   */
   room_rnum in_room;           /* In what room -1 when conta/carr      */

   struct obj_flag_data obj_flags;/* Object information               */
   struct obj_affected_type affected[MAX_OBJ_AFFECT];  /* affects */

   char *name;                    /* Title of object :get etc.        */
   char *description;             /* When in room                     */
   char *short_description;       /* when worn/carry/in cont.         */
   char *action_description;      /* What to write when used          */
   struct extra_descr_data *ex_description; /* extra descriptions     */
   struct char_data *carried_by;  /* Carried by :NULL in room/conta   */
   struct char_data *worn_by;     /* Worn by?                         */
   sh_int worn_on;                /* Worn where?                      */
   sh_int worned;                 /* Worned before renting            */

   struct obj_data *in_obj;       /* In what object NULL when none    */
   struct obj_data *contains;     /* Contains objects                 */

   long id;                       /* used by DG triggers              */
   struct trig_proto_list *proto_script; /* list of default triggers  */
   struct script_data *script;    /* script info for the object       */

   struct obj_data *next_content; /* For 'contains' lists             */
   struct obj_data *next;         /* For the object list              */
};
/* ======================================================================= */


/* ====================== File Element for Objects ======================= */
/*                 BEWARE: Changing it will ruin rent files                */
struct obj_file_elem {
   obj_vnum item_number;

#if USE_AUTOEQ
   sh_int location;
#endif
   int  value[4];
   long  extra_flags;
   int  weight;
   int  timer;
   sh_int worned;
   long bitvector;
   int cond;
   struct obj_affected_type affected[MAX_OBJ_AFFECT];

};


/* header block for rent files.  BEWARE: Changing it will ruin rent files  */
struct rent_info {
   int  time;
   int  rentcode;
   int  net_cost_per_diem;
   int  gold;
   int  account;
   int  nitems;
   int  spare0;
   int  spare1;
   int  spare2;
   int  spare3;
   int  spare4;
   int  spare5;
   int  spare6;
   int  spare7;
};
/* ======================================================================= */


/* room-related structures ************************************************/


struct room_direction_data {
   char *general_description;       /* When look DIR.                   */

   char *keyword;               /* for open/close                       */

   sh_int exit_info;            /* Exit info                            */
   obj_vnum key;                /* Key's number (-1 for no key)         */
   room_rnum to_room;           /* Where direction leads (NOWHERE)      */
};


/* ================== Memory Structure for room ======================= */
struct room_data {
   room_vnum number;            /* Rooms number (vnum)                */
   sh_int zone;                 /* Room zone (for resetting)          */
   int  sector_type;            /* sector type (move/hide)            */
   char *name;                  /* Rooms name 'You are ...'           */
   char *description;           /* Shown when entered                 */
   struct extra_descr_data *ex_description; /* for examine/look       */
   struct room_direction_data *dir_option[NUM_OF_DIRS]; /* Directions */
   int room_flags;              /* DEATH,DARK ... etc                 */

   byte light;                  /* Number of lightsources in room     */
   SPECIAL(*func);

   struct trig_proto_list *proto_script; /* list of default triggers  */
   struct script_data *script;  /* script info for the object         */

   struct obj_data *contents;   /* List of items in room              */
   struct char_data *people;    /* List of NPC / PC in room           */

   struct teleport_data *tele;	/* teleport info */

   long  room_affections;    /* bitvector for spells/skills */
};
/* ====================================================================== */


/* char-related structures ************************************************/


/* memory structure for characters */
struct memory_rec_struct {
   long id;
   struct memory_rec_struct *next;
};

typedef struct memory_rec_struct memory_rec;


/* This structure is purely intended to be an easy way to transfer */
/* and return information about time (real or mudwise).            */
struct time_info_data {
   byte hours, day, month;
   sh_int year;
};


/* These data contain information about a players time data */
struct time_data {
   time_t birth;    /* This represents the characters age                */
   time_t logon;    /* Time of the last logon (used to calculate played) */
   int  played;     /* This is the total accumulated time played in secs */
};

/* The pclean_criteria_data is set up in config.c and used in db.c to
   determine the conditions which will cause a player character to be
   deleted from disk if the automagic pwipe system is enabled (see config.c).
*/
struct pclean_criteria_data {
  int level;		/* max level for this time limit	*/
  int days;		/* time limit in days			*/
};

/* general player-related info, usually PC's and NPC's */
struct char_player_data {
   char passwd[MAX_PWD_LENGTH+1]; /* character's password      */
   char email[MAX_EMAIL_LENGTH+1]; /* character's e-mail       */
   char *name;         /* PC / NPC s name (kill ...  )         */
   char *short_descr;  /* for NPC 'actions'                    */
   char *long_descr;   /* for 'look'                           */
   char *description;  /* Extra descriptions                   */
   char *whoisdesc;    /* Extra whoisdescriptions              */
   char *title;        /* PC / NPC's title                     */
   char *prename;        /* PC / NPC's title                     */
   int id_master; 
   byte sex;           /* PC / NPC's sex                       */
   byte chclass;       /* PC / NPC's class                     */
   byte race;
   short int level;         /* PC / NPC's level                     */
   byte remort;
   short int  hometown;      /* PC s Hometown (zone)                 */
   struct time_data time;  /* PC's AGE in days                 */
   ubyte weight;       /* PC / NPC's weight                    */
   ubyte height;       /* PC / NPC's height                    */
   byte fbi_pos;
   int killed;
   int died;
   int a_killed;
   int a_died;
   struct char_data *challenger;

   int trans;
   int trans_hp;
   int trans_mana;
   int trans_move;

   short int liberdade;

/* For the final sumary of the game */
   byte lvl_sum;
   int exp_sum;
   int gold_sum;
   int kills_mob_sum;
   int kills_ppl_sum;
   int died_sum;
   int points_sum;
   int points_g_sum;

};


/* Char's abilities.  Used in char_file_u *DO*NOT*CHANGE* */
struct char_ability_data {
   sbyte str;
   sbyte str_add;      /* 000 - 100 if strength 18             */
   sbyte intel;
   sbyte wis;
   sbyte dex;
   sbyte con;
   sbyte cha;
   sbyte luk;
};


/* Char's points.  Used in char_file_u *DO*NOT*CHANGE* */
struct char_point_data {
   int mana;
   int max_mana;     /* Max move for PC/NPC                     */
   int hit;
   int max_hit;      /* Max hit for PC/NPC                      */
   int move;
   int max_move;     /* Max move for PC/NPC                     */
   sh_int oxigen;
   sh_int max_oxigen;   /* Max oxigenation			   */
   int mental;
   int max_mental;	/* Max mental energy			   */

   sh_int armor;        /* Internal -100..100, external -10..10 AC */
   int  gold;           /* Money carried                           */
   int  bank_gold;      /* Gold the char has in a bank account     */
   int  exp;            /* The experience of the player            */

   sh_int hitroll;       /* Any bonus or penalty to the hit roll    */
   sh_int damroll;       /* Any bonus or penalty to the damage roll */

};


/*
 * char_special_data_saved: specials which both a PC and an NPC have in
 * common, but which must be saved to the playerfile for PC's.
 *
 * WARNING:  Do not change this structure.  Doing so will ruin the
 * playerfile.  If you want to add to the playerfile, use the spares
 * in player_special_data.
 */
struct char_special_data_saved {
   int  alignment;              /* +-1000 for alignments                */
   long idnum;                  /* player's idnum; -1 for mobiles       */
   long challenge;		/* player's challenger			*/
   long act;                    /* act flag for NPC's; player flag for PC's */
   long act2;                    /* act flag for NPC's; player flag for PC's */
   long affected_by;            /* Bitvector for spells/skills affected by */
   long affected2_by;            /* Bitvector for spells/skills affected by */
   long affected3_by;            /* Bitvector for spells/skills affected by */
   sh_int apply_saving_throw[5]; /* Saving throw (Bonuses)              */
};


/* Special playing constants shared by PCs and NPCs which aren't in pfile */
struct char_special_data {
   struct char_data *fighting;  /* Opponent                             */
   struct char_data *hunting;   /* Char hunted by this char             */

   byte position;               /* Standing, fighting, sleeping, etc.   */

   int  carry_weight;           /* Carried weight                       */
   byte carry_items;            /* Number of items carried              */
   int  timer;                  /* Timer for update                     */

   struct char_special_data_saved saved; /* constants saved in plrfile  */
};


/*
 *  If you want to add new values to the playerfile, do it here.  DO NOT
 * ADD, DELETE OR MOVE ANY OF THE VARIABLES - doing so will change the
 * size of the structure and ruin the playerfile.  However, you can change
 * the names of the spares to something more meaningful, and then use them
 * in your new code.  They will automatically be transferred from the
 * playerfile into memory when players log in.
 */
struct player_special_data_saved {
   byte skills[MAX_SKILLS+1];   /* array of skills plus skill 0         */
   byte PADDING0;               /* used to be spells_to_learn           */
   bool talks[MAX_TONGUE];      /* PC s Tongues 0 for NPC               */
   int  wimp_level;             /* Below this # of hit points, flee!    */
   byte freeze_level;           /* Level of god who froze char, if any  */
   sh_int invis_level;          /* level of invisibility                */
   room_vnum load_room;         /* Which room to place char in          */
   long pref;                   /* preference flags for PC's.           */
   long pref2;                   /* preference flags for PC's.           */
   ubyte bad_pws;               /* number of bad password attemps       */
   sbyte conditions[3];         /* Drunk, full, thirsty                 */

   /* spares below for future expansion.  You can change the names from
      'sparen' to something meaningful, but don't change the order.  */

   int spells_to_learn;         /* How many can you learn yet this level*/
   int olc_zone;
   int points;
   int qpoints;
   int clan;  /* clan number */
   int clan_rank; /*  clan rank  */
   int cpoints;
   int house_vnum;
   ubyte uextra[10];

   short int style;
   sh_int rskills[MAX_REMORT][MAX_RSKILLS+1];   /* array of skills plus skill 0         */

   unsigned short int religion;
   short int rp;
   
};

/*
 * Specials needed only by PCs, not NPCs.  Space for this structure is
 * not allocated in memory for NPCs, but it is for PCs and the portion
 * of it labelled 'saved' is saved in the playerfile.  This structure can
 * be changed freely; beware, though, that changing the contents of
 * player_special_data_saved will corrupt the playerfile.
 */
struct player_special_data {
   struct player_special_data_saved saved;


   char *poofin;                /* Description on arrival of a god.     */
   char *poofout;               /* Description upon a god's exit.       */
   struct alias *aliases;       /* Character's aliases                  */
   long last_tell;              /* idnum of last tell from              */
   void *last_olc_targ;		/* olc control                          */
   struct char_data *betted_on; /* arena bet on who?                    */
   int bet_amt;                 /* arena bet amount                     */
   int last_olc_mode;		/* olc control                          */
   char *host;			/* player host				*/
};


/* Specials used by NPCs, not PCs */
struct mob_special_data {
   byte last_direction;     /* The last direction the monster went     */
   int  attack_type;        /* The Attack Type Bitvector for NPC's     */
   byte default_pos;        /* Default position for NPC                */
   memory_rec *memory;      /* List of attackers to remember           */
   sh_int damnodice;          /* The number of damage dice's             */
   sh_int damsizedice;        /* The size of the damage dice's           */
   int wait_state;          /* Wait state for bashed mobs              */
   int attack1;
   int attack2;
   int attack3;
};


/* An affect structure.  Used in char_file_u *DO*NOT*CHANGE* */
struct affected_type {
   sh_int type;          /* The type of spell that caused this      */
   sh_int duration;      /* For how long its effects will last      */
   int modifier;       /* This is added to apropriate ability     */
   byte location;        /* Tells which ability to change(APPLY_XXX)*/
   long bitvector;       /* Tells which bits to set (AFF_XXX)       */
   long bitvector2;       /* Tells which bits to set (AFF_XXX)       */
   long bitvector3;       /* Tells which bits to set (AFF_XXX)       */

   struct affected_type *next;
};


/* Structure used for chars following other chars */
struct follow_type {
   struct char_data *follower;
   struct follow_type *next;
};


/* ================== Structure for player/non-player ===================== */
struct char_data {
   int pfilepos;                         /* playerfile pos                */
   sh_int nr;                            /* Mob's rnum                    */
   room_rnum in_room;                    /* Location (real room number)   */
   room_rnum was_in_room;                /* location for linkdead people  */

   struct char_player_data player;       /* Normal data                   */
   struct char_ability_data real_abils;  /* Abilities without modifiers   */
   struct char_ability_data aff_abils;   /* Abils with spells/stones/etc  */
   struct char_point_data points;        /* Points                        */
   struct char_special_data char_specials;      /* PC/NPC specials        */
   struct player_special_data *player_specials; /* PC specials            */
   struct mob_special_data mob_specials;        /* NPC specials           */

   struct affected_type *affected;       /* affected by what spells       */
   struct obj_data *equipment[NUM_WEARS];/* Equipment array               */

   struct obj_data *carrying;            /* Head of list                  */
   struct descriptor_data *desc;         /* NULL for mobiles              */

   long id;                            /* used by DG triggers             */
   struct trig_proto_list *proto_script; /* list of default triggers      */
   struct script_data *script;         /* script info for the object      */
   struct script_memory *memory;       /* for mob memory triggers         */

   int current_quest;			/* vnum of current quest          */

   struct char_data *next_in_room;      /* For room->people - list         */
   struct char_data *next;              /* For either monster or ppl-list  */
   struct char_data *next_fighting;     /* For fighting list               */

   struct follow_type *followers;       /* List of chars followers       */
   struct char_data *master;            /* Who is char following?        */
};
/* ====================================================================== */


/* ==================== File Structure for Player ======================= */
/*             BEWARE: Changing it will ruin the playerfile               */
struct char_file_u {
   /* char_player_data */
   char name[MAX_NAME_LENGTH+1];
   char description[EXDSCR_LENGTH];
   char whoisdesc[EXDSCR_LENGTH];
   char title[MAX_TITLE_LENGTH+1];
   char prename[MAX_TITLE_LENGTH+1];
   int id_master;
   byte sex;
   byte chclass;
   byte race;
   int level;
   byte remort;
   sh_int hometown;
   time_t birth;   /* Time of birth of character     */
   int  played;    /* Number of secs played in total */
   ubyte weight;
   ubyte height;
   byte fbi_pos;
   int killed;
   int died;
   int a_killed;
   int a_died;

   int trans;
   int trans_hp;
   int trans_mana;
   int trans_move;

   short int liberdade;

   char pwd[MAX_PWD_LENGTH+1];         /* character's password */
   char email[MAX_EMAIL_LENGTH+1];     /* character's e-mail */

   struct char_special_data_saved char_specials_saved;
   struct player_special_data_saved player_specials_saved;
   struct char_ability_data abilities;
   struct char_point_data points;
   struct affected_type affected[MAX_AFFECT];

   int current_quest;

   time_t last_logon;           /* Time (in secs) of last logon */
   char host[HOST_LENGTH+1];    /* host of last logon */
};
/* ====================================================================== */


/* descriptor-related structures ******************************************/


struct txt_block {
   char *text;
   int aliased;
   struct txt_block *next;
};


struct txt_q {
   struct txt_block *head;
   struct txt_block *tail;
};


struct descriptor_data {
   socket_t     descriptor;     /* file descriptor for socket           */
   char host[HOST_LENGTH+1];    /* hostname                             */
   byte bad_pws;                /* number of bad pw attemps this login  */
   byte idle_tics;              /* tics idle at password prompt         */
   int  connected;              /* mode of 'connectedness'              */
   int  wait;                   /* wait for how many loops              */
   int  desc_num;               /* unique num assigned to desc          */
   time_t login_time;           /* when the person connected            */
   char *showstr_head;          /* for keeping track of an internal str */
   char **showstr_vector;       /* for paging through texts             */
   int  showstr_count;          /* number of pages to page through      */
   int  showstr_page;           /* which page are we currently showing? */
   char **str;                  /* for the modify-str system            */
   size_t max_str;              /*              -                       */
   char *backstr;               /* added for handling abort buffers     */
   long mail_to;                /* name for mail system                 */
   int  has_prompt;             /* is the user at a prompt?             */
   char inbuf[MAX_RAW_INPUT_LENGTH];  /* buffer for raw input           */
   char last_input[MAX_INPUT_LENGTH]; /* the last input                 */
   char small_outbuf[SMALL_BUFSIZE];  /* standard output buffer		*/
   char *output;                /* ptr to the current output buffer     */
   char **history;              /* History of commands, for ! mostly.   */
   int  history_pos;            /* Circular array position.             */
   int  bufptr;                 /* ptr to end of current output         */
   int  bufspace;               /* space left in the output buffer      */
   struct txt_block *large_outbuf; /* ptr to large buffer, if we need it */
   struct txt_q input;          /* q of unprocessed input               */
   struct char_data *character; /* linked to char                       */
   struct char_data *original;  /* original char if switched            */
   struct descriptor_data *snooping; /* Who is this char snooping       */
   struct descriptor_data *snoop_by; /* And who is snooping this char   */
   struct descriptor_data *next; /* link to next descriptor             */
   struct olc_data *olc;             /*. OLC info - defined in olc.h   .*/
   char   *storage;
   int hp, mana, move;
};


/* other miscellaneous structures ***************************************/


struct msg_type {
   char *attacker_msg;  /* message to attacker */
   char *victim_msg;    /* message to victim   */
   char *room_msg;      /* message to room     */
};


struct message_type {
   struct msg_type die_msg;     /* messages when death                  */
   struct msg_type miss_msg;    /* messages when miss                   */
   struct msg_type hit_msg;     /* messages when hit                    */
   struct msg_type god_msg;     /* messages when hit on god             */
   struct message_type *next;   /* to next messages of this kind.       */
};


struct message_list {
   int  a_type;                 /* Attack type                          */
   int  number_of_attacks;      /* How many attack messages to chose from. */
   struct message_type *msg;    /* List of messages.                    */
};


struct dex_skill_type {
   sh_int p_pocket;
   sh_int p_locks;
   sh_int traps;
   sh_int sneak;
   sh_int hide;
};


struct dex_app_type {
   sh_int reaction;
   sh_int miss_att;
   sh_int defensive;
};


struct str_app_type {
   sh_int tohit;    /* To Hit (THAC0) Bonus/Penalty        */
   sh_int todam;    /* Damage Bonus/Penalty                */
   sh_int carry_w;  /* Maximum weight that can be carrried */
   sh_int wield_w;  /* Maximum weight that can be wielded  */
};


struct wis_app_type {
   byte bonus;       /* how many practices player gains per lev */
};


struct int_app_type {
   byte learn;       /* how many % a player learns a spell/skill */
};


struct con_app_type {
   sh_int hitp;
   sh_int shock;
};

struct message_data {
  char   message[MAX_STRING_LENGTH];
  char   writer[MAX_STRING_LENGTH];
  time_t time;
};


struct weather_data {
   int  pressure;       /* How is the pressure ( Mb ) */
   int  change; /* How fast and what way does it change. */
   int  sky;    /* How is the sky. */
   int  sunlight;       /* And how much sun. */
};


struct title_type {
   char *title_m;
   char *title_f;
   int  exp;
};


/* element in monster and object index-tables   */
struct index_data {
   int  vnum;           /* virtual number of this mob/obj               */
   int  number;         /* number of existing units of this mob/obj     */
   SPECIAL(*func);

   char *farg;         /* string argument for special function     */
   struct trig_data *proto;     /* for triggers... the trigger     */
};

/* linked list for mob/object prototype trigger lists */
struct trig_proto_list {
  int vnum;                             /* vnum of the trigger   */
  struct trig_proto_list *next;         /* next trigger          */
};

/* used in the socials */
struct social_messg {
   int act_nr;
   char *command;               /* holds copy of activating command */
   char *sort_as;		/* holds a copy of a similar command or
				 * abbreviation to sort by for the parser */
   int hide;			/* ? */
   int min_victim_position;	/* Position of victim */
   int min_char_position;	/* Position of char */
   int min_level_char;          /* Minimum level of socialing char */

   /* No argument was supplied */
   char *char_no_arg;
   char *others_no_arg;

   /* An argument was there, and a victim was found */
   char *char_found;
   char *others_found;
   char *vict_found;

   /* An argument was there, as well as a body part, and a victim was found */
   char *char_body_found;
   char *others_body_found;
   char *vict_body_found;

   /* An argument was there, but no victim was found */
   char *not_found;

   /* The victim turned out to be the character */
   char *char_auto;
   char *others_auto;

   /* If the char cant be found search the char's inven and do these: */
   char *char_obj_found;
   char *others_obj_found;
};

struct teleport_data {
   int time;
   int targ;
   long mask;
   int cnt;
   int obj;
};

struct time_write {
   int year, month, day;
};

struct raff_node {
	room_rnum room;        /* location in the world[] array of the room */
	int      timer;       /* how many ticks this affection lasts */
	long     affection;   /* which affection does this room have */
	int      spell;       /* the spell number */

	struct raff_node *next; /* link to the next node */
};
::::::::::::::
sysdep.h
::::::::::::::
/* ************************************************************************
*   File: sysdep.h                                      Part of CircleMUD *
*  Usage: machine-specific defs based on values in conf.h (from configure)*
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/*
 * CircleMUD uses the crypt(3) function to encrypt player passwords in the
 * playerfile so that they are never stored in plaintext form.  However,
 * due to U.S. export restrictions on machine-readable cryptographic
 * software, the crypt() function is not available on some operating
 * systems such as FreeBSD.  By default, the 'configure' script will
 * determine if you have crypt() available and enable or disable password
 * encryption appropriately.  #define NOCRYPT (by uncommenting the line
 * below) if you'd like to explicitly disable password encryption (i.e.,
 * if you have moved your MUD from an OS that does not support encryption
 * to one that does.)
 *
 * See running.doc for details.
 */

/* #define NOCRYPT */

/**************************************************************************/

/*
 * If you are porting CircleMUD to a new (untested) platform and you find
 * that POSIX-standard non-blocking I/O does *not* work, you can define
 * the constant below to have Circle work around the problem.  Not having
 * non-blocking I/O can cause the MUD to freeze if someone types part of
 * a command while the MUD waits for the remainder of the command.
 *
 * NOTE: **DO** **NOT** use this constant unless you are SURE you understand
 * exactly what non-blocking I/O is, and you are SURE that your operating
 * system does NOT have it!  (The only UNIX system I've ever seen that has
 * broken POSIX non-blocking I/O is AIX 3.2.)  If your MUD is freezing but
 * you're not sure why, do NOT use this constant.  Use this constant ONLY
 * if you're sure that your MUD is freezing because of a non-blocking I/O
 * problem.
 *
 * See running.doc for details.
 */

/* #define POSIX_NONBLOCK_BROKEN */

/**************************************************************************/

/*
 * The Circle code prototypes library functions to avoid compiler warnings.
 * (Operating system header files *should* do this, but sometimes don't.)
 * However, Circle's prototypes cause the compilation to fail under some
 * combinations of operating systems and compilers.
 *
 * If your compiler reports "conflicting types" for functions, you need to
 * define this constant to turn off library function prototyping.  Note,
 * **DO** **NOT** blindly turn on this constant unless you're sure the
 * problem is type conflicts between my header files and the header files
 * of your operating system.  The error message will look something like
 * this:
 *
 * In file included from comm.c:14:
 *    sysdep.h:207: conflicting types for `random'
 * /usr/local/lib/gcc-lib/alpha-dec-osf3.2/2.7.2/include/stdlib.h:253:
 *    previous declaration of `random'
 *
 * See running.doc for details.
 */

/* #define NO_LIBRARY_PROTOTYPES */

/************************************************************************/
/*** Do not change anything below this line *****************************/
/************************************************************************/

/*
 * Set up various machine-specific things based on the values determined
 * from configure and conf.h.
 */

/* Standard C headers  *************************************************/

#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>

#ifdef HAVE_STRING_H
#include <string.h>
#endif

#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif


#if     (defined (STDC_HEADERS) || defined (__GNU_LIBRARY__))
#include <stdlib.h>

#else   /* No standard headers.  */

#ifdef  HAVE_MEMORY_H
#include <memory.h>
#endif

extern char *malloc(), *calloc(), *realloc();
extern void free ();

extern void abort (), exit ();

#endif  /* Standard headers.  */

/* POSIX compliance  *************************************************/

#ifdef HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif

#ifdef CIRCLE_WINDOWS
# include <sys\types.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

/* Now, we #define POSIX if we have a POSIX system. */

#ifdef HAVE_UNISTD_H
/* Ultrix's unistd.h always defines _POSIX_VERSION, but you only get
   POSIX.1 behavior with `cc -YPOSIX', which predefines POSIX itself!  */
#if defined (_POSIX_VERSION) && !defined (ultrix)
#define POSIX
#endif

/* Some systems define _POSIX_VERSION but are not really POSIX.1.  */
#if (defined (butterfly) || defined (__arm) || \
     (defined (__mips) && defined (_SYSTYPE_SVR3)) || \
     (defined (sequent) && defined (i386)))
#undef POSIX
#endif
#endif /* HAVE_UNISTD_H */

#if !defined (POSIX) && defined (_AIX) && defined (_POSIX_SOURCE)
#define POSIX
#endif

#if defined(_AIX)
#define POSIX_NONBLOCK_BROKEN
#endif


/* Header files *******************************************************/

 
/* Header files common to all source files */

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif

#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

#ifdef HAVE_NET_ERRNO_H
#include <net/errno.h>
#endif

/* Macintosh */
#ifdef HAVE_SYS_ERRNO_H
#include <sys/errno.h>
#endif

#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_ASSERT_H
#include <assert.h>
#else
#define assert(arg)
#endif


/* Header files only used in comm.c and some of the utils */

#if defined(__COMM_C__) || defined(CIRCLE_UTIL)

#ifndef HAVE_STRUCT_IN_ADDR
struct in_addr {
  unsigned long int s_addr;	/* for inet_addr, etc. */
}
#endif

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_SYS_FCNTL_H
#include <sys/fcntl.h>
#endif

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif

#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

#ifdef HAVE_SYS_WAIT_H
# include <sys/wait.h>
#endif

#ifdef HAVE_NETINET_IN_H
# include <netinet/in.h>
#endif

#ifdef HAVE_ARPA_INET_H
# include <arpa/inet.h>
#endif

#ifdef HAVE_NETDB_H
# include <netdb.h>
#endif

#ifdef HAVE_SIGNAL_H
# ifndef _POSIX_C_SOURCE
#  define _POSIX_C_SOURCE 2
#  include <signal.h>
#  undef _POSIX_C_SOURCE
# else
#  include <signal.h>	/* GNU libc 6 already defines _POSIX_C_SOURCE. */
# endif
#endif

#ifdef HAVE_SYS_UIO_H
# include <sys/uio.h>
#endif

#endif /* __COMM_C__ && CIRCLE_UNIX */


/* Header files that are only used in act.other.c */
#ifdef __ACT_OTHER_C__

#ifdef HAVE_SYS_STAT_H
# include <sys/stat.h>
#endif

#endif /* __ACT_OTHER_C__ */


/* Basic system dependencies *******************************************/

#if !defined(__GNUC__)
#define __attribute__(x)	/* nothing */
#endif

#if defined(__MWERKS__)
# define isascii(c)	(((c) & ~0x7f) == 0)	/* So easy to have, but ... */
#endif

/* Socket/header miscellany. */

#if defined(CIRCLE_WINDOWS)	/* Definitions for Win32 */

# if !defined(__BORLANDC__) && !defined(LCC_WIN32)	/* MSVC */
#  define chdir _chdir
#  pragma warning(disable:4761)		/* Integral size mismatch. */
#  pragma warning(disable:4244)		/* Possible loss of data. */
# endif

# if defined(__BORLANDC__)	/* Silence warnings we don't care about. */
#  pragma warn -par	/* to turn off >parameter< 'ident' is never used. */
#  pragma warn -pia	/* to turn off possibly incorrect assignment. 'if (!(x=a))' */
#  pragma warn -sig	/* to turn off conversion may lose significant digits. */
# endif

# ifndef _WINSOCK2API_	/* Winsock1 and Winsock 2 conflict. */
#  include <winsock.h>
# endif

# ifndef FD_SETSIZE	/* MSVC 6 is reported to have 64. */
#  define FD_SETSIZE		1024
# endif

#elif defined(CIRCLE_VMS)

/*
 * Necessary Definitions For DEC C With DEC C Sockets Under OpenVMS.
 */
# if defined(DECC)
#  include <stdio.h>
#  include <time.h>
#  include <stropts.h>
#  include <unixio.h>
# endif

#elif !defined(CIRCLE_MACINTOSH) && !defined(CIRCLE_UNIX) && !defined(CIRCLE_ACORN)
# error "You forgot to include conf.h or do not have a valid system define."
#endif

/* SOCKET -- must be after the winsock.h #include. */
#ifdef CIRCLE_WINDOWS
# define CLOSE_SOCKET(sock)	closesocket(sock)
  typedef SOCKET		socket_t;
#else
# define CLOSE_SOCKET(sock)	close(sock)
  typedef int			socket_t;
#endif

#if defined(__cplusplus)	/* C++ */
#define cpp_extern	extern
#else				/* C */
#define cpp_extern	/* Nothing */
#endif

/* Guess if we have the getrlimit()/setrlimit() functions */
#if defined(RLIMIT_NOFILE) || defined (RLIMIT_OFILE)
#define HAS_RLIMIT
#if !defined (RLIMIT_NOFILE)
# define RLIMIT_NOFILE RLIMIT_OFILE
#endif
#endif


/* Make sure we have STDERR_FILENO */
#ifndef STDERR_FILENO
#define STDERR_FILENO 2
#endif

/* Make sure we have STDOUT_FILENO too. */
#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif


/* Function prototypes ************************************************/

/*
 * For reasons that perplex me, the header files of many OS's do not contain
 * function prototypes for the standard C library functions.  This produces
 * annoying warning messages (sometimes, a huge number of them) on such OS's
 * when compiling with gcc's -Wall.
 *
 * Some versions of CircleMUD prior to 3.0 patchlevel 9 attempted to
 * include prototypes taken from OS man pages for a large number of
 * OS's in the header files.  I now think such an approach is a bad
 * idea: maintaining that list is very difficult and time-consuming,
 * and when new revisions of OS's are released with new header files,
 * Circle can break if the prototypes contained in Circle's .h files
 * differs from the new OS header files; for example, Circle 3.0
 * patchlevel 8 failed with compiler errors under Solaris 2.5 and
 * Linux 1.3.xx whereas under previous revisions of those OS's it had
 * been fine.
 *
 * Thus, to silence the compiler warnings but still maintain some level of
 * portability (albiet at the expense of worse error checking in the code),
 * my solution is to define a "typeless" function prototype for all problem
 * functions that have not already been prototyped by the OS. --JE
 *
 * 20 Mar 96: My quest is not yet over.  These definitions still cause
 * clashes with some compilers.  Therefore, we only use these prototypes
 * if we're using gcc (which makes sense, since they're only here for gcc's
 * -Wall option in the first place), and configure tells gcc to use
 * -fno-strict-prototypes, so that these definitions don't clash with
 * previous prototypes.
 *
 * 4 June 96: The quest continues.  OSF/1 still doesn't like these
 * prototypes, even with gcc and -fno-strict-prototypes.  I've created
 * the constant NO_LIBRARY_PROTOTYPES to allow people to turn off the
 * prototyping.
 *
 * 27 Oct 97: This is driving me crazy but I think I've finally come
 * up with the solution that will work.  I've changed the configure
 * script to detect which prototypes exist already; this header file
 * only prototypes functions that aren't already prototyped by the
 * system headers.  A clash should be impossible.  This should give us
 * our strong type-checking back.  This should be the last word on
 * this issue!
 */

#ifndef NO_LIBRARY_PROTOTYPES

#ifdef NEED_ATOI_PROTO
   int atoi(const char *str);
#endif

#ifdef NEED_ATOL_PROTO
   long atol(const char *str);
#endif

/*
 * bzero is deprecated - use memset() instead.  Not directly used in Circle
 * but the prototype needed for FD_xxx macros on some machines.
 */
#ifdef NEED_BZERO_PROTO
     void bzero(char *b, int length);
#endif
 
#ifdef NEED_CRYPT_PROTO
   char *crypt(const char *key, const char *salt);
#endif

#ifdef NEED_FCLOSE_PROTO
   int fclose(FILE *stream);
#endif

#ifdef NEED_FDOPEN_PROTO
   FILE *fdopen(int fd, const char *mode);
#endif

#ifdef NEED_FFLUSH_PROTO
   int fflush(FILE *stream);
#endif

#ifdef NEED_FPRINTF_PROTO
   int fprintf(FILE *strm, const char *format, /* args */ ... );
#endif

#ifdef NEED_FREAD_PROTO
   size_t fread(void *ptr, size_t size, size_t nitems, FILE *stream);
#endif

#ifdef NEED_FSCANF_PROTO
  int fscanf(FILE *strm, const char *format, ...);
#endif

#ifdef NEED_FSEEK_PROTO
   int fseek(FILE *stream, long offset, int ptrname);
#endif

#ifdef NEED_FWRITE_PROTO
  size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream);
#endif

#ifdef NEED_GETPID_PROTO
   pid_t getpid(void);
#endif

#ifdef NEED_PERROR_PROTO
   void perror(const char *s);
#endif

#ifdef NEED_QSORT_PROTO
   void qsort(void *base, size_t nel, size_t width,
          int (*compar) (const void *, const void *));
#endif

#ifdef NEED_REWIND_PROTO
   void rewind(FILE *stream);
#endif

#ifdef NEED_SPRINTF_PROTO
   int sprintf(char *s, const char *format, /* args */ ... );
#endif

#ifdef NEED_SSCANF_PROTO
   int sscanf(const char *s, const char *format, ...);
#endif

#ifdef NEED_STRERROR_PROTO
   char *strerror(int errnum);
#endif

#ifdef NEED_SYSTEM_PROTO
   int system(const char *string);
#endif

#ifdef NEED_TIME_PROTO
   time_t time(time_t *tloc);
#endif

#ifdef NEED_UNLINK_PROTO
   int unlink(const char *path);
#endif

#ifdef NEED_REMOVE_PROTO
   int remove(const char *path);
#endif

/* Function prototypes that are only used in comm.c and some of the utils */

#if defined(__COMM_C__) || defined(CIRCLE_UTIL)

#ifdef NEED_ACCEPT_PROTO
   int accept(socket_t s, struct sockaddr *addr, int *addrlen);
#endif

#ifdef NEED_BIND_PROTO
   int bind(socket_t s, const struct sockaddr *name, int namelen);
#endif

#ifdef NEED_CHDIR_PROTO
   int chdir(const char *path);
#endif

#ifdef NEED_CLOSE_PROTO
   int close(int fildes);
#endif

#ifdef NEED_FCNTL_PROTO
   int fcntl(int fildes, int cmd, /* arg */ ...);
#endif

#ifdef NEED_FPUTC_PROTO
   int fputc(char c, FILE *stream);
#endif

#ifdef NEED_FPUTS_PROTO
   int fputs(const char *s, FILE *stream);
#endif

#ifdef NEED_GETPEERNAME_PROTO
   int getpeername(socket_t s, struct sockaddr *name, int *namelen);
#endif

#if defined(HAS_RLIMIT) && defined(NEED_GETRLIMIT_PROTO)
   int getrlimit(int resource, struct rlimit *rlp);
#endif

#ifdef NEED_GETSOCKNAME_PROTO
   int getsockname(socket_t s, struct sockaddr *name, int *namelen);
#endif

#ifdef NEED_GETTIMEOFDAY_PROTO
   int gettimeofday(struct timeval *tp, void * );
#endif

#ifdef NEED_HTONL_PROTO
   ulong htonl(u_long hostlong);
#endif

#ifdef NEED_HTONS_PROTO
   u_short htons(u_short hostshort);
#endif

#if defined(HAVE_INET_ADDR) && defined(NEED_INET_ADDR_PROTO)
   unsigned long int inet_addr(const char *cp);
#endif

#if defined(HAVE_INET_ATON) && defined(NEED_INET_ATON_PROTO)
   int inet_aton(const char *cp, struct in_addr *inp);
#endif

#ifdef NEED_INET_NTOA_PROTO
   char *inet_ntoa(const struct in_addr in);
#endif

#ifdef NEED_LISTEN_PROTO
   int listen(socket_t s, int backlog);
#endif

#ifdef NEED_NTOHL_PROTO
   u_long ntohl(u_long netlong);
#endif

#ifdef NEED_PRINTF_PROTO
   int printf(char *format, ...);
#endif

#ifdef NEED_READ_PROTO
   ssize_t read(int fildes, void *buf, size_t nbyte);
#endif

#ifdef NEED_SELECT_PROTO
   int select(int nfds, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout);   
#endif

#ifdef NEED_SETITIMER_PROTO
   int setitimer(int which, const struct itimerval *value,
          struct itimerval *ovalue);
#endif

#if defined(HAS_RLIMIT) && defined(NEED_SETRLIMIT_PROTO)
   int setrlimit(int resource, const struct rlimit *rlp);
#endif

#ifdef NEED_SETSOCKOPT_PROTO
   int setsockopt(socket_t s, int level, int optname, const char *optval,
		  int optlen);
#endif

#ifdef NEED_SOCKET_PROTO
   int socket(int domain, int type, int protocol);
#endif

#ifdef NEED_WRITE_PROTO
    ssize_t write(int fildes, const void *buf, size_t nbyte);
#endif

#endif /* __COMM_C__ */


#endif /* NO_LIBRARY_PROTOTYPES */


::::::::::::::
teleport.h
::::::::::::::
#ifndef _TELEPORT_H_
#define _TELEPORT_H_

#define PULSE_TELEPORT      (10 RL_SEC)
#define MIN_TELEPORT_FREQ   2		/* 20 seconds RealTime */
#define MAX_TELEPORT_FREQ   30		/* 5 minutes RealTime */

#define TELE_LOOK	    (1 << 0)
#define TELE_COUNT	    (1 << 1)
#define TELE_RANDOM         (1 << 2)
#define TELE_SPIN	    (1 << 3)
#define TELE_OBJ            (1 << 4)
#define TELE_NOOBJ          (1 << 5)
#define TELE_NOMSG          (1 << 6)
#define TELE_NOMOB          (1 << 7)
#define TELE_SKIPOBJ        (1 << 8)

#define NUM_TELEPORT		9


void TeleportPulseStuff();

#endif /* _TELEPORT_H_ */
::::::::::::::
telnet.h
::::::::::::::
/*
 * Copyright (c) 1983, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)telnet.h    8.2 (Berkeley) 12/15/93
 */

#ifndef _ARPA_TELNET_H
#define _ARPA_TELNET_H

/*
 * Definitions for the TELNET protocol.
 */
#define IAC     255             /* interpret as command: */
#define DONT    254             /* you are not to use option */
#define DO      253             /* please, you use option */
#define WONT    252             /* I won't use option */
#define WILL    251             /* I will use option */
#define SB      250             /* interpret as subnegotiation */
#define GA      249             /* you may reverse the line */
#define EL      248             /* erase the current line */
#define EC      247             /* erase the current character */
#define AYT     246             /* are you there */
#define AO      245             /* abort output--but let prog finish */
#define IP      244             /* interrupt process--permanently */
#define BREAK   243             /* break */
#define DM      242             /* data mark--for connect. cleaning */
#define NOP     241             /* nop */
#define SE      240             /* end sub negotiation */
#define EOR     239             /* end of record (transparent mode) */
#define ABORT   238             /* Abort process */
#define SUSP    237             /* Suspend process */
#define xEOF    236             /* End of file: EOF is already used... */

#define SYNCH   242             /* for telfunc calls */

#ifdef TELCMDS
char *telcmds[] = {
        "EOF", "SUSP", "ABORT", "EOR",
        "SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC",
        "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC", 0,
};
#else
extern char *telcmds[];
#endif

#define TELCMD_FIRST    xEOF
#define TELCMD_LAST     IAC
#define TELCMD_OK(x)    ((unsigned int)(x) <= TELCMD_LAST && \
                         (unsigned int)(x) >= TELCMD_FIRST)
#define TELCMD(x)       telcmds[(x)-TELCMD_FIRST]

/* telnet options */
#define TELOPT_BINARY   0       /* 8-bit data path */
#define TELOPT_ECHO     1       /* echo */
#define TELOPT_RCP      2       /* prepare to reconnect */
#define TELOPT_SGA      3       /* suppress go ahead */
#define TELOPT_NAMS     4       /* approximate message size */
#define TELOPT_STATUS   5       /* give status */
#define TELOPT_TM       6       /* timing mark */
#define TELOPT_RCTE     7       /* remote controlled transmission and echo */
#define TELOPT_NAOL     8       /* negotiate about output line width */
#define TELOPT_NAOP     9       /* negotiate about output page size */
#define TELOPT_NAOCRD   10      /* negotiate about CR disposition */
#define TELOPT_NAOHTS   11      /* negotiate about horizontal tabstops */
#define TELOPT_NAOHTD   12      /* negotiate about horizontal tab disposition */
#define TELOPT_NAOFFD   13      /* negotiate about formfeed disposition */
#define TELOPT_NAOVTS   14      /* negotiate about vertical tab stops */
#define TELOPT_NAOVTD   15      /* negotiate about vertical tab disposition */
#define TELOPT_NAOLFD   16      /* negotiate about output LF disposition */
#define TELOPT_XASCII   17      /* extended ascic character set */
#define TELOPT_LOGOUT   18      /* force logout */
#define TELOPT_BM       19      /* byte macro */
#define TELOPT_DET      20      /* data entry terminal */
#define TELOPT_SUPDUP   21      /* supdup protocol */
#define TELOPT_SUPDUPOUTPUT 22  /* supdup output */
#define TELOPT_SNDLOC   23      /* send location */
#define TELOPT_TTYPE    24      /* terminal type */
#define TELOPT_EOR      25      /* end or record */
#define TELOPT_TUID     26      /* TACACS user identification */
#define TELOPT_OUTMRK   27      /* output marking */
#define TELOPT_TTYLOC   28      /* terminal location number */
#define TELOPT_3270REGIME 29    /* 3270 regime */
#define TELOPT_X3PAD    30      /* X.3 PAD */
#define TELOPT_NAWS     31      /* window size */
#define TELOPT_TSPEED   32      /* terminal speed */
#define TELOPT_LFLOW    33      /* remote flow control */
#define TELOPT_LINEMODE 34      /* Linemode option */
#define TELOPT_XDISPLOC 35      /* X Display Location */
#define TELOPT_OLD_ENVIRON 36   /* Old - Environment variables */
#define TELOPT_AUTHENTICATION 37/* Authenticate */
#define TELOPT_ENCRYPT  38      /* Encryption option */
#define TELOPT_NEW_ENVIRON 39   /* New - Environment variables */
#define TELOPT_EXOPL    255     /* extended-options-list */


#define NTELOPTS        (1+TELOPT_NEW_ENVIRON)
#ifdef TELOPTS
char *telopts[NTELOPTS+1] = {
        "BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
        "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
        "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
        "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
        "DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
        "SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
        "TACACS UID", "OUTPUT MARKING", "TTYLOC",
        "3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
        "LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION",
        "ENCRYPT", "NEW-ENVIRON",
        0,
};
#define TELOPT_FIRST    TELOPT_BINARY
#define TELOPT_LAST     TELOPT_NEW_ENVIRON
#define TELOPT_OK(x)    ((unsigned int)(x) <= TELOPT_LAST)
#define TELOPT(x)       telopts[(x)-TELOPT_FIRST]
#endif

/* sub-option qualifiers */
#define TELQUAL_IS      0       /* option is... */
#define TELQUAL_SEND    1       /* send option */
#define TELQUAL_INFO    2       /* ENVIRON: informational version of IS */
#define TELQUAL_REPLY   2       /* AUTHENTICATION: client version of IS */
#define TELQUAL_NAME    3       /* AUTHENTICATION: client version of IS */

#define LFLOW_OFF               0       /* Disable remote flow control */
#define LFLOW_ON                1       /* Enable remote flow control */
#define LFLOW_RESTART_ANY       2       /* Restart output on any char */
#define LFLOW_RESTART_XON       3       /* Restart output only on XON */

/*
 * LINEMODE suboptions
 */

#define LM_MODE         1
#define LM_FORWARDMASK  2
#define LM_SLC          3

#define MODE_EDIT       0x01
#define MODE_TRAPSIG    0x02
#define MODE_ACK        0x04
#define MODE_SOFT_TAB   0x08
#define MODE_LIT_ECHO   0x10

#define MODE_MASK       0x1f

/* Not part of protocol, but needed to simplify things... */
#define MODE_FLOW               0x0100
#define MODE_ECHO               0x0200
#define MODE_INBIN              0x0400
#define MODE_OUTBIN             0x0800
#define MODE_FORCE              0x1000

#define SLC_SYNCH       1
#define SLC_BRK         2
#define SLC_IP          3
#define SLC_AO          4
#define SLC_AYT         5
#define SLC_EOR         6
#define SLC_ABORT       7
#define SLC_EOF         8
#define SLC_SUSP        9
#define SLC_EC          10
#define SLC_EL          11
#define SLC_EW          12
#define SLC_RP          13
#define SLC_LNEXT       14
#define SLC_XON         15
#define SLC_XOFF        16
#define SLC_FORW1       17
#define SLC_FORW2       18

#define NSLC            18

/*
 * For backwards compatability, we define SLC_NAMES to be the
 * list of names if SLC_NAMES is not defined.
 */
#define SLC_NAMELIST    "0", "SYNCH", "BRK", "IP", "AO", "AYT", "EOR", \
                        "ABORT", "EOF", "SUSP", "EC", "EL", "EW", "RP", \
                        "LNEXT", "XON", "XOFF", "FORW1", "FORW2", 0,
#ifdef  SLC_NAMES
char *slc_names[] = {
        SLC_NAMELIST
};
#else
extern char *slc_names[];
#define SLC_NAMES SLC_NAMELIST
#endif

#define SLC_NAME_OK(x)  ((unsigned int)(x) <= NSLC)
#define SLC_NAME(x)     slc_names[x]

#define SLC_NOSUPPORT   0
#define SLC_CANTCHANGE  1
#define SLC_VARIABLE    2
#define SLC_DEFAULT     3
#define SLC_LEVELBITS   0x03

#define SLC_FUNC        0
#define SLC_FLAGS       1
#define SLC_VALUE       2

#define SLC_ACK         0x80
#define SLC_FLUSHIN     0x40
#define SLC_FLUSHOUT    0x20

#define OLD_ENV_VAR     1
#define OLD_ENV_VALUE   0
#define NEW_ENV_VAR     0
#define NEW_ENV_VALUE   1
#define ENV_ESC         2
#define ENV_USERVAR     3

/*
 * AUTHENTICATION suboptions
 */

/*
 * Who is authenticating who ...
 */
#define AUTH_WHO_CLIENT         0       /* Client authenticating server */
#define AUTH_WHO_SERVER         1       /* Server authenticating client */
#define AUTH_WHO_MASK           1

/*
 * amount of authentication done
 */
#define AUTH_HOW_ONE_WAY        0
#define AUTH_HOW_MUTUAL         2
#define AUTH_HOW_MASK           2

#define AUTHTYPE_NULL           0
#define AUTHTYPE_KERBEROS_V4    1
#define AUTHTYPE_KERBEROS_V5    2
#define AUTHTYPE_SPX            3
#define AUTHTYPE_MINK           4
#define AUTHTYPE_CNT            5

#define AUTHTYPE_TEST           99

#ifdef  AUTH_NAMES
char *authtype_names[] = {
        "NULL", "KERBEROS_V4", "KERBEROS_V5", "SPX", "MINK", 0,
};
#else
extern char *authtype_names[];
#endif

#define AUTHTYPE_NAME_OK(x)     ((unsigned int)(x) < AUTHTYPE_CNT)
#define AUTHTYPE_NAME(x)        authtype_names[x]

/*
 * ENCRYPTion suboptions
 */
#define ENCRYPT_IS              0       /* I pick encryption type ... */
#define ENCRYPT_SUPPORT         1       /* I support encryption types ... */
#define ENCRYPT_REPLY           2       /* Initial setup response */
#define ENCRYPT_START           3       /* Am starting to send encrypted */
#define ENCRYPT_END             4       /* Am ending encrypted */
#define ENCRYPT_REQSTART        5       /* Request you start encrypting */
#define ENCRYPT_REQEND          6       /* Request you send encrypting */
#define ENCRYPT_ENC_KEYID       7
#define ENCRYPT_DEC_KEYID       8
#define ENCRYPT_CNT             9

#define ENCTYPE_ANY             0
#define ENCTYPE_DES_CFB64       1
#define ENCTYPE_DES_OFB64       2
#define ENCTYPE_CNT             3

#ifdef  ENCRYPT_NAMES
char *encrypt_names[] = {
        "IS", "SUPPORT", "REPLY", "START", "END",
        "REQUEST-START", "REQUEST-END", "ENC-KEYID", "DEC-KEYID",
        0,
};
char *enctype_names[] = {
        "ANY", "DES_CFB64",  "DES_OFB64",  0,
};
#else
extern char *encrypt_names[];
extern char *enctype_names[];
#endif


#define ENCRYPT_NAME_OK(x)      ((unsigned int)(x) < ENCRYPT_CNT)
#define ENCRYPT_NAME(x)         encrypt_names[x]

#define ENCTYPE_NAME_OK(x)      ((unsigned int)(x) < ENCTYPE_CNT)
#define ENCTYPE_NAME(x)         enctype_names[x]
#endif /* _ARPA_TELNET_H */
::::::::::::::
utils.h
::::::::::::::
/* ************************************************************************
*   File: utils.h                                       Part of CircleMUD *
*  Usage: header file: utility macros and prototypes of utility funcs     *
*                                                                         *
*  All rights reserved.  See license.doc for complete information.        *
*                                                                         *
*  Copyright (C) 1993, 94 by the Trustees of the Johns Hopkins University *
*  CircleMUD is based on DikuMUD, Copyright (C) 1990, 1991.               *
************************************************************************ */

/* external declarations and prototypes **********************************/

extern struct weather_data weather_info;
extern FILE *logfile;

extern const char *god_names[];

#define log                     basic_mud_log

/* public functions in utils.c */
//char    *str_dup(const char *source);
int     str_cmp(const char *arg1, const char *arg2);
int     strn_cmp(const char *arg1, const char *arg2, int n);
void    basic_mud_log(const char *format, ...) __attribute__ ((format (printf, 1, 2)));
int     touch(const char *path);
void    mudlog(const char *str, int type, int level, int file);
void    log_death_trap(struct char_data *ch);
int     number(int from, int to);
int     dice(int number, int size);
void    sprintbit(long vektor, const char *names[], char *result);
void    sprinttype(int type, const char *names[], char *result);
int     get_line(FILE *fl, char *buf);
int     get_filename(char *orig_name, char *filename, int mode);
struct time_info_data *age(struct char_data *ch);
int     num_pc_in_room(struct room_data *room);
void    core_dump_real(const char *, ush_int);
int     replace_str(char **string, char *pattern, char *replacement, int rep_all, int max_size);
void    format_text(char **ptr_string, int mode, struct descriptor_data *d, int maxlen);
char    *add_points(int value);
char 	*convert_num(double var);
int 	allow_follower(struct char_data *ch, int max_fol);
void 	really_free(void *ptr);
char 	*reprimir(char *vemde, int num);
void manda_som(char *som, struct char_data *ch);
#define SOUND(musica, receptor)  manda_som(musica, receptor)

/*
extern int leak_logging;
extern void leak_dump(void);
extern void leak_clear(void);

extern void *leak_malloc(size_t, const char *, int);
extern void *leak_realloc(void *, size_t, const char *, int);
extern void leak_free(void *, const char *, int);
extern void *leak_calloc(size_t, size_t, const char *, int);
extern char *leak_strdup(const char *, const char *, int);

#undef malloc
#undef realloc
#undef free
#undef calloc
#undef strdup

#define malloc(s) leak_malloc(s, __FILE__, __LINE__)
#define realloc(p, s) leak_realloc(p, s, __FILE__, __LINE__)
#define free(p)  leak_free(p, __FILE__, __LINE__)
#define calloc(s, t) leak_calloc(s, t, __FILE__, __LINE__)
#define str_dup(s) leak_strdup(s, __FILE__, __LINE__)
*/

//#define str_dup(s) leak_strdup(s, __FILE__, __LINE__)
#define str_dup(s) strdup(s)

#define core_dump()             core_dump_real(__FILE__, __LINE__)

/* random functions in random.c */
void circle_srandom(unsigned long initial_seed);
unsigned long circle_random(void);

/* undefine MAX and MIN so that our functions are used instead */
#ifdef MAX
#undef MAX
#endif

#ifdef MIN
#undef MIN
#endif

int MAX(int a, int b);
int MIN(int a, int b);

/* in magic.c */
bool    circle_follow(struct char_data *ch, struct char_data * victim);

/* in act.informative.c */
void    look_at_room(struct char_data *ch, int mode);

/* in act.movmement.c */
int     do_simple_move(struct char_data *ch, int dir, int following);
int     perform_move(struct char_data *ch, int dir, int following);

/* in limits.c */
int     mana_limit(struct char_data *ch);
int     hit_limit(struct char_data *ch);
int     move_limit(struct char_data *ch);
int     mana_gain(struct char_data *ch);
int     hit_gain(struct char_data *ch);
int     move_gain(struct char_data *ch);
void    advance_level(struct char_data *ch);
void    set_title(struct char_data *ch, char *title);
void    set_prename(struct char_data *ch, char *title);
void    gain_exp(struct char_data *ch, int gain);
void    gain_exp_regardless(struct char_data *ch, int gain);
void    gain_condition(struct char_data *ch, int condition, int value);
void    check_idling(struct char_data *ch);
void    point_update(void);
void    update_pos(struct char_data *victim);

/* various constants *****************************************************/

/* defines for mudlog() */
#define OFF     0
#define BRF     1
#define NRM     2
#define CMP     3

/* get_filename() */
#define CRASH_FILE      0
#define ETEXT_FILE      1
#define ALIAS_FILE      2
#define IGNORE_FILE     3//last

//toca som 
#define HAS_SOUND(ch) (PLR_FLAGGED(ch, PLR_MSP))
 #define SND_CHAR 1
 #define SND_ROOM 2
 #define SND_AREA 3
 #define SND_WORLD 4



/* breadth-first searching */
#define BFS_ERROR               -1
#define BFS_ALREADY_THERE       -2
#define BFS_NO_PATH             -3

/*
 * XXX: These constants should be configurable. See act.informative.c
 *      and utils.c for other places to change.
 */
/* mud-life time */
#define SECS_PER_MUD_HOUR       75
#define SECS_PER_MUD_DAY        (24*SECS_PER_MUD_HOUR)
#define SECS_PER_MUD_MONTH      (35*SECS_PER_MUD_DAY)
#define SECS_PER_MUD_YEAR       (17*SECS_PER_MUD_MONTH)

/* real-life time (remember Real Life?) */
#define SECS_PER_REAL_MIN       60
#define SECS_PER_REAL_HOUR      (60*SECS_PER_REAL_MIN)
#define SECS_PER_REAL_DAY       (24*SECS_PER_REAL_HOUR)
#define SECS_PER_REAL_YEAR      (365*SECS_PER_REAL_DAY)


/* string utils **********************************************************/


#define YESNO(a) ((a) ? "YES" : "NO")
#define ONOFF(a) ((a) ? "ON" : "OFF")

#define LOWER(c)   (((c)>='A'  && (c) <= 'Z') ? ((c)+('a'-'A')) : (c))
#define UPPER(c)   (((c)>='a'  && (c) <= 'z') ? ((c)+('A'-'a')) : (c) )

#define ISNEWL(ch) ((ch) == '\n' || (ch) == '\r')
#define IF_STR(st) ((st) ? (st) : "\0")
#define CAP(st)  (*(st) = UPPER(*(st)), st)

#define AN(string) (strchr("aeiouAEIOU", *string) ? "an" : "a")


/* memory utils **********************************************************/

#define CREATE(result, type, number)  do {\
	if ((number) * sizeof(type) <= 0)	\
		log("SYSERR: Zero bytes or less requested at %s:%d.", __FILE__, __LINE__);	\
	if (!((result) = (type *) calloc ((number), sizeof(type))))	\
		{ perror("SYSERR: malloc failure"); abort(); } } while(0)

#define RECREATE(result,type,number) do {\
  if (!((result) = (type *) realloc ((result), sizeof(type) * (number))))\
		{ perror("SYSERR: realloc failure"); abort(); } } while(0)

/*
 * the source previously used the same code in many places to remove an item
 * from a list: if it's the list head, change the head, else traverse the
 * list looking for the item before the one to be removed.  Now, we have a
 * macro to do this.  To use, just make sure that there is a variable 'temp'
 * declared as the same type as the list to be manipulated.  BTW, this is
 * a great application for C++ templates but, alas, this is not C++.  Maybe
 * CircleMUD 4.0 will be...
 */
#define REMOVE_FROM_LIST(item, head, next)      \
   if ((item) == (head))                \
      head = (item)->next;              \
   else {                               \
      temp = head;                      \
      while (temp && (temp->next != (item))) \
         temp = temp->next;             \
      if (temp)                         \
         temp->next = (item)->next;     \
   }                                    \


/* basic bitvector utils *************************************************/


#define IS_SET(flag,bit)  ((flag) & (bit))
#define SET_BIT(var,bit)  ((var) |= (bit))
#define REMOVE_BIT(var,bit)  ((var) &= ~(bit))
#define TOGGLE_BIT(var,bit) ((var) = (var) ^ (bit))

/*
 * Accessing player specific data structures on a mobile is a very bad thing
 * to do.  Consider that changing these variables for a single mob will change
 * it for every other single mob in the game.  If we didn't specifically check
 * for it, 'wimpy' would be an extremely bad thing for a mob to do, as an
 * example.  If you really couldn't care less, change this to a '#if 0'.
 */
#if 1
/* Subtle bug in the '#var', but works well for now. */
#define CHECK_PLAYER_SPECIAL(ch, var) \
        (*(((ch)->player_specials == &dummy_mob) ? (log("SYSERR: Mob using '"#var"' at %s:%d.", __FILE__, __LINE__), &(var)) : &(var)))
#else
#define CHECK_PLAYER_SPECIAL(ch, var)   (var)
#endif

#define MOB_FLAGS(ch) ((ch)->char_specials.saved.act)
#define PLR_FLAGS(ch) ((ch)->char_specials.saved.act)
#define PLR2_FLAGS(ch) ((ch)->char_specials.saved.act2)
#define PRF_FLAGS(ch) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.pref))
#define PRF2_FLAGS(ch) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.pref2))
#define AFF_FLAGS(ch) ((ch)->char_specials.saved.affected_by)
#define AFF2_FLAGS(ch) ((ch)->char_specials.saved.affected2_by)
#define AFF3_FLAGS(ch) ((ch)->char_specials.saved.affected3_by)
#define ROOM_FLAGS(loc) (world[(loc)].room_flags)
#define ROOM_AFFECTIONS(loc)    (world[(loc)].room_affections)
#define ZONE_FLAGS(loc)		(zone_table[(loc)].zone_flags)


#define IS_NPC(ch)  (IS_SET(MOB_FLAGS(ch), MOB_ISNPC))
#define IS_MOB(ch)  (IS_NPC(ch) && ((ch)->nr >-1))

#define MOB_FLAGGED(ch, flag) (IS_NPC(ch) && IS_SET(MOB_FLAGS(ch), (flag)))
#define PLR_FLAGGED(ch, flag) (!IS_NPC(ch) && IS_SET(PLR_FLAGS(ch), (flag)))
#define AFF_FLAGGED(ch, flag) (IS_SET(AFF_FLAGS(ch), (flag)))
#define AFF2_FLAGGED(ch, flag) (IS_SET(AFF2_FLAGS(ch), (flag)))
#define AFF3_FLAGGED(ch, flag) (IS_SET(AFF3_FLAGS(ch), (flag)))
#define PRF_FLAGGED(ch, flag) (IS_SET(PRF_FLAGS(ch), (flag)))
#define PRF2_FLAGGED(ch, flag) (IS_SET(PRF2_FLAGS(ch), (flag)))
#define ROOM_FLAGGED(loc, flag) (IS_SET(ROOM_FLAGS(loc), (flag)))
#define ZONE_FLAGGED(loc, flag)  (IS_SET(ZONE_FLAGS(loc), (flag)))
#define EXIT_FLAGGED(exit, flag) (IS_SET((exit)->exit_info, (flag)))
#define OBJVAL_FLAGGED(obj, flag) (IS_SET(GET_OBJ_VAL((obj), 1), (flag)))
#define OBJWEAR_FLAGGED(obj, flag) (IS_SET((obj)->obj_flags.wear_flags, (flag)))
#define OBJ_FLAGGED(obj, flag) (IS_SET(GET_OBJ_EXTRA(obj), (flag)))
#define ROOM_AFFECTED(loc, aff) (IS_SET(ROOM_AFFECTIONS(loc), (aff)))

/* IS_AFFECTED for backwards compatibility */
#define IS_AFFECTED(ch, skill) (AFF_FLAGGED((ch), (skill)))
#define IS_AFFECTED2(ch, skill) (AFF2_FLAGGED((ch), (skill)))
#define IS_AFFECTED3(ch, skill) (AFF3_FLAGGED((ch), (skill)))

#define PLR_TOG_CHK(ch,flag) ((TOGGLE_BIT(PLR_FLAGS(ch), (flag))) & (flag))
#define PLR2_TOG_CHK(ch,flag) ((TOGGLE_BIT(PLR2_FLAGS(ch), (flag))) & (flag))
#define PRF_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF_FLAGS(ch), (flag))) & (flag))
#define PRF2_TOG_CHK(ch,flag) ((TOGGLE_BIT(PRF2_FLAGS(ch), (flag))) & (flag))

/* room utils ************************************************************/


#define SECT(room)      (world[(room)].sector_type)

#define IS_DARK(room)  ( !world[room].light && \
                         (ROOM_FLAGGED(room, ROOM_DARK) || \
                          ( ( SECT(room) != SECT_INSIDE && \
                              SECT(room) != SECT_CITY ) && \
                            (weather_info.sunlight == SUN_SET || \
                             weather_info.sunlight == SUN_DARK)) ) )

#define IS_LIGHT(room)  (!IS_DARK(room))

#define GET_ROOM_VNUM(rnum)     ((rnum) >= 0 && (rnum) <= top_of_world ? world[(rnum)].number : NOWHERE)
#define GET_ROOM_SPEC(room) ((room) >= 0 ? world[(room)].func : NULL)

/* char utils ************************************************************/


#define GET_GOD_NAME(ch)     (god_names[((ch)->player.level) - LVL_IMMORT])
#define GET_GOD_WIZNAME(ch)  (god_wiznames[((ch)->player.level) - LVL_IMMORT])
#define GET_REMORT_NAME(ch)  (remort_names[((ch)->player.remort) - 1])

#define GET_CLAN(ch)		((ch)->player_specials->saved.clan)
#define GET_CLAN_POS(ch)	((ch)->player_specials->saved.clan_rank)
#define GET_POINTS(ch) 		((ch)->player_specials->saved.points)
#define GET_QP(ch)     		((ch)->player_specials->saved.qpoints)
#define GET_CP(ch)     		((ch)->player_specials->saved.cpoints)


#define IN_ROOM(ch)     ((ch)->in_room)
#define GET_WAS_IN(ch)  ((ch)->was_in_room)
#define GET_AGE(ch)     (age(ch)->year)

#define GET_NAME(ch)    (IS_NPC(ch) ? \
                         (ch)->player.short_descr : (ch)->player.name)
#define GET_TITLE(ch)   ((ch)->player.title)
#define GET_PRENAME(ch) ((ch)->player.prename)
#define GET_LEVEL(ch)   ((ch)->player.level)
#define GET_PASSWD(ch)  ((ch)->player.passwd)
#define GET_EMAIL(ch)   ((ch)->player.email)
#define GET_PFILEPOS(ch)((ch)->pfilepos)
#define GET_REMORT(ch)  ((ch)->player.remort)
#define GET_MASTER(ch)	((ch)->player.id_master)

#define GET_QUEST(ch)       ((ch)->current_quest)
#define GET_QUEST_TYPE(ch)  (aquest_table[real_quest((int)GET_QUEST((ch)))].type)

#define GET_STYLE(ch)		((ch)->player_specials->saved.style)
#define GET_RELIGION(ch)	((ch)->player_specials->saved.religion)
#define GET_RP(ch)		((ch)->player_specials->saved.rp)
#define GET_PIT_TIMER(ch)       ((ch)->player_specials->saved.uextra[0])

/*
 * I wonder if this definition of GET_REAL_LEVEL should be the definition
 * of GET_LEVEL?  JE
 */
#define GET_REAL_LEVEL(ch) \
   (ch->desc && ch->desc->original ? GET_LEVEL(ch->desc->original) : \
    GET_LEVEL(ch))

#define GET_CLASS(ch)   ((ch)->player.chclass)
#define GET_RACE(ch)    ((ch)->player.race)
#define GET_HOME(ch)    ((ch)->player.hometown)
#define GET_HEIGHT(ch)  ((ch)->player.height)
#define GET_WEIGHT(ch)  ((ch)->player.weight)
#define GET_SEX(ch)     ((ch)->player.sex)

#define GET_KILLED(ch)  ((ch)->player.killed)
#define GET_FBI_POS(ch) ((ch)->player.fbi_pos)
#define GET_DIED(ch)    ((ch)->player.died)
#define GET_ARENA_KILLED(ch)  ((ch)->player.a_killed)
#define GET_ARENA_DIED(ch)    ((ch)->player.a_died)

#define GET_TRANS(ch)		((ch)->player.trans)
#define GET_TRANS_HP(ch)	((ch)->player.trans_hp)
#define GET_TRANS_MANA(ch)	((ch)->player.trans_mana)
#define GET_TRANS_MOVE(ch)	((ch)->player.trans_move)

#define LIBERDADE(ch)		((ch)->player.liberdade)

// definido para summary
#define GET_LVL_SUM(ch)		((ch)->player.lvl_sum)
#define GET_EXP_SUM(ch)		((ch)->player.exp_sum)
#define GET_GOLD_SUM(ch)	((ch)->player.gold_sum)
#define GET_KMS(ch)		((ch)->player.kills_mob_sum)
#define GET_KPS(ch)		((ch)->player.kills_ppl_sum)
#define GET_DIED_S(ch)		((ch)->player.died_sum)
#define GET_POINTS_S(ch)	((ch)->player.points_sum)
#define GET_POINTS_GS(ch)	((ch)->player.points_g_sum)
// fim do summary

#define GET_STR(ch)     ((ch)->aff_abils.str)
#define GET_ADD(ch)     ((ch)->aff_abils.str_add)
#define GET_DEX(ch)     ((ch)->aff_abils.dex)
#define GET_INT(ch)     ((ch)->aff_abils.intel)
#define GET_WIS(ch)     ((ch)->aff_abils.wis)
#define GET_CON(ch)     ((ch)->aff_abils.con)
#define GET_CHA(ch)     ((ch)->aff_abils.cha)
#define GET_LUK(ch)     ((ch)->aff_abils.luk)

#define GET_AC(ch)        ((ch)->points.armor)
#define GET_HIT(ch)       ((ch)->points.hit)
#define GET_MAX_HIT(ch)   ((ch)->points.max_hit)
#define GET_MOVE(ch)      ((ch)->points.move)
#define GET_MAX_MOVE(ch)  ((ch)->points.max_move)
#define GET_MANA(ch)      ((ch)->points.mana)
#define GET_MAX_MANA(ch)  ((ch)->points.max_mana)
#define GET_OXI(ch)       ((ch)->points.oxigen)
#define GET_MAX_OXI(ch)   ((ch)->points.max_oxigen)
#define GET_MENTAL(ch)    ((ch)->points.mental)
#define GET_MAX_MENTAL(ch)((ch)->points.max_mental)
#define GET_GOLD(ch)      ((ch)->points.gold)
#define GET_BANK_GOLD(ch) ((ch)->points.bank_gold)
#define GET_HITROLL(ch)   ((ch)->points.hitroll)
#define GET_DAMROLL(ch)   ((ch)->points.damroll)
#define GET_EXP(ch)       ((ch)->points.exp)

#define GET_POS(ch)       ((ch)->char_specials.position)
#define GET_IDNUM(ch)     ((ch)->char_specials.saved.idnum)
#define GET_ID(x)         ((x)->id)
#define GET_CHALLENGE(ch) ((ch)->char_specials.saved.challenge)
#define GET_CHALLENGER(ch)  ((ch)->player.challenger)
#define IS_CARRYING_W(ch) ((ch)->char_specials.carry_weight)
#define IS_CARRYING_N(ch) ((ch)->char_specials.carry_items)
#define FIGHTING(ch)      ((ch)->char_specials.fighting)
#define HUNTING(ch)       ((ch)->char_specials.hunting)
#define GET_SAVE(ch, i)   ((ch)->char_specials.saved.apply_saving_throw[i])
#define GET_ALIGNMENT(ch) ((ch)->char_specials.saved.alignment)
#define GET_BETTED_ON(ch) ((ch)->player_specials->betted_on)
#define GET_BET_AMT(ch)   ((ch)->player_specials->bet_amt)

#define GET_COND(ch, i)         CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.conditions[(i)]))
#define GET_LOADROOM(ch)        CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.load_room))
#define GET_PRACTICES(ch)       CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.spells_to_learn))
#define GET_INVIS_LEV(ch)       CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.invis_level))
#define GET_WIMP_LEV(ch)        CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.wimp_level))
#define GET_FREEZE_LEV(ch)      CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.freeze_level))
#define GET_BAD_PWS(ch)         CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.bad_pws))
#define GET_TALK(ch, i)         CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.talks[i]))
#define POOFIN(ch)              CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->poofin))
#define POOFOUT(ch)             CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->poofout))
#define GET_LAST_OLC_TARG(ch)   CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_olc_targ))
#define GET_LAST_OLC_MODE(ch)   CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_olc_mode))
#define GET_ALIASES(ch)         CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->aliases))
#define GET_LAST_TELL(ch)       CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_tell))



#define GET_SKILL(ch, i)        (AFF2_FLAGGED(ch, AFF2_TRANSFORM) ? 0 : CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.skills[i])))

#define GET_SKILL_LS(ch, i)     CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.skills[i]))

#define SET_SKILL(ch, i, pct)   do { CHECK_PLAYER_SPECIAL((ch), (ch)->player_specials->saved.skills[i]) = pct; } while(0)

#define GET_RSKILL(ch, i, num)  CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.rskills[i][num+1]))
#define GET_CLASS_REMORT(ch, i) CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.rskills[i][0]))

#define GET_EQ(ch, i)           ((ch)->equipment[i])

#define GET_MOB_SPEC(ch)        (IS_MOB(ch) ? mob_index[(ch)->nr].func : NULL)
#define GET_MOB_RNUM(mob)       ((mob)->nr)
#define GET_MOB_VNUM(mob)       (IS_MOB(mob) ? \
                                 mob_index[GET_MOB_RNUM(mob)].vnum : -1)

#define GET_MOB_WAIT(ch)        ((ch)->mob_specials.wait_state)
#define GET_DEFAULT_POS(ch)     ((ch)->mob_specials.default_pos)
#define MEMORY(ch)              ((ch)->mob_specials.memory)

#define STRENGTH_APPLY_INDEX(ch) GET_STR(ch)

#define CAN_CARRY_W(ch) (str_app[STRENGTH_APPLY_INDEX(ch)].carry_w)
#define CAN_CARRY_N(ch) (int) (1 + ((GET_DEX(ch)) * (1+(GET_LEVEL(ch)/200))))
#define AWAKE(ch) (GET_POS(ch) > POS_SLEEPING)
#define CAN_SEE_IN_DARK(ch) \
   (AFF_FLAGGED(ch, AFF_INFRAVISION) || (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_HOLYLIGHT)))

#define IS_GOOD(ch)    (GET_ALIGNMENT(ch) >= 350)
#define IS_EVIL(ch)    (GET_ALIGNMENT(ch) <= -350)
#define IS_NEUTRAL(ch) (!IS_GOOD(ch) && !IS_EVIL(ch))


/* descriptor-based utils ************************************************/

/* These three deprecated. */
#define WAIT_STATE(ch, cycle) { \
        if ((ch)->desc) (ch)->desc->wait = (cycle); \
        else if (IS_NPC(ch)) GET_MOB_WAIT(ch) = (cycle); }

#define CHECK_WAIT(ch)  (((ch)->desc) ? ((ch)->desc->wait > 1) : 0)
/* New, preferred macro. */
#define GET_WAIT_STATE(d)    ((d)->wait)

#define STATE(d)        ((d)->connected)


/* object utils **********************************************************/


#define GET_OBJ_TYPE(obj)       ((obj)->obj_flags.type_flag)
#define GET_OBJ_COST(obj)       ((obj)->obj_flags.cost)
#define GET_OBJ_RENT(obj)       ((obj)->obj_flags.cost_per_day)
#define GET_OBJ_EXTRA(obj)      ((obj)->obj_flags.extra_flags)
#define GET_OBJ_WEAR(obj)       ((obj)->obj_flags.wear_flags)
#define GET_OBJ_VAL(obj, val)   ((obj)->obj_flags.value[(val)])
#define GET_OBJ_WEIGHT(obj)     ((obj)->obj_flags.weight)
#define GET_OBJ_TIMER(obj)      ((obj)->obj_flags.timer)
#define GET_OBJ_LEVEL(obj)      ((obj)->obj_flags.obj_level)
#define GET_OBJ_PERM(obj)       ((obj)->obj_flags.bitvector)
#define GET_OBJ_COND(obj)       ((obj)->obj_flags.cond)
#define GET_OBJ_RNUM(obj)       ((obj)->item_number)
#define GET_OBJ_VNUM(obj)       (GET_OBJ_RNUM(obj) >= 0 ? \
                                 obj_index[GET_OBJ_RNUM(obj)].vnum : -1)
#define IS_OBJ_STAT(obj,stat)   (IS_SET((obj)->obj_flags.extra_flags,stat))
#define IS_CORPSE(obj)          (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                        (GET_OBJ_VAL((obj), 3) == 1 || \
                                         GET_OBJ_VAL((obj), 3) == 2))
#define IS_PC_CORPSE(obj)          (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                         GET_OBJ_VAL((obj), 3) == 1)
#define IS_NPC_CORPSE(obj)          (GET_OBJ_TYPE(obj) == ITEM_CONTAINER && \
                                         GET_OBJ_VAL((obj), 3) == 2)

#define GET_OBJ_SPEC(obj) ((obj)->item_number >= 0 ? \
        (obj_index[(obj)->item_number].func) : NULL)

#define CAN_WEAR(obj, part) (IS_SET((obj)->obj_flags.wear_flags, (part)))

/* compound utilities and other macros **********************************/

/*
 * Used to compute CircleMUD version. To see if the code running is newer
 * than 3.0pl13, you would use: #if _CIRCLEMUD > CIRCLEMUD_VERSION(3,0,13)
 */
#define CIRCLEMUD_VERSION	"&RBattle&n &BW&bar&BD&bome &BII,&bVersion &R2.0&n"

#define HSHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "his":"her") :"its")
#define HSSH(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "he" :"she") : "it")
#define HMHR(ch) (GET_SEX(ch) ? (GET_SEX(ch)==SEX_MALE ? "him":"her") : "it")

#define ANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "An" : "A")
#define SANA(obj) (strchr("aeiouyAEIOUY", *(obj)->name) ? "an" : "a")


/* Various macros building up to CAN_SEE */

#define LIGHT_OK(sub)   (!AFF_FLAGGED(sub, AFF_BLIND) && \
   (IS_LIGHT((sub)->in_room) || AFF_FLAGGED((sub), AFF_INFRAVISION)))

#define INVIS_OK(sub, obj) \
 ((!AFF_FLAGGED((obj),AFF_INVISIBLE) || AFF_FLAGGED(sub,AFF_DETECT_INVIS)) && \
 (!AFF_FLAGGED((obj), AFF_HIDE) || AFF_FLAGGED(sub, AFF_SENSE_LIFE)) && \
  !AFF_FLAGGED((obj), AFF_GAS) && !ROOM_AFFECTED(sub->in_room, RAFF_FOG))

#define MORT_CAN_SEE(sub, obj) (LIGHT_OK(sub) && INVIS_OK(sub, obj))

#define IMM_CAN_SEE(sub, obj) \
   (MORT_CAN_SEE(sub, obj) || (!IS_NPC(sub) && PRF_FLAGGED(sub, PRF_HOLYLIGHT)))

#define SELF(sub, obj)  ((sub) == (obj))

/* Can subject see character "obj"? */
#define CAN_SEE(sub, obj) (SELF(sub, obj) || \
   ((GET_REAL_LEVEL(sub) >= (IS_NPC(obj) ? 0 : GET_INVIS_LEV(obj))) && \
   IMM_CAN_SEE(sub, obj)))

/* End of CAN_SEE */


#define INVIS_OK_OBJ(sub, obj) \
  (!IS_OBJ_STAT((obj), ITEM_INVISIBLE) || AFF_FLAGGED((sub), AFF_DETECT_INVIS))

/* Is anyone carrying this object and if so, are they visible? */
#define CAN_SEE_OBJ_CARRIER(sub, obj) \
  ((!obj->carried_by || CAN_SEE(sub, obj->carried_by)) &&       \
   (!obj->worn_by || CAN_SEE(sub, obj->worn_by)))

#define MORT_CAN_SEE_OBJ(sub, obj) \
  (LIGHT_OK(sub) && INVIS_OK_OBJ(sub, obj) && CAN_SEE_OBJ_CARRIER(sub, obj))

#define CAN_SEE_OBJ(sub, obj) \
   (MORT_CAN_SEE_OBJ(sub, obj) || (!IS_NPC(sub) && PRF_FLAGGED((sub), PRF_HOLYLIGHT)))

#define CAN_CARRY_OBJ(ch,obj)  \
   (((IS_CARRYING_W(ch) + GET_OBJ_WEIGHT(obj)) <= CAN_CARRY_W(ch)) &&   \
    ((IS_CARRYING_N(ch) + 1) <= CAN_CARRY_N(ch)))

#define CAN_GET_OBJ(ch, obj)   \
   (CAN_WEAR((obj), ITEM_WEAR_TAKE) && CAN_CARRY_OBJ((ch),(obj)) && \
    CAN_SEE_OBJ((ch),(obj)))

#define PERS(ch, vict)   (CAN_SEE(vict, ch) ? GET_NAME(ch) : "Someone")

#define OBJS(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
        (obj)->short_description  : "something")

#define OBJN(obj, vict) (CAN_SEE_OBJ((vict), (obj)) ? \
        fname((obj)->name) : "something")


#define EXIT(ch, door)  (world[(ch)->in_room].dir_option[door])

#define CAN_GO(ch, door) (EXIT(ch,door) && \
                         (EXIT(ch,door)->to_room != NOWHERE) && \
                         !IS_SET(EXIT(ch, door)->exit_info, EX_CLOSED))


#define CLASS_ABBR(ch) (IS_NPC(ch) ? npc_class_abbrevs[(int)GET_CLASS(ch)] : \
                                         class_abbrevs[(int)GET_CLASS(ch)])

#define RACE_ABBR(ch)  (IS_NPC(ch) ? "--" : race_abbrevs[(int)GET_RACE(ch)])

#define IS_MAGIC_USER(ch)       (GET_CLASS(ch) == CLASS_MAGIC_USER)

#define IS_CLERIC(ch)           (GET_CLASS(ch) == CLASS_CLERIC)

#define IS_THIEF(ch)            (GET_CLASS(ch) == CLASS_THIEF)

#define IS_WARRIOR(ch)          (GET_CLASS(ch) == CLASS_WARRIOR)

#define IS_NECROMANCER(ch)      (GET_CLASS(ch) == CLASS_NECROMANCER)

#define IS_PALADIN(ch)          (GET_CLASS(ch) == CLASS_PALADIN)

#define IS_NINJA(ch)            (GET_CLASS(ch) == CLASS_NINJA)

#define IS_RANGER(ch)           (GET_CLASS(ch) == CLASS_RANGER)

#define IS_PSIONICIST(ch)       (GET_CLASS(ch) == CLASS_PSIONICIST)

#define IS_WARLOCK(ch)          (GET_CLASS(ch) == CLASS_WARLOCK)

#define IS_BARBARIAN(ch)        (GET_CLASS(ch) == CLASS_BARBARIAN)

#define IS_SORCERER(ch)         (GET_CLASS(ch) == CLASS_SORCERER)


#define IS_VAMPIRE(ch)          (GET_RACE(ch) == RACE_VAMPIRE)

#define IS_DROW(ch)             (GET_RACE(ch) == RACE_DROW)

#define IS_DWARF(ch)            (GET_RACE(ch) == RACE_DWARF)

#define IS_ELF(ch)              (GET_RACE(ch) == RACE_ELF)

#define IS_OGRE(ch)             (GET_RACE(ch) == RACE_OGRE)

#define IS_ORC(ch)              (GET_RACE(ch) == RACE_ORC)

#define IS_TROLL(ch)            (GET_RACE(ch) == RACE_TROLL)

#define IS_GITH(ch)             (GET_RACE(ch) == RACE_GITH)

#define IS_GNOME(ch)            (GET_RACE(ch) == RACE_GNOME)

#define IS_LIZARDMAN(ch)        (GET_RACE(ch) == RACE_LIZARDMAN)

#define IS_SEA_ELF(ch)          (GET_RACE(ch) == RACE_SEA_ELF)

#define IS_GORAK(ch)            (GET_RACE(ch) == RACE_GORAK)

#define IS_DUNEDAIN(ch)         (GET_RACE(ch) == RACE_DUNEDAIN)

#define IS_ANCI_DROW(ch)        (GET_RACE(ch) == RACE_ANCI_DROW)

#define IS_NAUGRIM(ch)          (GET_RACE(ch) == RACE_NAUGRIM)

#define IS_HIGH_ELF(ch)         (GET_RACE(ch) == RACE_HIGH_ELF)

#define IS_HILL_OGRE(ch)        (GET_RACE(ch) == RACE_HILL_OGRE)

#define IS_BUGBEAR(ch)          (GET_RACE(ch) == RACE_BUGBEAR)

#define IS_CAVE_TROLL(ch)       (GET_RACE(ch) == RACE_CAVE_TROLL)

#define IS_LICH(ch)             (GET_RACE(ch) == RACE_LICH)

#define IS_TINKER(ch)           (GET_RACE(ch) == RACE_TINKER)

#define IS_DRACONIAN(ch)        (GET_RACE(ch) == RACE_DRACONIAN)

#define IS_H_SEA_ELF(ch)        (GET_RACE(ch) == RACE_H_SEA_ELF)

#define IS_ARCHONS(ch)          (GET_RACE(ch) == RACE_ARCHONS)


#define OUTSIDE(ch) (!ROOM_FLAGGED((ch)->in_room, ROOM_INDOORS))


/* OS compatibility ******************************************************/


/* there could be some strange OS which doesn't have NULL... */
#ifndef NULL
#define NULL (void *)0
#endif

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE  (!FALSE)
#endif

/* defines for fseek */
#ifndef SEEK_SET
#define SEEK_SET        0
#define SEEK_CUR        1
#define SEEK_END        2
#endif

/*
 * NOCRYPT can be defined by an implementor manually in sysdep.h.
 * CIRCLE_CRYPT is a variable that the 'configure' script
 * automatically sets when it determines whether or not the system is
 * capable of encrypting.
 */
#if defined(NOCRYPT) || !defined(CIRCLE_CRYPT)
#define CRYPT(a,b) (a)
#else
#define CRYPT(a,b) ((char *) crypt((a),(b)))
#endif

#define SENDOK(ch)	((ch)->desc && (to_sleeping || AWAKE(ch)) && \
			!PLR_FLAGGED((ch), PLR_WRITING))

/* arena */
#define ARENA_OFF	0
#define ARENA_START	1
#define ARENA_RUNNING	2
#define HALL_FAME_FILE "text/hallfame" /* the arena hall of fame */

#define PULSE_ARENA	(75 RL_SEC)

#define MIN_ARENA_COST	1000	/* minimum cost per level */

#define sportschan(buf)   send_to_all(buf)

/* in arena.c */
struct hall_of_fame_element {
   char name[MAX_NAME_LENGTH+1];
   char lastname[MAX_NAME_LENGTH+1];
   time_t date;
   long award;
   struct  hall_of_fame_element *next;
};

void start_arena();
void show_jack_pot();
void do_game();
int num_in_arena();
void find_game_winner();
void do_end_game();
void start_game();
void silent_end();
void write_fame_list(void);
void find_bet_winners(struct char_data *winner);
void write_one_fame_node(FILE *fp, struct hall_of_fame_element *node);
void load_hall_of_fame(void);

extern int in_arena;
extern int game_length;
extern int time_to_start;
extern int time_left_in_game;
extern int lo_lim;
extern int hi_lim;
extern int lo_rem;
extern int hi_rem;
extern int cost_per_lev;
extern int start_time;

extern int leak_logging;

#define HOUSE(ch) (ch->player_specials->saved.house_vnum) /* Fenix - WHS */
::::::::::::::
winddragon.h
::::::::::::::
#define NUM_DRAGONS 2
#define NUM_ROOMS   3
#define DRAGON_VNUM 11001
#define DRAGONROOM_INI 11001
#define DRAGONROOM_FALL 11003 

extern const sh_int to_fly_rooms [NUM_ROOMS + 1];

sh_int vet_dragons [NUM_DRAGONS + 1];

struct pont_dragon {
   struct char_data *player;
   int room;
  }; 

struct pont_dragon buf_dragon_indo[NUM_DRAGONS + 1];
struct pont_dragon buf_dragon_vindo[NUM_DRAGONS + 1];
